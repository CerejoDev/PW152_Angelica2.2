; Listing generated by Microsoft (R) Optimizing Compiler Version 19.40.33813.0 

	TITLE	D:\pw152\Common\SpeedTreeRT\RT_DynamicLib\Debug VC 6.0\SpeedTreeRT.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?m_uiAllRefCount@CSpeedTreeRT@@0IA		; CSpeedTreeRT::m_uiAllRefCount
PUBLIC	?m_bTextureFlip@CSpeedTreeRT@@0_NA		; CSpeedTreeRT::m_bTextureFlip
PUBLIC	?m_bDropToBillboard@CSpeedTreeRT@@0_NA		; CSpeedTreeRT::m_bDropToBillboard
PUBLIC	?m_fHorizontalFadeStartAngle@CSpeedTreeRT@@0MA	; CSpeedTreeRT::m_fHorizontalFadeStartAngle
PUBLIC	?m_fHorizontalFadeEndAngle@CSpeedTreeRT@@0MA	; CSpeedTreeRT::m_fHorizontalFadeEndAngle
PUBLIC	?m_fHorizontalFadeValue@CSpeedTreeRT@@0MA	; CSpeedTreeRT::m_fHorizontalFadeValue
_BSS	SEGMENT
?m_uiAllRefCount@CSpeedTreeRT@@0IA DD 01H DUP (?)	; CSpeedTreeRT::m_uiAllRefCount
?m_bTextureFlip@CSpeedTreeRT@@0_NA DB 01H DUP (?)	; CSpeedTreeRT::m_bTextureFlip
	ALIGN	4

?m_bDropToBillboard@CSpeedTreeRT@@0_NA DB 01H DUP (?)	; CSpeedTreeRT::m_bDropToBillboard
_BSS	ENDS
CONST	SEGMENT
?g_fIdvACosTable@@3QBMB DD 040490fdbr		; 3.14159 ; g_fIdvACosTable
	DD	040470fd5r			; 3.11034
	DD	040463bb8r			; 3.09739
	DD	0404598f0r			; 3.08746
	DD	040450fb0r			; 3.07908
	DD	0404496c1r			; 3.0717
	DD	040442969r			; 3.06503
	DD	04043c4d8r			; 3.05889
	DD	04043673ar			; 3.05318
	DD	040430f4ar			; 3.04781
	DD	04042bc1cr			; 3.04273
	DD	040426cfbr			; 3.0379
	DD	04042215er			; 3.03329
	DD	04041d8d5r			; 3.02886
	DD	040419308r			; 3.0246
	DD	040414fadr			; 3.02049
	DD	040410e85r			; 3.01651
	DD	04040cf5cr			; 3.01266
	DD	040409207r			; 3.00891
	DD	04040565er			; 3.00527
	DD	040401c41r			; 3.00172
	DD	0403fe391r			; 2.99826
	DD	0403fac35r			; 2.99489
	DD	0403f7616r			; 2.99158
	DD	0403f411fr			; 2.98835
	DD	0403f0d3er			; 2.98518
	DD	0403eda63r			; 2.98208
	DD	0403ea87er			; 2.97903
	DD	0403e7782r			; 2.97604
	DD	0403e4763r			; 2.97311
	DD	0403e1814r			; 2.97022
	DD	0403de98dr			; 2.96738
	DD	0403dbbc3r			; 2.96459
	DD	0403d8eadr			; 2.96183
	DD	0403d6243r			; 2.95912
	DD	0403d367er			; 2.95645
	DD	0403d0b56r			; 2.95382
	DD	0403ce0c6r			; 2.95122
	DD	0403cb6c6r			; 2.94866
	DD	0403c8d52r			; 2.94613
	DD	0403c6463r			; 2.94363
	DD	0403c3bf6r			; 2.94116
	DD	0403c1405r			; 2.93872
	DD	0403bec8br			; 2.93631
	DD	0403bc585r			; 2.93393
	DD	0403b9eefr			; 2.93158
	DD	0403b78c5r			; 2.92925
	DD	0403b5303r			; 2.92694
	DD	0403b2da6r			; 2.92466
	DD	0403b08abr			; 2.9224
	DD	0403ae410r			; 2.92017
	DD	0403abfd0r			; 2.91796
	DD	0403a9bear			; 2.91577
	DD	0403a785ar			; 2.9136
	DD	0403a551fr			; 2.91145
	DD	0403a3236r			; 2.90931
	DD	0403a0f9dr			; 2.9072
	DD	04039ed51r			; 2.90511
	DD	04039cb51r			; 2.90303
	DD	04039a99br			; 2.90098
	DD	04039882cr			; 2.89894
	DD	040396703r			; 2.89691
	DD	04039461fr			; 2.8949
	DD	04039257dr			; 2.89291
	DD	04039051dr			; 2.89094
	DD	04038e4fbr			; 2.88898
	DD	04038c518r			; 2.88703
	DD	04038a571r			; 2.8851
	DD	040388606r			; 2.88318
	DD	0403866d5r			; 2.88128
	DD	0403847dcr			; 2.87939
	DD	04038291ar			; 2.87751
	DD	040380a8fr			; 2.87564
	DD	04037ec3ar			; 2.87379
	DD	04037ce18r			; 2.87195
	DD	04037b029r			; 2.87013
	DD	04037926cr			; 2.86831
	DD	0403774e0r			; 2.86651
	DD	040375784r			; 2.86472
	DD	040373a57r			; 2.86294
	DD	040371d59r			; 2.86117
	DD	040370088r			; 2.85941
	DD	04036e3e3r			; 2.85766
	DD	04036c76ar			; 2.85592
	DD	04036ab1cr			; 2.85419
	DD	040368ef7r			; 2.85248
	DD	0403672fdr			; 2.85077
	DD	04036572br			; 2.84907
	DD	040363b80r			; 2.84738
	DD	040361ffer			; 2.8457
	DD	0403604a1r			; 2.84403
	DD	04035e96br			; 2.84237
	DD	04035ce5ar			; 2.84072
	DD	04035b36dr			; 2.83908
	DD	0403598a5r			; 2.83744
	DD	040357e00r			; 2.83582
	DD	04035637er			; 2.8342
	DD	04035491fr			; 2.83259
	DD	040352ee1r			; 2.83099
	DD	0403514c5r			; 2.82939
	DD	04034facar			; 2.82781
	DD	04034e0efr			; 2.82623
	DD	04034c734r			; 2.82466
	DD	04034ad98r			; 2.8231
	DD	04034941br			; 2.82154
	DD	040347abdr			; 2.81999
	DD	04034617cr			; 2.81845
	DD	04034485ar			; 2.81692
	DD	040342f54r			; 2.81539
	DD	04034166cr			; 2.81387
	DD	04033fd9fr			; 2.81235
	DD	04033e4efr			; 2.81085
	DD	04033cc5ar			; 2.80935
	DD	04033b3e1r			; 2.80785
	DD	040339b82r			; 2.80637
	DD	04033833er			; 2.80489
	DD	040336b14r			; 2.80341
	DD	040335304r			; 2.80194
	DD	040333b0er			; 2.80048
	DD	040332330r			; 2.79902
	DD	040330b6cr			; 2.79757
	DD	04032f3c0r			; 2.79613
	DD	04032dc2cr			; 2.79469
	DD	04032c4b0r			; 2.79325
	DD	04032ad4cr			; 2.79183
	DD	0403295ffr			; 2.79041
	DD	040327ecar			; 2.78899
	DD	0403267abr			; 2.78758
	DD	0403250a2r			; 2.78617
	DD	0403239b0r			; 2.78477
	DD	0403222d4r			; 2.78338
	DD	040320c0dr			; 2.78199
	DD	04031f55cr			; 2.7806
	DD	04031dec0r			; 2.77922
	DD	04031c839r			; 2.77785
	DD	04031b1c7r			; 2.77648
	DD	040319b6ar			; 2.77511
	DD	040318521r			; 2.77375
	DD	040316eebr			; 2.77239
	DD	0403158car			; 2.77104
	DD	0403142bcr			; 2.7697
	DD	040312cc2r			; 2.76836
	DD	0403116dbr			; 2.76702
	DD	040310107r			; 2.76569
	DD	04030eb46r			; 2.76436
	DD	04030d597r			; 2.76304
	DD	04030bffbr			; 2.76172
	DD	04030aa71r			; 2.7604
	DD	0403094f9r			; 2.75909
	DD	040307f93r			; 2.75779
	DD	040306a3er			; 2.75648
	DD	0403054fbr			; 2.75519
	DD	040303fc9r			; 2.75389
	DD	040302aa9r			; 2.7526
	DD	040301599r			; 2.75132
	DD	04030009ar			; 2.75004
	DD	0402febacr			; 2.74876
	DD	0402fd6cer			; 2.74749
	DD	0402fc201r			; 2.74622
	DD	0402fad44r			; 2.74495
	DD	0402f9896r			; 2.74369
	DD	0402f83f9r			; 2.74243
	DD	0402f6f6br			; 2.74118
	DD	0402f5aedr			; 2.73992
	DD	0402f467er			; 2.73868
	DD	0402f321fr			; 2.73743
	DD	0402f1dcer			; 2.73619
	DD	0402f098dr			; 2.73496
	DD	0402ef55ar			; 2.73373
	DD	0402ee136r			; 2.7325
	DD	0402ecd21r			; 2.73127
	DD	0402eb91ar			; 2.73005
	DD	0402ea522r			; 2.72883
	DD	0402e9137r			; 2.72761
	DD	0402e7d5br			; 2.7264
	DD	0402e698dr			; 2.72519
	DD	0402e55ccr			; 2.72399
	DD	0402e4219r			; 2.72278
	DD	0402e2e74r			; 2.72159
	DD	0402e1adcr			; 2.72039
	DD	0402e0752r			; 2.7192
	DD	0402df3d5r			; 2.71801
	DD	0402de065r			; 2.71682
	DD	0402dcd02r			; 2.71564
	DD	0402db9acr			; 2.71446
	DD	0402da662r			; 2.71328
	DD	0402d9326r			; 2.71211
	DD	0402d7ff6r			; 2.71094
	DD	0402d6cd2r			; 2.70977
	DD	0402d59bbr			; 2.7086
	DD	0402d46b0r			; 2.70744
	DD	0402d33b1r			; 2.70628
	DD	0402d20bfr			; 2.70512
	DD	0402d0dd8r			; 2.70397
	DD	0402cfafer			; 2.70282
	DD	0402ce82fr			; 2.70167
	DD	0402cd56cr			; 2.70053
	DD	0402cc2b4r			; 2.69938
	DD	0402cb008r			; 2.69824
	DD	0402c9d67r			; 2.69711
	DD	0402c8ad2r			; 2.69597
	DD	0402c7848r			; 2.69484
	DD	0402c65car			; 2.69371
	DD	0402c5356r			; 2.69259
	DD	0402c40edr			; 2.69146
	DD	0402c2e90r			; 2.69034
	DD	0402c1c3dr			; 2.68922
	DD	0402c09f5r			; 2.68811
	DD	0402bf7b7r			; 2.68699
	DD	0402be585r			; 2.68588
	DD	0402bd35cr			; 2.68478
	DD	0402bc13er			; 2.68367
	DD	0402baf2br			; 2.68257
	DD	0402b9d22r			; 2.68147
	DD	0402b8b23r			; 2.68037
	DD	0402b792er			; 2.67927
	DD	0402b6744r			; 2.67818
	DD	0402b5563r			; 2.67709
	DD	0402b438dr			; 2.676
	DD	0402b31c0r			; 2.67491
	DD	0402b1ffdr			; 2.67383
	DD	0402b0e44r			; 2.67275
	DD	0402afc94r			; 2.67167
	DD	0402aeaeer			; 2.67059
	DD	0402ad952r			; 2.66951
	DD	0402ac7bfr			; 2.66844
	DD	0402ab635r			; 2.66737
	DD	0402aa4b5r			; 2.6663
	DD	0402a933er			; 2.66524
	DD	0402a81d0r			; 2.66417
	DD	0402a706cr			; 2.66311
	DD	0402a5f10r			; 2.66205
	DD	0402a4dber			; 2.661
	DD	0402a3c74r			; 2.65994
	DD	0402a2b34r			; 2.65889
	DD	0402a19fcr			; 2.65784
	DD	0402a08cdr			; 2.65679
	DD	04029f7a7r			; 2.65574
	DD	04029e68ar			; 2.6547
	DD	04029d575r			; 2.65365
	DD	04029c468r			; 2.65261
	DD	04029b365r			; 2.65157
	DD	04029a269r			; 2.65054
	DD	040299177r			; 2.6495
	DD	04029808cr			; 2.64847
	DD	040296faar			; 2.64744
	DD	040295ed0r			; 2.64641
	DD	040294dfer			; 2.64539
	DD	040293d34r			; 2.64436
	DD	040292c73r			; 2.64334
	DD	040291bbar			; 2.64232
	DD	040290b08r			; 2.6413
	DD	04028fa5fr			; 2.64028
	DD	04028e9bdr			; 2.63927
	DD	04028d923r			; 2.63825
	DD	04028c891r			; 2.63724
	DD	04028b807r			; 2.63623
	DD	04028a785r			; 2.63522
	DD	04028970ar			; 2.63422
	DD	040288697r			; 2.63321
	DD	04028762br			; 2.63221
	DD	0402865c7r			; 2.63121
	DD	04028556ar			; 2.63021
	DD	040284515r			; 2.62922
	DD	0402834c7r			; 2.62822
	DD	040282481r			; 2.62723
	DD	040281442r			; 2.62624
	DD	04028040ar			; 2.62525
	DD	04027f3d9r			; 2.62426
	DD	04027e3b0r			; 2.62327
	DD	04027d38er			; 2.62229
	DD	04027c372r			; 2.6213
	DD	04027b35er			; 2.62032
	DD	04027a351r			; 2.61934
	DD	04027934br			; 2.61837
	DD	04027834cr			; 2.61739
	DD	040277354r			; 2.61641
	DD	040276362r			; 2.61544
	DD	040275378r			; 2.61447
	DD	040274394r			; 2.6135
	DD	0402733b7r			; 2.61253
	DD	0402723e1r			; 2.61156
	DD	040271411r			; 2.6106
	DD	040270448r			; 2.60964
	DD	04026f485r			; 2.60867
	DD	04026e4car			; 2.60771
	DD	04026d514r			; 2.60676
	DD	04026c566r			; 2.6058
	DD	04026b5bdr			; 2.60484
	DD	04026a61br			; 2.60389
	DD	040269680r			; 2.60294
	DD	0402686ebr			; 2.60198
	DD	04026775cr			; 2.60104
	DD	0402667d3r			; 2.60009
	DD	040265851r			; 2.59914
	DD	0402648d5r			; 2.5982
	DD	04026395fr			; 2.59725
	DD	0402629efr			; 2.59631
	DD	040261a86r			; 2.59537
	DD	040260b22r			; 2.59443
	DD	04025fbc5r			; 2.59349
	DD	04025ec6dr			; 2.59256
	DD	04025dd1cr			; 2.59162
	DD	04025cdd1r			; 2.59069
	DD	04025be8br			; 2.58975
	DD	04025af4cr			; 2.58882
	DD	04025a012r			; 2.58789
	DD	0402590der			; 2.58697
	DD	0402581b0r			; 2.58604
	DD	040257288r			; 2.58512
	DD	040256365r			; 2.58419
	DD	040255449r			; 2.58327
	DD	040254532r			; 2.58235
	DD	040253620r			; 2.58143
	DD	040252715r			; 2.58051
	DD	04025180fr			; 2.57959
	DD	04025090er			; 2.57868
	DD	04024fa13r			; 2.57776
	DD	04024eb1er			; 2.57685
	DD	04024dc2er			; 2.57594
	DD	04024cd44r			; 2.57503
	DD	04024be5fr			; 2.57412
	DD	04024af7fr			; 2.57321
	DD	04024a0a5r			; 2.5723
	DD	0402491d0r			; 2.5714
	DD	040248301r			; 2.5705
	DD	040247437r			; 2.56959
	DD	040246572r			; 2.56869
	DD	0402456b3r			; 2.56779
	DD	0402447f9r			; 2.56689
	DD	040243944r			; 2.566
	DD	040242a94r			; 2.5651
	DD	040241be9r			; 2.5642
	DD	040240d44r			; 2.56331
	DD	04023fea3r			; 2.56242
	DD	04023f008r			; 2.56153
	DD	04023e172r			; 2.56064
	DD	04023d2e1r			; 2.55975
	DD	04023c455r			; 2.55886
	DD	04023b5cer			; 2.55797
	DD	04023a74cr			; 2.55709
	DD	0402398cfr			; 2.5562
	DD	040238a57r			; 2.55532
	DD	040237be3r			; 2.55444
	DD	040236d75r			; 2.55356
	DD	040235f0cr			; 2.55268
	DD	0402350a7r			; 2.5518
	DD	040234247r			; 2.55092
	DD	0402333ecr			; 2.55004
	DD	040232596r			; 2.54917
	DD	040231745r			; 2.5483
	DD	0402308f8r			; 2.54742
	DD	04022fab0r			; 2.54655
	DD	04022ec6dr			; 2.54568
	DD	04022de2er			; 2.54481
	DD	04022cff4r			; 2.54394
	DD	04022c1bfr			; 2.54308
	DD	04022b38er			; 2.54221
	DD	04022a562r			; 2.54134
	DD	04022973br			; 2.54048
	DD	040228918r			; 2.53962
	DD	040227af9r			; 2.53876
	DD	040226ce0r			; 2.5379
	DD	040225ecar			; 2.53704
	DD	0402250b9r			; 2.53618
	DD	0402242adr			; 2.53532
	DD	0402234a5r			; 2.53446
	DD	0402226a1r			; 2.53361
	DD	0402218a2r			; 2.53275
	DD	040220aa8r			; 2.5319
	DD	04021fcb1r			; 2.53105
	DD	04021eebfr			; 2.5302
	DD	04021e0d1r			; 2.52935
	DD	04021d2e8r			; 2.5285
	DD	04021c503r			; 2.52765
	DD	04021b722r			; 2.5268
	DD	04021a945r			; 2.52596
	DD	040219b6dr			; 2.52511
	DD	040218d99r			; 2.52427
	DD	040217fc9r			; 2.52342
	DD	0402171fdr			; 2.52258
	DD	040216436r			; 2.52174
	DD	040215672r			; 2.5209
	DD	0402148b3r			; 2.52006
	DD	040213af8r			; 2.51922
	DD	040212d41r			; 2.51839
	DD	040211f8er			; 2.51755
	DD	0402111dfr			; 2.51672
	DD	040210434r			; 2.51588
	DD	04020f68dr			; 2.51505
	DD	04020e8ebr			; 2.51422
	DD	04020db4cr			; 2.51338
	DD	04020cdb1r			; 2.51255
	DD	04020c01ar			; 2.51172
	DD	04020b287r			; 2.5109
	DD	04020a4f8r			; 2.51007
	DD	04020976dr			; 2.50924
	DD	0402089e6r			; 2.50842
	DD	040207c63r			; 2.50759
	DD	040206ee4r			; 2.50677
	DD	040206168r			; 2.50595
	DD	0402053f1r			; 2.50512
	DD	04020467dr			; 2.5043
	DD	04020390dr			; 2.50348
	DD	040202ba1r			; 2.50266
	DD	040201e38r			; 2.50184
	DD	0402010d3r			; 2.50103
	DD	040200373r			; 2.50021
	DD	0401ff615r			; 2.49939
	DD	0401fe8bcr			; 2.49858
	DD	0401fdb66r			; 2.49777
	DD	0401fce14r			; 2.49695
	DD	0401fc0c6r			; 2.49614
	DD	0401fb37br			; 2.49533
	DD	0401fa634r			; 2.49452
	DD	0401f98f1r			; 2.49371
	DD	0401f8bb1r			; 2.4929
	DD	0401f7e75r			; 2.49209
	DD	0401f713dr			; 2.49129
	DD	0401f6408r			; 2.49048
	DD	0401f56d6r			; 2.48968
	DD	0401f49a9r			; 2.48887
	DD	0401f3c7er			; 2.48807
	DD	0401f2f58r			; 2.48726
	DD	0401f2234r			; 2.48646
	DD	0401f1515r			; 2.48566
	DD	0401f07f8r			; 2.48486
	DD	0401efae0r			; 2.48406
	DD	0401eedcbr			; 2.48326
	DD	0401ee0b9r			; 2.48247
	DD	0401ed3aar			; 2.48167
	DD	0401ec69fr			; 2.48087
	DD	0401eb998r			; 2.48008
	DD	0401eac94r			; 2.47928
	DD	0401e9f93r			; 2.47849
	DD	0401e9296r			; 2.4777
	DD	0401e859cr			; 2.4769
	DD	0401e78a5r			; 2.47611
	DD	0401e6bb2r			; 2.47532
	DD	0401e5ec2r			; 2.47453
	DD	0401e51d5r			; 2.47374
	DD	0401e44ecr			; 2.47296
	DD	0401e3806r			; 2.47217
	DD	0401e2b23r			; 2.47138
	DD	0401e1e44r			; 2.4706
	DD	0401e1168r			; 2.46981
	DD	0401e048fr			; 2.46903
	DD	0401df7b9r			; 2.46824
	DD	0401deae6r			; 2.46746
	DD	0401dde17r			; 2.46668
	DD	0401dd14br			; 2.4659
	DD	0401dc482r			; 2.46512
	DD	0401db7bcr			; 2.46434
	DD	0401daafar			; 2.46356
	DD	0401d9e3ar			; 2.46278
	DD	0401d917er			; 2.46201
	DD	0401d84c5r			; 2.46123
	DD	0401d780fr			; 2.46045
	DD	0401d6b5cr			; 2.45968
	DD	0401d5eacr			; 2.4589
	DD	0401d5200r			; 2.45813
	DD	0401d4556r			; 2.45736
	DD	0401d38afr			; 2.45658
	DD	0401d2c0cr			; 2.45581
	DD	0401d1f6br			; 2.45504
	DD	0401d12cer			; 2.45427
	DD	0401d0634r			; 2.4535
	DD	0401cf99cr			; 2.45273
	DD	0401ced08r			; 2.45197
	DD	0401ce076r			; 2.4512
	DD	0401cd3e8r			; 2.45043
	DD	0401cc75dr			; 2.44967
	DD	0401cbad4r			; 2.4489
	DD	0401cae4fr			; 2.44814
	DD	0401ca1ccr			; 2.44738
	DD	0401c954dr			; 2.44661
	DD	0401c88d0r			; 2.44585
	DD	0401c7c56r			; 2.44509
	DD	0401c6fdfr			; 2.44433
	DD	0401c636br			; 2.44357
	DD	0401c56far			; 2.44281
	DD	0401c4a8cr			; 2.44205
	DD	0401c3e21r			; 2.44129
	DD	0401c31b8r			; 2.44053
	DD	0401c2552r			; 2.43978
	DD	0401c18f0r			; 2.43902
	DD	0401c0c90r			; 2.43827
	DD	0401c0033r			; 2.43751
	DD	0401bf3d8r			; 2.43676
	DD	0401be781r			; 2.436
	DD	0401bdb2cr			; 2.43525
	DD	0401bcedar			; 2.4345
	DD	0401bc28br			; 2.43375
	DD	0401bb63er			; 2.433
	DD	0401ba9f5r			; 2.43225
	DD	0401b9daer			; 2.4315
	DD	0401b9169r			; 2.43075
	DD	0401b8528r			; 2.43
	DD	0401b78e9r			; 2.42925
	DD	0401b6cadr			; 2.42851
	DD	0401b6074r			; 2.42776
	DD	0401b543dr			; 2.42702
	DD	0401b4809r			; 2.42627
	DD	0401b3bd8r			; 2.42553
	DD	0401b2fa9r			; 2.42478
	DD	0401b237dr			; 2.42404
	DD	0401b1754r			; 2.4233
	DD	0401b0b2dr			; 2.42256
	DD	0401aff09r			; 2.42182
	DD	0401af2e8r			; 2.42108
	DD	0401ae6c9r			; 2.42034
	DD	0401adaadr			; 2.4196
	DD	0401ace93r			; 2.41886
	DD	0401ac27cr			; 2.41812
	DD	0401ab668r			; 2.41738
	DD	0401aaa56r			; 2.41665
	DD	0401a9e47r			; 2.41591
	DD	0401a923ar			; 2.41517
	DD	0401a8630r			; 2.41444
	DD	0401a7a29r			; 2.41371
	DD	0401a6e23r			; 2.41297
	DD	0401a6221r			; 2.41224
	DD	0401a5621r			; 2.41151
	DD	0401a4a23r			; 2.41077
	DD	0401a3e28r			; 2.41004
	DD	0401a3230r			; 2.40931
	DD	0401a263ar			; 2.40858
	DD	0401a1a46r			; 2.40785
	DD	0401a0e55r			; 2.40712
	DD	0401a0267r			; 2.4064
	DD	04019f67ar			; 2.40567
	DD	04019ea91r			; 2.40494
	DD	04019dea9r			; 2.40422
	DD	04019d2c5r			; 2.40349
	DD	04019c6e2r			; 2.40276
	DD	04019bb02r			; 2.40204
	DD	04019af25r			; 2.40131
	DD	04019a34ar			; 2.40059
	DD	040199771r			; 2.39987
	DD	040198b9ar			; 2.39915
	DD	040197fc6r			; 2.39842
	DD	0401973f5r			; 2.3977
	DD	040196826r			; 2.39698
	DD	040195c59r			; 2.39626
	DD	04019508er			; 2.39554
	DD	0401944c6r			; 2.39482
	DD	040193900r			; 2.3941
	DD	040192d3dr			; 2.39339
	DD	04019217cr			; 2.39267
	DD	0401915bdr			; 2.39195
	DD	040190a00r			; 2.39124
	DD	04018fe46r			; 2.39052
	DD	04018f28er			; 2.3898
	DD	04018e6d8r			; 2.38909
	DD	04018db25r			; 2.38838
	DD	04018cf74r			; 2.38766
	DD	04018c3c5r			; 2.38695
	DD	04018b819r			; 2.38624
	DD	04018ac6fr			; 2.38552
	DD	04018a0c7r			; 2.38481
	DD	040189521r			; 2.3841
	DD	04018897dr			; 2.38339
	DD	040187ddcr			; 2.38268
	DD	04018723dr			; 2.38197
	DD	0401866a0r			; 2.38126
	DD	040185b05r			; 2.38056
	DD	040184f6dr			; 2.37985
	DD	0401843d7r			; 2.37914
	DD	040183843r			; 2.37843
	DD	040182cb1r			; 2.37773
	DD	040182121r			; 2.37702
	DD	040181594r			; 2.37632
	DD	040180a08r			; 2.37561
	DD	04017fe7fr			; 2.37491
	DD	04017f2f8r			; 2.3742
	DD	04017e773r			; 2.3735
	DD	04017dbf1r			; 2.3728
	DD	04017d070r			; 2.3721
	DD	04017c4f2r			; 2.3714
	DD	04017b975r			; 2.37069
	DD	04017adfbr			; 2.36999
	DD	04017a283r			; 2.36929
	DD	04017970dr			; 2.36859
	DD	040178b99r			; 2.3679
	DD	040178028r			; 2.3672
	DD	0401774b8r			; 2.3665
	DD	04017694ar			; 2.3658
	DD	040175ddfr			; 2.3651
	DD	040175276r			; 2.36441
	DD	04017470er			; 2.36371
	DD	040173ba9r			; 2.36302
	DD	040173046r			; 2.36232
	DD	0401724e4r			; 2.36163
	DD	040171985r			; 2.36093
	DD	040170e28r			; 2.36024
	DD	0401702cdr			; 2.35955
	DD	04016f774r			; 2.35885
	DD	04016ec1dr			; 2.35816
	DD	04016e0c8r			; 2.35747
	DD	04016d575r			; 2.35678
	DD	04016ca24r			; 2.35609
	DD	04016bed5r			; 2.3554
	DD	04016b388r			; 2.35471
	DD	04016a83dr			; 2.35402
	DD	040169cf4r			; 2.35333
	DD	0401691adr			; 2.35264
	DD	040168668r			; 2.35195
	DD	040167b25r			; 2.35127
	DD	040166fe3r			; 2.35058
	DD	0401664a4r			; 2.34989
	DD	040165967r			; 2.34921
	DD	040164e2cr			; 2.34852
	DD	0401642f2r			; 2.34784
	DD	0401637bbr			; 2.34715
	DD	040162c85r			; 2.34647
	DD	040162152r			; 2.34578
	DD	040161620r			; 2.3451
	DD	040160af0r			; 2.34442
	DD	04015ffc3r			; 2.34374
	DD	04015f497r			; 2.34305
	DD	04015e96dr			; 2.34237
	DD	04015de44r			; 2.34169
	DD	04015d31er			; 2.34101
	DD	04015c7far			; 2.34033
	DD	04015bcd7r			; 2.33965
	DD	04015b1b7r			; 2.33897
	DD	04015a698r			; 2.33829
	DD	040159b7br			; 2.33761
	DD	040159060r			; 2.33694
	DD	040158547r			; 2.33626
	DD	040157a2fr			; 2.33558
	DD	040156f1ar			; 2.33491
	DD	040156406r			; 2.33423
	DD	0401558f5r			; 2.33355
	DD	040154de5r			; 2.33288
	DD	0401542d6r			; 2.3322
	DD	0401537car			; 2.33153
	DD	040152cbfr			; 2.33086
	DD	0401521b7r			; 2.33018
	DD	0401516b0r			; 2.32951
	DD	040150babr			; 2.32884
	DD	0401500a7r			; 2.32816
	DD	04014f5a6r			; 2.32749
	DD	04014eaa6r			; 2.32682
	DD	04014dfa8r			; 2.32615
	DD	04014d4acr			; 2.32548
	DD	04014c9b2r			; 2.32481
	DD	04014beb9r			; 2.32414
	DD	04014b3c2r			; 2.32347
	DD	04014a8cdr			; 2.3228
	DD	040149ddar			; 2.32213
	DD	0401492e8r			; 2.32147
	DD	0401487f8r			; 2.3208
	DD	040147d0ar			; 2.32013
	DD	04014721dr			; 2.31946
	DD	040146733r			; 2.3188
	DD	040145c4ar			; 2.31813
	DD	040145163r			; 2.31747
	DD	04014467dr			; 2.3168
	DD	040143b99r			; 2.31614
	DD	0401430b7r			; 2.31547
	DD	0401425d7r			; 2.31481
	DD	040141af8r			; 2.31415
	DD	04014101br			; 2.31348
	DD	040140540r			; 2.31282
	DD	04013fa66r			; 2.31216
	DD	04013ef8er			; 2.3115
	DD	04013e4b8r			; 2.31083
	DD	04013d9e4r			; 2.31017
	DD	04013cf11r			; 2.30951
	DD	04013c43fr			; 2.30885
	DD	04013b970r			; 2.30819
	DD	04013aea2r			; 2.30753
	DD	04013a3d6r			; 2.30687
	DD	04013990br			; 2.30622
	DD	040138e42r			; 2.30556
	DD	04013837br			; 2.3049
	DD	0401378b5r			; 2.30424
	DD	040136df1r			; 2.30359
	DD	04013632fr			; 2.30293
	DD	04013586er			; 2.30227
	DD	040134dafr			; 2.30162
	DD	0401342f1r			; 2.30096
	DD	040133835r			; 2.30031
	DD	040132d7br			; 2.29965
	DD	0401322c2r			; 2.299
	DD	04013180br			; 2.29834
	DD	040130d55r			; 2.29769
	DD	0401302a1r			; 2.29704
	DD	04012f7efr			; 2.29638
	DD	04012ed3er			; 2.29573
	DD	04012e28fr			; 2.29508
	DD	04012d7e2r			; 2.29443
	DD	04012cd35r			; 2.29377
	DD	04012c28br			; 2.29312
	DD	04012b7e2r			; 2.29247
	DD	04012ad3br			; 2.29182
	DD	04012a295r			; 2.29117
	DD	0401297f1r			; 2.29052
	DD	040128d4er			; 2.28987
	DD	0401282adr			; 2.28923
	DD	04012780dr			; 2.28858
	DD	040126d6fr			; 2.28793
	DD	0401262d3r			; 2.28728
	DD	040125838r			; 2.28663
	DD	040124d9er			; 2.28599
	DD	040124306r			; 2.28534
	DD	040123870r			; 2.28469
	DD	040122ddbr			; 2.28405
	DD	040122348r			; 2.2834
	DD	0401218b6r			; 2.28276
	DD	040120e25r			; 2.28211
	DD	040120397r			; 2.28147
	DD	04011f909r			; 2.28082
	DD	04011ee7dr			; 2.28018
	DD	04011e3f3r			; 2.27954
	DD	04011d96ar			; 2.27889
	DD	04011cee3r			; 2.27825
	DD	04011c45dr			; 2.27761
	DD	04011b9d8r			; 2.27697
	DD	04011af55r			; 2.27633
	DD	04011a4d4r			; 2.27569
	DD	040119a54r			; 2.27504
	DD	040118fd5r			; 2.2744
	DD	040118558r			; 2.27376
	DD	040117adcr			; 2.27312
	DD	040117062r			; 2.27248
	DD	0401165e9r			; 2.27185
	DD	040115b72r			; 2.27121
	DD	0401150fcr			; 2.27057
	DD	040114688r			; 2.26993
	DD	040113c15r			; 2.26929
	DD	0401131a3r			; 2.26865
	DD	040112733r			; 2.26802
	DD	040111cc4r			; 2.26738
	DD	040111257r			; 2.26674
	DD	0401107ebr			; 2.26611
	DD	04010fd81r			; 2.26547
	DD	04010f317r			; 2.26484
	DD	04010e8b0r			; 2.2642
	DD	04010de4ar			; 2.26357
	DD	04010d3e5r			; 2.26293
	DD	04010c981r			; 2.2623
	DD	04010bf1fr			; 2.26167
	DD	04010b4bfr			; 2.26103
	DD	04010aa5fr			; 2.2604
	DD	04010a001r			; 2.25977
	DD	0401095a5r			; 2.25913
	DD	040108b4ar			; 2.2585
	DD	0401080f0r			; 2.25787
	DD	040107698r			; 2.25724
	DD	040106c41r			; 2.25661
	DD	0401061ebr			; 2.25598
	DD	040105797r			; 2.25535
	DD	040104d44r			; 2.25472
	DD	0401042f2r			; 2.25409
	DD	0401038a2r			; 2.25346
	DD	040102e53r			; 2.25283
	DD	040102406r			; 2.2522
	DD	0401019bar			; 2.25157
	DD	040100f6fr			; 2.25094
	DD	040100525r			; 2.25031
	DD	0400ffaddr			; 2.24969
	DD	0400ff096r			; 2.24906
	DD	0400fe651r			; 2.24843
	DD	0400fdc0dr			; 2.24781
	DD	0400fd1car			; 2.24718
	DD	0400fc788r			; 2.24655
	DD	0400fbd48r			; 2.24593
	DD	0400fb309r			; 2.2453
	DD	0400fa8ccr			; 2.24468
	DD	0400f9e8fr			; 2.24405
	DD	0400f9455r			; 2.24343
	DD	0400f8a1br			; 2.2428
	DD	0400f7fe3r			; 2.24218
	DD	0400f75abr			; 2.24156
	DD	0400f6b76r			; 2.24093
	DD	0400f6141r			; 2.24031
	DD	0400f570er			; 2.23969
	DD	0400f4cdcr			; 2.23907
	DD	0400f42abr			; 2.23844
	DD	0400f387cr			; 2.23782
	DD	0400f2e4er			; 2.2372
	DD	0400f2421r			; 2.23658
	DD	0400f19f6r			; 2.23596
	DD	0400f0fcbr			; 2.23534
	DD	0400f05a2r			; 2.23472
	DD	0400efb7br			; 2.2341
	DD	0400ef154r			; 2.23348
	DD	0400ee72fr			; 2.23286
	DD	0400edd0br			; 2.23224
	DD	0400ed2e8r			; 2.23162
	DD	0400ec8c7r			; 2.231
	DD	0400ebea7r			; 2.23039
	DD	0400eb488r			; 2.22977
	DD	0400eaa6ar			; 2.22915
	DD	0400ea04dr			; 2.22853
	DD	0400e9632r			; 2.22792
	DD	0400e8c18r			; 2.2273
	DD	0400e81ffr			; 2.22668
	DD	0400e77e8r			; 2.22607
	DD	0400e6dd1r			; 2.22545
	DD	0400e63bcr			; 2.22484
	DD	0400e59a8r			; 2.22422
	DD	0400e4f95r			; 2.22361
	DD	0400e4584r			; 2.22299
	DD	0400e3b74r			; 2.22238
	DD	0400e3165r			; 2.22176
	DD	0400e2757r			; 2.22115
	DD	0400e1d4ar			; 2.22054
	DD	0400e133fr			; 2.21992
	DD	0400e0934r			; 2.21931
	DD	0400dff2br			; 2.2187
	DD	0400df523r			; 2.21809
	DD	0400deb1cr			; 2.21747
	DD	0400de117r			; 2.21686
	DD	0400dd713r			; 2.21625
	DD	0400dcd0fr			; 2.21564
	DD	0400dc30dr			; 2.21503
	DD	0400db90dr			; 2.21442
	DD	0400daf0dr			; 2.21381
	DD	0400da50er			; 2.2132
	DD	0400d9b11r			; 2.21259
	DD	0400d9115r			; 2.21198
	DD	0400d871ar			; 2.21137
	DD	0400d7d20r			; 2.21076
	DD	0400d7328r			; 2.21015
	DD	0400d6930r			; 2.20955
	DD	0400d5f3ar			; 2.20894
	DD	0400d5544r			; 2.20833
	DD	0400d4b50r			; 2.20772
	DD	0400d415dr			; 2.20711
	DD	0400d376cr			; 2.20651
	DD	0400d2d7br			; 2.2059
	DD	0400d238cr			; 2.20529
	DD	0400d199dr			; 2.20469
	DD	0400d0fb0r			; 2.20408
	DD	0400d05c4r			; 2.20348
	DD	0400cfbd9r			; 2.20287
	DD	0400cf1efr			; 2.20227
	DD	0400ce806r			; 2.20166
	DD	0400cde1fr			; 2.20106
	DD	0400cd438r			; 2.20045
	DD	0400cca53r			; 2.19985
	DD	0400cc06fr			; 2.19925
	DD	0400cb68br			; 2.19864
	DD	0400caca9r			; 2.19804
	DD	0400ca2c8r			; 2.19744
	DD	0400c98e9r			; 2.19683
	DD	0400c8f0ar			; 2.19623
	DD	0400c852cr			; 2.19563
	DD	0400c7b50r			; 2.19503
	DD	0400c7174r			; 2.19442
	DD	0400c679ar			; 2.19382
	DD	0400c5dc1r			; 2.19322
	DD	0400c53e8r			; 2.19262
	DD	0400c4a11r			; 2.19202
	DD	0400c403br			; 2.19142
	DD	0400c3666r			; 2.19082
	DD	0400c2c93r			; 2.19022
	DD	0400c22c0r			; 2.18962
	DD	0400c18eer			; 2.18902
	DD	0400c0f1dr			; 2.18842
	DD	0400c054er			; 2.18782
	DD	0400bfb7fr			; 2.18723
	DD	0400bf1b2r			; 2.18663
	DD	0400be7e6r			; 2.18603
	DD	0400bde1ar			; 2.18543
	DD	0400bd450r			; 2.18483
	DD	0400bca87r			; 2.18424
	DD	0400bc0bfr			; 2.18364
	DD	0400bb6f8r			; 2.18304
	DD	0400bad32r			; 2.18245
	DD	0400ba36dr			; 2.18185
	DD	0400b99a9r			; 2.18125
	DD	0400b8fe6r			; 2.18066
	DD	0400b8624r			; 2.18006
	DD	0400b7c63r			; 2.17947
	DD	0400b72a3r			; 2.17887
	DD	0400b68e4r			; 2.17828
	DD	0400b5f27r			; 2.17768
	DD	0400b556ar			; 2.17709
	DD	0400b4baer			; 2.17649
	DD	0400b41f4r			; 2.1759
	DD	0400b383ar			; 2.17531
	DD	0400b2e81r			; 2.17471
	DD	0400b24car			; 2.17412
	DD	0400b1b13r			; 2.17353
	DD	0400b115er			; 2.17294
	DD	0400b07a9r			; 2.17234
	DD	0400afdf6r			; 2.17175
	DD	0400af443r			; 2.17116
	DD	0400aea92r			; 2.17057
	DD	0400ae0e1r			; 2.16998
	DD	0400ad731r			; 2.16938
	DD	0400acd83r			; 2.16879
	DD	0400ac3d5r			; 2.1682
	DD	0400aba29r			; 2.16761
	DD	0400ab07dr			; 2.16702
	DD	0400aa6d3r			; 2.16643
	DD	0400a9d29r			; 2.16584
	DD	0400a9381r			; 2.16525
	DD	0400a89d9r			; 2.16466
	DD	0400a8033r			; 2.16407
	DD	0400a768dr			; 2.16349
	DD	0400a6ce8r			; 2.1629
	DD	0400a6345r			; 2.16231
	DD	0400a59a2r			; 2.16172
	DD	0400a5000r			; 2.16113
	DD	0400a465fr			; 2.16055
	DD	0400a3cc0r			; 2.15996
	DD	0400a3321r			; 2.15937
	DD	0400a2983r			; 2.15878
	DD	0400a1fe6r			; 2.1582
	DD	0400a164ar			; 2.15761
	DD	0400a0cafr			; 2.15702
	DD	0400a0315r			; 2.15644
	DD	04009f97cr			; 2.15585
	DD	04009efe4r			; 2.15527
	DD	04009e64dr			; 2.15468
	DD	04009dcb7r			; 2.1541
	DD	04009d321r			; 2.15351
	DD	04009c98dr			; 2.15293
	DD	04009bffar			; 2.15234
	DD	04009b667r			; 2.15176
	DD	04009acd6r			; 2.15117
	DD	04009a345r			; 2.15059
	DD	0400999b6r			; 2.15001
	DD	040099027r			; 2.14942
	DD	040098699r			; 2.14884
	DD	040097d0dr			; 2.14826
	DD	040097381r			; 2.14767
	DD	0400969f6r			; 2.14709
	DD	04009606cr			; 2.14651
	DD	0400956e3r			; 2.14593
	DD	040094d5ar			; 2.14535
	DD	0400943d3r			; 2.14476
	DD	040093a4dr			; 2.14418
	DD	0400930c7r			; 2.1436
	DD	040092743r			; 2.14302
	DD	040091dbfr			; 2.14244
	DD	04009143cr			; 2.14186
	DD	040090abbr			; 2.14128
	DD	04009013ar			; 2.1407
	DD	04008f7bar			; 2.14012
	DD	04008ee3br			; 2.13954
	DD	04008e4bcr			; 2.13896
	DD	04008db3fr			; 2.13838
	DD	04008d1c3r			; 2.1378
	DD	04008c847r			; 2.13722
	DD	04008becdr			; 2.13665
	DD	04008b553r			; 2.13607
	DD	04008abdar			; 2.13549
	DD	04008a262r			; 2.13491
	DD	0400898ebr			; 2.13433
	DD	040088f75r			; 2.13376
	DD	040088600r			; 2.13318
	DD	040087c8br			; 2.1326
	DD	040087318r			; 2.13202
	DD	0400869a5r			; 2.13145
	DD	040086033r			; 2.13087
	DD	0400856c3r			; 2.1303
	DD	040084d52r			; 2.12972
	DD	0400843e3r			; 2.12914
	DD	040083a75r			; 2.12857
	DD	040083108r			; 2.12799
	DD	04008279br			; 2.12742
	DD	040081e2fr			; 2.12684
	DD	0400814c5r			; 2.12627
	DD	040080b5br			; 2.12569
	DD	0400801f1r			; 2.12512
	DD	04007f889r			; 2.12454
	DD	04007ef22r			; 2.12397
	DD	04007e5bbr			; 2.1234
	DD	04007dc56r			; 2.12282
	DD	04007d2f1r			; 2.12225
	DD	04007c98dr			; 2.12168
	DD	04007c02ar			; 2.1211
	DD	04007b6c7r			; 2.12053
	DD	04007ad66r			; 2.11996
	DD	04007a405r			; 2.11939
	DD	040079aa5r			; 2.11881
	DD	040079146r			; 2.11824
	DD	0400787e8r			; 2.11767
	DD	040077e8br			; 2.1171
	DD	04007752fr			; 2.11653
	DD	040076bd3r			; 2.11596
	DD	040076278r			; 2.11539
	DD	04007591er			; 2.11481
	DD	040074fc5r			; 2.11424
	DD	04007466dr			; 2.11367
	DD	040073d15r			; 2.1131
	DD	0400733bfr			; 2.11253
	DD	040072a69r			; 2.11196
	DD	040072114r			; 2.11139
	DD	0400717c0r			; 2.11082
	DD	040070e6cr			; 2.11026
	DD	04007051ar			; 2.10969
	DD	04006fbc8r			; 2.10912
	DD	04006f277r			; 2.10855
	DD	04006e927r			; 2.10798
	DD	04006dfd7r			; 2.10741
	DD	04006d689r			; 2.10684
	DD	04006cd3br			; 2.10628
	DD	04006c3eer			; 2.10571
	DD	04006baa2r			; 2.10514
	DD	04006b157r			; 2.10457
	DD	04006a80cr			; 2.10401
	DD	040069ec3r			; 2.10344
	DD	04006957ar			; 2.10287
	DD	040068c31r			; 2.10231
	DD	0400682ear			; 2.10174
	DD	0400679a4r			; 2.10117
	DD	04006705er			; 2.10061
	DD	040066719r			; 2.10004
	DD	040065dd5r			; 2.09948
	DD	040065491r			; 2.09891
	DD	040064b4er			; 2.09835
	DD	04006420dr			; 2.09778
	DD	0400638ccr			; 2.09722
	DD	040062f8br			; 2.09665
	DD	04006264cr			; 2.09609
	DD	040061d0dr			; 2.09552
	DD	0400613cfr			; 2.09496
	DD	040060a92r			; 2.0944
	DD	040060155r			; 2.09383
	DD	04005f81ar			; 2.09327
	DD	04005eedfr			; 2.0927
	DD	04005e5a5r			; 2.09214
	DD	04005dc6br			; 2.09158
	DD	04005d333r			; 2.09102
	DD	04005c9fbr			; 2.09045
	DD	04005c0c4r			; 2.08989
	DD	04005b78dr			; 2.08933
	DD	04005ae58r			; 2.08877
	DD	04005a523r			; 2.0882
	DD	040059befr			; 2.08764
	DD	0400592bcr			; 2.08708
	DD	040058989r			; 2.08652
	DD	040058057r			; 2.08596
	DD	040057726r			; 2.0854
	DD	040056df6r			; 2.08484
	DD	0400564c6r			; 2.08428
	DD	040055b97r			; 2.08372
	DD	040055269r			; 2.08315
	DD	04005493cr			; 2.08259
	DD	04005400fr			; 2.08203
	DD	0400536e3r			; 2.08148
	DD	040052db8r			; 2.08092
	DD	04005248er			; 2.08036
	DD	040051b64r			; 2.0798
	DD	04005123br			; 2.07924
	DD	040050913r			; 2.07868
	DD	04004ffebr			; 2.07812
	DD	04004f6c5r			; 2.07756
	DD	04004ed9fr			; 2.077
	DD	04004e479r			; 2.07644
	DD	04004db55r			; 2.07589
	DD	04004d231r			; 2.07533
	DD	04004c90er			; 2.07477
	DD	04004bfebr			; 2.07421
	DD	04004b6car			; 2.07366
	DD	04004ada9r			; 2.0731
	DD	04004a488r			; 2.07254
	DD	040049b69r			; 2.07199
	DD	04004924ar			; 2.07143
	DD	04004892cr			; 2.07087
	DD	04004800er			; 2.07032
	DD	0400476f2r			; 2.06976
	DD	040046dd6r			; 2.0692
	DD	0400464bar			; 2.06865
	DD	040045ba0r			; 2.06809
	DD	040045286r			; 2.06754
	DD	04004496dr			; 2.06698
	DD	040044054r			; 2.06643
	DD	04004373cr			; 2.06587
	DD	040042e25r			; 2.06532
	DD	04004250fr			; 2.06476
	DD	040041bf9r			; 2.06421
	DD	0400412e4r			; 2.06365
	DD	0400409d0r			; 2.0631
	DD	0400400bcr			; 2.06254
	DD	04003f7a9r			; 2.06199
	DD	04003ee97r			; 2.06144
	DD	04003e585r			; 2.06088
	DD	04003dc75r			; 2.06033
	DD	04003d364r			; 2.05978
	DD	04003ca55r			; 2.05922
	DD	04003c146r			; 2.05867
	DD	04003b838r			; 2.05812
	DD	04003af2ar			; 2.05757
	DD	04003a61er			; 2.05701
	DD	040039d11r			; 2.05646
	DD	040039406r			; 2.05591
	DD	040038afbr			; 2.05536
	DD	0400381f1r			; 2.05481
	DD	0400378e8r			; 2.05425
	DD	040036fdfr			; 2.0537
	DD	0400366d7r			; 2.05315
	DD	040035dcfr			; 2.0526
	DD	0400354c9r			; 2.05205
	DD	040034bc3r			; 2.0515
	DD	0400342bdr			; 2.05095
	DD	0400339b8r			; 2.0504
	DD	0400330b4r			; 2.04985
	DD	0400327b1r			; 2.0493
	DD	040031eaer			; 2.04875
	DD	0400315acr			; 2.0482
	DD	040030caar			; 2.04765
	DD	0400303aar			; 2.0471
	DD	04002faa9r			; 2.04655
	DD	04002f1aar			; 2.046
	DD	04002e8abr			; 2.04545
	DD	04002dfadr			; 2.0449
	DD	04002d6afr			; 2.04435
	DD	04002cdb2r			; 2.0438
	DD	04002c4b6r			; 2.04326
	DD	04002bbbar			; 2.04271
	DD	04002b2bfr			; 2.04216
	DD	04002a9c5r			; 2.04161
	DD	04002a0cbr			; 2.04106
	DD	0400297d2r			; 2.04052
	DD	040028edar			; 2.03997
	DD	0400285e2r			; 2.03942
	DD	040027cebr			; 2.03887
	DD	0400273f4r			; 2.03833
	DD	040026afer			; 2.03778
	DD	040026209r			; 2.03723
	DD	040025915r			; 2.03669
	DD	040025021r			; 2.03614
	DD	04002472dr			; 2.03559
	DD	040023e3ar			; 2.03505
	DD	040023548r			; 2.0345
	DD	040022c57r			; 2.03396
	DD	040022366r			; 2.03341
	DD	040021a76r			; 2.03287
	DD	040021186r			; 2.03232
	DD	040020897r			; 2.03177
	DD	04001ffa9r			; 2.03123
	DD	04001f6bbr			; 2.03068
	DD	04001edcer			; 2.03014
	DD	04001e4e1r			; 2.02959
	DD	04001dbf5r			; 2.02905
	DD	04001d30ar			; 2.02851
	DD	04001ca1fr			; 2.02796
	DD	04001c135r			; 2.02742
	DD	04001b84cr			; 2.02687
	DD	04001af63r			; 2.02633
	DD	04001a67br			; 2.02579
	DD	040019d93r			; 2.02524
	DD	0400194acr			; 2.0247
	DD	040018bc6r			; 2.02416
	DD	0400182e0r			; 2.02361
	DD	0400179fbr			; 2.02307
	DD	040017116r			; 2.02253
	DD	040016832r			; 2.02198
	DD	040015f4er			; 2.02144
	DD	04001566cr			; 2.0209
	DD	040014d89r			; 2.02036
	DD	0400144a8r			; 2.01982
	DD	040013bc7r			; 2.01927
	DD	0400132e6r			; 2.01873
	DD	040012a06r			; 2.01819
	DD	040012127r			; 2.01765
	DD	040011848r			; 2.01711
	DD	040010f6ar			; 2.01657
	DD	04001068dr			; 2.01602
	DD	04000fdb0r			; 2.01548
	DD	04000f4d3r			; 2.01494
	DD	04000ebf8r			; 2.0144
	DD	04000e31dr			; 2.01386
	DD	04000da42r			; 2.01332
	DD	04000d168r			; 2.01278
	DD	04000c88er			; 2.01224
	DD	04000bfb6r			; 2.0117
	DD	04000b6ddr			; 2.01116
	DD	04000ae06r			; 2.01062
	DD	04000a52fr			; 2.01008
	DD	040009c58r			; 2.00954
	DD	040009382r			; 2.009
	DD	040008aadr			; 2.00846
	DD	0400081d8r			; 2.00793
	DD	040007903r			; 2.00739
	DD	040007030r			; 2.00685
	DD	04000675dr			; 2.00631
	DD	040005e8ar			; 2.00577
	DD	0400055b8r			; 2.00523
	DD	040004ce7r			; 2.00469
	DD	040004416r			; 2.00416
	DD	040003b45r			; 2.00362
	DD	040003276r			; 2.00308
	DD	0400029a6r			; 2.00254
	DD	0400020d8r			; 2.002
	DD	04000180ar			; 2.00147
	DD	040000f3cr			; 2.00093
	DD	04000066fr			; 2.00039
	DD	03ffffb46r			; 1.99986
	DD	03fffe9aer			; 1.99932
	DD	03fffd817r			; 1.99878
	DD	03fffc682r			; 1.99825
	DD	03fffb4edr			; 1.99771
	DD	03fffa35ar			; 1.99717
	DD	03fff91c8r			; 1.99664
	DD	03fff8037r			; 1.9961
	DD	03fff6ea7r			; 1.99556
	DD	03fff5d18r			; 1.99503
	DD	03fff4b8ar			; 1.99449
	DD	03fff39fdr			; 1.99396
	DD	03fff2871r			; 1.99342
	DD	03fff16e7r			; 1.99289
	DD	03fff055dr			; 1.99235
	DD	03ffef3d5r			; 1.99182
	DD	03ffee24dr			; 1.99128
	DD	03ffed0c7r			; 1.99075
	DD	03ffebf42r			; 1.99021
	DD	03ffeadber			; 1.98968
	DD	03ffe9c3ar			; 1.98914
	DD	03ffe8ab8r			; 1.98861
	DD	03ffe7937r			; 1.98807
	DD	03ffe67b8r			; 1.98754
	DD	03ffe5639r			; 1.98701
	DD	03ffe44bbr			; 1.98647
	DD	03ffe333er			; 1.98594
	DD	03ffe21c2r			; 1.98541
	DD	03ffe1048r			; 1.98487
	DD	03ffdfecer			; 1.98434
	DD	03ffded56r			; 1.98381
	DD	03ffddbder			; 1.98327
	DD	03ffdca68r			; 1.98274
	DD	03ffdb8f2r			; 1.98221
	DD	03ffda77er			; 1.98167
	DD	03ffd960br			; 1.98114
	DD	03ffd8498r			; 1.98061
	DD	03ffd7327r			; 1.98008
	DD	03ffd61b7r			; 1.97954
	DD	03ffd5048r			; 1.97901
	DD	03ffd3ed9r			; 1.97848
	DD	03ffd2d6cr			; 1.97795
	DD	03ffd1c00r			; 1.97742
	DD	03ffd0a95r			; 1.97689
	DD	03ffcf92br			; 1.97635
	DD	03ffce7c2r			; 1.97582
	DD	03ffcd65ar			; 1.97529
	DD	03ffcc4f3r			; 1.97476
	DD	03ffcb38dr			; 1.97423
	DD	03ffca228r			; 1.9737
	DD	03ffc90c4r			; 1.97317
	DD	03ffc7f61r			; 1.97264
	DD	03ffc6dffr			; 1.97211
	DD	03ffc5c9er			; 1.97158
	DD	03ffc4b3er			; 1.97105
	DD	03ffc39dfr			; 1.97052
	DD	03ffc2881r			; 1.96999
	DD	03ffc1723r			; 1.96946
	DD	03ffc05c7r			; 1.96893
	DD	03ffbf46cr			; 1.9684
	DD	03ffbe312r			; 1.96787
	DD	03ffbd1b9r			; 1.96734
	DD	03ffbc061r			; 1.96681
	DD	03ffbaf0ar			; 1.96628
	DD	03ffb9db4r			; 1.96575
	DD	03ffb8c5fr			; 1.96522
	DD	03ffb7b0br			; 1.96469
	DD	03ffb69b7r			; 1.96416
	DD	03ffb5865r			; 1.96364
	DD	03ffb4714r			; 1.96311
	DD	03ffb35c4r			; 1.96258
	DD	03ffb2474r			; 1.96205
	DD	03ffb1326r			; 1.96152
	DD	03ffb01d9r			; 1.96099
	DD	03ffaf08cr			; 1.96047
	DD	03ffadf41r			; 1.95994
	DD	03ffacdf6r			; 1.95941
	DD	03ffabcadr			; 1.95888
	DD	03ffaab64r			; 1.95836
	DD	03ffa9a1cr			; 1.95783
	DD	03ffa88d6r			; 1.9573
	DD	03ffa7790r			; 1.95677
	DD	03ffa664br			; 1.95625
	DD	03ffa5507r			; 1.95572
	DD	03ffa43c4r			; 1.95519
	DD	03ffa3283r			; 1.95467
	DD	03ffa2141r			; 1.95414
	DD	03ffa1001r			; 1.95361
	DD	03ff9fec2r			; 1.95309
	DD	03ff9ed84r			; 1.95256
	DD	03ff9dc47r			; 1.95203
	DD	03ff9cb0ar			; 1.95151
	DD	03ff9b9cfr			; 1.95098
	DD	03ff9a894r			; 1.95046
	DD	03ff9975br			; 1.94993
	DD	03ff98622r			; 1.94941
	DD	03ff974ebr			; 1.94888
	DD	03ff963b4r			; 1.94836
	DD	03ff9527er			; 1.94783
	DD	03ff94149r			; 1.9473
	DD	03ff93015r			; 1.94678
	DD	03ff91ee2r			; 1.94625
	DD	03ff90dafr			; 1.94573
	DD	03ff8fc7er			; 1.94521
	DD	03ff8eb4er			; 1.94468
	DD	03ff8da1er			; 1.94416
	DD	03ff8c8f0r			; 1.94363
	DD	03ff8b7c2r			; 1.94311
	DD	03ff8a695r			; 1.94258
	DD	03ff89569r			; 1.94206
	DD	03ff8843er			; 1.94154
	DD	03ff87314r			; 1.94101
	DD	03ff861ebr			; 1.94049
	DD	03ff850c2r			; 1.93996
	DD	03ff83f9br			; 1.93944
	DD	03ff82e74r			; 1.93892
	DD	03ff81d4fr			; 1.93839
	DD	03ff80c2ar			; 1.93787
	DD	03ff7fb06r			; 1.93735
	DD	03ff7e9e3r			; 1.93683
	DD	03ff7d8c1r			; 1.9363
	DD	03ff7c7a0r			; 1.93578
	DD	03ff7b67fr			; 1.93526
	DD	03ff7a560r			; 1.93473
	DD	03ff79441r			; 1.93421
	DD	03ff78323r			; 1.93369
	DD	03ff77206r			; 1.93317
	DD	03ff760ear			; 1.93265
	DD	03ff74fcfr			; 1.93212
	DD	03ff73eb5r			; 1.9316
	DD	03ff72d9br			; 1.93108
	DD	03ff71c83r			; 1.93056
	DD	03ff70b6br			; 1.93004
	DD	03ff6fa54r			; 1.92951
	DD	03ff6e93er			; 1.92899
	DD	03ff6d829r			; 1.92847
	DD	03ff6c715r			; 1.92795
	DD	03ff6b601r			; 1.92743
	DD	03ff6a4efr			; 1.92691
	DD	03ff693ddr			; 1.92639
	DD	03ff682ccr			; 1.92587
	DD	03ff671bcr			; 1.92535
	DD	03ff660adr			; 1.92483
	DD	03ff64f9er			; 1.9243
	DD	03ff63e91r			; 1.92378
	DD	03ff62d84r			; 1.92326
	DD	03ff61c78r			; 1.92274
	DD	03ff60b6dr			; 1.92222
	DD	03ff5fa63r			; 1.9217
	DD	03ff5e959r			; 1.92118
	DD	03ff5d851r			; 1.92066
	DD	03ff5c749r			; 1.92014
	DD	03ff5b642r			; 1.91962
	DD	03ff5a53cr			; 1.91911
	DD	03ff59437r			; 1.91859
	DD	03ff58332r			; 1.91807
	DD	03ff5722fr			; 1.91755
	DD	03ff5612cr			; 1.91703
	DD	03ff5502ar			; 1.91651
	DD	03ff53f29r			; 1.91599
	DD	03ff52e28r			; 1.91547
	DD	03ff51d29r			; 1.91495
	DD	03ff50c2ar			; 1.91443
	DD	03ff4fb2cr			; 1.91392
	DD	03ff4ea2fr			; 1.9134
	DD	03ff4d933r			; 1.91288
	DD	03ff4c837r			; 1.91236
	DD	03ff4b73dr			; 1.91184
	DD	03ff4a643r			; 1.91132
	DD	03ff49549r			; 1.91081
	DD	03ff48451r			; 1.91029
	DD	03ff4735ar			; 1.90977
	DD	03ff46263r			; 1.90925
	DD	03ff4516dr			; 1.90873
	DD	03ff44078r			; 1.90822
	DD	03ff42f83r			; 1.9077
	DD	03ff41e90r			; 1.90718
	DD	03ff40d9dr			; 1.90667
	DD	03ff3fcabr			; 1.90615
	DD	03ff3ebbar			; 1.90563
	DD	03ff3dac9r			; 1.90511
	DD	03ff3c9dar			; 1.9046
	DD	03ff3b8ebr			; 1.90408
	DD	03ff3a7fdr			; 1.90356
	DD	03ff3970fr			; 1.90305
	DD	03ff38623r			; 1.90253
	DD	03ff37537r			; 1.90201
	DD	03ff3644cr			; 1.9015
	DD	03ff35361r			; 1.90098
	DD	03ff34278r			; 1.90047
	DD	03ff3318fr			; 1.89995
	DD	03ff320a7r			; 1.89943
	DD	03ff30fc0r			; 1.89892
	DD	03ff2fedar			; 1.8984
	DD	03ff2edf4r			; 1.89789
	DD	03ff2dd0fr			; 1.89737
	DD	03ff2cc2br			; 1.89686
	DD	03ff2bb47r			; 1.89634
	DD	03ff2aa65r			; 1.89583
	DD	03ff29983r			; 1.89531
	DD	03ff288a1r			; 1.89479
	DD	03ff277c1r			; 1.89428
	DD	03ff266e1r			; 1.89376
	DD	03ff25602r			; 1.89325
	DD	03ff24524r			; 1.89274
	DD	03ff23447r			; 1.89222
	DD	03ff2236ar			; 1.89171
	DD	03ff2128er			; 1.89119
	DD	03ff201b3r			; 1.89068
	DD	03ff1f0d8r			; 1.89016
	DD	03ff1dffer			; 1.88965
	DD	03ff1cf25r			; 1.88913
	DD	03ff1be4dr			; 1.88862
	DD	03ff1ad76r			; 1.88811
	DD	03ff19c9fr			; 1.88759
	DD	03ff18bc9r			; 1.88708
	DD	03ff17af3r			; 1.88656
	DD	03ff16a1er			; 1.88605
	DD	03ff1594ar			; 1.88554
	DD	03ff14877r			; 1.88502
	DD	03ff137a5r			; 1.88451
	DD	03ff126d3r			; 1.884
	DD	03ff11602r			; 1.88348
	DD	03ff10531r			; 1.88297
	DD	03ff0f462r			; 1.88246
	DD	03ff0e393r			; 1.88195
	DD	03ff0d2c5r			; 1.88143
	DD	03ff0c1f7r			; 1.88092
	DD	03ff0b12ar			; 1.88041
	DD	03ff0a05er			; 1.87989
	DD	03ff08f93r			; 1.87938
	DD	03ff07ec8r			; 1.87887
	DD	03ff06dfer			; 1.87836
	DD	03ff05d35r			; 1.87784
	DD	03ff04c6cr			; 1.87733
	DD	03ff03ba4r			; 1.87682
	DD	03ff02addr			; 1.87631
	DD	03ff01a16r			; 1.8758
	DD	03ff00950r			; 1.87528
	DD	03feff88br			; 1.87477
	DD	03fefe7c7r			; 1.87426
	DD	03fefd703r			; 1.87375
	DD	03fefc640r			; 1.87324
	DD	03fefb57er			; 1.87273
	DD	03fefa4bcr			; 1.87221
	DD	03fef93fbr			; 1.8717
	DD	03fef833ar			; 1.87119
	DD	03fef727br			; 1.87068
	DD	03fef61bcr			; 1.87017
	DD	03fef50fdr			; 1.86966
	DD	03fef4040r			; 1.86915
	DD	03fef2f83r			; 1.86864
	DD	03fef1ec6r			; 1.86813
	DD	03fef0e0br			; 1.86762
	DD	03feefd50r			; 1.86711
	DD	03feeec96r			; 1.8666
	DD	03feedbdcr			; 1.86608
	DD	03feecb23r			; 1.86557
	DD	03feeba6br			; 1.86506
	DD	03feea9b3r			; 1.86455
	DD	03fee98fcr			; 1.86404
	DD	03fee8846r			; 1.86353
	DD	03fee7790r			; 1.86302
	DD	03fee66dbr			; 1.86251
	DD	03fee5627r			; 1.862
	DD	03fee4573r			; 1.86149
	DD	03fee34c0r			; 1.86098
	DD	03fee240dr			; 1.86048
	DD	03fee135cr			; 1.85997
	DD	03fee02abr			; 1.85946
	DD	03fedf1far			; 1.85895
	DD	03fede14ar			; 1.85844
	DD	03fedd09br			; 1.85793
	DD	03fedbfedr			; 1.85742
	DD	03fedaf3fr			; 1.85691
	DD	03fed9e92r			; 1.8564
	DD	03fed8de5r			; 1.85589
	DD	03fed7d39r			; 1.85538
	DD	03fed6c8er			; 1.85488
	DD	03fed5be3r			; 1.85437
	DD	03fed4b39r			; 1.85386
	DD	03fed3a8fr			; 1.85335
	DD	03fed29e7r			; 1.85284
	DD	03fed193er			; 1.85233
	DD	03fed0897r			; 1.85182
	DD	03fecf7f0r			; 1.85132
	DD	03fece74ar			; 1.85081
	DD	03fecd6a4r			; 1.8503
	DD	03fecc5ffr			; 1.84979
	DD	03fecb55ar			; 1.84928
	DD	03feca4b7r			; 1.84878
	DD	03fec9413r			; 1.84827
	DD	03fec8371r			; 1.84776
	DD	03fec72cfr			; 1.84725
	DD	03fec622dr			; 1.84675
	DD	03fec518dr			; 1.84624
	DD	03fec40edr			; 1.84573
	DD	03fec304dr			; 1.84522
	DD	03fec1faer			; 1.84472
	DD	03fec0f10r			; 1.84421
	DD	03febfe72r			; 1.8437
	DD	03febedd5r			; 1.8432
	DD	03febdd38r			; 1.84269
	DD	03febcc9dr			; 1.84218
	DD	03febbc01r			; 1.84167
	DD	03febab67r			; 1.84117
	DD	03feb9accr			; 1.84066
	DD	03feb8a33r			; 1.84016
	DD	03feb799ar			; 1.83965
	DD	03feb6902r			; 1.83914
	DD	03feb586ar			; 1.83864
	DD	03feb47d3r			; 1.83813
	DD	03feb373cr			; 1.83762
	DD	03feb26a6r			; 1.83712
	DD	03feb1611r			; 1.83661
	DD	03feb057cr			; 1.8361
	DD	03feaf4e8r			; 1.8356
	DD	03feae454r			; 1.83509
	DD	03fead3c1r			; 1.83459
	DD	03feac32fr			; 1.83408
	DD	03feab29dr			; 1.83358
	DD	03feaa20br			; 1.83307
	DD	03fea917br			; 1.83256
	DD	03fea80ebr			; 1.83206
	DD	03fea705br			; 1.83155
	DD	03fea5fccr			; 1.83105
	DD	03fea4f3dr			; 1.83054
	DD	03fea3eb0r			; 1.83004
	DD	03fea2e22r			; 1.82953
	DD	03fea1d95r			; 1.82903
	DD	03fea0d09r			; 1.82852
	DD	03fe9fc7er			; 1.82802
	DD	03fe9ebf3r			; 1.82751
	DD	03fe9db68r			; 1.82701
	DD	03fe9cader			; 1.8265
	DD	03fe9ba55r			; 1.826
	DD	03fe9a9ccr			; 1.82549
	DD	03fe99944r			; 1.82499
	DD	03fe988bcr			; 1.82449
	DD	03fe97835r			; 1.82398
	DD	03fe967aer			; 1.82348
	DD	03fe95728r			; 1.82297
	DD	03fe946a3r			; 1.82247
	DD	03fe9361er			; 1.82196
	DD	03fe92599r			; 1.82146
	DD	03fe91515r			; 1.82096
	DD	03fe90492r			; 1.82045
	DD	03fe8f40fr			; 1.81995
	DD	03fe8e38dr			; 1.81944
	DD	03fe8d30br			; 1.81894
	DD	03fe8c28ar			; 1.81844
	DD	03fe8b20ar			; 1.81793
	DD	03fe8a18ar			; 1.81743
	DD	03fe8910ar			; 1.81693
	DD	03fe8808br			; 1.81642
	DD	03fe8700dr			; 1.81592
	DD	03fe85f8fr			; 1.81542
	DD	03fe84f11r			; 1.81491
	DD	03fe83e94r			; 1.81441
	DD	03fe82e18r			; 1.81391
	DD	03fe81d9cr			; 1.8134
	DD	03fe80d21r			; 1.8129
	DD	03fe7fca6r			; 1.8124
	DD	03fe7ec2cr			; 1.81189
	DD	03fe7dbb2r			; 1.81139
	DD	03fe7cb39r			; 1.81089
	DD	03fe7bac0r			; 1.81039
	DD	03fe7aa48r			; 1.80988
	DD	03fe799d0r			; 1.80938
	DD	03fe78959r			; 1.80888
	DD	03fe778e2r			; 1.80838
	DD	03fe7686cr			; 1.80787
	DD	03fe757f7r			; 1.80737
	DD	03fe74782r			; 1.80687
	DD	03fe7370dr			; 1.80637
	DD	03fe72699r			; 1.80587
	DD	03fe71625r			; 1.80536
	DD	03fe705b2r			; 1.80486
	DD	03fe6f540r			; 1.80436
	DD	03fe6e4cer			; 1.80386
	DD	03fe6d45cr			; 1.80336
	DD	03fe6c3ebr			; 1.80285
	DD	03fe6b37ar			; 1.80235
	DD	03fe6a30ar			; 1.80185
	DD	03fe6929br			; 1.80135
	DD	03fe6822cr			; 1.80085
	DD	03fe671bdr			; 1.80035
	DD	03fe6614fr			; 1.79984
	DD	03fe650e1r			; 1.79934
	DD	03fe64074r			; 1.79884
	DD	03fe63008r			; 1.79834
	DD	03fe61f9cr			; 1.79784
	DD	03fe60f30r			; 1.79734
	DD	03fe5fec5r			; 1.79684
	DD	03fe5ee5ar			; 1.79634
	DD	03fe5ddf0r			; 1.79584
	DD	03fe5cd86r			; 1.79533
	DD	03fe5bd1dr			; 1.79483
	DD	03fe5acb4r			; 1.79433
	DD	03fe59c4cr			; 1.79383
	DD	03fe58be4r			; 1.79333
	DD	03fe57b7dr			; 1.79283
	DD	03fe56b16r			; 1.79233
	DD	03fe55ab0r			; 1.79183
	DD	03fe54a4ar			; 1.79133
	DD	03fe539e4r			; 1.79083
	DD	03fe5297fr			; 1.79033
	DD	03fe5191br			; 1.78983
	DD	03fe508b7r			; 1.78933
	DD	03fe4f853r			; 1.78883
	DD	03fe4e7f0r			; 1.78833
	DD	03fe4d78er			; 1.78783
	DD	03fe4c72br			; 1.78733
	DD	03fe4b6car			; 1.78683
	DD	03fe4a668r			; 1.78633
	DD	03fe49608r			; 1.78583
	DD	03fe485a7r			; 1.78533
	DD	03fe47547r			; 1.78483
	DD	03fe464e8r			; 1.78433
	DD	03fe45489r			; 1.78383
	DD	03fe4442br			; 1.78333
	DD	03fe433ccr			; 1.78283
	DD	03fe4236fr			; 1.78233
	DD	03fe41312r			; 1.78183
	DD	03fe402b5r			; 1.78133
	DD	03fe3f259r			; 1.78083
	DD	03fe3e1fdr			; 1.78033
	DD	03fe3d1a2r			; 1.77983
	DD	03fe3c147r			; 1.77934
	DD	03fe3b0ecr			; 1.77884
	DD	03fe3a092r			; 1.77834
	DD	03fe39038r			; 1.77784
	DD	03fe37fdfr			; 1.77734
	DD	03fe36f87r			; 1.77684
	DD	03fe35f2er			; 1.77634
	DD	03fe34ed6r			; 1.77584
	DD	03fe33e7fr			; 1.77534
	DD	03fe32e28r			; 1.77485
	DD	03fe31dd1r			; 1.77435
	DD	03fe30d7br			; 1.77385
	DD	03fe2fd26r			; 1.77335
	DD	03fe2ecd0r			; 1.77285
	DD	03fe2dc7cr			; 1.77235
	DD	03fe2cc27r			; 1.77186
	DD	03fe2bbd3r			; 1.77136
	DD	03fe2ab80r			; 1.77086
	DD	03fe29b2cr			; 1.77036
	DD	03fe28adar			; 1.76986
	DD	03fe27a87r			; 1.76936
	DD	03fe26a35r			; 1.76887
	DD	03fe259e4r			; 1.76837
	DD	03fe24993r			; 1.76787
	DD	03fe23942r			; 1.76737
	DD	03fe228f2r			; 1.76687
	DD	03fe218a2r			; 1.76638
	DD	03fe20853r			; 1.76588
	DD	03fe1f804r			; 1.76538
	DD	03fe1e7b5r			; 1.76488
	DD	03fe1d767r			; 1.76439
	DD	03fe1c719r			; 1.76389
	DD	03fe1b6ccr			; 1.76339
	DD	03fe1a67fr			; 1.76289
	DD	03fe19632r			; 1.7624
	DD	03fe185e6r			; 1.7619
	DD	03fe1759br			; 1.7614
	DD	03fe1654fr			; 1.7609
	DD	03fe15504r			; 1.76041
	DD	03fe144bar			; 1.75991
	DD	03fe13470r			; 1.75941
	DD	03fe12426r			; 1.75892
	DD	03fe113dcr			; 1.75842
	DD	03fe10393r			; 1.75792
	DD	03fe0f34br			; 1.75742
	DD	03fe0e303r			; 1.75693
	DD	03fe0d2bbr			; 1.75643
	DD	03fe0c273r			; 1.75593
	DD	03fe0b22cr			; 1.75544
	DD	03fe0a1e6r			; 1.75494
	DD	03fe091a0r			; 1.75444
	DD	03fe0815ar			; 1.75395
	DD	03fe07114r			; 1.75345
	DD	03fe060cfr			; 1.75295
	DD	03fe0508ar			; 1.75246
	DD	03fe04046r			; 1.75196
	DD	03fe03002r			; 1.75147
	DD	03fe01fbfr			; 1.75097
	DD	03fe00f7br			; 1.75047
	DD	03fdfff39r			; 1.74998
	DD	03fdfeef6r			; 1.74948
	DD	03fdfdeb4r			; 1.74898
	DD	03fdfce72r			; 1.74849
	DD	03fdfbe31r			; 1.74799
	DD	03fdfadf0r			; 1.7475
	DD	03fdf9dafr			; 1.747
	DD	03fdf8d6fr			; 1.7465
	DD	03fdf7d2fr			; 1.74601
	DD	03fdf6cf0r			; 1.74551
	DD	03fdf5cb1r			; 1.74502
	DD	03fdf4c72r			; 1.74452
	DD	03fdf3c33r			; 1.74402
	DD	03fdf2bf5r			; 1.74353
	DD	03fdf1bb8r			; 1.74303
	DD	03fdf0b7ar			; 1.74254
	DD	03fdefb3dr			; 1.74204
	DD	03fdeeb01r			; 1.74155
	DD	03fdedac4r			; 1.74105
	DD	03fdeca89r			; 1.74056
	DD	03fdeba4dr			; 1.74006
	DD	03fdeaa12r			; 1.73957
	DD	03fde99d7r			; 1.73907
	DD	03fde899cr			; 1.73857
	DD	03fde7962r			; 1.73808
	DD	03fde6928r			; 1.73758
	DD	03fde58efr			; 1.73709
	DD	03fde48b6r			; 1.73659
	DD	03fde387dr			; 1.7361
	DD	03fde2845r			; 1.7356
	DD	03fde180dr			; 1.73511
	DD	03fde07d5r			; 1.73461
	DD	03fddf79dr			; 1.73412
	DD	03fdde766r			; 1.73362
	DD	03fddd730r			; 1.73313
	DD	03fddc6f9r			; 1.73263
	DD	03fddb6c3r			; 1.73214
	DD	03fdda68dr			; 1.73165
	DD	03fdd9658r			; 1.73115
	DD	03fdd8623r			; 1.73066
	DD	03fdd75eer			; 1.73016
	DD	03fdd65bar			; 1.72967
	DD	03fdd5586r			; 1.72917
	DD	03fdd4552r			; 1.72868
	DD	03fdd351fr			; 1.72818
	DD	03fdd24ebr			; 1.72769
	DD	03fdd14b9r			; 1.72719
	DD	03fdd0486r			; 1.7267
	DD	03fdcf454r			; 1.72621
	DD	03fdce422r			; 1.72571
	DD	03fdcd3f1r			; 1.72522
	DD	03fdcc3c0r			; 1.72472
	DD	03fdcb38fr			; 1.72423
	DD	03fdca35er			; 1.72374
	DD	03fdc932er			; 1.72324
	DD	03fdc82fer			; 1.72275
	DD	03fdc72cfr			; 1.72225
	DD	03fdc629fr			; 1.72176
	DD	03fdc5270r			; 1.72127
	DD	03fdc4242r			; 1.72077
	DD	03fdc3213r			; 1.72028
	DD	03fdc21e5r			; 1.71978
	DD	03fdc11b8r			; 1.71929
	DD	03fdc018ar			; 1.7188
	DD	03fdbf15dr			; 1.7183
	DD	03fdbe130r			; 1.71781
	DD	03fdbd104r			; 1.71732
	DD	03fdbc0d7r			; 1.71682
	DD	03fdbb0acr			; 1.71633
	DD	03fdba080r			; 1.71584
	DD	03fdb9055r			; 1.71534
	DD	03fdb802ar			; 1.71485
	DD	03fdb6fffr			; 1.71436
	DD	03fdb5fd4r			; 1.71386
	DD	03fdb4faar			; 1.71337
	DD	03fdb3f80r			; 1.71288
	DD	03fdb2f57r			; 1.71238
	DD	03fdb1f2er			; 1.71189
	DD	03fdb0f05r			; 1.7114
	DD	03fdafedcr			; 1.7109
	DD	03fdaeeb4r			; 1.71041
	DD	03fdade8cr			; 1.70992
	DD	03fdace64r			; 1.70942
	DD	03fdabe3cr			; 1.70893
	DD	03fdaae15r			; 1.70844
	DD	03fda9deer			; 1.70794
	DD	03fda8dc7r			; 1.70745
	DD	03fda7da1r			; 1.70696
	DD	03fda6d7br			; 1.70647
	DD	03fda5d55r			; 1.70597
	DD	03fda4d2fr			; 1.70548
	DD	03fda3d0ar			; 1.70499
	DD	03fda2ce5r			; 1.7045
	DD	03fda1cc0r			; 1.704
	DD	03fda0c9cr			; 1.70351
	DD	03fd9fc78r			; 1.70302
	DD	03fd9ec54r			; 1.70252
	DD	03fd9dc30r			; 1.70203
	DD	03fd9cc0dr			; 1.70154
	DD	03fd9bbe9r			; 1.70105
	DD	03fd9abc7r			; 1.70055
	DD	03fd99ba4r			; 1.70006
	DD	03fd98b82r			; 1.69957
	DD	03fd97b60r			; 1.69908
	DD	03fd96b3er			; 1.69859
	DD	03fd95b1cr			; 1.69809
	DD	03fd94afbr			; 1.6976
	DD	03fd93adar			; 1.69711
	DD	03fd92ab9r			; 1.69662
	DD	03fd91a99r			; 1.69612
	DD	03fd90a78r			; 1.69563
	DD	03fd8fa58r			; 1.69514
	DD	03fd8ea39r			; 1.69465
	DD	03fd8da19r			; 1.69416
	DD	03fd8c9far			; 1.69366
	DD	03fd8b9dbr			; 1.69317
	DD	03fd8a9bcr			; 1.69268
	DD	03fd8999er			; 1.69219
	DD	03fd88980r			; 1.6917
	DD	03fd87962r			; 1.6912
	DD	03fd86944r			; 1.69071
	DD	03fd85926r			; 1.69022
	DD	03fd84909r			; 1.68973
	DD	03fd838ecr			; 1.68924
	DD	03fd828cfr			; 1.68875
	DD	03fd818b3r			; 1.68825
	DD	03fd80896r			; 1.68776
	DD	03fd7f87ar			; 1.68727
	DD	03fd7e85er			; 1.68678
	DD	03fd7d843r			; 1.68629
	DD	03fd7c828r			; 1.6858
	DD	03fd7b80cr			; 1.6853
	DD	03fd7a7f2r			; 1.68481
	DD	03fd797d7r			; 1.68432
	DD	03fd787bcr			; 1.68383
	DD	03fd777a2r			; 1.68334
	DD	03fd76788r			; 1.68285
	DD	03fd7576fr			; 1.68236
	DD	03fd74755r			; 1.68186
	DD	03fd7373cr			; 1.68137
	DD	03fd72723r			; 1.68088
	DD	03fd7170ar			; 1.68039
	DD	03fd706f1r			; 1.6799
	DD	03fd6f6d9r			; 1.67941
	DD	03fd6e6c1r			; 1.67892
	DD	03fd6d6a9r			; 1.67843
	DD	03fd6c691r			; 1.67793
	DD	03fd6b67ar			; 1.67744
	DD	03fd6a662r			; 1.67695
	DD	03fd6964br			; 1.67646
	DD	03fd68634r			; 1.67597
	DD	03fd6761er			; 1.67548
	DD	03fd66607r			; 1.67499
	DD	03fd655f1r			; 1.6745
	DD	03fd645dbr			; 1.67401
	DD	03fd635c5r			; 1.67352
	DD	03fd625b0r			; 1.67303
	DD	03fd6159ar			; 1.67253
	DD	03fd60585r			; 1.67204
	DD	03fd5f570r			; 1.67155
	DD	03fd5e55br			; 1.67106
	DD	03fd5d547r			; 1.67057
	DD	03fd5c532r			; 1.67008
	DD	03fd5b51er			; 1.66959
	DD	03fd5a50ar			; 1.6691
	DD	03fd594f6r			; 1.66861
	DD	03fd584e3r			; 1.66812
	DD	03fd574cfr			; 1.66763
	DD	03fd564bcr			; 1.66714
	DD	03fd554a9r			; 1.66665
	DD	03fd54496r			; 1.66616
	DD	03fd53484r			; 1.66567
	DD	03fd52471r			; 1.66517
	DD	03fd5145fr			; 1.66468
	DD	03fd5044dr			; 1.66419
	DD	03fd4f43br			; 1.6637
	DD	03fd4e42ar			; 1.66321
	DD	03fd4d418r			; 1.66272
	DD	03fd4c407r			; 1.66223
	DD	03fd4b3f6r			; 1.66174
	DD	03fd4a3e5r			; 1.66125
	DD	03fd493d4r			; 1.66076
	DD	03fd483c4r			; 1.66027
	DD	03fd473b3r			; 1.65978
	DD	03fd463a3r			; 1.65929
	DD	03fd45393r			; 1.6588
	DD	03fd44383r			; 1.65831
	DD	03fd43374r			; 1.65782
	DD	03fd42364r			; 1.65733
	DD	03fd41355r			; 1.65684
	DD	03fd40346r			; 1.65635
	DD	03fd3f337r			; 1.65586
	DD	03fd3e328r			; 1.65537
	DD	03fd3d319r			; 1.65488
	DD	03fd3c30br			; 1.65439
	DD	03fd3b2fdr			; 1.6539
	DD	03fd3a2efr			; 1.65341
	DD	03fd392e1r			; 1.65292
	DD	03fd382d3r			; 1.65243
	DD	03fd372c5r			; 1.65194
	DD	03fd362b8r			; 1.65145
	DD	03fd352abr			; 1.65096
	DD	03fd3429er			; 1.65047
	DD	03fd33291r			; 1.64998
	DD	03fd32284r			; 1.64949
	DD	03fd31277r			; 1.649
	DD	03fd3026br			; 1.64851
	DD	03fd2f25er			; 1.64802
	DD	03fd2e252r			; 1.64753
	DD	03fd2d246r			; 1.64704
	DD	03fd2c23ar			; 1.64655
	DD	03fd2b22fr			; 1.64606
	DD	03fd2a223r			; 1.64557
	DD	03fd29218r			; 1.64508
	DD	03fd2820cr			; 1.64459
	DD	03fd27201r			; 1.6441
	DD	03fd261f6r			; 1.64361
	DD	03fd251ecr			; 1.64313
	DD	03fd241e1r			; 1.64264
	DD	03fd231d6r			; 1.64215
	DD	03fd221ccr			; 1.64166
	DD	03fd211c2r			; 1.64117
	DD	03fd201b8r			; 1.64068
	DD	03fd1f1aer			; 1.64019
	DD	03fd1e1a4r			; 1.6397
	DD	03fd1d19ar			; 1.63921
	DD	03fd1c191r			; 1.63872
	DD	03fd1b187r			; 1.63823
	DD	03fd1a17er			; 1.63774
	DD	03fd19175r			; 1.63725
	DD	03fd1816cr			; 1.63676
	DD	03fd17163r			; 1.63627
	DD	03fd1615ar			; 1.63578
	DD	03fd15152r			; 1.63529
	DD	03fd14149r			; 1.6348
	DD	03fd13141r			; 1.63432
	DD	03fd12139r			; 1.63383
	DD	03fd11131r			; 1.63334
	DD	03fd10129r			; 1.63285
	DD	03fd0f121r			; 1.63236
	DD	03fd0e119r			; 1.63187
	DD	03fd0d111r			; 1.63138
	DD	03fd0c10ar			; 1.63089
	DD	03fd0b103r			; 1.6304
	DD	03fd0a0fbr			; 1.62991
	DD	03fd090f4r			; 1.62942
	DD	03fd080edr			; 1.62893
	DD	03fd070e6r			; 1.62845
	DD	03fd060e0r			; 1.62796
	DD	03fd050d9r			; 1.62747
	DD	03fd040d3r			; 1.62698
	DD	03fd030ccr			; 1.62649
	DD	03fd020c6r			; 1.626
	DD	03fd010c0r			; 1.62551
	DD	03fd000bar			; 1.62502
	DD	03fcff0b4r			; 1.62453
	DD	03fcfe0aer			; 1.62404
	DD	03fcfd0a8r			; 1.62356
	DD	03fcfc0a2r			; 1.62307
	DD	03fcfb09dr			; 1.62258
	DD	03fcfa097r			; 1.62209
	DD	03fcf9092r			; 1.6216
	DD	03fcf808dr			; 1.62111
	DD	03fcf7088r			; 1.62062
	DD	03fcf6083r			; 1.62013
	DD	03fcf507er			; 1.61964
	DD	03fcf4079r			; 1.61916
	DD	03fcf3074r			; 1.61867
	DD	03fcf206fr			; 1.61818
	DD	03fcf106br			; 1.61769
	DD	03fcf0066r			; 1.6172
	DD	03fcef062r			; 1.61671
	DD	03fcee05er			; 1.61622
	DD	03fced059r			; 1.61573
	DD	03fcec055r			; 1.61524
	DD	03fceb051r			; 1.61476
	DD	03fcea04dr			; 1.61427
	DD	03fce904ar			; 1.61378
	DD	03fce8046r			; 1.61329
	DD	03fce7042r			; 1.6128
	DD	03fce603fr			; 1.61231
	DD	03fce503br			; 1.61182
	DD	03fce4038r			; 1.61133
	DD	03fce3034r			; 1.61085
	DD	03fce2031r			; 1.61036
	DD	03fce102er			; 1.60987
	DD	03fce002br			; 1.60938
	DD	03fcdf028r			; 1.60889
	DD	03fcde025r			; 1.6084
	DD	03fcdd022r			; 1.60791
	DD	03fcdc01fr			; 1.60743
	DD	03fcdb01dr			; 1.60694
	DD	03fcda01ar			; 1.60645
	DD	03fcd9017r			; 1.60596
	DD	03fcd8015r			; 1.60547
	DD	03fcd7012r			; 1.60498
	DD	03fcd6010r			; 1.60449
	DD	03fcd500er			; 1.60401
	DD	03fcd400cr			; 1.60352
	DD	03fcd3009r			; 1.60303
	DD	03fcd2007r			; 1.60254
	DD	03fcd1005r			; 1.60205
	DD	03fcd0003r			; 1.60156
	DD	03fccf001r			; 1.60107
	DD	03fcce000r			; 1.60059
	DD	03fcccffer			; 1.6001
	DD	03fccbffcr			; 1.59961
	DD	03fccaffar			; 1.59912
	DD	03fcc9ff9r			; 1.59863
	DD	03fcc8ff7r			; 1.59814
	DD	03fcc7ff6r			; 1.59766
	DD	03fcc6ff4r			; 1.59717
	DD	03fcc5ff3r			; 1.59668
	DD	03fcc4ff2r			; 1.59619
	DD	03fcc3ff0r			; 1.5957
	DD	03fcc2fefr			; 1.59521
	DD	03fcc1feer			; 1.59472
	DD	03fcc0fedr			; 1.59424
	DD	03fcbffecr			; 1.59375
	DD	03fcbefear			; 1.59326
	DD	03fcbdfe9r			; 1.59277
	DD	03fcbcfe9r			; 1.59228
	DD	03fcbbfe8r			; 1.59179
	DD	03fcbafe7r			; 1.59131
	DD	03fcb9fe6r			; 1.59082
	DD	03fcb8fe5r			; 1.59033
	DD	03fcb7fe4r			; 1.58984
	DD	03fcb6fe4r			; 1.58935
	DD	03fcb5fe3r			; 1.58886
	DD	03fcb4fe2r			; 1.58838
	DD	03fcb3fe2r			; 1.58789
	DD	03fcb2fe1r			; 1.5874
	DD	03fcb1fe0r			; 1.58691
	DD	03fcb0fe0r			; 1.58642
	DD	03fcaffdfr			; 1.58593
	DD	03fcaefdfr			; 1.58545
	DD	03fcadfdfr			; 1.58496
	DD	03fcacfder			; 1.58447
	DD	03fcabfder			; 1.58398
	DD	03fcaafddr			; 1.58349
	DD	03fca9fddr			; 1.583
	DD	03fca8fddr			; 1.58252
	DD	03fca7fddr			; 1.58203
	DD	03fca6fdcr			; 1.58154
	DD	03fca5fdcr			; 1.58105
	DD	03fca4fdcr			; 1.58056
	DD	03fca3fdcr			; 1.58007
	DD	03fca2fdcr			; 1.57959
	DD	03fca1fdbr			; 1.5791
	DD	03fca0fdbr			; 1.57861
	DD	03fc9ffdbr			; 1.57812
	DD	03fc9efdbr			; 1.57763
	DD	03fc9dfdbr			; 1.57714
	DD	03fc9cfdbr			; 1.57666
	DD	03fc9bfdbr			; 1.57617
	DD	03fc9afdbr			; 1.57568
	DD	03fc99fdbr			; 1.57519
	DD	03fc98fdbr			; 1.5747
	DD	03fc97fdbr			; 1.57421
	DD	03fc96fdbr			; 1.57373
	DD	03fc95fdbr			; 1.57324
	DD	03fc94fdbr			; 1.57275
	DD	03fc93fdbr			; 1.57226
	DD	03fc92fdbr			; 1.57177
	DD	03fc91fdbr			; 1.57128
	DD	03fc90fdbr			; 1.5708
	DD	03fc8ffdbr			; 1.57031
	DD	03fc8efdbr			; 1.56982
	DD	03fc8dfdbr			; 1.56933
	DD	03fc8cfdbr			; 1.56884
	DD	03fc8bfdbr			; 1.56835
	DD	03fc8afdbr			; 1.56787
	DD	03fc89fdbr			; 1.56738
	DD	03fc88fdbr			; 1.56689
	DD	03fc87fdbr			; 1.5664
	DD	03fc86fdar			; 1.56591
	DD	03fc85fdar			; 1.56543
	DD	03fc84fdar			; 1.56494
	DD	03fc83fdar			; 1.56445
	DD	03fc82fdar			; 1.56396
	DD	03fc81fdar			; 1.56347
	DD	03fc80fdar			; 1.56298
	DD	03fc7ffdar			; 1.5625
	DD	03fc7efdar			; 1.56201
	DD	03fc7dfdar			; 1.56152
	DD	03fc7cfd9r			; 1.56103
	DD	03fc7bfd9r			; 1.56054
	DD	03fc7afd9r			; 1.56005
	DD	03fc79fd9r			; 1.55957
	DD	03fc78fd8r			; 1.55908
	DD	03fc77fd8r			; 1.55859
	DD	03fc76fd8r			; 1.5581
	DD	03fc75fd7r			; 1.55761
	DD	03fc74fd7r			; 1.55712
	DD	03fc73fd7r			; 1.55664
	DD	03fc72fd6r			; 1.55615
	DD	03fc71fd6r			; 1.55566
	DD	03fc70fd5r			; 1.55517
	DD	03fc6ffd5r			; 1.55468
	DD	03fc6efd4r			; 1.55419
	DD	03fc6dfd4r			; 1.55371
	DD	03fc6cfd3r			; 1.55322
	DD	03fc6bfd2r			; 1.55273
	DD	03fc6afd2r			; 1.55224
	DD	03fc69fd1r			; 1.55175
	DD	03fc68fd0r			; 1.55126
	DD	03fc67fcfr			; 1.55078
	DD	03fc66fcfr			; 1.55029
	DD	03fc65fcer			; 1.5498
	DD	03fc64fcdr			; 1.54931
	DD	03fc63fccr			; 1.54882
	DD	03fc62fcbr			; 1.54833
	DD	03fc61fcar			; 1.54785
	DD	03fc60fc9r			; 1.54736
	DD	03fc5ffc7r			; 1.54687
	DD	03fc5efc6r			; 1.54638
	DD	03fc5dfc5r			; 1.54589
	DD	03fc5cfc4r			; 1.5454
	DD	03fc5bfc2r			; 1.54491
	DD	03fc5afc1r			; 1.54443
	DD	03fc59fc0r			; 1.54394
	DD	03fc58fber			; 1.54345
	DD	03fc57fbcr			; 1.54296
	DD	03fc56fbbr			; 1.54247
	DD	03fc55fb9r			; 1.54198
	DD	03fc54fb7r			; 1.5415
	DD	03fc53fb6r			; 1.54101
	DD	03fc52fb4r			; 1.54052
	DD	03fc51fb2r			; 1.54003
	DD	03fc50fb0r			; 1.53954
	DD	03fc4ffaer			; 1.53905
	DD	03fc4efacr			; 1.53856
	DD	03fc4dfaar			; 1.53808
	DD	03fc4cfa7r			; 1.53759
	DD	03fc4bfa5r			; 1.5371
	DD	03fc4afa3r			; 1.53661
	DD	03fc49fa0r			; 1.53612
	DD	03fc48f9er			; 1.53563
	DD	03fc47f9br			; 1.53514
	DD	03fc46f99r			; 1.53466
	DD	03fc45f96r			; 1.53417
	DD	03fc44f93r			; 1.53368
	DD	03fc43f90r			; 1.53319
	DD	03fc42f8dr			; 1.5327
	DD	03fc41f8ar			; 1.53221
	DD	03fc40f87r			; 1.53172
	DD	03fc3ff84r			; 1.53124
	DD	03fc3ef81r			; 1.53075
	DD	03fc3df7er			; 1.53026
	DD	03fc3cf7ar			; 1.52977
	DD	03fc3bf77r			; 1.52928
	DD	03fc3af73r			; 1.52879
	DD	03fc39f6fr			; 1.5283
	DD	03fc38f6cr			; 1.52781
	DD	03fc37f68r			; 1.52733
	DD	03fc36f64r			; 1.52684
	DD	03fc35f60r			; 1.52635
	DD	03fc34f5cr			; 1.52586
	DD	03fc33f58r			; 1.52537
	DD	03fc32f53r			; 1.52488
	DD	03fc31f4fr			; 1.52439
	DD	03fc30f4ar			; 1.5239
	DD	03fc2ff46r			; 1.52342
	DD	03fc2ef41r			; 1.52293
	DD	03fc2df3dr			; 1.52244
	DD	03fc2cf38r			; 1.52195
	DD	03fc2bf33r			; 1.52146
	DD	03fc2af2er			; 1.52097
	DD	03fc29f29r			; 1.52048
	DD	03fc28f23r			; 1.51999
	DD	03fc27f1er			; 1.5195
	DD	03fc26f19r			; 1.51902
	DD	03fc25f13r			; 1.51853
	DD	03fc24f0dr			; 1.51804
	DD	03fc23f08r			; 1.51755
	DD	03fc22f02r			; 1.51706
	DD	03fc21efcr			; 1.51657
	DD	03fc20ef6r			; 1.51608
	DD	03fc1feefr			; 1.51559
	DD	03fc1eee9r			; 1.5151
	DD	03fc1dee3r			; 1.51461
	DD	03fc1cedcr			; 1.51413
	DD	03fc1bed6r			; 1.51364
	DD	03fc1aecfr			; 1.51315
	DD	03fc19ec8r			; 1.51266
	DD	03fc18ec1r			; 1.51217
	DD	03fc17ebar			; 1.51168
	DD	03fc16eb3r			; 1.51119
	DD	03fc15eabr			; 1.5107
	DD	03fc14ea4r			; 1.51021
	DD	03fc13e9cr			; 1.50972
	DD	03fc12e94r			; 1.50923
	DD	03fc11e8dr			; 1.50874
	DD	03fc10e85r			; 1.50826
	DD	03fc0fe7dr			; 1.50777
	DD	03fc0ee74r			; 1.50728
	DD	03fc0de6cr			; 1.50679
	DD	03fc0ce64r			; 1.5063
	DD	03fc0be5br			; 1.50581
	DD	03fc0ae52r			; 1.50532
	DD	03fc09e49r			; 1.50483
	DD	03fc08e40r			; 1.50434
	DD	03fc07e37r			; 1.50385
	DD	03fc06e2er			; 1.50336
	DD	03fc05e25r			; 1.50287
	DD	03fc04e1br			; 1.50238
	DD	03fc03e11r			; 1.50189
	DD	03fc02e08r			; 1.5014
	DD	03fc01dfer			; 1.50092
	DD	03fc00df4r			; 1.50043
	DD	03fbffde9r			; 1.49994
	DD	03fbfeddfr			; 1.49945
	DD	03fbfddd4r			; 1.49896
	DD	03fbfcdcar			; 1.49847
	DD	03fbfbdbfr			; 1.49798
	DD	03fbfadb4r			; 1.49749
	DD	03fbf9da9r			; 1.497
	DD	03fbf8d9er			; 1.49651
	DD	03fbf7d92r			; 1.49602
	DD	03fbf6d87r			; 1.49553
	DD	03fbf5d7br			; 1.49504
	DD	03fbf4d6fr			; 1.49455
	DD	03fbf3d63r			; 1.49406
	DD	03fbf2d57r			; 1.49357
	DD	03fbf1d4br			; 1.49308
	DD	03fbf0d3er			; 1.49259
	DD	03fbefd31r			; 1.4921
	DD	03fbeed25r			; 1.49161
	DD	03fbedd18r			; 1.49112
	DD	03fbecd0br			; 1.49063
	DD	03fbebcfdr			; 1.49014
	DD	03fbeacf0r			; 1.48965
	DD	03fbe9ce2r			; 1.48916
	DD	03fbe8cd5r			; 1.48867
	DD	03fbe7cc7r			; 1.48818
	DD	03fbe6cb9r			; 1.48769
	DD	03fbe5caar			; 1.4872
	DD	03fbe4c9cr			; 1.48671
	DD	03fbe3c8dr			; 1.48622
	DD	03fbe2c7er			; 1.48573
	DD	03fbe1c6fr			; 1.48524
	DD	03fbe0c60r			; 1.48475
	DD	03fbdfc51r			; 1.48426
	DD	03fbdec42r			; 1.48377
	DD	03fbddc32r			; 1.48328
	DD	03fbdcc22r			; 1.48279
	DD	03fbdbc12r			; 1.4823
	DD	03fbdac02r			; 1.48181
	DD	03fbd9bf2r			; 1.48132
	DD	03fbd8be1r			; 1.48083
	DD	03fbd7bd0r			; 1.48034
	DD	03fbd6bbfr			; 1.47985
	DD	03fbd5baer			; 1.47936
	DD	03fbd4b9dr			; 1.47887
	DD	03fbd3b8cr			; 1.47838
	DD	03fbd2b7ar			; 1.47789
	DD	03fbd1b68r			; 1.4774
	DD	03fbd0b56r			; 1.47691
	DD	03fbcfb44r			; 1.47642
	DD	03fbceb31r			; 1.47593
	DD	03fbcdb1fr			; 1.47544
	DD	03fbccb0cr			; 1.47495
	DD	03fbcbaf9r			; 1.47446
	DD	03fbcaae6r			; 1.47397
	DD	03fbc9ad3r			; 1.47347
	DD	03fbc8abfr			; 1.47298
	DD	03fbc7aabr			; 1.47249
	DD	03fbc6a97r			; 1.472
	DD	03fbc5a83r			; 1.47151
	DD	03fbc4a6fr			; 1.47102
	DD	03fbc3a5ar			; 1.47053
	DD	03fbc2a45r			; 1.47004
	DD	03fbc1a30r			; 1.46955
	DD	03fbc0a1br			; 1.46906
	DD	03fbbfa06r			; 1.46857
	DD	03fbbe9f0r			; 1.46808
	DD	03fbbd9dar			; 1.46759
	DD	03fbbc9c4r			; 1.46709
	DD	03fbbb9aer			; 1.4666
	DD	03fbba998r			; 1.46611
	DD	03fbb9981r			; 1.46562
	DD	03fbb896ar			; 1.46513
	DD	03fbb7953r			; 1.46464
	DD	03fbb693cr			; 1.46415
	DD	03fbb5924r			; 1.46366
	DD	03fbb490cr			; 1.46317
	DD	03fbb38f5r			; 1.46268
	DD	03fbb28dcr			; 1.46218
	DD	03fbb18c4r			; 1.46169
	DD	03fbb08abr			; 1.4612
	DD	03fbaf893r			; 1.46071
	DD	03fbae879r			; 1.46022
	DD	03fbad860r			; 1.45973
	DD	03fbac847r			; 1.45924
	DD	03fbab82dr			; 1.45875
	DD	03fbaa813r			; 1.45825
	DD	03fba97f9r			; 1.45776
	DD	03fba87der			; 1.45727
	DD	03fba77c4r			; 1.45678
	DD	03fba67a9r			; 1.45629
	DD	03fba578er			; 1.4558
	DD	03fba4772r			; 1.45531
	DD	03fba3757r			; 1.45481
	DD	03fba273br			; 1.45432
	DD	03fba171fr			; 1.45383
	DD	03fba0703r			; 1.45334
	DD	03fb9f6e6r			; 1.45285
	DD	03fb9e6c9r			; 1.45236
	DD	03fb9d6acr			; 1.45186
	DD	03fb9c68fr			; 1.45137
	DD	03fb9b672r			; 1.45088
	DD	03fb9a654r			; 1.45039
	DD	03fb99636r			; 1.4499
	DD	03fb98618r			; 1.4494
	DD	03fb975f9r			; 1.44891
	DD	03fb965dar			; 1.44842
	DD	03fb955bbr			; 1.44793
	DD	03fb9459cr			; 1.44744
	DD	03fb9357dr			; 1.44694
	DD	03fb9255dr			; 1.44645
	DD	03fb9153dr			; 1.44596
	DD	03fb9051dr			; 1.44547
	DD	03fb8f4fcr			; 1.44498
	DD	03fb8e4dbr			; 1.44448
	DD	03fb8d4bar			; 1.44399
	DD	03fb8c499r			; 1.4435
	DD	03fb8b477r			; 1.44301
	DD	03fb8a456r			; 1.44252
	DD	03fb89434r			; 1.44202
	DD	03fb88411r			; 1.44153
	DD	03fb873efr			; 1.44104
	DD	03fb863ccr			; 1.44055
	DD	03fb853a9r			; 1.44005
	DD	03fb84385r			; 1.43956
	DD	03fb83362r			; 1.43907
	DD	03fb8233er			; 1.43858
	DD	03fb81319r			; 1.43808
	DD	03fb802f5r			; 1.43759
	DD	03fb7f2d0r			; 1.4371
	DD	03fb7e2abr			; 1.4366
	DD	03fb7d286r			; 1.43611
	DD	03fb7c260r			; 1.43562
	DD	03fb7b23br			; 1.43513
	DD	03fb7a214r			; 1.43463
	DD	03fb791eer			; 1.43414
	DD	03fb781c7r			; 1.43365
	DD	03fb771a0r			; 1.43316
	DD	03fb76179r			; 1.43266
	DD	03fb75152r			; 1.43217
	DD	03fb7412ar			; 1.43168
	DD	03fb73102r			; 1.43118
	DD	03fb720d9r			; 1.43069
	DD	03fb710b1r			; 1.4302
	DD	03fb70088r			; 1.4297
	DD	03fb6f05er			; 1.42921
	DD	03fb6e035r			; 1.42872
	DD	03fb6d00br			; 1.42822
	DD	03fb6bfe1r			; 1.42773
	DD	03fb6afb6r			; 1.42724
	DD	03fb69f8cr			; 1.42674
	DD	03fb68f61r			; 1.42625
	DD	03fb67f35r			; 1.42576
	DD	03fb66f0ar			; 1.42526
	DD	03fb65eder			; 1.42477
	DD	03fb64eb2r			; 1.42428
	DD	03fb63e85r			; 1.42378
	DD	03fb62e58r			; 1.42329
	DD	03fb61e2br			; 1.4228
	DD	03fb60dfer			; 1.4223
	DD	03fb5fdd0r			; 1.42181
	DD	03fb5eda2r			; 1.42131
	DD	03fb5dd74r			; 1.42082
	DD	03fb5cd45r			; 1.42033
	DD	03fb5bd16r			; 1.41983
	DD	03fb5ace7r			; 1.41934
	DD	03fb59cb7r			; 1.41885
	DD	03fb58c87r			; 1.41835
	DD	03fb57c57r			; 1.41786
	DD	03fb56c26r			; 1.41736
	DD	03fb55bf6r			; 1.41687
	DD	03fb54bc4r			; 1.41637
	DD	03fb53b93r			; 1.41588
	DD	03fb52b61r			; 1.41539
	DD	03fb51b2fr			; 1.41489
	DD	03fb50afdr			; 1.4144
	DD	03fb4facar			; 1.4139
	DD	03fb4ea97r			; 1.41341
	DD	03fb4da63r			; 1.41291
	DD	03fb4ca30r			; 1.41242
	DD	03fb4b9fbr			; 1.41193
	DD	03fb4a9c7r			; 1.41143
	DD	03fb49992r			; 1.41094
	DD	03fb4895dr			; 1.41044
	DD	03fb47928r			; 1.40995
	DD	03fb468f2r			; 1.40945
	DD	03fb458bcr			; 1.40896
	DD	03fb44886r			; 1.40846
	DD	03fb4384fr			; 1.40797
	DD	03fb42818r			; 1.40747
	DD	03fb417e0r			; 1.40698
	DD	03fb407a9r			; 1.40648
	DD	03fb3f771r			; 1.40599
	DD	03fb3e738r			; 1.40549
	DD	03fb3d6ffr			; 1.405
	DD	03fb3c6c6r			; 1.4045
	DD	03fb3b68dr			; 1.40401
	DD	03fb3a653r			; 1.40351
	DD	03fb39619r			; 1.40302
	DD	03fb385der			; 1.40252
	DD	03fb375a3r			; 1.40203
	DD	03fb36568r			; 1.40153
	DD	03fb3552dr			; 1.40104
	DD	03fb344f1r			; 1.40054
	DD	03fb334b5r			; 1.40005
	DD	03fb32478r			; 1.39955
	DD	03fb3143br			; 1.39905
	DD	03fb303fer			; 1.39856
	DD	03fb2f3c0r			; 1.39806
	DD	03fb2e382r			; 1.39757
	DD	03fb2d343r			; 1.39707
	DD	03fb2c305r			; 1.39658
	DD	03fb2b2c6r			; 1.39608
	DD	03fb2a286r			; 1.39558
	DD	03fb29246r			; 1.39509
	DD	03fb28206r			; 1.39459
	DD	03fb271c5r			; 1.3941
	DD	03fb26184r			; 1.3936
	DD	03fb25143r			; 1.3931
	DD	03fb24101r			; 1.39261
	DD	03fb230bfr			; 1.39211
	DD	03fb2207dr			; 1.39162
	DD	03fb2103ar			; 1.39112
	DD	03fb1fff7r			; 1.39062
	DD	03fb1efb3r			; 1.39013
	DD	03fb1df6fr			; 1.38963
	DD	03fb1cf2br			; 1.38913
	DD	03fb1bee6r			; 1.38864
	DD	03fb1aea1r			; 1.38814
	DD	03fb19e5cr			; 1.38765
	DD	03fb18e16r			; 1.38715
	DD	03fb17dcfr			; 1.38665
	DD	03fb16d89r			; 1.38616
	DD	03fb15d42r			; 1.38566
	DD	03fb14cfar			; 1.38516
	DD	03fb13cb3r			; 1.38466
	DD	03fb12c6ar			; 1.38417
	DD	03fb11c22r			; 1.38367
	DD	03fb10bd9r			; 1.38317
	DD	03fb0fb8fr			; 1.38268
	DD	03fb0eb46r			; 1.38218
	DD	03fb0dafcr			; 1.38168
	DD	03fb0cab1r			; 1.38119
	DD	03fb0ba66r			; 1.38069
	DD	03fb0aa1br			; 1.38019
	DD	03fb099cfr			; 1.37969
	DD	03fb08983r			; 1.3792
	DD	03fb07936r			; 1.3787
	DD	03fb068e9r			; 1.3782
	DD	03fb0589cr			; 1.3777
	DD	03fb0484er			; 1.37721
	DD	03fb03800r			; 1.37671
	DD	03fb027b1r			; 1.37621
	DD	03fb01762r			; 1.37571
	DD	03fb00713r			; 1.37522
	DD	03faff6c3r			; 1.37472
	DD	03fafe673r			; 1.37422
	DD	03fafd622r			; 1.37372
	DD	03fafc5d1r			; 1.37322
	DD	03fafb580r			; 1.37273
	DD	03fafa52er			; 1.37223
	DD	03faf94dcr			; 1.37173
	DD	03faf8489r			; 1.37123
	DD	03faf7436r			; 1.37073
	DD	03faf63e2r			; 1.37024
	DD	03faf538er			; 1.36974
	DD	03faf433ar			; 1.36924
	DD	03faf32e5r			; 1.36874
	DD	03faf2290r			; 1.36824
	DD	03faf123ar			; 1.36774
	DD	03faf01e4r			; 1.36725
	DD	03faef18dr			; 1.36675
	DD	03faee136r			; 1.36625
	DD	03faed0dfr			; 1.36575
	DD	03faec087r			; 1.36525
	DD	03faeb02fr			; 1.36475
	DD	03fae9fd6r			; 1.36425
	DD	03fae8f7dr			; 1.36375
	DD	03fae7f23r			; 1.36325
	DD	03fae6ec9r			; 1.36276
	DD	03fae5e6fr			; 1.36226
	DD	03fae4e14r			; 1.36176
	DD	03fae3db8r			; 1.36126
	DD	03fae2d5dr			; 1.36076
	DD	03fae1d00r			; 1.36026
	DD	03fae0ca4r			; 1.35976
	DD	03fadfc46r			; 1.35926
	DD	03fadebe9r			; 1.35876
	DD	03faddb8br			; 1.35826
	DD	03fadcb2cr			; 1.35776
	DD	03fadbacdr			; 1.35726
	DD	03fadaa6er			; 1.35676
	DD	03fad9a0er			; 1.35626
	DD	03fad89aer			; 1.35576
	DD	03fad794dr			; 1.35526
	DD	03fad68ecr			; 1.35476
	DD	03fad588ar			; 1.35426
	DD	03fad4828r			; 1.35376
	DD	03fad37c5r			; 1.35326
	DD	03fad2762r			; 1.35276
	DD	03fad16fer			; 1.35226
	DD	03fad069ar			; 1.35176
	DD	03facf636r			; 1.35126
	DD	03face5d1r			; 1.35076
	DD	03facd56cr			; 1.35026
	DD	03facc506r			; 1.34976
	DD	03facb49fr			; 1.34926
	DD	03faca438r			; 1.34876
	DD	03fac93d1r			; 1.34826
	DD	03fac8369r			; 1.34776
	DD	03fac7301r			; 1.34726
	DD	03fac6298r			; 1.34676
	DD	03fac522fr			; 1.34626
	DD	03fac41c5r			; 1.34576
	DD	03fac315br			; 1.34526
	DD	03fac20f1r			; 1.34476
	DD	03fac1085r			; 1.34425
	DD	03fac001ar			; 1.34375
	DD	03fabefaer			; 1.34325
	DD	03fabdf41r			; 1.34275
	DD	03fabced4r			; 1.34225
	DD	03fabbe66r			; 1.34175
	DD	03fabadf8r			; 1.34125
	DD	03fab9d8ar			; 1.34075
	DD	03fab8d1ar			; 1.34024
	DD	03fab7cabr			; 1.33974
	DD	03fab6c3br			; 1.33924
	DD	03fab5bcar			; 1.33874
	DD	03fab4b59r			; 1.33824
	DD	03fab3ae8r			; 1.33774
	DD	03fab2a76r			; 1.33723
	DD	03fab1a03r			; 1.33673
	DD	03fab0990r			; 1.33623
	DD	03faaf91cr			; 1.33573
	DD	03faae8a8r			; 1.33523
	DD	03faad834r			; 1.33472
	DD	03faac7bfr			; 1.33422
	DD	03faab749r			; 1.33372
	DD	03faaa6d3r			; 1.33322
	DD	03faa965cr			; 1.33271
	DD	03faa85e5r			; 1.33221
	DD	03faa756dr			; 1.33171
	DD	03faa64f5r			; 1.33121
	DD	03faa547cr			; 1.3307
	DD	03faa4403r			; 1.3302
	DD	03faa338ar			; 1.3297
	DD	03faa230fr			; 1.32919
	DD	03faa1294r			; 1.32869
	DD	03faa0219r			; 1.32819
	DD	03fa9f19dr			; 1.32769
	DD	03fa9e121r			; 1.32718
	DD	03fa9d0a4r			; 1.32668
	DD	03fa9c027r			; 1.32618
	DD	03fa9afa9r			; 1.32567
	DD	03fa99f2ar			; 1.32517
	DD	03fa98eabr			; 1.32467
	DD	03fa97e2cr			; 1.32416
	DD	03fa96dacr			; 1.32366
	DD	03fa95d2br			; 1.32316
	DD	03fa94caar			; 1.32265
	DD	03fa93c28r			; 1.32215
	DD	03fa92ba6r			; 1.32164
	DD	03fa91b23r			; 1.32114
	DD	03fa90aa0r			; 1.32064
	DD	03fa8fa1cr			; 1.32013
	DD	03fa8e998r			; 1.31963
	DD	03fa8d913r			; 1.31912
	DD	03fa8c88dr			; 1.31862
	DD	03fa8b807r			; 1.31812
	DD	03fa8a780r			; 1.31761
	DD	03fa896f9r			; 1.31711
	DD	03fa88672r			; 1.3166
	DD	03fa875e9r			; 1.3161
	DD	03fa86560r			; 1.31559
	DD	03fa854d7r			; 1.31509
	DD	03fa8444dr			; 1.31458
	DD	03fa833c3r			; 1.31408
	DD	03fa82338r			; 1.31357
	DD	03fa812acr			; 1.31307
	DD	03fa80220r			; 1.31256
	DD	03fa7f193r			; 1.31206
	DD	03fa7e106r			; 1.31155
	DD	03fa7d078r			; 1.31105
	DD	03fa7bfe9r			; 1.31054
	DD	03fa7af5ar			; 1.31004
	DD	03fa79ecbr			; 1.30953
	DD	03fa78e3br			; 1.30903
	DD	03fa77daar			; 1.30852
	DD	03fa76d19r			; 1.30802
	DD	03fa75c87r			; 1.30751
	DD	03fa74bf4r			; 1.30701
	DD	03fa73b61r			; 1.3065
	DD	03fa72acdr			; 1.30599
	DD	03fa71a39r			; 1.30549
	DD	03fa709a4r			; 1.30498
	DD	03fa6f90fr			; 1.30448
	DD	03fa6e879r			; 1.30397
	DD	03fa6d7e3r			; 1.30346
	DD	03fa6c74br			; 1.30296
	DD	03fa6b6b4r			; 1.30245
	DD	03fa6a61br			; 1.30194
	DD	03fa69582r			; 1.30144
	DD	03fa684e9r			; 1.30093
	DD	03fa6744fr			; 1.30042
	DD	03fa663b4r			; 1.29992
	DD	03fa65319r			; 1.29941
	DD	03fa6427dr			; 1.2989
	DD	03fa631e0r			; 1.2984
	DD	03fa62143r			; 1.29789
	DD	03fa610a6r			; 1.29738
	DD	03fa60007r			; 1.29688
	DD	03fa5ef68r			; 1.29637
	DD	03fa5dec9r			; 1.29586
	DD	03fa5ce29r			; 1.29535
	DD	03fa5bd88r			; 1.29485
	DD	03fa5ace6r			; 1.29434
	DD	03fa59c44r			; 1.29383
	DD	03fa58ba2r			; 1.29332
	DD	03fa57affr			; 1.29282
	DD	03fa56a5br			; 1.29231
	DD	03fa559b6r			; 1.2918
	DD	03fa54911r			; 1.29129
	DD	03fa5386cr			; 1.29078
	DD	03fa527c5r			; 1.29028
	DD	03fa5171er			; 1.28977
	DD	03fa50677r			; 1.28926
	DD	03fa4f5cfr			; 1.28875
	DD	03fa4e526r			; 1.28824
	DD	03fa4d47cr			; 1.28773
	DD	03fa4c3d2r			; 1.28723
	DD	03fa4b328r			; 1.28672
	DD	03fa4a27cr			; 1.28621
	DD	03fa491d0r			; 1.2857
	DD	03fa48124r			; 1.28519
	DD	03fa47076r			; 1.28468
	DD	03fa45fc9r			; 1.28417
	DD	03fa44f1ar			; 1.28366
	DD	03fa43e6br			; 1.28315
	DD	03fa42dbbr			; 1.28265
	DD	03fa41d0br			; 1.28214
	DD	03fa40c5ar			; 1.28163
	DD	03fa3fba8r			; 1.28112
	DD	03fa3eaf5r			; 1.28061
	DD	03fa3da42r			; 1.2801
	DD	03fa3c98fr			; 1.27959
	DD	03fa3b8dar			; 1.27908
	DD	03fa3a825r			; 1.27857
	DD	03fa39770r			; 1.27806
	DD	03fa386b9r			; 1.27755
	DD	03fa37602r			; 1.27704
	DD	03fa3654br			; 1.27653
	DD	03fa35492r			; 1.27602
	DD	03fa343d9r			; 1.27551
	DD	03fa33320r			; 1.275
	DD	03fa32265r			; 1.27449
	DD	03fa311aar			; 1.27398
	DD	03fa300efr			; 1.27347
	DD	03fa2f033r			; 1.27296
	DD	03fa2df76r			; 1.27244
	DD	03fa2ceb8r			; 1.27193
	DD	03fa2bdfar			; 1.27142
	DD	03fa2ad3br			; 1.27091
	DD	03fa29c7br			; 1.2704
	DD	03fa28bbbr			; 1.26989
	DD	03fa27af9r			; 1.26938
	DD	03fa26a38r			; 1.26887
	DD	03fa25975r			; 1.26836
	DD	03fa248b2r			; 1.26784
	DD	03fa237eer			; 1.26733
	DD	03fa2272ar			; 1.26682
	DD	03fa21665r			; 1.26631
	DD	03fa2059fr			; 1.2658
	DD	03fa1f4d8r			; 1.26528
	DD	03fa1e411r			; 1.26477
	DD	03fa1d349r			; 1.26426
	DD	03fa1c281r			; 1.26375
	DD	03fa1b1b7r			; 1.26324
	DD	03fa1a0edr			; 1.26272
	DD	03fa19023r			; 1.26221
	DD	03fa17f57r			; 1.2617
	DD	03fa16e8br			; 1.26119
	DD	03fa15dber			; 1.26067
	DD	03fa14cf1r			; 1.26016
	DD	03fa13c22r			; 1.25965
	DD	03fa12b54r			; 1.25913
	DD	03fa11a84r			; 1.25862
	DD	03fa109b3r			; 1.25811
	DD	03fa0f8e2r			; 1.2576
	DD	03fa0e811r			; 1.25708
	DD	03fa0d73er			; 1.25657
	DD	03fa0c66br			; 1.25606
	DD	03fa0b597r			; 1.25554
	DD	03fa0a4c2r			; 1.25503
	DD	03fa093edr			; 1.25451
	DD	03fa08317r			; 1.254
	DD	03fa07240r			; 1.25349
	DD	03fa06168r			; 1.25297
	DD	03fa05090r			; 1.25246
	DD	03fa03fb7r			; 1.25194
	DD	03fa02eddr			; 1.25143
	DD	03fa01e03r			; 1.25092
	DD	03fa00d27r			; 1.2504
	DD	03f9ffc4br			; 1.24989
	DD	03f9feb6fr			; 1.24937
	DD	03f9fda91r			; 1.24886
	DD	03f9fc9b3r			; 1.24834
	DD	03f9fb8d4r			; 1.24783
	DD	03f9fa7f4r			; 1.24731
	DD	03f9f9714r			; 1.2468
	DD	03f9f8633r			; 1.24628
	DD	03f9f7551r			; 1.24577
	DD	03f9f646er			; 1.24525
	DD	03f9f538br			; 1.24474
	DD	03f9f42a6r			; 1.24422
	DD	03f9f31c1r			; 1.24371
	DD	03f9f20dcr			; 1.24319
	DD	03f9f0ff5r			; 1.24267
	DD	03f9eff0er			; 1.24216
	DD	03f9eee26r			; 1.24164
	DD	03f9edd3dr			; 1.24113
	DD	03f9ecc54r			; 1.24061
	DD	03f9ebb6ar			; 1.24009
	DD	03f9eaa7er			; 1.23958
	DD	03f9e9993r			; 1.23906
	DD	03f9e88a6r			; 1.23855
	DD	03f9e77b9r			; 1.23803
	DD	03f9e66cbr			; 1.23751
	DD	03f9e55dcr			; 1.237
	DD	03f9e44ecr			; 1.23648
	DD	03f9e33fcr			; 1.23596
	DD	03f9e230ar			; 1.23544
	DD	03f9e1218r			; 1.23493
	DD	03f9e0126r			; 1.23441
	DD	03f9df032r			; 1.23389
	DD	03f9ddf3er			; 1.23338
	DD	03f9dce48r			; 1.23286
	DD	03f9dbd52r			; 1.23234
	DD	03f9dac5cr			; 1.23182
	DD	03f9d9b64r			; 1.2313
	DD	03f9d8a6cr			; 1.23079
	DD	03f9d7973r			; 1.23027
	DD	03f9d6879r			; 1.22975
	DD	03f9d577er			; 1.22923
	DD	03f9d4683r			; 1.22871
	DD	03f9d3586r			; 1.2282
	DD	03f9d2489r			; 1.22768
	DD	03f9d138br			; 1.22716
	DD	03f9d028cr			; 1.22664
	DD	03f9cf18dr			; 1.22612
	DD	03f9ce08cr			; 1.2256
	DD	03f9ccf8br			; 1.22508
	DD	03f9cbe89r			; 1.22456
	DD	03f9cad86r			; 1.22405
	DD	03f9c9c83r			; 1.22353
	DD	03f9c8b7er			; 1.22301
	DD	03f9c7a79r			; 1.22249
	DD	03f9c6973r			; 1.22197
	DD	03f9c586cr			; 1.22145
	DD	03f9c4764r			; 1.22093
	DD	03f9c365cr			; 1.22041
	DD	03f9c2552r			; 1.21989
	DD	03f9c1448r			; 1.21937
	DD	03f9c033dr			; 1.21885
	DD	03f9bf231r			; 1.21833
	DD	03f9be125r			; 1.21781
	DD	03f9bd017r			; 1.21729
	DD	03f9bbf09r			; 1.21677
	DD	03f9badf9r			; 1.21625
	DD	03f9b9ce9r			; 1.21573
	DD	03f9b8bd8r			; 1.21521
	DD	03f9b7ac7r			; 1.21468
	DD	03f9b69b4r			; 1.21416
	DD	03f9b58a1r			; 1.21364
	DD	03f9b478cr			; 1.21312
	DD	03f9b3677r			; 1.2126
	DD	03f9b2561r			; 1.21208
	DD	03f9b144ar			; 1.21156
	DD	03f9b0333r			; 1.21104
	DD	03f9af21ar			; 1.21051
	DD	03f9ae100r			; 1.20999
	DD	03f9acfe6r			; 1.20947
	DD	03f9abecbr			; 1.20895
	DD	03f9aadafr			; 1.20843
	DD	03f9a9c92r			; 1.2079
	DD	03f9a8b74r			; 1.20738
	DD	03f9a7a56r			; 1.20686
	DD	03f9a6936r			; 1.20634
	DD	03f9a5816r			; 1.20581
	DD	03f9a46f4r			; 1.20529
	DD	03f9a35d2r			; 1.20477
	DD	03f9a24afr			; 1.20424
	DD	03f9a138br			; 1.20372
	DD	03f9a0267r			; 1.2032
	DD	03f99f141r			; 1.20267
	DD	03f99e01ar			; 1.20215
	DD	03f99cef3r			; 1.20163
	DD	03f99bdcbr			; 1.2011
	DD	03f99aca1r			; 1.20058
	DD	03f999b77r			; 1.20006
	DD	03f998a4cr			; 1.19953
	DD	03f997920r			; 1.19901
	DD	03f9967f3r			; 1.19848
	DD	03f9956c6r			; 1.19796
	DD	03f994597r			; 1.19744
	DD	03f993468r			; 1.19691
	DD	03f992337r			; 1.19639
	DD	03f991206r			; 1.19586
	DD	03f9900d4r			; 1.19534
	DD	03f98efa0r			; 1.19481
	DD	03f98de6cr			; 1.19429
	DD	03f98cd37r			; 1.19376
	DD	03f98bc02r			; 1.19324
	DD	03f98aacbr			; 1.19271
	DD	03f989993r			; 1.19219
	DD	03f98885ar			; 1.19166
	DD	03f987721r			; 1.19114
	DD	03f9865e6r			; 1.19061
	DD	03f9854abr			; 1.19008
	DD	03f98436fr			; 1.18956
	DD	03f983231r			; 1.18903
	DD	03f9820f3r			; 1.18851
	DD	03f980fb4r			; 1.18798
	DD	03f97fe74r			; 1.18745
	DD	03f97ed33r			; 1.18693
	DD	03f97dbf1r			; 1.1864
	DD	03f97caaer			; 1.18587
	DD	03f97b96ar			; 1.18535
	DD	03f97a825r			; 1.18482
	DD	03f9796dfr			; 1.18429
	DD	03f978599r			; 1.18376
	DD	03f977451r			; 1.18324
	DD	03f976309r			; 1.18271
	DD	03f9751bfr			; 1.18218
	DD	03f974074r			; 1.18165
	DD	03f972f29r			; 1.18113
	DD	03f971dddr			; 1.1806
	DD	03f970c8fr			; 1.18007
	DD	03f96fb41r			; 1.17954
	DD	03f96e9f2r			; 1.17901
	DD	03f96d8a1r			; 1.17849
	DD	03f96c750r			; 1.17796
	DD	03f96b5fer			; 1.17743
	DD	03f96a4abr			; 1.1769
	DD	03f969356r			; 1.17637
	DD	03f968201r			; 1.17584
	DD	03f9670abr			; 1.17531
	DD	03f965f54r			; 1.17478
	DD	03f964dfcr			; 1.17425
	DD	03f963ca3r			; 1.17373
	DD	03f962b49r			; 1.1732
	DD	03f9619eer			; 1.17267
	DD	03f960892r			; 1.17214
	DD	03f95f735r			; 1.17161
	DD	03f95e5d7r			; 1.17108
	DD	03f95d478r			; 1.17055
	DD	03f95c318r			; 1.17002
	DD	03f95b1b7r			; 1.16949
	DD	03f95a055r			; 1.16896
	DD	03f958ef2r			; 1.16842
	DD	03f957d8er			; 1.16789
	DD	03f956c29r			; 1.16736
	DD	03f955ac3r			; 1.16683
	DD	03f95495cr			; 1.1663
	DD	03f9537f3r			; 1.16577
	DD	03f95268ar			; 1.16524
	DD	03f951520r			; 1.16471
	DD	03f9503b5r			; 1.16418
	DD	03f94f249r			; 1.16364
	DD	03f94e0dcr			; 1.16311
	DD	03f94cf6er			; 1.16258
	DD	03f94bdfer			; 1.16205
	DD	03f94ac8er			; 1.16152
	DD	03f949b1dr			; 1.16098
	DD	03f9489abr			; 1.16045
	DD	03f947837r			; 1.15992
	DD	03f9466c3r			; 1.15939
	DD	03f94554er			; 1.15885
	DD	03f9443d7r			; 1.15832
	DD	03f943260r			; 1.15779
	DD	03f9420e7r			; 1.15725
	DD	03f940f6dr			; 1.15672
	DD	03f93fdf3r			; 1.15619
	DD	03f93ec77r			; 1.15565
	DD	03f93dafar			; 1.15512
	DD	03f93c97dr			; 1.15459
	DD	03f93b7fer			; 1.15405
	DD	03f93a67er			; 1.15352
	DD	03f9394fdr			; 1.15298
	DD	03f93837br			; 1.15245
	DD	03f9371f8r			; 1.15192
	DD	03f936074r			; 1.15138
	DD	03f934eeer			; 1.15085
	DD	03f933d68r			; 1.15031
	DD	03f932be1r			; 1.14978
	DD	03f931a58r			; 1.14924
	DD	03f9308cfr			; 1.14871
	DD	03f92f744r			; 1.14817
	DD	03f92e5b8r			; 1.14764
	DD	03f92d42cr			; 1.1471
	DD	03f92c29er			; 1.14656
	DD	03f92b10fr			; 1.14603
	DD	03f929f7fr			; 1.14549
	DD	03f928deer			; 1.14496
	DD	03f927c5br			; 1.14442
	DD	03f926ac8r			; 1.14388
	DD	03f925934r			; 1.14335
	DD	03f92479er			; 1.14281
	DD	03f923607r			; 1.14227
	DD	03f922470r			; 1.14174
	DD	03f9212d7r			; 1.1412
	DD	03f92013dr			; 1.14066
	DD	03f91efa2r			; 1.14013
	DD	03f91de06r			; 1.13959
	DD	03f91cc68r			; 1.13905
	DD	03f91bacar			; 1.13851
	DD	03f91a92br			; 1.13798
	DD	03f91978ar			; 1.13744
	DD	03f9185e8r			; 1.1369
	DD	03f917445r			; 1.13636
	DD	03f9162a1r			; 1.13582
	DD	03f9150fcr			; 1.13528
	DD	03f913f56r			; 1.13475
	DD	03f912daer			; 1.13421
	DD	03f911c06r			; 1.13367
	DD	03f910a5cr			; 1.13313
	DD	03f90f8b1r			; 1.13259
	DD	03f90e705r			; 1.13205
	DD	03f90d558r			; 1.13151
	DD	03f90c3aar			; 1.13097
	DD	03f90b1fbr			; 1.13043
	DD	03f90a04ar			; 1.12989
	DD	03f908e98r			; 1.12935
	DD	03f907ce5r			; 1.12881
	DD	03f906b31r			; 1.12827
	DD	03f90597cr			; 1.12773
	DD	03f9047c6r			; 1.12719
	DD	03f90360er			; 1.12665
	DD	03f902456r			; 1.12611
	DD	03f90129cr			; 1.12557
	DD	03f9000e1r			; 1.12503
	DD	03f8fef25r			; 1.12449
	DD	03f8fdd67r			; 1.12394
	DD	03f8fcba9r			; 1.1234
	DD	03f8fb9e9r			; 1.12286
	DD	03f8fa828r			; 1.12232
	DD	03f8f9666r			; 1.12178
	DD	03f8f84a3r			; 1.12124
	DD	03f8f72der			; 1.12069
	DD	03f8f6118r			; 1.12015
	DD	03f8f4f52r			; 1.11961
	DD	03f8f3d89r			; 1.11907
	DD	03f8f2bc0r			; 1.11852
	DD	03f8f19f6r			; 1.11798
	DD	03f8f082ar			; 1.11744
	DD	03f8ef65dr			; 1.11689
	DD	03f8ee48fr			; 1.11635
	DD	03f8ed2c0r			; 1.11581
	DD	03f8ec0efr			; 1.11526
	DD	03f8eaf1er			; 1.11472
	DD	03f8e9d4br			; 1.11418
	DD	03f8e8b76r			; 1.11363
	DD	03f8e79a1r			; 1.11309
	DD	03f8e67cbr			; 1.11254
	DD	03f8e55f3r			; 1.112
	DD	03f8e441ar			; 1.11145
	DD	03f8e323fr			; 1.11091
	DD	03f8e2064r			; 1.11036
	DD	03f8e0e87r			; 1.10982
	DD	03f8dfca9r			; 1.10927
	DD	03f8deacar			; 1.10873
	DD	03f8dd8e9r			; 1.10818
	DD	03f8dc708r			; 1.10764
	DD	03f8db525r			; 1.10709
	DD	03f8da340r			; 1.10654
	DD	03f8d915br			; 1.106
	DD	03f8d7f74r			; 1.10545
	DD	03f8d6d8cr			; 1.10491
	DD	03f8d5ba3r			; 1.10436
	DD	03f8d49b8r			; 1.10381
	DD	03f8d37cdr			; 1.10327
	DD	03f8d25e0r			; 1.10272
	DD	03f8d13f1r			; 1.10217
	DD	03f8d0202r			; 1.10162
	DD	03f8cf011r			; 1.10108
	DD	03f8cde1fr			; 1.10053
	DD	03f8ccc2br			; 1.09998
	DD	03f8cba37r			; 1.09943
	DD	03f8ca841r			; 1.09888
	DD	03f8c9649r			; 1.09834
	DD	03f8c8451r			; 1.09779
	DD	03f8c7257r			; 1.09724
	DD	03f8c605cr			; 1.09669
	DD	03f8c4e5fr			; 1.09614
	DD	03f8c3c62r			; 1.09559
	DD	03f8c2a63r			; 1.09504
	DD	03f8c1862r			; 1.09449
	DD	03f8c0661r			; 1.09394
	DD	03f8bf45er			; 1.09339
	DD	03f8be259r			; 1.09285
	DD	03f8bd054r			; 1.0923
	DD	03f8bbe4dr			; 1.09175
	DD	03f8bac45r			; 1.09119
	DD	03f8b9a3br			; 1.09064
	DD	03f8b8830r			; 1.09009
	DD	03f8b7624r			; 1.08954
	DD	03f8b6416r			; 1.08899
	DD	03f8b5208r			; 1.08844
	DD	03f8b3ff7r			; 1.08789
	DD	03f8b2de6r			; 1.08734
	DD	03f8b1bd3r			; 1.08679
	DD	03f8b09bfr			; 1.08623
	DD	03f8af7a9r			; 1.08568
	DD	03f8ae592r			; 1.08513
	DD	03f8ad37ar			; 1.08458
	DD	03f8ac161r			; 1.08403
	DD	03f8aaf46r			; 1.08347
	DD	03f8a9d29r			; 1.08292
	DD	03f8a8b0cr			; 1.08237
	DD	03f8a78edr			; 1.08182
	DD	03f8a66ccr			; 1.08126
	DD	03f8a54aar			; 1.08071
	DD	03f8a4287r			; 1.08016
	DD	03f8a3063r			; 1.0796
	DD	03f8a1e3dr			; 1.07905
	DD	03f8a0c16r			; 1.07849
	DD	03f89f9edr			; 1.07794
	DD	03f89e7c3r			; 1.07739
	DD	03f89d597r			; 1.07683
	DD	03f89c36br			; 1.07628
	DD	03f89b13cr			; 1.07572
	DD	03f899f0dr			; 1.07517
	DD	03f898cdcr			; 1.07461
	DD	03f897aa9r			; 1.07406
	DD	03f896876r			; 1.0735
	DD	03f895640r			; 1.07294
	DD	03f89440ar			; 1.07239
	DD	03f8931d2r			; 1.07183
	DD	03f891f98r			; 1.07128
	DD	03f890d5er			; 1.07072
	DD	03f88fb21r			; 1.07016
	DD	03f88e8e4r			; 1.06961
	DD	03f88d6a4r			; 1.06905
	DD	03f88c464r			; 1.06849
	DD	03f88b222r			; 1.06794
	DD	03f889fdfr			; 1.06738
	DD	03f888d9ar			; 1.06682
	DD	03f887b53r			; 1.06626
	DD	03f88690cr			; 1.06571
	DD	03f8856c3r			; 1.06515
	DD	03f884478r			; 1.06459
	DD	03f88322cr			; 1.06403
	DD	03f881fder			; 1.06347
	DD	03f880d8fr			; 1.06291
	DD	03f87fb3fr			; 1.06235
	DD	03f87e8edr			; 1.0618
	DD	03f87d69ar			; 1.06124
	DD	03f87c445r			; 1.06068
	DD	03f87b1efr			; 1.06012
	DD	03f879f97r			; 1.05956
	DD	03f878d3er			; 1.059
	DD	03f877ae3r			; 1.05844
	DD	03f876887r			; 1.05788
	DD	03f875629r			; 1.05732
	DD	03f8743car			; 1.05676
	DD	03f873169r			; 1.0562
	DD	03f871f07r			; 1.05563
	DD	03f870ca3r			; 1.05507
	DD	03f86fa3er			; 1.05451
	DD	03f86e7d8r			; 1.05395
	DD	03f86d56fr			; 1.05339
	DD	03f86c306r			; 1.05283
	DD	03f86b09br			; 1.05226
	DD	03f869e2er			; 1.0517
	DD	03f868bc0r			; 1.05114
	DD	03f867950r			; 1.05058
	DD	03f8666dfr			; 1.05001
	DD	03f86546cr			; 1.04945
	DD	03f8641f8r			; 1.04889
	DD	03f862f82r			; 1.04832
	DD	03f861d0br			; 1.04776
	DD	03f860a92r			; 1.0472
	DD	03f85f817r			; 1.04663
	DD	03f85e59br			; 1.04607
	DD	03f85d31er			; 1.04551
	DD	03f85c09fr			; 1.04494
	DD	03f85ae1er			; 1.04438
	DD	03f859b9cr			; 1.04381
	DD	03f858918r			; 1.04325
	DD	03f857693r			; 1.04268
	DD	03f85640cr			; 1.04212
	DD	03f855184r			; 1.04155
	DD	03f853efar			; 1.04098
	DD	03f852c6er			; 1.04042
	DD	03f8519e1r			; 1.03985
	DD	03f850752r			; 1.03929
	DD	03f84f4c2r			; 1.03872
	DD	03f84e230r			; 1.03815
	DD	03f84cf9dr			; 1.03759
	DD	03f84bd08r			; 1.03702
	DD	03f84aa71r			; 1.03645
	DD	03f8497d9r			; 1.03588
	DD	03f84853fr			; 1.03532
	DD	03f8472a3r			; 1.03475
	DD	03f846006r			; 1.03418
	DD	03f844d68r			; 1.03361
	DD	03f843ac7r			; 1.03304
	DD	03f842825r			; 1.03248
	DD	03f841582r			; 1.03191
	DD	03f8402ddr			; 1.03134
	DD	03f83f036r			; 1.03077
	DD	03f83dd8er			; 1.0302
	DD	03f83cae4r			; 1.02963
	DD	03f83b838r			; 1.02906
	DD	03f83a58br			; 1.02849
	DD	03f8392dcr			; 1.02792
	DD	03f83802br			; 1.02735
	DD	03f836d79r			; 1.02678
	DD	03f835ac5r			; 1.02621
	DD	03f83480fr			; 1.02564
	DD	03f833558r			; 1.02507
	DD	03f83229fr			; 1.02449
	DD	03f830fe5r			; 1.02392
	DD	03f82fd28r			; 1.02335
	DD	03f82ea6ar			; 1.02278
	DD	03f82d7abr			; 1.02221
	DD	03f82c4ear			; 1.02163
	DD	03f82b227r			; 1.02106
	DD	03f829f62r			; 1.02049
	DD	03f828c9cr			; 1.01992
	DD	03f8279d4r			; 1.01934
	DD	03f82670ar			; 1.01877
	DD	03f82543fr			; 1.0182
	DD	03f824172r			; 1.01762
	DD	03f822ea3r			; 1.01705
	DD	03f821bd2r			; 1.01647
	DD	03f820900r			; 1.0159
	DD	03f81f62cr			; 1.01533
	DD	03f81e356r			; 1.01475
	DD	03f81d07fr			; 1.01418
	DD	03f81bda6r			; 1.0136
	DD	03f81aacbr			; 1.01302
	DD	03f8197efr			; 1.01245
	DD	03f818510r			; 1.01187
	DD	03f817230r			; 1.0113
	DD	03f815f4er			; 1.01072
	DD	03f814c6br			; 1.01014
	DD	03f813986r			; 1.00957
	DD	03f81269fr			; 1.00899
	DD	03f8113b6r			; 1.00841
	DD	03f8100cbr			; 1.00784
	DD	03f80eddfr			; 1.00726
	DD	03f80daf1r			; 1.00668
	DD	03f80c801r			; 1.0061
	DD	03f80b50fr			; 1.00553
	DD	03f80a21cr			; 1.00495
	DD	03f808f27r			; 1.00437
	DD	03f807c30r			; 1.00379
	DD	03f806937r			; 1.00321
	DD	03f80563cr			; 1.00263
	DD	03f804340r			; 1.00205
	DD	03f803042r			; 1.00147
	DD	03f801d42r			; 1.00089
	DD	03f800a40r			; 1.00031
	DD	03f7fee79r			; 0.999733
	DD	03f7fc86er			; 0.999152
	DD	03f7fa260r			; 0.998571
	DD	03f7f7c4dr			; 0.99799
	DD	03f7f5638r			; 0.997409
	DD	03f7f301er			; 0.996828
	DD	03f7f0a01r			; 0.996246
	DD	03f7ee3e0r			; 0.995665
	DD	03f7ebdbcr			; 0.995083
	DD	03f7e9794r			; 0.9945
	DD	03f7e7168r			; 0.993918
	DD	03f7e4b38r			; 0.993335
	DD	03f7e2505r			; 0.992752
	DD	03f7dfecer			; 0.992169
	DD	03f7dd894r			; 0.991586
	DD	03f7db255r			; 0.991002
	DD	03f7d8c13r			; 0.990419
	DD	03f7d65cdr			; 0.989835
	DD	03f7d3f83r			; 0.98925
	DD	03f7d1936r			; 0.988666
	DD	03f7cf2e5r			; 0.988081
	DD	03f7ccc90r			; 0.987496
	DD	03f7ca637r			; 0.986911
	DD	03f7c7fdar			; 0.986326
	DD	03f7c597ar			; 0.98574
	DD	03f7c3316r			; 0.985155
	DD	03f7c0caer			; 0.984568
	DD	03f7be642r			; 0.983982
	DD	03f7bbfd2r			; 0.983396
	DD	03f7b995fr			; 0.982809
	DD	03f7b72e7r			; 0.982222
	DD	03f7b4c6cr			; 0.981635
	DD	03f7b25edr			; 0.981047
	DD	03f7aff6ar			; 0.98046
	DD	03f7ad8e3r			; 0.979872
	DD	03f7ab258r			; 0.979284
	DD	03f7a8bcar			; 0.978696
	DD	03f7a6537r			; 0.978107
	DD	03f7a3ea0r			; 0.977518
	DD	03f7a1806r			; 0.976929
	DD	03f79f168r			; 0.97634
	DD	03f79cac5r			; 0.97575
	DD	03f79a41fr			; 0.975161
	DD	03f797d75r			; 0.974571
	DD	03f7956c7r			; 0.97398
	DD	03f793015r			; 0.97339
	DD	03f79095fr			; 0.972799
	DD	03f78e2a5r			; 0.972208
	DD	03f78bbe6r			; 0.971617
	DD	03f789524r			; 0.971026
	DD	03f786e5er			; 0.970434
	DD	03f784794r			; 0.969842
	DD	03f7820c6r			; 0.96925
	DD	03f77f9f4r			; 0.968658
	DD	03f77d31er			; 0.968065
	DD	03f77ac43r			; 0.967472
	DD	03f778565r			; 0.966879
	DD	03f775e82r			; 0.966286
	DD	03f77379cr			; 0.965692
	DD	03f7710b1r			; 0.965098
	DD	03f76e9c3r			; 0.964504
	DD	03f76c2d0r			; 0.96391
	DD	03f769bd9r			; 0.963316
	DD	03f7674der			; 0.962721
	DD	03f764ddfr			; 0.962126
	DD	03f7626dbr			; 0.96153
	DD	03f75ffd4r			; 0.960935
	DD	03f75d8c8r			; 0.960339
	DD	03f75b1b8r			; 0.959743
	DD	03f758aa4r			; 0.959147
	DD	03f75638cr			; 0.95855
	DD	03f753c70r			; 0.957953
	DD	03f75154fr			; 0.957356
	DD	03f74ee2ar			; 0.956759
	DD	03f74c701r			; 0.956162
	DD	03f749fd4r			; 0.955564
	DD	03f7478a3r			; 0.954966
	DD	03f74516dr			; 0.954367
	DD	03f742a33r			; 0.953769
	DD	03f7402f5r			; 0.95317
	DD	03f73dbb2r			; 0.952571
	DD	03f73b46br			; 0.951972
	DD	03f738d20r			; 0.951372
	DD	03f7365d1r			; 0.950772
	DD	03f733e7dr			; 0.950172
	DD	03f731725r			; 0.949572
	DD	03f72efc9r			; 0.948971
	DD	03f72c868r			; 0.94837
	DD	03f72a103r			; 0.947769
	DD	03f72799ar			; 0.947168
	DD	03f72522cr			; 0.946566
	DD	03f722abar			; 0.945964
	DD	03f720343r			; 0.945362
	DD	03f71dbc8r			; 0.94476
	DD	03f71b449r			; 0.944157
	DD	03f718cc5r			; 0.943554
	DD	03f71653dr			; 0.942951
	DD	03f713db0r			; 0.942348
	DD	03f71161fr			; 0.941744
	DD	03f70ee8ar			; 0.94114
	DD	03f70c6f0r			; 0.940536
	DD	03f709f51r			; 0.939931
	DD	03f7077aer			; 0.939326
	DD	03f705007r			; 0.938721
	DD	03f70285br			; 0.938116
	DD	03f7000abr			; 0.93751
	DD	03f6fd8f6r			; 0.936904
	DD	03f6fb13cr			; 0.936298
	DD	03f6f897er			; 0.935692
	DD	03f6f61bcr			; 0.935085
	DD	03f6f39f5r			; 0.934478
	DD	03f6f1229r			; 0.933871
	DD	03f6eea59r			; 0.933263
	DD	03f6ec284r			; 0.932656
	DD	03f6e9aaar			; 0.932047
	DD	03f6e72ccr			; 0.931439
	DD	03f6e4aear			; 0.930831
	DD	03f6e2302r			; 0.930222
	DD	03f6dfb16r			; 0.929613
	DD	03f6dd326r			; 0.929003
	DD	03f6dab31r			; 0.928393
	DD	03f6d8337r			; 0.927783
	DD	03f6d5b38r			; 0.927173
	DD	03f6d3335r			; 0.926563
	DD	03f6d0b2dr			; 0.925952
	DD	03f6ce320r			; 0.925341
	DD	03f6cbb0fr			; 0.924729
	DD	03f6c92f9r			; 0.924118
	DD	03f6c6ader			; 0.923506
	DD	03f6c42ber			; 0.922893
	DD	03f6c1a9ar			; 0.922281
	DD	03f6bf270r			; 0.921668
	DD	03f6bca42r			; 0.921055
	DD	03f6ba210r			; 0.920442
	DD	03f6b79d8r			; 0.919828
	DD	03f6b519cr			; 0.919214
	DD	03f6b295br			; 0.9186
	DD	03f6b0115r			; 0.917985
	DD	03f6ad8car			; 0.91737
	DD	03f6ab07ar			; 0.916755
	DD	03f6a8825r			; 0.91614
	DD	03f6a5fccr			; 0.915524
	DD	03f6a376er			; 0.914908
	DD	03f6a0f0ar			; 0.914292
	DD	03f69e6a2r			; 0.913675
	DD	03f69be35r			; 0.913059
	DD	03f6995c3r			; 0.912441
	DD	03f696d4cr			; 0.911824
	DD	03f6944d0r			; 0.911206
	DD	03f691c4fr			; 0.910588
	DD	03f68f3c9r			; 0.90997
	DD	03f68cb3er			; 0.909351
	DD	03f68a2aer			; 0.908732
	DD	03f687a1ar			; 0.908113
	DD	03f685180r			; 0.907494
	DD	03f6828e1r			; 0.906874
	DD	03f68003dr			; 0.906254
	DD	03f67d794r			; 0.905633
	DD	03f67aee6r			; 0.905012
	DD	03f678632r			; 0.904391
	DD	03f675d7ar			; 0.90377
	DD	03f6734bdr			; 0.903148
	DD	03f670bfar			; 0.902526
	DD	03f66e333r			; 0.901904
	DD	03f66ba66r			; 0.901282
	DD	03f669194r			; 0.900659
	DD	03f6668bdr			; 0.900036
	DD	03f663fe0r			; 0.899412
	DD	03f6616ffr			; 0.898788
	DD	03f65ee18r			; 0.898164
	DD	03f65c52dr			; 0.89754
	DD	03f659c3cr			; 0.896915
	DD	03f657345r			; 0.89629
	DD	03f654a4ar			; 0.895665
	DD	03f652149r			; 0.895039
	DD	03f64f843r			; 0.894413
	DD	03f64cf38r			; 0.893787
	DD	03f64a627r			; 0.89316
	DD	03f647d11r			; 0.892533
	DD	03f6453f6r			; 0.891906
	DD	03f642ad5r			; 0.891279
	DD	03f6401afr			; 0.890651
	DD	03f63d884r			; 0.890023
	DD	03f63af53r			; 0.889394
	DD	03f63861dr			; 0.888765
	DD	03f635ce2r			; 0.888136
	DD	03f6333a1r			; 0.887507
	DD	03f630a5br			; 0.886877
	DD	03f62e10fr			; 0.886247
	DD	03f62b7ber			; 0.885616
	DD	03f628e68r			; 0.884985
	DD	03f62650cr			; 0.884354
	DD	03f623baar			; 0.883723
	DD	03f621243r			; 0.883091
	DD	03f61e8d7r			; 0.882459
	DD	03f61bf65r			; 0.881827
	DD	03f6195edr			; 0.881194
	DD	03f616c70r			; 0.880561
	DD	03f6142eer			; 0.879928
	DD	03f611965r			; 0.879294
	DD	03f60efd8r			; 0.87866
	DD	03f60c644r			; 0.878025
	DD	03f609cabr			; 0.877391
	DD	03f60730dr			; 0.876756
	DD	03f604968r			; 0.87612
	DD	03f601fbfr			; 0.875484
	DD	03f5ff60fr			; 0.874848
	DD	03f5fcc5ar			; 0.874212
	DD	03f5fa29fr			; 0.873575
	DD	03f5f78der			; 0.872938
	DD	03f5f4f18r			; 0.872301
	DD	03f5f254cr			; 0.871663
	DD	03f5efb7ar			; 0.871025
	DD	03f5ed1a3r			; 0.870386
	DD	03f5ea7c5r			; 0.869747
	DD	03f5e7de2r			; 0.869108
	DD	03f5e53f9r			; 0.868469
	DD	03f5e2a0br			; 0.867829
	DD	03f5e0016r			; 0.867189
	DD	03f5dd61cr			; 0.866548
	DD	03f5dac1cr			; 0.865907
	DD	03f5d8216r			; 0.865266
	DD	03f5d580ar			; 0.864625
	DD	03f5d2df8r			; 0.863983
	DD	03f5d03e0r			; 0.86334
	DD	03f5cd9c3r			; 0.862698
	DD	03f5caf9fr			; 0.862055
	DD	03f5c8575r			; 0.861411
	DD	03f5c5b46r			; 0.860768
	DD	03f5c3110r			; 0.860124
	DD	03f5c06d5r			; 0.859479
	DD	03f5bdc93r			; 0.858834
	DD	03f5bb24cr			; 0.858189
	DD	03f5b87fer			; 0.857544
	DD	03f5b5dabr			; 0.856898
	DD	03f5b3351r			; 0.856252
	DD	03f5b08f1r			; 0.855605
	DD	03f5ade8cr			; 0.854958
	DD	03f5ab420r			; 0.854311
	DD	03f5a89adr			; 0.853663
	DD	03f5a5f35r			; 0.853015
	DD	03f5a34b7r			; 0.852367
	DD	03f5a0a32r			; 0.851718
	DD	03f59dfa8r			; 0.851069
	DD	03f59b517r			; 0.850419
	DD	03f598a80r			; 0.84977
	DD	03f595fe2r			; 0.849119
	DD	03f59353fr			; 0.848469
	DD	03f590a95r			; 0.847818
	DD	03f58dfe4r			; 0.847166
	DD	03f58b52er			; 0.846515
	DD	03f588a71r			; 0.845862
	DD	03f585faer			; 0.84521
	DD	03f5834e5r			; 0.844557
	DD	03f580a15r			; 0.843904
	DD	03f57df3fr			; 0.84325
	DD	03f57b462r			; 0.842596
	DD	03f57897fr			; 0.841942
	DD	03f575e96r			; 0.841287
	DD	03f5733a6r			; 0.840632
	DD	03f5708b0r			; 0.839976
	DD	03f56ddb3r			; 0.83932
	DD	03f56b2b0r			; 0.838664
	DD	03f5687a6r			; 0.838007
	DD	03f565c96r			; 0.83735
	DD	03f56317fr			; 0.836693
	DD	03f560662r			; 0.836035
	DD	03f55db3er			; 0.835377
	DD	03f55b014r			; 0.834718
	DD	03f5584e3r			; 0.834059
	DD	03f5559abr			; 0.833399
	DD	03f552e6dr			; 0.83274
	DD	03f550328r			; 0.832079
	DD	03f54d7dcr			; 0.831419
	DD	03f54ac8ar			; 0.830758
	DD	03f548131r			; 0.830096
	DD	03f5455d1r			; 0.829434
	DD	03f542a6br			; 0.828772
	DD	03f53fefer			; 0.82811
	DD	03f53d38ar			; 0.827447
	DD	03f53a80fr			; 0.826783
	DD	03f537c8er			; 0.826119
	DD	03f535105r			; 0.825455
	DD	03f532576r			; 0.82479
	DD	03f52f9e0r			; 0.824125
	DD	03f52ce43r			; 0.82346
	DD	03f52a29fr			; 0.822794
	DD	03f5276f5r			; 0.822128
	DD	03f524b43r			; 0.821461
	DD	03f521f8br			; 0.820794
	DD	03f51f3cbr			; 0.820126
	DD	03f51c804r			; 0.819458
	DD	03f519c37r			; 0.81879
	DD	03f517062r			; 0.818121
	DD	03f514487r			; 0.817452
	DD	03f5118a4r			; 0.816782
	DD	03f50ecbbr			; 0.816112
	DD	03f50c0car			; 0.815442
	DD	03f5094d2r			; 0.814771
	DD	03f5068d3r			; 0.814099
	DD	03f503ccdr			; 0.813428
	DD	03f5010c0r			; 0.812756
	DD	03f4fe4abr			; 0.812083
	DD	03f4fb88fr			; 0.81141
	DD	03f4f8c6dr			; 0.810736
	DD	03f4f6042r			; 0.810063
	DD	03f4f3411r			; 0.809388
	DD	03f4f07d8r			; 0.808713
	DD	03f4edb98r			; 0.808038
	DD	03f4eaf51r			; 0.807363
	DD	03f4e8303r			; 0.806687
	DD	03f4e56adr			; 0.80601
	DD	03f4e2a4fr			; 0.805333
	DD	03f4dfdebr			; 0.804656
	DD	03f4dd17er			; 0.803978
	DD	03f4da50br			; 0.8033
	DD	03f4d7890r			; 0.802621
	DD	03f4d4c0dr			; 0.801942
	DD	03f4d1f83r			; 0.801262
	DD	03f4cf2f2r			; 0.800582
	DD	03f4cc659r			; 0.799902
	DD	03f4c99b8r			; 0.799221
	DD	03f4c6d10r			; 0.798539
	DD	03f4c4060r			; 0.797857
	DD	03f4c13a9r			; 0.797175
	DD	03f4be6ear			; 0.796492
	DD	03f4bba23r			; 0.795809
	DD	03f4b8d55r			; 0.795125
	DD	03f4b607fr			; 0.794441
	DD	03f4b33a1r			; 0.793757
	DD	03f4b06bcr			; 0.793072
	DD	03f4ad9cer			; 0.792386
	DD	03f4aacd9r			; 0.7917
	DD	03f4a7fddr			; 0.791014
	DD	03f4a52d8r			; 0.790327
	DD	03f4a25cbr			; 0.789639
	DD	03f49f8b7r			; 0.788951
	DD	03f49cb9br			; 0.788263
	DD	03f499e77r			; 0.787574
	DD	03f49714br			; 0.786885
	DD	03f494417r			; 0.786195
	DD	03f4916dbr			; 0.785505
	DD	03f48e997r			; 0.784814
	DD	03f48bc4br			; 0.784123
	DD	03f488ef7r			; 0.783431
	DD	03f48619ar			; 0.782739
	DD	03f483436r			; 0.782047
	DD	03f4806car			; 0.781354
	DD	03f47d955r			; 0.78066
	DD	03f47abd9r			; 0.779966
	DD	03f477e54r			; 0.779271
	DD	03f4750c7r			; 0.778576
	DD	03f472332r			; 0.777881
	DD	03f46f594r			; 0.777185
	DD	03f46c7efr			; 0.776488
	DD	03f469a41r			; 0.775791
	DD	03f466c8ar			; 0.775094
	DD	03f463eccr			; 0.774396
	DD	03f461105r			; 0.773697
	DD	03f45e335r			; 0.772998
	DD	03f45b55dr			; 0.772299
	DD	03f45877dr			; 0.771599
	DD	03f455995r			; 0.770898
	DD	03f452ba3r			; 0.770197
	DD	03f44fdaar			; 0.769496
	DD	03f44cfa7r			; 0.768794
	DD	03f44a19dr			; 0.768091
	DD	03f447389r			; 0.767388
	DD	03f44456dr			; 0.766684
	DD	03f441749r			; 0.76598
	DD	03f43e91cr			; 0.765276
	DD	03f43bae6r			; 0.764571
	DD	03f438ca7r			; 0.763865
	DD	03f435e60r			; 0.763159
	DD	03f433010r			; 0.762452
	DD	03f4301b7r			; 0.761745
	DD	03f42d355r			; 0.761037
	DD	03f42a4ear			; 0.760329
	DD	03f427677r			; 0.75962
	DD	03f4247fbr			; 0.758911
	DD	03f421976r			; 0.758201
	DD	03f41eae8r			; 0.757491
	DD	03f41bc51r			; 0.75678
	DD	03f418db0r			; 0.756068
	DD	03f415f07r			; 0.755356
	DD	03f413055r			; 0.754644
	DD	03f41019ar			; 0.753931
	DD	03f40d2d6r			; 0.753217
	DD	03f40a409r			; 0.752503
	DD	03f407532r			; 0.751788
	DD	03f404652r			; 0.751073
	DD	03f40176ar			; 0.750357
	DD	03f3fe877r			; 0.749641
	DD	03f3fb97cr			; 0.748924
	DD	03f3f8a77r			; 0.748207
	DD	03f3f5b69r			; 0.747489
	DD	03f3f2c52r			; 0.74677
	DD	03f3efd31r			; 0.746051
	DD	03f3ece07r			; 0.745331
	DD	03f3e9ed4r			; 0.744611
	DD	03f3e6f97r			; 0.74389
	DD	03f3e4051r			; 0.743169
	DD	03f3e1101r			; 0.742447
	DD	03f3de1a7r			; 0.741724
	DD	03f3db244r			; 0.741001
	DD	03f3d82d8r			; 0.740278
	DD	03f3d5361r			; 0.739554
	DD	03f3d23e2r			; 0.738829
	DD	03f3cf458r			; 0.738103
	DD	03f3cc4c5r			; 0.737377
	DD	03f3c9528r			; 0.736651
	DD	03f3c6581r			; 0.735924
	DD	03f3c35d0r			; 0.735196
	DD	03f3c0616r			; 0.734468
	DD	03f3bd652r			; 0.733739
	DD	03f3ba683r			; 0.73301
	DD	03f3b76abr			; 0.732279
	DD	03f3b46c9r			; 0.731549
	DD	03f3b16ddr			; 0.730818
	DD	03f3ae6e7r			; 0.730086
	DD	03f3ab6e7r			; 0.729353
	DD	03f3a86ddr			; 0.72862
	DD	03f3a56c8r			; 0.727887
	DD	03f3a26aar			; 0.727152
	DD	03f39f681r			; 0.726418
	DD	03f39c64fr			; 0.725682
	DD	03f399612r			; 0.724946
	DD	03f3965car			; 0.724209
	DD	03f393579r			; 0.723472
	DD	03f39051dr			; 0.722734
	DD	03f38d4b6r			; 0.721996
	DD	03f38a446r			; 0.721257
	DD	03f3873car			; 0.720517
	DD	03f384345r			; 0.719776
	DD	03f3812b5r			; 0.719035
	DD	03f37e21ar			; 0.718294
	DD	03f37b175r			; 0.717552
	DD	03f3780c5r			; 0.716809
	DD	03f37500ar			; 0.716065
	DD	03f371f45r			; 0.715321
	DD	03f36ee75r			; 0.714576
	DD	03f36bd9br			; 0.713831
	DD	03f368cb6r			; 0.713085
	DD	03f365bc5r			; 0.712338
	DD	03f362acar			; 0.71159
	DD	03f35f9c5r			; 0.710842
	DD	03f35c8b4r			; 0.710094
	DD	03f359798r			; 0.709344
	DD	03f356671r			; 0.708594
	DD	03f353540r			; 0.707844
	DD	03f350403r			; 0.707092
	DD	03f34d2bbr			; 0.70634
	DD	03f34a168r			; 0.705588
	DD	03f34700ar			; 0.704835
	DD	03f343ea0r			; 0.704081
	DD	03f340d2cr			; 0.703326
	DD	03f33dbacr			; 0.702571
	DD	03f33aa21r			; 0.701815
	DD	03f33788ar			; 0.701058
	DD	03f3346e8r			; 0.700301
	DD	03f33153br			; 0.699543
	DD	03f32e382r			; 0.698784
	DD	03f32b1ber			; 0.698025
	DD	03f327feer			; 0.697265
	DD	03f324e12r			; 0.696504
	DD	03f321c2br			; 0.695742
	DD	03f31ea38r			; 0.69498
	DD	03f31b83ar			; 0.694217
	DD	03f318630r			; 0.693454
	DD	03f31541ar			; 0.69269
	DD	03f3121f8r			; 0.691925
	DD	03f30efcar			; 0.691159
	DD	03f30bd91r			; 0.690393
	DD	03f308b4br			; 0.689625
	DD	03f3058far			; 0.688858
	DD	03f30269cr			; 0.688089
	DD	03f2ff433r			; 0.68732
	DD	03f2fc1bdr			; 0.68655
	DD	03f2f8f3br			; 0.685779
	DD	03f2f5cadr			; 0.685008
	DD	03f2f2a13r			; 0.684236
	DD	03f2ef76cr			; 0.683463
	DD	03f2ec4bar			; 0.682689
	DD	03f2e91far			; 0.681915
	DD	03f2e5f2fr			; 0.68114
	DD	03f2e2c57r			; 0.680364
	DD	03f2df972r			; 0.679587
	DD	03f2dc681r			; 0.67881
	DD	03f2d9384r			; 0.678032
	DD	03f2d6079r			; 0.677253
	DD	03f2d2d62r			; 0.676474
	DD	03f2cfa3fr			; 0.675693
	DD	03f2cc70er			; 0.674912
	DD	03f2c93d1r			; 0.67413
	DD	03f2c6087r			; 0.673348
	DD	03f2c2d30r			; 0.672565
	DD	03f2bf9ccr			; 0.67178
	DD	03f2bc65br			; 0.670995
	DD	03f2b92ddr			; 0.67021
	DD	03f2b5f53r			; 0.669423
	DD	03f2b2bbar			; 0.668636
	DD	03f2af815r			; 0.667848
	DD	03f2ac463r			; 0.667059
	DD	03f2a90a3r			; 0.666269
	DD	03f2a5cd6r			; 0.665479
	DD	03f2a28fbr			; 0.664688
	DD	03f29f513r			; 0.663896
	DD	03f29c11er			; 0.663103
	DD	03f298d1br			; 0.662309
	DD	03f29590br			; 0.661515
	DD	03f2924edr			; 0.66072
	DD	03f28f0c1r			; 0.659924
	DD	03f28bc88r			; 0.659127
	DD	03f288840r			; 0.658329
	DD	03f2853ebr			; 0.65753
	DD	03f281f89r			; 0.656731
	DD	03f27eb18r			; 0.655931
	DD	03f27b699r			; 0.65513
	DD	03f27820cr			; 0.654328
	DD	03f274d71r			; 0.653525
	DD	03f2718c8r			; 0.652722
	DD	03f26e411r			; 0.651918
	DD	03f26af4cr			; 0.651112
	DD	03f267a78r			; 0.650306
	DD	03f264596r			; 0.649499
	DD	03f2610a6r			; 0.648692
	DD	03f25dba7r			; 0.647883
	DD	03f25a699r			; 0.647073
	DD	03f25717dr			; 0.646263
	DD	03f253c53r			; 0.645452
	DD	03f250719r			; 0.64464
	DD	03f24d1d1r			; 0.643827
	DD	03f249c7ar			; 0.643013
	DD	03f246715r			; 0.642198
	DD	03f2431a0r			; 0.641382
	DD	03f23fc1dr			; 0.640566
	DD	03f23c68ar			; 0.639748
	DD	03f2390e8r			; 0.63893
	DD	03f235b38r			; 0.638111
	DD	03f232578r			; 0.63729
	DD	03f22efa8r			; 0.636469
	DD	03f22b9car			; 0.635647
	DD	03f2283dcr			; 0.634825
	DD	03f224ddfr			; 0.634001
	DD	03f2217d2r			; 0.633176
	DD	03f21e1b5r			; 0.63235
	DD	03f21ab89r			; 0.631524
	DD	03f21754dr			; 0.630696
	DD	03f213f02r			; 0.629868
	DD	03f2108a6r			; 0.629038
	DD	03f20d23br			; 0.628208
	DD	03f209bc0r			; 0.627377
	DD	03f206535r			; 0.626544
	DD	03f202e9ar			; 0.625711
	DD	03f1ff7eer			; 0.624877
	DD	03f1fc133r			; 0.624042
	DD	03f1f8a67r			; 0.623206
	DD	03f1f538br			; 0.622369
	DD	03f1f1c9er			; 0.62153
	DD	03f1ee5a1r			; 0.620691
	DD	03f1eae93r			; 0.619851
	DD	03f1e7775r			; 0.61901
	DD	03f1e4046r			; 0.618168
	DD	03f1e0906r			; 0.617325
	DD	03f1dd1b6r			; 0.616481
	DD	03f1d9a55r			; 0.615636
	DD	03f1d62e2r			; 0.61479
	DD	03f1d2b5fr			; 0.613943
	DD	03f1cf3cbr			; 0.613095
	DD	03f1cbc25r			; 0.612246
	DD	03f1c846er			; 0.611396
	DD	03f1c4ca6r			; 0.610545
	DD	03f1c14ccr			; 0.609692
	DD	03f1bdce1r			; 0.608839
	DD	03f1ba4e5r			; 0.607985
	DD	03f1b6cd7r			; 0.60713
	DD	03f1b34b7r			; 0.606273
	DD	03f1afc85r			; 0.605416
	DD	03f1ac442r			; 0.604557
	DD	03f1a8becr			; 0.603698
	DD	03f1a5385r			; 0.602837
	DD	03f1a1b0br			; 0.601975
	DD	03f19e280r			; 0.601112
	DD	03f19a9e2r			; 0.600248
	DD	03f197131r			; 0.599383
	DD	03f19386fr			; 0.598517
	DD	03f18ff9ar			; 0.59765
	DD	03f18c6b2r			; 0.596782
	DD	03f188db8r			; 0.595912
	DD	03f1854abr			; 0.595042
	DD	03f181b8br			; 0.59417
	DD	03f17e258r			; 0.593297
	DD	03f17a913r			; 0.592424
	DD	03f176fbar			; 0.591549
	DD	03f17364er			; 0.590672
	DD	03f16fccfr			; 0.589795
	DD	03f16c33dr			; 0.588917
	DD	03f168997r			; 0.588037
	DD	03f164fddr			; 0.587156
	DD	03f161610r			; 0.586274
	DD	03f15dc30r			; 0.585391
	DD	03f15a23br			; 0.584507
	DD	03f156833r			; 0.583621
	DD	03f152e17r			; 0.582735
	DD	03f14f3e7r			; 0.581847
	DD	03f14b9a2r			; 0.580958
	DD	03f147f4ar			; 0.580067
	DD	03f1444ddr			; 0.579176
	DD	03f140a5cr			; 0.578283
	DD	03f13cfc6r			; 0.577389
	DD	03f13951br			; 0.576494
	DD	03f135a5cr			; 0.575598
	DD	03f131f88r			; 0.5747
	DD	03f12e4a0r			; 0.573801
	DD	03f12a9a2r			; 0.572901
	DD	03f126e8fr			; 0.571999
	DD	03f123367r			; 0.571097
	DD	03f11f829r			; 0.570193
	DD	03f11bcd6r			; 0.569288
	DD	03f11816er			; 0.568381
	DD	03f1145f0r			; 0.567473
	DD	03f110a5cr			; 0.566564
	DD	03f10ceb3r			; 0.565654
	DD	03f1092f3r			; 0.564742
	DD	03f10571er			; 0.563829
	DD	03f101b32r			; 0.562915
	DD	03f0fdf30r			; 0.561999
	DD	03f0fa318r			; 0.561082
	DD	03f0f66e9r			; 0.560164
	DD	03f0f2aa4r			; 0.559244
	DD	03f0eee47r			; 0.558323
	DD	03f0eb1d5r			; 0.557401
	DD	03f0e754br			; 0.556477
	DD	03f0e38aar			; 0.555552
	DD	03f0dfbf2r			; 0.554626
	DD	03f0dbf23r			; 0.553698
	DD	03f0d823cr			; 0.552768
	DD	03f0d453er			; 0.551838
	DD	03f0d0828r			; 0.550906
	DD	03f0ccafar			; 0.549972
	DD	03f0c8db5r			; 0.549037
	DD	03f0c5057r			; 0.548101
	DD	03f0c12e1r			; 0.547163
	DD	03f0bd553r			; 0.546224
	DD	03f0b97adr			; 0.545283
	DD	03f0b59eer			; 0.544341
	DD	03f0b1c17r			; 0.543397
	DD	03f0ade27r			; 0.542452
	DD	03f0aa01dr			; 0.541506
	DD	03f0a61fbr			; 0.540558
	DD	03f0a23c0r			; 0.539608
	DD	03f09e56br			; 0.538657
	DD	03f09a6fdr			; 0.537704
	DD	03f096876r			; 0.53675
	DD	03f0929d4r			; 0.535794
	DD	03f08eb19r			; 0.534837
	DD	03f08ac44r			; 0.533879
	DD	03f086d55r			; 0.532918
	DD	03f082e4br			; 0.531956
	DD	03f07ef27r			; 0.530993
	DD	03f07afe8r			; 0.530028
	DD	03f07708fr			; 0.529061
	DD	03f07311br			; 0.528093
	DD	03f06f18cr			; 0.527123
	DD	03f06b1e2r			; 0.526152
	DD	03f06721cr			; 0.525179
	DD	03f06323br			; 0.524204
	DD	03f05f23er			; 0.523228
	DD	03f05b226r			; 0.52225
	DD	03f0571f1r			; 0.52127
	DD	03f0531a1r			; 0.520289
	DD	03f04f134r			; 0.519305
	DD	03f04b0abr			; 0.518321
	DD	03f047005r			; 0.517334
	DD	03f042f43r			; 0.516346
	DD	03f03ee64r			; 0.515356
	DD	03f03ad67r			; 0.514365
	DD	03f036c4er			; 0.513371
	DD	03f032b16r			; 0.512376
	DD	03f02e9c2r			; 0.511379
	DD	03f02a84fr			; 0.510381
	DD	03f0266bfr			; 0.50938
	DD	03f022510r			; 0.508378
	DD	03f01e344r			; 0.507374
	DD	03f01a158r			; 0.506368
	DD	03f015f4er			; 0.50536
	DD	03f011d26r			; 0.504351
	DD	03f00dader			; 0.50334
	DD	03f009877r			; 0.502326
	DD	03f0055f0r			; 0.501311
	DD	03f00134ar			; 0.500294
	DD	03effa109r			; 0.499275
	DD	03eff1b3dr			; 0.498255
	DD	03efe9531r			; 0.497232
	DD	03efe0ee4r			; 0.496207
	DD	03efd8856r			; 0.495181
	DD	03efd0187r			; 0.494152
	DD	03efc7a75r			; 0.493122
	DD	03efbf321r			; 0.492089
	DD	03efb6b8ar			; 0.491055
	DD	03efae3b0r			; 0.490018
	DD	03efa5b92r			; 0.48898
	DD	03ef9d330r			; 0.487939
	DD	03ef94a89r			; 0.486897
	DD	03ef8c19dr			; 0.485852
	DD	03ef8386cr			; 0.484805
	DD	03ef7aef5r			; 0.483757
	DD	03ef72537r			; 0.482706
	DD	03ef69b33r			; 0.481653
	DD	03ef610e7r			; 0.480598
	DD	03ef58654r			; 0.47954
	DD	03ef4fb78r			; 0.478481
	DD	03ef47054r			; 0.477419
	DD	03ef3e4e6r			; 0.476356
	DD	03ef3592fr			; 0.47529
	DD	03ef2cd2dr			; 0.474222
	DD	03ef240e0r			; 0.473151
	DD	03ef1b449r			; 0.472079
	DD	03ef12765r			; 0.471004
	DD	03ef09a36r			; 0.469927
	DD	03ef00cb9r			; 0.468847
	DD	03eef7eefr			; 0.467765
	DD	03eeef0d7r			; 0.466681
	DD	03eee6271r			; 0.465595
	DD	03eedd3bcr			; 0.464506
	DD	03eed44b7r			; 0.463415
	DD	03eecb562r			; 0.462321
	DD	03eec25bcr			; 0.461225
	DD	03eeb95c5r			; 0.460127
	DD	03eeb057cr			; 0.459026
	DD	03eea74e1r			; 0.457923
	DD	03ee9e3f3r			; 0.456817
	DD	03ee952b1r			; 0.455709
	DD	03ee8c11br			; 0.454598
	DD	03ee82f30r			; 0.453485
	DD	03ee79cefr			; 0.452369
	DD	03ee70a58r			; 0.451251
	DD	03ee6776br			; 0.45013
	DD	03ee5e426r			; 0.449006
	DD	03ee55088r			; 0.44788
	DD	03ee4bc92r			; 0.446751
	DD	03ee42843r			; 0.44562
	DD	03ee39399r			; 0.444485
	DD	03ee2fe95r			; 0.443349
	DD	03ee26935r			; 0.442209
	DD	03ee1d379r			; 0.441067
	DD	03ee13d5fr			; 0.439921
	DD	03ee0a6e8r			; 0.438773
	DD	03ee01013r			; 0.437623
	DD	03edf78der			; 0.436469
	DD	03edee14ar			; 0.435313
	DD	03ede4954r			; 0.434153
	DD	03eddb0fer			; 0.432991
	DD	03edd1844r			; 0.431826
	DD	03edc7f28r			; 0.430658
	DD	03edbe5a8r			; 0.429487
	DD	03edb4bc3r			; 0.428312
	DD	03edab179r			; 0.427135
	DD	03eda16c8r			; 0.425955
	DD	03ed97bb0r			; 0.424772
	DD	03ed8e02fr			; 0.423585
	DD	03ed84446r			; 0.422396
	DD	03ed7a7f3r			; 0.421203
	DD	03ed70b35r			; 0.420007
	DD	03ed66e0br			; 0.418808
	DD	03ed5d074r			; 0.417606
	DD	03ed53270r			; 0.4164
	DD	03ed493fdr			; 0.415192
	DD	03ed3f51br			; 0.413979
	DD	03ed355c9r			; 0.412764
	DD	03ed2b604r			; 0.411545
	DD	03ed215cdr			; 0.410323
	DD	03ed17523r			; 0.409097
	DD	03ed0d404r			; 0.407868
	DD	03ed0326fr			; 0.406635
	DD	03ecf9064r			; 0.405398
	DD	03eceede1r			; 0.404159
	DD	03ece4ae4r			; 0.402915
	DD	03ecda76er			; 0.401668
	DD	03ecd037dr			; 0.400417
	DD	03ecc5f0fr			; 0.399163
	DD	03ecbba23r			; 0.397904
	DD	03ecb14b9r			; 0.396642
	DD	03eca6ecfr			; 0.395377
	DD	03ec9c863r			; 0.394107
	DD	03ec92175r			; 0.392833
	DD	03ec87a04r			; 0.391556
	DD	03ec7d20dr			; 0.390274
	DD	03ec72990r			; 0.388989
	DD	03ec6808br			; 0.387699
	DD	03ec5d6fdr			; 0.386406
	DD	03ec52ce5r			; 0.385108
	DD	03ec48241r			; 0.383806
	DD	03ec3d70fr			; 0.3825
	DD	03ec32b4fr			; 0.38119
	DD	03ec27effr			; 0.379875
	DD	03ec1d21dr			; 0.378556
	DD	03ec124a7r			; 0.377233
	DD	03ec0769dr			; 0.375905
	DD	03ebfc7fdr			; 0.374573
	DD	03ebf18c4r			; 0.373236
	DD	03ebe68f2r			; 0.371894
	DD	03ebdb884r			; 0.370548
	DD	03ebd0779r			; 0.369198
	DD	03ebc55d0r			; 0.367842
	DD	03ebba386r			; 0.366482
	DD	03ebaf09ar			; 0.365117
	DD	03eba3d09r			; 0.363747
	DD	03eb988d3r			; 0.362372
	DD	03eb8d3f5r			; 0.360992
	DD	03eb81e6cr			; 0.359607
	DD	03eb76838r			; 0.358217
	DD	03eb6b156r			; 0.356822
	DD	03eb5f9c5r			; 0.355421
	DD	03eb54181r			; 0.354015
	DD	03eb48889r			; 0.352604
	DD	03eb3cedbr			; 0.351188
	DD	03eb31474r			; 0.349765
	DD	03eb25952r			; 0.348338
	DD	03eb19d74r			; 0.346904
	DD	03eb0e0d6r			; 0.345465
	DD	03eb02376r			; 0.344021
	DD	03eaf6552r			; 0.34257
	DD	03eaea667r			; 0.341113
	DD	03eade6b2r			; 0.339651
	DD	03ead2632r			; 0.338182
	DD	03eac64e3r			; 0.336707
	DD	03eaba2c3r			; 0.335226
	DD	03eaadfcer			; 0.333739
	DD	03eaa1c03r			; 0.332245
	DD	03ea9575dr			; 0.330745
	DD	03ea891dbr			; 0.329238
	DD	03ea7cb78r			; 0.327724
	DD	03ea70432r			; 0.326204
	DD	03ea63c07r			; 0.324677
	DD	03ea572f1r			; 0.323143
	DD	03ea4a8efr			; 0.321601
	DD	03ea3ddfcr			; 0.320053
	DD	03ea31216r			; 0.318497
	DD	03ea24538r			; 0.316934
	DD	03ea1775er			; 0.315364
	DD	03ea0a886r			; 0.313786
	DD	03e9fd8acr			; 0.3122
	DD	03e9f07car			; 0.310606
	DD	03e9e35der			; 0.309005
	DD	03e9d62e2r			; 0.307395
	DD	03e9c8ed4r			; 0.305777
	DD	03e9bb9aer			; 0.304151
	DD	03e9ae36br			; 0.302516
	DD	03e9a0c08r			; 0.300873
	DD	03e99337fr			; 0.299221
	DD	03e9859ccr			; 0.29756
	DD	03e977ee9r			; 0.29589
	DD	03e96a2d2r			; 0.294211
	DD	03e95c580r			; 0.292522
	DD	03e94e6efr			; 0.290824
	DD	03e940719r			; 0.289117
	DD	03e9325f9r			; 0.287399
	DD	03e924387r			; 0.285671
	DD	03e915fber			; 0.283934
	DD	03e907a98r			; 0.282185
	DD	03e8f940er			; 0.280426
	DD	03e8eac1ar			; 0.278657
	DD	03e8dc2b3r			; 0.276876
	DD	03e8cd7d4r			; 0.275084
	DD	03e8beb75r			; 0.273281
	DD	03e8afd8er			; 0.271466
	DD	03e8a0e17r			; 0.269639
	DD	03e891d09r			; 0.2678
	DD	03e882a5ar			; 0.265948
	DD	03e873601r			; 0.264084
	DD	03e863ff7r			; 0.262207
	DD	03e854830r			; 0.260316
	DD	03e844ea5r			; 0.258413
	DD	03e83534ar			; 0.256495
	DD	03e825614r			; 0.254563
	DD	03e8156fbr			; 0.252617
	DD	03e8055f0r			; 0.250656
	DD	03e7ea5d5r			; 0.248679
	DD	03e7c9bb8r			; 0.246688
	DD	03e7a8d73r			; 0.24468
	DD	03e787ae9r			; 0.242656
	DD	03e7663ffr			; 0.240616
	DD	03e744899r			; 0.238558
	DD	03e722899r			; 0.236483
	DD	03e7003dfr			; 0.23439
	DD	03e6dda4ar			; 0.232278
	DD	03e6babb9r			; 0.230147
	DD	03e697808r			; 0.227997
	DD	03e673f10r			; 0.225827
	DD	03e6500acr			; 0.223635
	DD	03e62bcb1r			; 0.221423
	DD	03e6072f4r			; 0.219189
	DD	03e5e2348r			; 0.216931
	DD	03e5bcd7cr			; 0.214651
	DD	03e59715fr			; 0.212347
	DD	03e570ebbr			; 0.210017
	DD	03e54a557r			; 0.207662
	DD	03e5234f9r			; 0.20528
	DD	03e4fbd61r			; 0.202871
	DD	03e4d3e4dr			; 0.200433
	DD	03e4ab775r			; 0.197965
	DD	03e48288fr			; 0.195467
	DD	03e45914ar			; 0.192937
	DD	03e42f151r			; 0.190374
	DD	03e404849r			; 0.187776
	DD	03e3d95d0r			; 0.185142
	DD	03e3ad97dr			; 0.18247
	DD	03e3812e1r			; 0.17976
	DD	03e354181r			; 0.177008
	DD	03e3264dbr			; 0.174213
	DD	03e2f7c63r			; 0.171373
	DD	03e2c877er			; 0.168486
	DD	03e298588r			; 0.165548
	DD	03e2675c9r			; 0.162559
	DD	03e23577cr			; 0.159513
	DD	03e2029c8r			; 0.156409
	DD	03e1cebbcr			; 0.153243
	DD	03e199c50r			; 0.15001
	DD	03e163a5er			; 0.146707
	DD	03e12c49dr			; 0.143328
	DD	03e0f399er			; 0.139868
	DD	03e0b97c4r			; 0.136321
	DD	03e07dd38r			; 0.13268
	DD	03e0407e4r			; 0.128936
	DD	03e00155fr			; 0.125082
	DD	03df805c1r			; 0.121105
	DD	03def9a4ar			; 0.116994
	DD	03de6e0a5r			; 0.112733
	DD	03dddcf97r			; 0.108306
	DD	03dd45befr			; 0.103691
	DD	03dca77ddr			; 0.0988614
	DD	03dc01205r			; 0.0937844
	DD	03db5140cr			; 0.0884171
	DD	03da96059r			; 0.0827033
	DD	03d9cce3fr			; 0.0765653
	DD	03d8f2332r			; 0.0698913
	DD	03d800556r			; 0.0625102
	DD	03d5dbac5r			; 0.0541332
	DD	03d3508b9r			; 0.0441978
	DD	03d000155r			; 0.0312513
	DD	000000000r			; 0
	ORG $+4
?g_fIdvCosTable@@3QBMB DD 03f800000r		; 1	; g_fIdvCosTable
	DD	03f7fffecr			; 0.999999
	DD	03f7fffb1r			; 0.999995
	DD	03f7fff4er			; 0.999989
	DD	03f7ffec4r			; 0.999981
	DD	03f7ffe13r			; 0.999971
	DD	03f7ffd39r			; 0.999958
	DD	03f7ffc39r			; 0.999942
	DD	03f7ffb11r			; 0.999925
	DD	03f7ff9c1r			; 0.999905
	DD	03f7ff84ar			; 0.999882
	DD	03f7ff6acr			; 0.999858
	DD	03f7ff4e6r			; 0.999831
	DD	03f7ff2f8r			; 0.999801
	DD	03f7ff0e3r			; 0.999769
	DD	03f7feea7r			; 0.999735
	DD	03f7fec43r			; 0.999699
	DD	03f7fe9b8r			; 0.99966
	DD	03f7fe705r			; 0.999619
	DD	03f7fe42br			; 0.999575
	DD	03f7fe129r			; 0.999529
	DD	03f7fde00r			; 0.999481
	DD	03f7fdaafr			; 0.999431
	DD	03f7fd737r			; 0.999378
	DD	03f7fd397r			; 0.999322
	DD	03f7fcfd1r			; 0.999265
	DD	03f7fcbe2r			; 0.999205
	DD	03f7fc7ccr			; 0.999142
	DD	03f7fc38fr			; 0.999078
	DD	03f7fbf2ar			; 0.999011
	DD	03f7fba9er			; 0.998941
	DD	03f7fb5ear			; 0.99887
	DD	03f7fb10fr			; 0.998795
	DD	03f7fac0dr			; 0.998719
	DD	03f7fa6e3r			; 0.99864
	DD	03f7fa191r			; 0.998559
	DD	03f7f9c18r			; 0.998476
	DD	03f7f9678r			; 0.99839
	DD	03f7f90b1r			; 0.998302
	DD	03f7f8ac2r			; 0.998211
	DD	03f7f84abr			; 0.998118
	DD	03f7f7e6dr			; 0.998023
	DD	03f7f7808r			; 0.997925
	DD	03f7f717br			; 0.997825
	DD	03f7f6ac7r			; 0.997723
	DD	03f7f63ecr			; 0.997618
	DD	03f7f5ce9r			; 0.997511
	DD	03f7f55bfr			; 0.997402
	DD	03f7f4e6dr			; 0.99729
	DD	03f7f46f4r			; 0.997176
	DD	03f7f3f54r			; 0.99706
	DD	03f7f378cr			; 0.996941
	DD	03f7f2f9dr			; 0.99682
	DD	03f7f2787r			; 0.996697
	DD	03f7f1f49r			; 0.996571
	DD	03f7f16e4r			; 0.996443
	DD	03f7f0e58r			; 0.996313
	DD	03f7f05a4r			; 0.99618
	DD	03f7efcc9r			; 0.996045
	DD	03f7ef3c7r			; 0.995907
	DD	03f7eea9dr			; 0.995767
	DD	03f7ee14cr			; 0.995625
	DD	03f7ed7d4r			; 0.995481
	DD	03f7ece34r			; 0.995334
	DD	03f7ec46dr			; 0.995185
	DD	03f7eba7fr			; 0.995033
	DD	03f7eb069r			; 0.994879
	DD	03f7ea62dr			; 0.994723
	DD	03f7e9bc9r			; 0.994565
	DD	03f7e913dr			; 0.994404
	DD	03f7e868br			; 0.99424
	DD	03f7e7bb1r			; 0.994075
	DD	03f7e70b0r			; 0.993907
	DD	03f7e6588r			; 0.993737
	DD	03f7e5a38r			; 0.993564
	DD	03f7e4ec1r			; 0.993389
	DD	03f7e4323r			; 0.993212
	DD	03f7e375er			; 0.993032
	DD	03f7e2b72r			; 0.99285
	DD	03f7e1f5er			; 0.992666
	DD	03f7e1324r			; 0.99248
	DD	03f7e06c2r			; 0.992291
	DD	03f7dfa38r			; 0.992099
	DD	03f7ded88r			; 0.991906
	DD	03f7de0b1r			; 0.99171
	DD	03f7dd3b2r			; 0.991511
	DD	03f7dc68cr			; 0.991311
	DD	03f7db940r			; 0.991108
	DD	03f7dabccr			; 0.990903
	DD	03f7d9e30r			; 0.990695
	DD	03f7d906er			; 0.990485
	DD	03f7d8285r			; 0.990273
	DD	03f7d7474r			; 0.990058
	DD	03f7d663dr			; 0.989841
	DD	03f7d57der			; 0.989622
	DD	03f7d4959r			; 0.9894
	DD	03f7d3aacr			; 0.989177
	DD	03f7d2bd8r			; 0.98895
	DD	03f7d1cddr			; 0.988722
	DD	03f7d0dbcr			; 0.988491
	DD	03f7cfe73r			; 0.988258
	DD	03f7cef03r			; 0.988022
	DD	03f7cdf6cr			; 0.987784
	DD	03f7ccfaer			; 0.987544
	DD	03f7cbfc9r			; 0.987301
	DD	03f7cafbdr			; 0.987057
	DD	03f7c9f8ar			; 0.986809
	DD	03f7c8f31r			; 0.98656
	DD	03f7c7eb0r			; 0.986308
	DD	03f7c6e08r			; 0.986054
	DD	03f7c5d3ar			; 0.985798
	DD	03f7c4c44r			; 0.985539
	DD	03f7c3b28r			; 0.985278
	DD	03f7c29e5r			; 0.985014
	DD	03f7c187ar			; 0.984748
	DD	03f7c06e9r			; 0.98448
	DD	03f7bf531r			; 0.98421
	DD	03f7be353r			; 0.983937
	DD	03f7bd14dr			; 0.983662
	DD	03f7bbf20r			; 0.983385
	DD	03f7baccdr			; 0.983105
	DD	03f7b9a53r			; 0.982824
	DD	03f7b87b2r			; 0.982539
	DD	03f7b74ear			; 0.982253
	DD	03f7b61fcr			; 0.981964
	DD	03f7b4ee7r			; 0.981673
	DD	03f7b3babr			; 0.981379
	DD	03f7b2848r			; 0.981083
	DD	03f7b14ber			; 0.980785
	DD	03f7b010er			; 0.980485
	DD	03f7aed37r			; 0.980182
	DD	03f7ad93ar			; 0.979877
	DD	03f7ac516r			; 0.97957
	DD	03f7ab0cbr			; 0.97926
	DD	03f7a9c59r			; 0.978948
	DD	03f7a87c1r			; 0.978634
	DD	03f7a7302r			; 0.978317
	DD	03f7a5e1cr			; 0.977998
	DD	03f7a4910r			; 0.977677
	DD	03f7a33ddr			; 0.977354
	DD	03f7a1e84r			; 0.977028
	DD	03f7a0904r			; 0.9767
	DD	03f79f35er			; 0.97637
	DD	03f79dd91r			; 0.976037
	DD	03f79c79dr			; 0.975702
	DD	03f79b183r			; 0.975365
	DD	03f799b43r			; 0.975025
	DD	03f7984dcr			; 0.974684
	DD	03f796e4er			; 0.974339
	DD	03f79579ar			; 0.973993
	DD	03f7940c0r			; 0.973644
	DD	03f7929bfr			; 0.973293
	DD	03f791298r			; 0.97294
	DD	03f78fb4ar			; 0.972584
	DD	03f78e3d6r			; 0.972227
	DD	03f78cc3br			; 0.971866
	DD	03f78b47br			; 0.971504
	DD	03f789c93r			; 0.971139
	DD	03f788486r			; 0.970772
	DD	03f786c52r			; 0.970403
	DD	03f7853f8r			; 0.970031
	DD	03f783b77r			; 0.969657
	DD	03f7822d1r			; 0.969281
	DD	03f780a04r			; 0.968903
	DD	03f77f110r			; 0.968522
	DD	03f77d7f7r			; 0.968139
	DD	03f77beb7r			; 0.967754
	DD	03f77a551r			; 0.967366
	DD	03f778bc5r			; 0.966976
	DD	03f777213r			; 0.966584
	DD	03f77583ar			; 0.96619
	DD	03f773e3cr			; 0.965793
	DD	03f772417r			; 0.965394
	DD	03f7709ccr			; 0.964993
	DD	03f76ef5br			; 0.96459
	DD	03f76d4c4r			; 0.964184
	DD	03f76ba07r			; 0.963776
	DD	03f769f24r			; 0.963366
	DD	03f76841br			; 0.962953
	DD	03f7668ecr			; 0.962538
	DD	03f764d97r			; 0.962121
	DD	03f76321br			; 0.961702
	DD	03f76167ar			; 0.96128
	DD	03f75fab3r			; 0.960857
	DD	03f75dec6r			; 0.960431
	DD	03f75c2b3r			; 0.960002
	DD	03f75a67br			; 0.959572
	DD	03f758a1cr			; 0.959139
	DD	03f756d97r			; 0.958703
	DD	03f7550edr			; 0.958266
	DD	03f75341dr			; 0.957826
	DD	03f751727r			; 0.957385
	DD	03f74fa0br			; 0.95694
	DD	03f74dcc9r			; 0.956494
	DD	03f74bf62r			; 0.956045
	DD	03f74a1d5r			; 0.955594
	DD	03f748422r			; 0.955141
	DD	03f746649r			; 0.954686
	DD	03f74484br			; 0.954228
	DD	03f742a27r			; 0.953768
	DD	03f740bddr			; 0.953306
	DD	03f73ed6er			; 0.952842
	DD	03f73ced9r			; 0.952375
	DD	03f73b01fr			; 0.951906
	DD	03f73913fr			; 0.951435
	DD	03f737239r			; 0.950962
	DD	03f73530er			; 0.950486
	DD	03f7333ber			; 0.950008
	DD	03f731447r			; 0.949528
	DD	03f72f4acr			; 0.949046
	DD	03f72d4ebr			; 0.948561
	DD	03f72b504r			; 0.948075
	DD	03f7294f8r			; 0.947586
	DD	03f7274c7r			; 0.947094
	DD	03f725470r			; 0.946601
	DD	03f7233f4r			; 0.946105
	DD	03f721352r			; 0.945607
	DD	03f71f28cr			; 0.945107
	DD	03f71d19fr			; 0.944605
	DD	03f71b08er			; 0.9441
	DD	03f718f57r			; 0.943593
	DD	03f716dfbr			; 0.943084
	DD	03f714c7ar			; 0.942573
	DD	03f712ad4r			; 0.94206
	DD	03f710908r			; 0.941544
	DD	03f70e717r			; 0.941026
	DD	03f70c501r			; 0.940506
	DD	03f70a2c6r			; 0.939984
	DD	03f708066r			; 0.939459
	DD	03f705de1r			; 0.938932
	DD	03f703b37r			; 0.938404
	DD	03f701867r			; 0.937872
	DD	03f6ff573r			; 0.937339
	DD	03f6fd25ar			; 0.936803
	DD	03f6faf1br			; 0.936266
	DD	03f6f8bb8r			; 0.935726
	DD	03f6f6830r			; 0.935184
	DD	03f6f4483r			; 0.934639
	DD	03f6f20b0r			; 0.934093
	DD	03f6efcbar			; 0.933544
	DD	03f6ed89er			; 0.932993
	DD	03f6eb45dr			; 0.93244
	DD	03f6e8ff8r			; 0.931884
	DD	03f6e6b6dr			; 0.931327
	DD	03f6e46ber			; 0.930767
	DD	03f6e21ebr			; 0.930205
	DD	03f6dfcf2r			; 0.929641
	DD	03f6dd7d5r			; 0.929075
	DD	03f6db293r			; 0.928506
	DD	03f6d8d2dr			; 0.927935
	DD	03f6d67a1r			; 0.927363
	DD	03f6d41f2r			; 0.926787
	DD	03f6d1c1dr			; 0.92621
	DD	03f6cf624r			; 0.925631
	DD	03f6cd007r			; 0.925049
	DD	03f6ca9c5r			; 0.924465
	DD	03f6c835er			; 0.92388
	DD	03f6c5cd4r			; 0.923291
	DD	03f6c3624r			; 0.922701
	DD	03f6c0f50r			; 0.922109
	DD	03f6be858r			; 0.921514
	DD	03f6bc13br			; 0.920917
	DD	03f6b99fbr			; 0.920318
	DD	03f6b7295r			; 0.919717
	DD	03f6b4b0cr			; 0.919114
	DD	03f6b235er			; 0.918508
	DD	03f6afb8cr			; 0.917901
	DD	03f6ad395r			; 0.917291
	DD	03f6aab7br			; 0.916679
	DD	03f6a833cr			; 0.916065
	DD	03f6a5ad9r			; 0.915449
	DD	03f6a3252r			; 0.91483
	DD	03f6a09a7r			; 0.91421
	DD	03f69e0d7r			; 0.913587
	DD	03f69b7e4r			; 0.912962
	DD	03f698eccr			; 0.912335
	DD	03f696591r			; 0.911706
	DD	03f693c32r			; 0.911075
	DD	03f6912aer			; 0.910441
	DD	03f68e907r			; 0.909806
	DD	03f68bf3cr			; 0.909168
	DD	03f68954cr			; 0.908528
	DD	03f686b39r			; 0.907886
	DD	03f684103r			; 0.907242
	DD	03f6816a8r			; 0.906596
	DD	03f67ec29r			; 0.905947
	DD	03f67c187r			; 0.905297
	DD	03f6796c1r			; 0.904644
	DD	03f676bd8r			; 0.903989
	DD	03f6740car			; 0.903332
	DD	03f671599r			; 0.902673
	DD	03f66ea45r			; 0.902012
	DD	03f66beccr			; 0.901349
	DD	03f669330r			; 0.900683
	DD	03f666771r			; 0.900016
	DD	03f663b8er			; 0.899346
	DD	03f660f88r			; 0.898674
	DD	03f65e35er			; 0.898001
	DD	03f65b710r			; 0.897325
	DD	03f658aa0r			; 0.896646
	DD	03f655e0br			; 0.895966
	DD	03f653154r			; 0.895284
	DD	03f650479r			; 0.894599
	DD	03f64d77br			; 0.893913
	DD	03f64aa59r			; 0.893224
	DD	03f647d14r			; 0.892534
	DD	03f644facr			; 0.891841
	DD	03f642221r			; 0.891146
	DD	03f63f473r			; 0.890449
	DD	03f63c6a1r			; 0.88975
	DD	03f6398acr			; 0.889048
	DD	03f636a95r			; 0.888345
	DD	03f633c5ar			; 0.88764
	DD	03f630dfcr			; 0.886932
	DD	03f62df7br			; 0.886223
	DD	03f62b0d7r			; 0.885511
	DD	03f628210r			; 0.884797
	DD	03f625326r			; 0.884081
	DD	03f62241ar			; 0.883363
	DD	03f61f4ear			; 0.882643
	DD	03f61c598r			; 0.881921
	DD	03f619622r			; 0.881197
	DD	03f61668ar			; 0.880471
	DD	03f6136d0r			; 0.879743
	DD	03f6106f2r			; 0.879012
	DD	03f60d6f2r			; 0.87828
	DD	03f60a6cfr			; 0.877545
	DD	03f607689r			; 0.876809
	DD	03f604621r			; 0.87607
	DD	03f601596r			; 0.875329
	DD	03f5fe4e9r			; 0.874587
	DD	03f5fb419r			; 0.873842
	DD	03f5f8327r			; 0.873095
	DD	03f5f5212r			; 0.872346
	DD	03f5f20dbr			; 0.871595
	DD	03f5eef81r			; 0.870842
	DD	03f5ebe05r			; 0.870087
	DD	03f5e8c67r			; 0.86933
	DD	03f5e5aa6r			; 0.868571
	DD	03f5e28c3r			; 0.867809
	DD	03f5df6ber			; 0.867046
	DD	03f5dc497r			; 0.866281
	DD	03f5d924dr			; 0.865514
	DD	03f5d5fe1r			; 0.864744
	DD	03f5d2d53r			; 0.863973
	DD	03f5cfaa3r			; 0.863199
	DD	03f5cc7d1r			; 0.862424
	DD	03f5c94ddr			; 0.861646
	DD	03f5c61c7r			; 0.860867
	DD	03f5c2e8er			; 0.860085
	DD	03f5bfb34r			; 0.859302
	DD	03f5bc7b8r			; 0.858516
	DD	03f5b941ar			; 0.857729
	DD	03f5b605ar			; 0.856939
	DD	03f5b2c79r			; 0.856147
	DD	03f5af875r			; 0.855354
	DD	03f5ac450r			; 0.854558
	DD	03f5a9009r			; 0.85376
	DD	03f5a5ba0r			; 0.852961
	DD	03f5a2716r			; 0.852159
	DD	03f59f26ar			; 0.851355
	DD	03f59bd9cr			; 0.850549
	DD	03f5988adr			; 0.849742
	DD	03f59539cr			; 0.848932
	DD	03f591e6ar			; 0.84812
	DD	03f58e916r			; 0.847307
	DD	03f58b3a1r			; 0.846491
	DD	03f587e0br			; 0.845673
	DD	03f584853r			; 0.844854
	DD	03f581279r			; 0.844032
	DD	03f57dc7fr			; 0.843208
	DD	03f57a663r			; 0.842383
	DD	03f577026r			; 0.841555
	DD	03f5739c7r			; 0.840725
	DD	03f570348r			; 0.839894
	DD	03f56cca7r			; 0.83906
	DD	03f5695e5r			; 0.838225
	DD	03f565f02r			; 0.837387
	DD	03f5627fer			; 0.836548
	DD	03f55f0d9r			; 0.835706
	DD	03f55b993r			; 0.834863
	DD	03f55822cr			; 0.834018
	DD	03f554aa4r			; 0.83317
	DD	03f5512fbr			; 0.832321
	DD	03f54db31r			; 0.83147
	DD	03f54a347r			; 0.830616
	DD	03f546b3br			; 0.829761
	DD	03f54330fr			; 0.828904
	DD	03f53fac3r			; 0.828045
	DD	03f53c255r			; 0.827184
	DD	03f5389c7r			; 0.826321
	DD	03f535118r			; 0.825456
	DD	03f531849r			; 0.824589
	DD	03f52df59r			; 0.823721
	DD	03f52a649r			; 0.82285
	DD	03f526d18r			; 0.821977
	DD	03f5233c6r			; 0.821102
	DD	03f51fa54r			; 0.820226
	DD	03f51c0c2r			; 0.819348
	DD	03f518710r			; 0.818467
	DD	03f514d3dr			; 0.817585
	DD	03f51134ar			; 0.816701
	DD	03f50d937r			; 0.815814
	DD	03f509f03r			; 0.814926
	DD	03f5064afr			; 0.814036
	DD	03f502a3br			; 0.813144
	DD	03f4fefa8r			; 0.812251
	DD	03f4fb4f4r			; 0.811355
	DD	03f4f7a1fr			; 0.810457
	DD	03f4f3f2br			; 0.809558
	DD	03f4f0417r			; 0.808656
	DD	03f4ec8e4r			; 0.807753
	DD	03f4e8d90r			; 0.806848
	DD	03f4e521cr			; 0.80594
	DD	03f4e1689r			; 0.805031
	DD	03f4ddad5r			; 0.80412
	DD	03f4d9f02r			; 0.803208
	DD	03f4d6310r			; 0.802293
	DD	03f4d26fdr			; 0.801376
	DD	03f4ceacbr			; 0.800458
	DD	03f4cae79r			; 0.799537
	DD	03f4c7208r			; 0.798615
	DD	03f4c3578r			; 0.797691
	DD	03f4bf8c7r			; 0.796765
	DD	03f4bbbf8r			; 0.795837
	DD	03f4b7f09r			; 0.794907
	DD	03f4b41far			; 0.793975
	DD	03f4b04ccr			; 0.793042
	DD	03f4ac77fr			; 0.792107
	DD	03f4a8a13r			; 0.791169
	DD	03f4a4c87r			; 0.79023
	DD	03f4a0edcr			; 0.789289
	DD	03f49d112r			; 0.788346
	DD	03f499329r			; 0.787402
	DD	03f495521r			; 0.786455
	DD	03f4916far			; 0.785507
	DD	03f48d8b3r			; 0.784557
	DD	03f489a4er			; 0.783605
	DD	03f485bcar			; 0.782651
	DD	03f481d27r			; 0.781695
	DD	03f47de65r			; 0.780737
	DD	03f479f84r			; 0.779778
	DD	03f476085r			; 0.778817
	DD	03f472167r			; 0.777853
	DD	03f46e22ar			; 0.776888
	DD	03f46a2cer			; 0.775922
	DD	03f466354r			; 0.774953
	DD	03f4623bbr			; 0.773983
	DD	03f45e403r			; 0.77301
	DD	03f45a42dr			; 0.772036
	DD	03f456439r			; 0.771061
	DD	03f452426r			; 0.770083
	DD	03f44e3f5r			; 0.769103
	DD	03f44a3a5r			; 0.768122
	DD	03f446337r			; 0.767139
	DD	03f4422abr			; 0.766154
	DD	03f43e200r			; 0.765167
	DD	03f43a138r			; 0.764179
	DD	03f436051r			; 0.763188
	DD	03f431f4cr			; 0.762196
	DD	03f42de29r			; 0.761202
	DD	03f429ce8r			; 0.760207
	DD	03f425b89r			; 0.759209
	DD	03f421a0br			; 0.75821
	DD	03f41d870r			; 0.757209
	DD	03f4196b7r			; 0.756206
	DD	03f4154e1r			; 0.755201
	DD	03f4112ecr			; 0.754195
	DD	03f40d0dar			; 0.753187
	DD	03f408ea9r			; 0.752177
	DD	03f404c5cr			; 0.751165
	DD	03f4009f0r			; 0.750152
	DD	03f3fc767r			; 0.749136
	DD	03f3f84c0r			; 0.748119
	DD	03f3f41fcr			; 0.747101
	DD	03f3eff1br			; 0.74608
	DD	03f3ebc1br			; 0.745058
	DD	03f3e78ffr			; 0.744034
	DD	03f3e35c5r			; 0.743008
	DD	03f3df26er			; 0.74198
	DD	03f3daef9r			; 0.740951
	DD	03f3d6b67r			; 0.73992
	DD	03f3d27b8r			; 0.738887
	DD	03f3ce3ecr			; 0.737853
	DD	03f3ca003r			; 0.736817
	DD	03f3c5bfcr			; 0.735779
	DD	03f3c17d9r			; 0.734739
	DD	03f3bd398r			; 0.733697
	DD	03f3b8f3br			; 0.732654
	DD	03f3b4ac1r			; 0.731609
	DD	03f3b0629r			; 0.730563
	DD	03f3ac175r			; 0.729514
	DD	03f3a7ca4r			; 0.728464
	DD	03f3a37b7r			; 0.727413
	DD	03f39f2acr			; 0.726359
	DD	03f39ad85r			; 0.725304
	DD	03f396842r			; 0.724247
	DD	03f3922e1r			; 0.723188
	DD	03f38dd65r			; 0.722128
	DD	03f3897cbr			; 0.721066
	DD	03f385216r			; 0.720003
	DD	03f380c43r			; 0.718937
	DD	03f37c655r			; 0.71787
	DD	03f37804ar			; 0.716801
	DD	03f373a23r			; 0.715731
	DD	03f36f3dfr			; 0.714659
	DD	03f36ad7fr			; 0.713585
	DD	03f366704r			; 0.712509
	DD	03f36206cr			; 0.711432
	DD	03f35d9b8r			; 0.710353
	DD	03f3592e7r			; 0.709273
	DD	03f354bfbr			; 0.708191
	DD	03f3504f3r			; 0.707107
	DD	03f34bdcfr			; 0.706021
	DD	03f34768fr			; 0.704934
	DD	03f342f34r			; 0.703845
	DD	03f33e7bcr			; 0.702755
	DD	03f33a029r			; 0.701663
	DD	03f33587ar			; 0.700569
	DD	03f3310afr			; 0.699473
	DD	03f32c8c9r			; 0.698376
	DD	03f3280c7r			; 0.697277
	DD	03f3238aar			; 0.696177
	DD	03f31f071r			; 0.695075
	DD	03f31a81dr			; 0.693971
	DD	03f315fadr			; 0.692866
	DD	03f311722r			; 0.691759
	DD	03f30ce7cr			; 0.690651
	DD	03f3085bbr			; 0.689541
	DD	03f303cder			; 0.688429
	DD	03f2ff3e6r			; 0.687315
	DD	03f2faad3r			; 0.6862
	DD	03f2f61a5r			; 0.685084
	DD	03f2f185br			; 0.683965
	DD	03f2ecef7r			; 0.682846
	DD	03f2e8578r			; 0.681724
	DD	03f2e3bder			; 0.680601
	DD	03f2df229r			; 0.679476
	DD	03f2da859r			; 0.67835
	DD	03f2d5e6fr			; 0.677222
	DD	03f2d1469r			; 0.676093
	DD	03f2cca49r			; 0.674962
	DD	03f2c800fr			; 0.673829
	DD	03f2c35b9r			; 0.672695
	DD	03f2beb4ar			; 0.671559
	DD	03f2ba0bfr			; 0.670422
	DD	03f2b561br			; 0.669283
	DD	03f2b0b5br			; 0.668142
	DD	03f2ac082r			; 0.667
	DD	03f2a758er			; 0.665856
	DD	03f2a2a80r			; 0.664711
	DD	03f29df57r			; 0.663564
	DD	03f299415r			; 0.662416
	DD	03f2948b8r			; 0.661266
	DD	03f28fd41r			; 0.660114
	DD	03f28b1b0r			; 0.658961
	DD	03f286605r			; 0.657807
	DD	03f281a40r			; 0.656651
	DD	03f27ce61r			; 0.655493
	DD	03f278268r			; 0.654334
	DD	03f273656r			; 0.653173
	DD	03f26ea2ar			; 0.652011
	DD	03f269de3r			; 0.650847
	DD	03f265184r			; 0.649681
	DD	03f26050ar			; 0.648514
	DD	03f25b877r			; 0.647346
	DD	03f256bcbr			; 0.646176
	DD	03f251f04r			; 0.645005
	DD	03f24d225r			; 0.643832
	DD	03f24852cr			; 0.642657
	DD	03f24381ar			; 0.641481
	DD	03f23eaeer			; 0.640303
	DD	03f239da9r			; 0.639124
	DD	03f23504br			; 0.637944
	DD	03f2302d3r			; 0.636762
	DD	03f22b543r			; 0.635578
	DD	03f226799r			; 0.634393
	DD	03f2219d7r			; 0.633207
	DD	03f21cbfbr			; 0.632019
	DD	03f217e06r			; 0.630829
	DD	03f212ff9r			; 0.629638
	DD	03f20e1d2r			; 0.628446
	DD	03f209393r			; 0.627252
	DD	03f20453br			; 0.626056
	DD	03f1ff6cbr			; 0.62486
	DD	03f1fa841r			; 0.623661
	DD	03f1f599fr			; 0.622461
	DD	03f1f0ae5r			; 0.62126
	DD	03f1ebc12r			; 0.620057
	DD	03f1e6d26r			; 0.618853
	DD	03f1e1e22r			; 0.617647
	DD	03f1dcf06r			; 0.61644
	DD	03f1d7fd1r			; 0.615232
	DD	03f1d3084r			; 0.614022
	DD	03f1ce11fr			; 0.61281
	DD	03f1c91a2r			; 0.611597
	DD	03f1c420cr			; 0.610383
	DD	03f1bf25fr			; 0.609167
	DD	03f1ba299r			; 0.60795
	DD	03f1b52bbr			; 0.606731
	DD	03f1b02c6r			; 0.605511
	DD	03f1ab2b8r			; 0.60429
	DD	03f1a6293r			; 0.603067
	DD	03f1a1255r			; 0.601842
	DD	03f19c200r			; 0.600616
	DD	03f197194r			; 0.599389
	DD	03f19210fr			; 0.598161
	DD	03f18d073r			; 0.596931
	DD	03f187fc0r			; 0.595699
	DD	03f182ef5r			; 0.594467
	DD	03f17de12r			; 0.593232
	DD	03f178d18r			; 0.591997
	DD	03f173c07r			; 0.59076
	DD	03f16eader			; 0.589521
	DD	03f16999fr			; 0.588282
	DD	03f164847r			; 0.58704
	DD	03f15f6d9r			; 0.585798
	DD	03f15a554r			; 0.584554
	DD	03f1553b7r			; 0.583309
	DD	03f150204r			; 0.582062
	DD	03f14b039r			; 0.580814
	DD	03f145e58r			; 0.579565
	DD	03f140c5fr			; 0.578314
	DD	03f13ba50r			; 0.577062
	DD	03f13682ar			; 0.575808
	DD	03f1315eer			; 0.574553
	DD	03f12c39ar			; 0.573297
	DD	03f127130r			; 0.57204
	DD	03f121eb0r			; 0.570781
	DD	03f11cc19r			; 0.569521
	DD	03f11796br			; 0.568259
	DD	03f1126a7r			; 0.566996
	DD	03f10d3cdr			; 0.565732
	DD	03f1080dcr			; 0.564466
	DD	03f102dd5r			; 0.563199
	DD	03f0fdab8r			; 0.561931
	DD	03f0f8784r			; 0.560662
	DD	03f0f343br			; 0.559391
	DD	03f0ee0dbr			; 0.558119
	DD	03f0e8d65r			; 0.556845
	DD	03f0e39dar			; 0.55557
	DD	03f0de638r			; 0.554294
	DD	03f0d9281r			; 0.553017
	DD	03f0d3eb3r			; 0.551738
	DD	03f0cead0r			; 0.550458
	DD	03f0c96d7r			; 0.549177
	DD	03f0c42c9r			; 0.547894
	DD	03f0beea5r			; 0.54661
	DD	03f0b9a6br			; 0.545325
	DD	03f0b461cr			; 0.544039
	DD	03f0af1b7r			; 0.542751
	DD	03f0a9d3dr			; 0.541462
	DD	03f0a48adr			; 0.540171
	DD	03f09f409r			; 0.53888
	DD	03f099f4er			; 0.537587
	DD	03f094a7fr			; 0.536293
	DD	03f08f59br			; 0.534998
	DD	03f08a0a1r			; 0.533701
	DD	03f084b92r			; 0.532403
	DD	03f07f66fr			; 0.531104
	DD	03f07a136r			; 0.529804
	DD	03f074be8r			; 0.528502
	DD	03f06f686r			; 0.527199
	DD	03f06a10er			; 0.525895
	DD	03f064b82r			; 0.52459
	DD	03f05f5e2r			; 0.523283
	DD	03f05a02cr			; 0.521975
	DD	03f054a62r			; 0.520666
	DD	03f04f484r			; 0.519356
	DD	03f049e91r			; 0.518045
	DD	03f044889r			; 0.516732
	DD	03f03f26dr			; 0.515418
	DD	03f039c3dr			; 0.514103
	DD	03f0345f8r			; 0.512786
	DD	03f02ef9fr			; 0.511469
	DD	03f029932r			; 0.51015
	DD	03f0242b1r			; 0.50883
	DD	03f01ec1cr			; 0.507509
	DD	03f019573r			; 0.506187
	DD	03f013eb5r			; 0.504863
	DD	03f00e7e4r			; 0.503538
	DD	03f0090ffr			; 0.502212
	DD	03f003a06r			; 0.500885
	DD	03effc5f3r			; 0.499557
	DD	03eff17b2r			; 0.498228
	DD	03efe694ar			; 0.496897
	DD	03efdbabbr			; 0.495565
	DD	03efd0c04r			; 0.494232
	DD	03efc5d27r			; 0.492898
	DD	03efbae22r			; 0.491563
	DD	03efafef7r			; 0.490226
	DD	03efa4fa5r			; 0.488889
	DD	03ef9a02dr			; 0.48755
	DD	03ef8f08er			; 0.48621
	DD	03ef840c8r			; 0.484869
	DD	03ef790dcr			; 0.483527
	DD	03ef6e0cbr			; 0.482184
	DD	03ef63093r			; 0.480839
	DD	03ef58035r			; 0.479494
	DD	03ef4cfb1r			; 0.478147
	DD	03ef41f07r			; 0.476799
	DD	03ef36e38r			; 0.47545
	DD	03ef2bd43r			; 0.4741
	DD	03ef20c29r			; 0.472749
	DD	03ef15aear			; 0.471397
	DD	03ef0a985r			; 0.470043
	DD	03eeff7fbr			; 0.468689
	DD	03eef464cr			; 0.467333
	DD	03eee9479r			; 0.465977
	DD	03eede280r			; 0.464619
	DD	03eed3063r			; 0.46326
	DD	03eec7e21r			; 0.4619
	DD	03eebcbbbr			; 0.460539
	DD	03eeb1930r			; 0.459177
	DD	03eea6681r			; 0.457813
	DD	03ee9b3aer			; 0.456449
	DD	03ee900b7r			; 0.455084
	DD	03ee84d9cr			; 0.453717
	DD	03ee79a5dr			; 0.45235
	DD	03ee6e6fbr			; 0.450981
	DD	03ee63375r			; 0.449611
	DD	03ee57fcbr			; 0.448241
	DD	03ee4cbfer			; 0.446869
	DD	03ee4180er			; 0.445496
	DD	03ee363far			; 0.444122
	DD	03ee2afc4r			; 0.442747
	DD	03ee1fb6ar			; 0.441371
	DD	03ee146eer			; 0.439994
	DD	03ee0924fr			; 0.438616
	DD	03edfdd8dr			; 0.437237
	DD	03edf28a9r			; 0.435857
	DD	03ede73a2r			; 0.434476
	DD	03eddbe79r			; 0.433094
	DD	03edd092er			; 0.431711
	DD	03edc53c1r			; 0.430326
	DD	03edb9e31r			; 0.428941
	DD	03edae880r			; 0.427555
	DD	03eda32adr			; 0.426168
	DD	03ed97cb9r			; 0.42478
	DD	03ed8c6a3r			; 0.42339
	DD	03ed8106br			; 0.422
	DD	03ed75a13r			; 0.420609
	DD	03ed6a399r			; 0.419217
	DD	03ed5ecfdr			; 0.417824
	DD	03ed53641r			; 0.41643
	DD	03ed47f64r			; 0.415034
	DD	03ed3c867r			; 0.413638
	DD	03ed31148r			; 0.412241
	DD	03ed25a09r			; 0.410843
	DD	03ed1a2aar			; 0.409444
	DD	03ed0eb2ar			; 0.408044
	DD	03ed0338ar			; 0.406643
	DD	03ecf7bcar			; 0.405241
	DD	03ecec3ear			; 0.403838
	DD	03ece0bear			; 0.402435
	DD	03ecd53car			; 0.40103
	DD	03ecc9b8br			; 0.399624
	DD	03ecbe32cr			; 0.398218
	DD	03ecb2aaer			; 0.39681
	DD	03eca7210r			; 0.395401
	DD	03ec9b953r			; 0.393992
	DD	03ec90077r			; 0.392582
	DD	03ec8477cr			; 0.39117
	DD	03ec78e62r			; 0.389758
	DD	03ec6d529r			; 0.388345
	DD	03ec61bd2r			; 0.386931
	DD	03ec5625cr			; 0.385516
	DD	03ec4a8c8r			; 0.3841
	DD	03ec3ef15r			; 0.382683
	DD	03ec33544r			; 0.381266
	DD	03ec27b55r			; 0.379847
	DD	03ec1c148r			; 0.378428
	DD	03ec1071er			; 0.377007
	DD	03ec04cd5r			; 0.375586
	DD	03ebf926fr			; 0.374164
	DD	03ebed7ebr			; 0.372741
	DD	03ebe1d4ar			; 0.371317
	DD	03ebd628br			; 0.369892
	DD	03ebca7afr			; 0.368467
	DD	03ebbecb6r			; 0.36704
	DD	03ebb31a0r			; 0.365613
	DD	03eba766er			; 0.364185
	DD	03eb9bb1er			; 0.362756
	DD	03eb8ffb2r			; 0.361326
	DD	03eb8442ar			; 0.359895
	DD	03eb78884r			; 0.358463
	DD	03eb6ccc3r			; 0.357031
	DD	03eb610e6r			; 0.355598
	DD	03eb554ecr			; 0.354164
	DD	03eb498d6r			; 0.352729
	DD	03eb3dca5r			; 0.351293
	DD	03eb32058r			; 0.349856
	DD	03eb263efr			; 0.348419
	DD	03eb1a76br			; 0.34698
	DD	03eb0eacbr			; 0.345541
	DD	03eb02e10r			; 0.344101
	DD	03eaf713ar			; 0.342661
	DD	03eaeb449r			; 0.341219
	DD	03eadf73cr			; 0.339777
	DD	03ead3a15r			; 0.338334
	DD	03eac7cd4r			; 0.33689
	DD	03eabbf77r			; 0.335445
	DD	03eab0201r			; 0.334
	DD	03eaa446fr			; 0.332553
	DD	03ea986c4r			; 0.331106
	DD	03ea8c8fer			; 0.329658
	DD	03ea80b1fr			; 0.32821
	DD	03ea74d25r			; 0.32676
	DD	03ea68f12r			; 0.32531
	DD	03ea5d0e5r			; 0.323859
	DD	03ea5129fr			; 0.322408
	DD	03ea4543fr			; 0.320955
	DD	03ea395c5r			; 0.319502
	DD	03ea2d733r			; 0.318048
	DD	03ea21887r			; 0.316593
	DD	03ea159c2r			; 0.315138
	DD	03ea09ae5r			; 0.313682
	DD	03e9fdbeer			; 0.312225
	DD	03e9f1cdfr			; 0.310767
	DD	03e9e5db8r			; 0.309309
	DD	03e9d9e78r			; 0.30785
	DD	03e9cdf20r			; 0.30639
	DD	03e9c1fafr			; 0.304929
	DD	03e9b6027r			; 0.303468
	DD	03e9aa086r			; 0.302006
	DD	03e99e0cer			; 0.300543
	DD	03e9920fer			; 0.29908
	DD	03e986116r			; 0.297616
	DD	03e97a117r			; 0.296151
	DD	03e96e100r			; 0.294685
	DD	03e9620d2r			; 0.293219
	DD	03e95608dr			; 0.291752
	DD	03e94a031r			; 0.290285
	DD	03e93dfbfr			; 0.288816
	DD	03e931f35r			; 0.287347
	DD	03e925e94r			; 0.285878
	DD	03e919dddr			; 0.284408
	DD	03e90dd10r			; 0.282937
	DD	03e901c2cr			; 0.281465
	DD	03e8f5b32r			; 0.279993
	DD	03e8e9a22r			; 0.27852
	DD	03e8dd8fcr			; 0.277046
	DD	03e8d17c0r			; 0.275572
	DD	03e8c566er			; 0.274097
	DD	03e8b9507r			; 0.272621
	DD	03e8ad38ar			; 0.271145
	DD	03e8a11f7r			; 0.269668
	DD	03e895050r			; 0.268191
	DD	03e888e93r			; 0.266713
	DD	03e87ccc1r			; 0.265234
	DD	03e870adar			; 0.263755
	DD	03e8648dfr			; 0.262275
	DD	03e8586cer			; 0.260794
	DD	03e84c4aar			; 0.259313
	DD	03e840270r			; 0.257831
	DD	03e834022r			; 0.256349
	DD	03e827dc0r			; 0.254866
	DD	03e81bb4ar			; 0.253382
	DD	03e80f8c0r			; 0.251898
	DD	03e803622r			; 0.250413
	DD	03e7ee6e1r			; 0.248928
	DD	03e7d6156r			; 0.247442
	DD	03e7bdba4r			; 0.245955
	DD	03e7a55cbr			; 0.244468
	DD	03e78cfccr			; 0.24298
	DD	03e7749a6r			; 0.241492
	DD	03e75c35ar			; 0.240003
	DD	03e743ce8r			; 0.238514
	DD	03e72b651r			; 0.237024
	DD	03e712f94r			; 0.235533
	DD	03e6fa8b2r			; 0.234042
	DD	03e6e21abr			; 0.23255
	DD	03e6c9a7fr			; 0.231058
	DD	03e6b132fr			; 0.229565
	DD	03e698bbar			; 0.228072
	DD	03e680422r			; 0.226578
	DD	03e667c66r			; 0.225084
	DD	03e64f486r			; 0.223589
	DD	03e636c83r			; 0.222094
	DD	03e61e45cr			; 0.220598
	DD	03e605c13r			; 0.219101
	DD	03e5ed3a8r			; 0.217604
	DD	03e5d4b1ar			; 0.216107
	DD	03e5bc26ar			; 0.214609
	DD	03e5a3997r			; 0.21311
	DD	03e58b0a4r			; 0.211611
	DD	03e57278fr			; 0.210112
	DD	03e559e58r			; 0.208612
	DD	03e541501r			; 0.207111
	DD	03e528b89r			; 0.20561
	DD	03e5101f1r			; 0.204109
	DD	03e4f7838r			; 0.202607
	DD	03e4dee60r			; 0.201105
	DD	03e4c6467r			; 0.199602
	DD	03e4ada4fr			; 0.198098
	DD	03e495018r			; 0.196595
	DD	03e47c5c2r			; 0.19509
	DD	03e463b4dr			; 0.193586
	DD	03e44b0b9r			; 0.19208
	DD	03e432607r			; 0.190575
	DD	03e419b37r			; 0.189069
	DD	03e401049r			; 0.187562
	DD	03e3e853er			; 0.186055
	DD	03e3cfa15r			; 0.184548
	DD	03e3b6ecfr			; 0.18304
	DD	03e39e36cr			; 0.181532
	DD	03e3857ecr			; 0.180023
	DD	03e36cc50r			; 0.178514
	DD	03e354098r			; 0.177004
	DD	03e33b4c4r			; 0.175494
	DD	03e3228d4r			; 0.173984
	DD	03e309cc9r			; 0.172473
	DD	03e2f10a2r			; 0.170962
	DD	03e2d8461r			; 0.16945
	DD	03e2bf804r			; 0.167938
	DD	03e2a6b8dr			; 0.166426
	DD	03e28defcr			; 0.164913
	DD	03e275251r			; 0.1634
	DD	03e25c58cr			; 0.161886
	DD	03e2438adr			; 0.160372
	DD	03e22abb6r			; 0.158858
	DD	03e211ea5r			; 0.157343
	DD	03e1f917br			; 0.155828
	DD	03e1e0438r			; 0.154313
	DD	03e1c76der			; 0.152797
	DD	03e1ae96br			; 0.151281
	DD	03e195be0r			; 0.149765
	DD	03e17ce3dr			; 0.148248
	DD	03e164083r			; 0.14673
	DD	03e14b2b2r			; 0.145213
	DD	03e1324car			; 0.143695
	DD	03e1196ccr			; 0.142177
	DD	03e1008b7r			; 0.140658
	DD	03e0e7a8br			; 0.139139
	DD	03e0cec4ar			; 0.13762
	DD	03e0b5df3r			; 0.136101
	DD	03e09cf86r			; 0.134581
	DD	03e084105r			; 0.133061
	DD	03e06b26er			; 0.13154
	DD	03e0523c2r			; 0.130019
	DD	03e039502r			; 0.128498
	DD	03e02062er			; 0.126977
	DD	03e007745r			; 0.125455
	DD	03dfdd092r			; 0.123933
	DD	03dfab273r			; 0.122411
	DD	03df7942cr			; 0.120888
	DD	03df475c0r			; 0.119365
	DD	03df1572er			; 0.117842
	DD	03dee3876r			; 0.116319
	DD	03deb199ar			; 0.114795
	DD	03de7fa9ar			; 0.113271
	DD	03de4db76r			; 0.111747
	DD	03de1bc2er			; 0.110222
	DD	03dde9cc4r			; 0.108697
	DD	03ddb7d37r			; 0.107172
	DD	03dd85d89r			; 0.105647
	DD	03dd53db9r			; 0.104122
	DD	03dd21dc8r			; 0.102596
	DD	03dcefdb7r			; 0.10107
	DD	03dcbdd86r			; 0.0995436
	DD	03dc8bd36r			; 0.0980171
	DD	03dc59cc6r			; 0.0964904
	DD	03dc27c39r			; 0.0949635
	DD	03dbf5b8dr			; 0.0934363
	DD	03dbc3ac3r			; 0.091909
	DD	03db919ddr			; 0.0903814
	DD	03db5f8dar			; 0.0888536
	DD	03db2d7bbr			; 0.0873255
	DD	03dafb680r			; 0.0857973
	DD	03dac952br			; 0.0842689
	DD	03da973bar			; 0.0827403
	DD	03da65230r			; 0.0812114
	DD	03da3308cr			; 0.0796824
	DD	03da00ecfr			; 0.0781532
	DD	03d9cecf9r			; 0.0766239
	DD	03d99cb0ar			; 0.0750943
	DD	03d96a905r			; 0.0735646
	DD	03d9386e7r			; 0.0720346
	DD	03d9064b4r			; 0.0705046
	DD	03d8d426ar			; 0.0689743
	DD	03d8a200ar			; 0.0674439
	DD	03d86fd94r			; 0.0659133
	DD	03d83db0ar			; 0.0643826
	DD	03d80b86cr			; 0.0628518
	DD	03d7b2b74r			; 0.0613207
	DD	03d74e5e9r			; 0.0597896
	DD	03d6ea038r			; 0.0582583
	DD	03d685a62r			; 0.0567268
	DD	03d621469r			; 0.0551952
	DD	03d5bce4cr			; 0.0536635
	DD	03d55880er			; 0.0521317
	DD	03d4f41afr			; 0.0505998
	DD	03d48fb30r			; 0.0490677
	DD	03d42b491r			; 0.0475355
	DD	03d3c6dd5r			; 0.0460032
	DD	03d3626fcr			; 0.0444708
	DD	03d2fe007r			; 0.0429383
	DD	03d2998f6r			; 0.0414056
	DD	03d2351cbr			; 0.0398729
	DD	03d1d0a88r			; 0.0383401
	DD	03d16c32cr			; 0.0368072
	DD	03d107bb8r			; 0.0352742
	DD	03d0a342fr			; 0.0337412
	DD	03d03ec90r			; 0.032208
	DD	03cfb49bar			; 0.0306748
	DD	03ceeba2cr			; 0.0291415
	DD	03ce22a7ar			; 0.0276081
	DD	03cd59aa6r			; 0.0260747
	DD	03cc90ab0r			; 0.0245412
	DD	03cbc7a9br			; 0.0230077
	DD	03cafea69r			; 0.0214741
	DD	03ca35a1cr			; 0.0199404
	DD	03c96c9b6r			; 0.0184067
	DD	03c8a3938r			; 0.016873
	DD	03c7b514br			; 0.0153392
	DD	03c622fffr			; 0.0138054
	DD	03c490e90r			; 0.0122715
	DD	03c2fed02r			; 0.0107377
	DD	03c16cb58r			; 0.00920375
	DD	03bfb5330r			; 0.00766983
	DD	03bc90f88r			; 0.00613588
	DD	03b96cbc1r			; 0.00460193
	DD	03b490fc6r			; 0.00306796
	DD	03ac90fd5r			; 0.00153398
	DD	0248d3000r			; 6.12303e-17
	DD	0bac90fd5r			; -0.00153398
	DD	0bb490fc6r			; -0.00306796
	DD	0bb96cbc1r			; -0.00460193
	DD	0bbc90f88r			; -0.00613588
	DD	0bbfb5330r			; -0.00766983
	DD	0bc16cb58r			; -0.00920375
	DD	0bc2fed02r			; -0.0107377
	DD	0bc490e90r			; -0.0122715
	DD	0bc622fffr			; -0.0138054
	DD	0bc7b514br			; -0.0153392
	DD	0bc8a3938r			; -0.016873
	DD	0bc96c9b6r			; -0.0184067
	DD	0bca35a1cr			; -0.0199404
	DD	0bcafea69r			; -0.0214741
	DD	0bcbc7a9br			; -0.0230077
	DD	0bcc90ab0r			; -0.0245412
	DD	0bcd59aa6r			; -0.0260747
	DD	0bce22a7ar			; -0.0276081
	DD	0bceeba2cr			; -0.0291415
	DD	0bcfb49bar			; -0.0306748
	DD	0bd03ec90r			; -0.032208
	DD	0bd0a342fr			; -0.0337412
	DD	0bd107bb8r			; -0.0352742
	DD	0bd16c32cr			; -0.0368072
	DD	0bd1d0a88r			; -0.0383401
	DD	0bd2351cbr			; -0.0398729
	DD	0bd2998f6r			; -0.0414056
	DD	0bd2fe007r			; -0.0429383
	DD	0bd3626fcr			; -0.0444708
	DD	0bd3c6dd5r			; -0.0460032
	DD	0bd42b491r			; -0.0475355
	DD	0bd48fb30r			; -0.0490677
	DD	0bd4f41afr			; -0.0505998
	DD	0bd55880er			; -0.0521317
	DD	0bd5bce4cr			; -0.0536635
	DD	0bd621469r			; -0.0551952
	DD	0bd685a62r			; -0.0567268
	DD	0bd6ea038r			; -0.0582583
	DD	0bd74e5e9r			; -0.0597896
	DD	0bd7b2b74r			; -0.0613207
	DD	0bd80b86cr			; -0.0628518
	DD	0bd83db0ar			; -0.0643826
	DD	0bd86fd94r			; -0.0659133
	DD	0bd8a200ar			; -0.0674439
	DD	0bd8d426ar			; -0.0689743
	DD	0bd9064b4r			; -0.0705046
	DD	0bd9386e7r			; -0.0720346
	DD	0bd96a905r			; -0.0735646
	DD	0bd99cb0ar			; -0.0750943
	DD	0bd9cecf9r			; -0.0766239
	DD	0bda00ecfr			; -0.0781532
	DD	0bda3308cr			; -0.0796824
	DD	0bda65230r			; -0.0812114
	DD	0bda973bar			; -0.0827403
	DD	0bdac952br			; -0.0842689
	DD	0bdafb680r			; -0.0857973
	DD	0bdb2d7bbr			; -0.0873255
	DD	0bdb5f8dar			; -0.0888536
	DD	0bdb919ddr			; -0.0903814
	DD	0bdbc3ac3r			; -0.091909
	DD	0bdbf5b8dr			; -0.0934363
	DD	0bdc27c39r			; -0.0949635
	DD	0bdc59cc6r			; -0.0964904
	DD	0bdc8bd36r			; -0.0980171
	DD	0bdcbdd86r			; -0.0995436
	DD	0bdcefdb7r			; -0.10107
	DD	0bdd21dc8r			; -0.102596
	DD	0bdd53db9r			; -0.104122
	DD	0bdd85d89r			; -0.105647
	DD	0bddb7d37r			; -0.107172
	DD	0bdde9cc4r			; -0.108697
	DD	0bde1bc2er			; -0.110222
	DD	0bde4db76r			; -0.111747
	DD	0bde7fa9ar			; -0.113271
	DD	0bdeb199ar			; -0.114795
	DD	0bdee3876r			; -0.116319
	DD	0bdf1572er			; -0.117842
	DD	0bdf475c0r			; -0.119365
	DD	0bdf7942cr			; -0.120888
	DD	0bdfab273r			; -0.122411
	DD	0bdfdd092r			; -0.123933
	DD	0be007745r			; -0.125455
	DD	0be02062er			; -0.126977
	DD	0be039502r			; -0.128498
	DD	0be0523c2r			; -0.130019
	DD	0be06b26er			; -0.13154
	DD	0be084105r			; -0.133061
	DD	0be09cf86r			; -0.134581
	DD	0be0b5df3r			; -0.136101
	DD	0be0cec4ar			; -0.13762
	DD	0be0e7a8br			; -0.139139
	DD	0be1008b7r			; -0.140658
	DD	0be1196ccr			; -0.142177
	DD	0be1324car			; -0.143695
	DD	0be14b2b2r			; -0.145213
	DD	0be164083r			; -0.14673
	DD	0be17ce3dr			; -0.148248
	DD	0be195be0r			; -0.149765
	DD	0be1ae96br			; -0.151281
	DD	0be1c76der			; -0.152797
	DD	0be1e0438r			; -0.154313
	DD	0be1f917br			; -0.155828
	DD	0be211ea5r			; -0.157343
	DD	0be22abb6r			; -0.158858
	DD	0be2438adr			; -0.160372
	DD	0be25c58cr			; -0.161886
	DD	0be275251r			; -0.1634
	DD	0be28defcr			; -0.164913
	DD	0be2a6b8dr			; -0.166426
	DD	0be2bf804r			; -0.167938
	DD	0be2d8461r			; -0.16945
	DD	0be2f10a2r			; -0.170962
	DD	0be309cc9r			; -0.172473
	DD	0be3228d4r			; -0.173984
	DD	0be33b4c4r			; -0.175494
	DD	0be354098r			; -0.177004
	DD	0be36cc50r			; -0.178514
	DD	0be3857ecr			; -0.180023
	DD	0be39e36cr			; -0.181532
	DD	0be3b6ecfr			; -0.18304
	DD	0be3cfa15r			; -0.184548
	DD	0be3e853er			; -0.186055
	DD	0be401049r			; -0.187562
	DD	0be419b37r			; -0.189069
	DD	0be432607r			; -0.190575
	DD	0be44b0b9r			; -0.19208
	DD	0be463b4dr			; -0.193586
	DD	0be47c5c2r			; -0.19509
	DD	0be495018r			; -0.196595
	DD	0be4ada4fr			; -0.198098
	DD	0be4c6467r			; -0.199602
	DD	0be4dee60r			; -0.201105
	DD	0be4f7838r			; -0.202607
	DD	0be5101f1r			; -0.204109
	DD	0be528b89r			; -0.20561
	DD	0be541501r			; -0.207111
	DD	0be559e58r			; -0.208612
	DD	0be57278fr			; -0.210112
	DD	0be58b0a4r			; -0.211611
	DD	0be5a3997r			; -0.21311
	DD	0be5bc26ar			; -0.214609
	DD	0be5d4b1ar			; -0.216107
	DD	0be5ed3a8r			; -0.217604
	DD	0be605c13r			; -0.219101
	DD	0be61e45cr			; -0.220598
	DD	0be636c83r			; -0.222094
	DD	0be64f486r			; -0.223589
	DD	0be667c66r			; -0.225084
	DD	0be680422r			; -0.226578
	DD	0be698bbar			; -0.228072
	DD	0be6b132fr			; -0.229565
	DD	0be6c9a7fr			; -0.231058
	DD	0be6e21abr			; -0.23255
	DD	0be6fa8b2r			; -0.234042
	DD	0be712f94r			; -0.235533
	DD	0be72b651r			; -0.237024
	DD	0be743ce8r			; -0.238514
	DD	0be75c35ar			; -0.240003
	DD	0be7749a6r			; -0.241492
	DD	0be78cfccr			; -0.24298
	DD	0be7a55cbr			; -0.244468
	DD	0be7bdba4r			; -0.245955
	DD	0be7d6156r			; -0.247442
	DD	0be7ee6e1r			; -0.248928
	DD	0be803622r			; -0.250413
	DD	0be80f8c0r			; -0.251898
	DD	0be81bb4ar			; -0.253382
	DD	0be827dc0r			; -0.254866
	DD	0be834022r			; -0.256349
	DD	0be840270r			; -0.257831
	DD	0be84c4aar			; -0.259313
	DD	0be8586cer			; -0.260794
	DD	0be8648dfr			; -0.262275
	DD	0be870adar			; -0.263755
	DD	0be87ccc1r			; -0.265234
	DD	0be888e93r			; -0.266713
	DD	0be895050r			; -0.268191
	DD	0be8a11f7r			; -0.269668
	DD	0be8ad38ar			; -0.271145
	DD	0be8b9507r			; -0.272621
	DD	0be8c566er			; -0.274097
	DD	0be8d17c0r			; -0.275572
	DD	0be8dd8fcr			; -0.277046
	DD	0be8e9a22r			; -0.27852
	DD	0be8f5b32r			; -0.279993
	DD	0be901c2cr			; -0.281465
	DD	0be90dd10r			; -0.282937
	DD	0be919dddr			; -0.284408
	DD	0be925e94r			; -0.285878
	DD	0be931f35r			; -0.287347
	DD	0be93dfbfr			; -0.288816
	DD	0be94a031r			; -0.290285
	DD	0be95608dr			; -0.291752
	DD	0be9620d2r			; -0.293219
	DD	0be96e100r			; -0.294685
	DD	0be97a117r			; -0.296151
	DD	0be986116r			; -0.297616
	DD	0be9920fer			; -0.29908
	DD	0be99e0cer			; -0.300543
	DD	0be9aa086r			; -0.302006
	DD	0be9b6027r			; -0.303468
	DD	0be9c1fafr			; -0.304929
	DD	0be9cdf20r			; -0.30639
	DD	0be9d9e78r			; -0.30785
	DD	0be9e5db8r			; -0.309309
	DD	0be9f1cdfr			; -0.310767
	DD	0be9fdbeer			; -0.312225
	DD	0bea09ae5r			; -0.313682
	DD	0bea159c2r			; -0.315138
	DD	0bea21887r			; -0.316593
	DD	0bea2d733r			; -0.318048
	DD	0bea395c5r			; -0.319502
	DD	0bea4543fr			; -0.320955
	DD	0bea5129fr			; -0.322408
	DD	0bea5d0e5r			; -0.323859
	DD	0bea68f12r			; -0.32531
	DD	0bea74d25r			; -0.32676
	DD	0bea80b1fr			; -0.32821
	DD	0bea8c8fer			; -0.329658
	DD	0bea986c4r			; -0.331106
	DD	0beaa446fr			; -0.332553
	DD	0beab0201r			; -0.334
	DD	0beabbf77r			; -0.335445
	DD	0beac7cd4r			; -0.33689
	DD	0bead3a15r			; -0.338334
	DD	0beadf73cr			; -0.339777
	DD	0beaeb449r			; -0.341219
	DD	0beaf713ar			; -0.342661
	DD	0beb02e10r			; -0.344101
	DD	0beb0eacbr			; -0.345541
	DD	0beb1a76br			; -0.34698
	DD	0beb263efr			; -0.348419
	DD	0beb32058r			; -0.349856
	DD	0beb3dca5r			; -0.351293
	DD	0beb498d6r			; -0.352729
	DD	0beb554ecr			; -0.354164
	DD	0beb610e6r			; -0.355598
	DD	0beb6ccc3r			; -0.357031
	DD	0beb78884r			; -0.358463
	DD	0beb8442ar			; -0.359895
	DD	0beb8ffb2r			; -0.361326
	DD	0beb9bb1er			; -0.362756
	DD	0beba766er			; -0.364185
	DD	0bebb31a0r			; -0.365613
	DD	0bebbecb6r			; -0.36704
	DD	0bebca7afr			; -0.368467
	DD	0bebd628br			; -0.369892
	DD	0bebe1d4ar			; -0.371317
	DD	0bebed7ebr			; -0.372741
	DD	0bebf926fr			; -0.374164
	DD	0bec04cd5r			; -0.375586
	DD	0bec1071er			; -0.377007
	DD	0bec1c148r			; -0.378428
	DD	0bec27b55r			; -0.379847
	DD	0bec33544r			; -0.381266
	DD	0bec3ef15r			; -0.382683
	DD	0bec4a8c8r			; -0.3841
	DD	0bec5625cr			; -0.385516
	DD	0bec61bd2r			; -0.386931
	DD	0bec6d529r			; -0.388345
	DD	0bec78e62r			; -0.389758
	DD	0bec8477cr			; -0.39117
	DD	0bec90077r			; -0.392582
	DD	0bec9b953r			; -0.393992
	DD	0beca7210r			; -0.395401
	DD	0becb2aaer			; -0.39681
	DD	0becbe32cr			; -0.398218
	DD	0becc9b8br			; -0.399624
	DD	0becd53car			; -0.40103
	DD	0bece0bear			; -0.402435
	DD	0becec3ear			; -0.403838
	DD	0becf7bcar			; -0.405241
	DD	0bed0338ar			; -0.406643
	DD	0bed0eb2ar			; -0.408044
	DD	0bed1a2aar			; -0.409444
	DD	0bed25a09r			; -0.410843
	DD	0bed31148r			; -0.412241
	DD	0bed3c867r			; -0.413638
	DD	0bed47f64r			; -0.415034
	DD	0bed53641r			; -0.41643
	DD	0bed5ecfdr			; -0.417824
	DD	0bed6a399r			; -0.419217
	DD	0bed75a13r			; -0.420609
	DD	0bed8106br			; -0.422
	DD	0bed8c6a3r			; -0.42339
	DD	0bed97cb9r			; -0.42478
	DD	0beda32adr			; -0.426168
	DD	0bedae880r			; -0.427555
	DD	0bedb9e31r			; -0.428941
	DD	0bedc53c1r			; -0.430326
	DD	0bedd092er			; -0.431711
	DD	0beddbe79r			; -0.433094
	DD	0bede73a2r			; -0.434476
	DD	0bedf28a9r			; -0.435857
	DD	0bedfdd8dr			; -0.437237
	DD	0bee0924fr			; -0.438616
	DD	0bee146eer			; -0.439994
	DD	0bee1fb6ar			; -0.441371
	DD	0bee2afc4r			; -0.442747
	DD	0bee363far			; -0.444122
	DD	0bee4180er			; -0.445496
	DD	0bee4cbfer			; -0.446869
	DD	0bee57fcbr			; -0.448241
	DD	0bee63375r			; -0.449611
	DD	0bee6e6fbr			; -0.450981
	DD	0bee79a5dr			; -0.45235
	DD	0bee84d9cr			; -0.453717
	DD	0bee900b7r			; -0.455084
	DD	0bee9b3aer			; -0.456449
	DD	0beea6681r			; -0.457813
	DD	0beeb1930r			; -0.459177
	DD	0beebcbbbr			; -0.460539
	DD	0beec7e21r			; -0.4619
	DD	0beed3063r			; -0.46326
	DD	0beede280r			; -0.464619
	DD	0beee9479r			; -0.465977
	DD	0beef464cr			; -0.467333
	DD	0beeff7fbr			; -0.468689
	DD	0bef0a985r			; -0.470043
	DD	0bef15aear			; -0.471397
	DD	0bef20c29r			; -0.472749
	DD	0bef2bd43r			; -0.4741
	DD	0bef36e38r			; -0.47545
	DD	0bef41f07r			; -0.476799
	DD	0bef4cfb1r			; -0.478147
	DD	0bef58035r			; -0.479494
	DD	0bef63093r			; -0.480839
	DD	0bef6e0cbr			; -0.482184
	DD	0bef790dcr			; -0.483527
	DD	0bef840c8r			; -0.484869
	DD	0bef8f08er			; -0.48621
	DD	0bef9a02dr			; -0.48755
	DD	0befa4fa5r			; -0.488889
	DD	0befafef7r			; -0.490226
	DD	0befbae22r			; -0.491563
	DD	0befc5d27r			; -0.492898
	DD	0befd0c04r			; -0.494232
	DD	0befdbabbr			; -0.495565
	DD	0befe694ar			; -0.496897
	DD	0beff17b2r			; -0.498228
	DD	0beffc5f3r			; -0.499557
	DD	0bf003a06r			; -0.500885
	DD	0bf0090ffr			; -0.502212
	DD	0bf00e7e4r			; -0.503538
	DD	0bf013eb5r			; -0.504863
	DD	0bf019573r			; -0.506187
	DD	0bf01ec1cr			; -0.507509
	DD	0bf0242b1r			; -0.50883
	DD	0bf029932r			; -0.51015
	DD	0bf02ef9fr			; -0.511469
	DD	0bf0345f8r			; -0.512786
	DD	0bf039c3dr			; -0.514103
	DD	0bf03f26dr			; -0.515418
	DD	0bf044889r			; -0.516732
	DD	0bf049e91r			; -0.518045
	DD	0bf04f484r			; -0.519356
	DD	0bf054a62r			; -0.520666
	DD	0bf05a02cr			; -0.521975
	DD	0bf05f5e2r			; -0.523283
	DD	0bf064b82r			; -0.52459
	DD	0bf06a10er			; -0.525895
	DD	0bf06f686r			; -0.527199
	DD	0bf074be8r			; -0.528502
	DD	0bf07a136r			; -0.529804
	DD	0bf07f66fr			; -0.531104
	DD	0bf084b92r			; -0.532403
	DD	0bf08a0a1r			; -0.533701
	DD	0bf08f59br			; -0.534998
	DD	0bf094a7fr			; -0.536293
	DD	0bf099f4er			; -0.537587
	DD	0bf09f409r			; -0.53888
	DD	0bf0a48adr			; -0.540171
	DD	0bf0a9d3dr			; -0.541462
	DD	0bf0af1b7r			; -0.542751
	DD	0bf0b461cr			; -0.544039
	DD	0bf0b9a6br			; -0.545325
	DD	0bf0beea5r			; -0.54661
	DD	0bf0c42c9r			; -0.547894
	DD	0bf0c96d7r			; -0.549177
	DD	0bf0cead0r			; -0.550458
	DD	0bf0d3eb3r			; -0.551738
	DD	0bf0d9281r			; -0.553017
	DD	0bf0de638r			; -0.554294
	DD	0bf0e39dar			; -0.55557
	DD	0bf0e8d65r			; -0.556845
	DD	0bf0ee0dbr			; -0.558119
	DD	0bf0f343br			; -0.559391
	DD	0bf0f8784r			; -0.560662
	DD	0bf0fdab8r			; -0.561931
	DD	0bf102dd5r			; -0.563199
	DD	0bf1080dcr			; -0.564466
	DD	0bf10d3cdr			; -0.565732
	DD	0bf1126a7r			; -0.566996
	DD	0bf11796br			; -0.568259
	DD	0bf11cc19r			; -0.569521
	DD	0bf121eb0r			; -0.570781
	DD	0bf127130r			; -0.57204
	DD	0bf12c39ar			; -0.573297
	DD	0bf1315eer			; -0.574553
	DD	0bf13682ar			; -0.575808
	DD	0bf13ba50r			; -0.577062
	DD	0bf140c5fr			; -0.578314
	DD	0bf145e58r			; -0.579565
	DD	0bf14b039r			; -0.580814
	DD	0bf150204r			; -0.582062
	DD	0bf1553b7r			; -0.583309
	DD	0bf15a554r			; -0.584554
	DD	0bf15f6d9r			; -0.585798
	DD	0bf164847r			; -0.58704
	DD	0bf16999fr			; -0.588282
	DD	0bf16eader			; -0.589521
	DD	0bf173c07r			; -0.59076
	DD	0bf178d18r			; -0.591997
	DD	0bf17de12r			; -0.593232
	DD	0bf182ef5r			; -0.594467
	DD	0bf187fc0r			; -0.595699
	DD	0bf18d073r			; -0.596931
	DD	0bf19210fr			; -0.598161
	DD	0bf197194r			; -0.599389
	DD	0bf19c200r			; -0.600616
	DD	0bf1a1255r			; -0.601842
	DD	0bf1a6293r			; -0.603067
	DD	0bf1ab2b8r			; -0.60429
	DD	0bf1b02c6r			; -0.605511
	DD	0bf1b52bbr			; -0.606731
	DD	0bf1ba299r			; -0.60795
	DD	0bf1bf25fr			; -0.609167
	DD	0bf1c420cr			; -0.610383
	DD	0bf1c91a2r			; -0.611597
	DD	0bf1ce11fr			; -0.61281
	DD	0bf1d3084r			; -0.614022
	DD	0bf1d7fd1r			; -0.615232
	DD	0bf1dcf06r			; -0.61644
	DD	0bf1e1e22r			; -0.617647
	DD	0bf1e6d26r			; -0.618853
	DD	0bf1ebc12r			; -0.620057
	DD	0bf1f0ae5r			; -0.62126
	DD	0bf1f599fr			; -0.622461
	DD	0bf1fa841r			; -0.623661
	DD	0bf1ff6cbr			; -0.62486
	DD	0bf20453br			; -0.626056
	DD	0bf209393r			; -0.627252
	DD	0bf20e1d2r			; -0.628446
	DD	0bf212ff9r			; -0.629638
	DD	0bf217e06r			; -0.630829
	DD	0bf21cbfbr			; -0.632019
	DD	0bf2219d7r			; -0.633207
	DD	0bf226799r			; -0.634393
	DD	0bf22b543r			; -0.635578
	DD	0bf2302d3r			; -0.636762
	DD	0bf23504br			; -0.637944
	DD	0bf239da9r			; -0.639124
	DD	0bf23eaeer			; -0.640303
	DD	0bf24381ar			; -0.641481
	DD	0bf24852cr			; -0.642657
	DD	0bf24d225r			; -0.643832
	DD	0bf251f04r			; -0.645005
	DD	0bf256bcbr			; -0.646176
	DD	0bf25b877r			; -0.647346
	DD	0bf26050ar			; -0.648514
	DD	0bf265184r			; -0.649681
	DD	0bf269de3r			; -0.650847
	DD	0bf26ea2ar			; -0.652011
	DD	0bf273656r			; -0.653173
	DD	0bf278268r			; -0.654334
	DD	0bf27ce61r			; -0.655493
	DD	0bf281a40r			; -0.656651
	DD	0bf286605r			; -0.657807
	DD	0bf28b1b0r			; -0.658961
	DD	0bf28fd41r			; -0.660114
	DD	0bf2948b8r			; -0.661266
	DD	0bf299415r			; -0.662416
	DD	0bf29df57r			; -0.663564
	DD	0bf2a2a80r			; -0.664711
	DD	0bf2a758er			; -0.665856
	DD	0bf2ac082r			; -0.667
	DD	0bf2b0b5br			; -0.668142
	DD	0bf2b561br			; -0.669283
	DD	0bf2ba0bfr			; -0.670422
	DD	0bf2beb4ar			; -0.671559
	DD	0bf2c35b9r			; -0.672695
	DD	0bf2c800fr			; -0.673829
	DD	0bf2cca49r			; -0.674962
	DD	0bf2d1469r			; -0.676093
	DD	0bf2d5e6fr			; -0.677222
	DD	0bf2da859r			; -0.67835
	DD	0bf2df229r			; -0.679476
	DD	0bf2e3bder			; -0.680601
	DD	0bf2e8578r			; -0.681724
	DD	0bf2ecef7r			; -0.682846
	DD	0bf2f185br			; -0.683965
	DD	0bf2f61a5r			; -0.685084
	DD	0bf2faad3r			; -0.6862
	DD	0bf2ff3e6r			; -0.687315
	DD	0bf303cder			; -0.688429
	DD	0bf3085bbr			; -0.689541
	DD	0bf30ce7cr			; -0.690651
	DD	0bf311722r			; -0.691759
	DD	0bf315fadr			; -0.692866
	DD	0bf31a81dr			; -0.693971
	DD	0bf31f071r			; -0.695075
	DD	0bf3238aar			; -0.696177
	DD	0bf3280c7r			; -0.697277
	DD	0bf32c8c9r			; -0.698376
	DD	0bf3310afr			; -0.699473
	DD	0bf33587ar			; -0.700569
	DD	0bf33a029r			; -0.701663
	DD	0bf33e7bcr			; -0.702755
	DD	0bf342f34r			; -0.703845
	DD	0bf34768fr			; -0.704934
	DD	0bf34bdcfr			; -0.706021
	DD	0bf3504f3r			; -0.707107
	DD	0bf354bfbr			; -0.708191
	DD	0bf3592e7r			; -0.709273
	DD	0bf35d9b8r			; -0.710353
	DD	0bf36206cr			; -0.711432
	DD	0bf366704r			; -0.712509
	DD	0bf36ad7fr			; -0.713585
	DD	0bf36f3dfr			; -0.714659
	DD	0bf373a23r			; -0.715731
	DD	0bf37804ar			; -0.716801
	DD	0bf37c655r			; -0.71787
	DD	0bf380c43r			; -0.718937
	DD	0bf385216r			; -0.720003
	DD	0bf3897cbr			; -0.721066
	DD	0bf38dd65r			; -0.722128
	DD	0bf3922e1r			; -0.723188
	DD	0bf396842r			; -0.724247
	DD	0bf39ad85r			; -0.725304
	DD	0bf39f2acr			; -0.726359
	DD	0bf3a37b7r			; -0.727413
	DD	0bf3a7ca4r			; -0.728464
	DD	0bf3ac175r			; -0.729514
	DD	0bf3b0629r			; -0.730563
	DD	0bf3b4ac1r			; -0.731609
	DD	0bf3b8f3br			; -0.732654
	DD	0bf3bd398r			; -0.733697
	DD	0bf3c17d9r			; -0.734739
	DD	0bf3c5bfcr			; -0.735779
	DD	0bf3ca003r			; -0.736817
	DD	0bf3ce3ecr			; -0.737853
	DD	0bf3d27b8r			; -0.738887
	DD	0bf3d6b67r			; -0.73992
	DD	0bf3daef9r			; -0.740951
	DD	0bf3df26er			; -0.74198
	DD	0bf3e35c5r			; -0.743008
	DD	0bf3e78ffr			; -0.744034
	DD	0bf3ebc1br			; -0.745058
	DD	0bf3eff1br			; -0.74608
	DD	0bf3f41fcr			; -0.747101
	DD	0bf3f84c0r			; -0.748119
	DD	0bf3fc767r			; -0.749136
	DD	0bf4009f0r			; -0.750152
	DD	0bf404c5cr			; -0.751165
	DD	0bf408ea9r			; -0.752177
	DD	0bf40d0dar			; -0.753187
	DD	0bf4112ecr			; -0.754195
	DD	0bf4154e1r			; -0.755201
	DD	0bf4196b7r			; -0.756206
	DD	0bf41d870r			; -0.757209
	DD	0bf421a0br			; -0.75821
	DD	0bf425b89r			; -0.759209
	DD	0bf429ce8r			; -0.760207
	DD	0bf42de29r			; -0.761202
	DD	0bf431f4cr			; -0.762196
	DD	0bf436051r			; -0.763188
	DD	0bf43a138r			; -0.764179
	DD	0bf43e200r			; -0.765167
	DD	0bf4422abr			; -0.766154
	DD	0bf446337r			; -0.767139
	DD	0bf44a3a5r			; -0.768122
	DD	0bf44e3f5r			; -0.769103
	DD	0bf452426r			; -0.770083
	DD	0bf456439r			; -0.771061
	DD	0bf45a42dr			; -0.772036
	DD	0bf45e403r			; -0.77301
	DD	0bf4623bbr			; -0.773983
	DD	0bf466354r			; -0.774953
	DD	0bf46a2cer			; -0.775922
	DD	0bf46e22ar			; -0.776888
	DD	0bf472167r			; -0.777853
	DD	0bf476085r			; -0.778817
	DD	0bf479f84r			; -0.779778
	DD	0bf47de65r			; -0.780737
	DD	0bf481d27r			; -0.781695
	DD	0bf485bcar			; -0.782651
	DD	0bf489a4er			; -0.783605
	DD	0bf48d8b3r			; -0.784557
	DD	0bf4916far			; -0.785507
	DD	0bf495521r			; -0.786455
	DD	0bf499329r			; -0.787402
	DD	0bf49d112r			; -0.788346
	DD	0bf4a0edcr			; -0.789289
	DD	0bf4a4c87r			; -0.79023
	DD	0bf4a8a13r			; -0.791169
	DD	0bf4ac77fr			; -0.792107
	DD	0bf4b04ccr			; -0.793042
	DD	0bf4b41far			; -0.793975
	DD	0bf4b7f09r			; -0.794907
	DD	0bf4bbbf8r			; -0.795837
	DD	0bf4bf8c7r			; -0.796765
	DD	0bf4c3578r			; -0.797691
	DD	0bf4c7208r			; -0.798615
	DD	0bf4cae79r			; -0.799537
	DD	0bf4ceacbr			; -0.800458
	DD	0bf4d26fdr			; -0.801376
	DD	0bf4d6310r			; -0.802293
	DD	0bf4d9f02r			; -0.803208
	DD	0bf4ddad5r			; -0.80412
	DD	0bf4e1689r			; -0.805031
	DD	0bf4e521cr			; -0.80594
	DD	0bf4e8d90r			; -0.806848
	DD	0bf4ec8e4r			; -0.807753
	DD	0bf4f0417r			; -0.808656
	DD	0bf4f3f2br			; -0.809558
	DD	0bf4f7a1fr			; -0.810457
	DD	0bf4fb4f4r			; -0.811355
	DD	0bf4fefa8r			; -0.812251
	DD	0bf502a3br			; -0.813144
	DD	0bf5064afr			; -0.814036
	DD	0bf509f03r			; -0.814926
	DD	0bf50d937r			; -0.815814
	DD	0bf51134ar			; -0.816701
	DD	0bf514d3dr			; -0.817585
	DD	0bf518710r			; -0.818467
	DD	0bf51c0c2r			; -0.819348
	DD	0bf51fa54r			; -0.820226
	DD	0bf5233c6r			; -0.821102
	DD	0bf526d18r			; -0.821977
	DD	0bf52a649r			; -0.82285
	DD	0bf52df59r			; -0.823721
	DD	0bf531849r			; -0.824589
	DD	0bf535118r			; -0.825456
	DD	0bf5389c7r			; -0.826321
	DD	0bf53c255r			; -0.827184
	DD	0bf53fac3r			; -0.828045
	DD	0bf54330fr			; -0.828904
	DD	0bf546b3br			; -0.829761
	DD	0bf54a347r			; -0.830616
	DD	0bf54db31r			; -0.83147
	DD	0bf5512fbr			; -0.832321
	DD	0bf554aa4r			; -0.83317
	DD	0bf55822cr			; -0.834018
	DD	0bf55b993r			; -0.834863
	DD	0bf55f0d9r			; -0.835706
	DD	0bf5627fer			; -0.836548
	DD	0bf565f02r			; -0.837387
	DD	0bf5695e5r			; -0.838225
	DD	0bf56cca7r			; -0.83906
	DD	0bf570348r			; -0.839894
	DD	0bf5739c7r			; -0.840725
	DD	0bf577026r			; -0.841555
	DD	0bf57a663r			; -0.842383
	DD	0bf57dc7fr			; -0.843208
	DD	0bf581279r			; -0.844032
	DD	0bf584853r			; -0.844854
	DD	0bf587e0br			; -0.845673
	DD	0bf58b3a1r			; -0.846491
	DD	0bf58e916r			; -0.847307
	DD	0bf591e6ar			; -0.84812
	DD	0bf59539cr			; -0.848932
	DD	0bf5988adr			; -0.849742
	DD	0bf59bd9cr			; -0.850549
	DD	0bf59f26ar			; -0.851355
	DD	0bf5a2716r			; -0.852159
	DD	0bf5a5ba0r			; -0.852961
	DD	0bf5a9009r			; -0.85376
	DD	0bf5ac450r			; -0.854558
	DD	0bf5af875r			; -0.855354
	DD	0bf5b2c79r			; -0.856147
	DD	0bf5b605ar			; -0.856939
	DD	0bf5b941ar			; -0.857729
	DD	0bf5bc7b8r			; -0.858516
	DD	0bf5bfb34r			; -0.859302
	DD	0bf5c2e8er			; -0.860085
	DD	0bf5c61c7r			; -0.860867
	DD	0bf5c94ddr			; -0.861646
	DD	0bf5cc7d1r			; -0.862424
	DD	0bf5cfaa3r			; -0.863199
	DD	0bf5d2d53r			; -0.863973
	DD	0bf5d5fe1r			; -0.864744
	DD	0bf5d924dr			; -0.865514
	DD	0bf5dc497r			; -0.866281
	DD	0bf5df6ber			; -0.867046
	DD	0bf5e28c3r			; -0.867809
	DD	0bf5e5aa6r			; -0.868571
	DD	0bf5e8c67r			; -0.86933
	DD	0bf5ebe05r			; -0.870087
	DD	0bf5eef81r			; -0.870842
	DD	0bf5f20dbr			; -0.871595
	DD	0bf5f5212r			; -0.872346
	DD	0bf5f8327r			; -0.873095
	DD	0bf5fb419r			; -0.873842
	DD	0bf5fe4e9r			; -0.874587
	DD	0bf601596r			; -0.875329
	DD	0bf604621r			; -0.87607
	DD	0bf607689r			; -0.876809
	DD	0bf60a6cfr			; -0.877545
	DD	0bf60d6f2r			; -0.87828
	DD	0bf6106f2r			; -0.879012
	DD	0bf6136d0r			; -0.879743
	DD	0bf61668ar			; -0.880471
	DD	0bf619622r			; -0.881197
	DD	0bf61c598r			; -0.881921
	DD	0bf61f4ear			; -0.882643
	DD	0bf62241ar			; -0.883363
	DD	0bf625326r			; -0.884081
	DD	0bf628210r			; -0.884797
	DD	0bf62b0d7r			; -0.885511
	DD	0bf62df7br			; -0.886223
	DD	0bf630dfcr			; -0.886932
	DD	0bf633c5ar			; -0.88764
	DD	0bf636a95r			; -0.888345
	DD	0bf6398acr			; -0.889048
	DD	0bf63c6a1r			; -0.88975
	DD	0bf63f473r			; -0.890449
	DD	0bf642221r			; -0.891146
	DD	0bf644facr			; -0.891841
	DD	0bf647d14r			; -0.892534
	DD	0bf64aa59r			; -0.893224
	DD	0bf64d77br			; -0.893913
	DD	0bf650479r			; -0.894599
	DD	0bf653154r			; -0.895284
	DD	0bf655e0br			; -0.895966
	DD	0bf658aa0r			; -0.896646
	DD	0bf65b710r			; -0.897325
	DD	0bf65e35er			; -0.898001
	DD	0bf660f88r			; -0.898674
	DD	0bf663b8er			; -0.899346
	DD	0bf666771r			; -0.900016
	DD	0bf669330r			; -0.900683
	DD	0bf66beccr			; -0.901349
	DD	0bf66ea45r			; -0.902012
	DD	0bf671599r			; -0.902673
	DD	0bf6740car			; -0.903332
	DD	0bf676bd8r			; -0.903989
	DD	0bf6796c1r			; -0.904644
	DD	0bf67c187r			; -0.905297
	DD	0bf67ec29r			; -0.905947
	DD	0bf6816a8r			; -0.906596
	DD	0bf684103r			; -0.907242
	DD	0bf686b39r			; -0.907886
	DD	0bf68954cr			; -0.908528
	DD	0bf68bf3cr			; -0.909168
	DD	0bf68e907r			; -0.909806
	DD	0bf6912aer			; -0.910441
	DD	0bf693c32r			; -0.911075
	DD	0bf696591r			; -0.911706
	DD	0bf698eccr			; -0.912335
	DD	0bf69b7e4r			; -0.912962
	DD	0bf69e0d7r			; -0.913587
	DD	0bf6a09a7r			; -0.91421
	DD	0bf6a3252r			; -0.91483
	DD	0bf6a5ad9r			; -0.915449
	DD	0bf6a833cr			; -0.916065
	DD	0bf6aab7br			; -0.916679
	DD	0bf6ad395r			; -0.917291
	DD	0bf6afb8cr			; -0.917901
	DD	0bf6b235er			; -0.918508
	DD	0bf6b4b0cr			; -0.919114
	DD	0bf6b7295r			; -0.919717
	DD	0bf6b99fbr			; -0.920318
	DD	0bf6bc13br			; -0.920917
	DD	0bf6be858r			; -0.921514
	DD	0bf6c0f50r			; -0.922109
	DD	0bf6c3624r			; -0.922701
	DD	0bf6c5cd4r			; -0.923291
	DD	0bf6c835er			; -0.92388
	DD	0bf6ca9c5r			; -0.924465
	DD	0bf6cd007r			; -0.925049
	DD	0bf6cf624r			; -0.925631
	DD	0bf6d1c1dr			; -0.92621
	DD	0bf6d41f2r			; -0.926787
	DD	0bf6d67a1r			; -0.927363
	DD	0bf6d8d2dr			; -0.927935
	DD	0bf6db293r			; -0.928506
	DD	0bf6dd7d5r			; -0.929075
	DD	0bf6dfcf2r			; -0.929641
	DD	0bf6e21ebr			; -0.930205
	DD	0bf6e46ber			; -0.930767
	DD	0bf6e6b6dr			; -0.931327
	DD	0bf6e8ff8r			; -0.931884
	DD	0bf6eb45dr			; -0.93244
	DD	0bf6ed89er			; -0.932993
	DD	0bf6efcbar			; -0.933544
	DD	0bf6f20b0r			; -0.934093
	DD	0bf6f4483r			; -0.934639
	DD	0bf6f6830r			; -0.935184
	DD	0bf6f8bb8r			; -0.935726
	DD	0bf6faf1br			; -0.936266
	DD	0bf6fd25ar			; -0.936803
	DD	0bf6ff573r			; -0.937339
	DD	0bf701867r			; -0.937872
	DD	0bf703b37r			; -0.938404
	DD	0bf705de1r			; -0.938932
	DD	0bf708066r			; -0.939459
	DD	0bf70a2c6r			; -0.939984
	DD	0bf70c501r			; -0.940506
	DD	0bf70e717r			; -0.941026
	DD	0bf710908r			; -0.941544
	DD	0bf712ad4r			; -0.94206
	DD	0bf714c7ar			; -0.942573
	DD	0bf716dfbr			; -0.943084
	DD	0bf718f57r			; -0.943593
	DD	0bf71b08er			; -0.9441
	DD	0bf71d19fr			; -0.944605
	DD	0bf71f28cr			; -0.945107
	DD	0bf721352r			; -0.945607
	DD	0bf7233f4r			; -0.946105
	DD	0bf725470r			; -0.946601
	DD	0bf7274c7r			; -0.947094
	DD	0bf7294f8r			; -0.947586
	DD	0bf72b504r			; -0.948075
	DD	0bf72d4ebr			; -0.948561
	DD	0bf72f4acr			; -0.949046
	DD	0bf731447r			; -0.949528
	DD	0bf7333ber			; -0.950008
	DD	0bf73530er			; -0.950486
	DD	0bf737239r			; -0.950962
	DD	0bf73913fr			; -0.951435
	DD	0bf73b01fr			; -0.951906
	DD	0bf73ced9r			; -0.952375
	DD	0bf73ed6er			; -0.952842
	DD	0bf740bddr			; -0.953306
	DD	0bf742a27r			; -0.953768
	DD	0bf74484br			; -0.954228
	DD	0bf746649r			; -0.954686
	DD	0bf748422r			; -0.955141
	DD	0bf74a1d5r			; -0.955594
	DD	0bf74bf62r			; -0.956045
	DD	0bf74dcc9r			; -0.956494
	DD	0bf74fa0br			; -0.95694
	DD	0bf751727r			; -0.957385
	DD	0bf75341dr			; -0.957826
	DD	0bf7550edr			; -0.958266
	DD	0bf756d97r			; -0.958703
	DD	0bf758a1cr			; -0.959139
	DD	0bf75a67br			; -0.959572
	DD	0bf75c2b3r			; -0.960002
	DD	0bf75dec6r			; -0.960431
	DD	0bf75fab3r			; -0.960857
	DD	0bf76167ar			; -0.96128
	DD	0bf76321br			; -0.961702
	DD	0bf764d97r			; -0.962121
	DD	0bf7668ecr			; -0.962538
	DD	0bf76841br			; -0.962953
	DD	0bf769f24r			; -0.963366
	DD	0bf76ba07r			; -0.963776
	DD	0bf76d4c4r			; -0.964184
	DD	0bf76ef5br			; -0.96459
	DD	0bf7709ccr			; -0.964993
	DD	0bf772417r			; -0.965394
	DD	0bf773e3cr			; -0.965793
	DD	0bf77583ar			; -0.96619
	DD	0bf777213r			; -0.966584
	DD	0bf778bc5r			; -0.966976
	DD	0bf77a551r			; -0.967366
	DD	0bf77beb7r			; -0.967754
	DD	0bf77d7f7r			; -0.968139
	DD	0bf77f110r			; -0.968522
	DD	0bf780a04r			; -0.968903
	DD	0bf7822d1r			; -0.969281
	DD	0bf783b77r			; -0.969657
	DD	0bf7853f8r			; -0.970031
	DD	0bf786c52r			; -0.970403
	DD	0bf788486r			; -0.970772
	DD	0bf789c93r			; -0.971139
	DD	0bf78b47br			; -0.971504
	DD	0bf78cc3br			; -0.971866
	DD	0bf78e3d6r			; -0.972227
	DD	0bf78fb4ar			; -0.972584
	DD	0bf791298r			; -0.97294
	DD	0bf7929bfr			; -0.973293
	DD	0bf7940c0r			; -0.973644
	DD	0bf79579ar			; -0.973993
	DD	0bf796e4er			; -0.974339
	DD	0bf7984dcr			; -0.974684
	DD	0bf799b43r			; -0.975025
	DD	0bf79b183r			; -0.975365
	DD	0bf79c79dr			; -0.975702
	DD	0bf79dd91r			; -0.976037
	DD	0bf79f35er			; -0.97637
	DD	0bf7a0904r			; -0.9767
	DD	0bf7a1e84r			; -0.977028
	DD	0bf7a33ddr			; -0.977354
	DD	0bf7a4910r			; -0.977677
	DD	0bf7a5e1cr			; -0.977998
	DD	0bf7a7302r			; -0.978317
	DD	0bf7a87c1r			; -0.978634
	DD	0bf7a9c59r			; -0.978948
	DD	0bf7ab0cbr			; -0.97926
	DD	0bf7ac516r			; -0.97957
	DD	0bf7ad93ar			; -0.979877
	DD	0bf7aed37r			; -0.980182
	DD	0bf7b010er			; -0.980485
	DD	0bf7b14ber			; -0.980785
	DD	0bf7b2848r			; -0.981083
	DD	0bf7b3babr			; -0.981379
	DD	0bf7b4ee7r			; -0.981673
	DD	0bf7b61fcr			; -0.981964
	DD	0bf7b74ear			; -0.982253
	DD	0bf7b87b2r			; -0.982539
	DD	0bf7b9a53r			; -0.982824
	DD	0bf7baccdr			; -0.983105
	DD	0bf7bbf20r			; -0.983385
	DD	0bf7bd14dr			; -0.983662
	DD	0bf7be353r			; -0.983937
	DD	0bf7bf531r			; -0.98421
	DD	0bf7c06e9r			; -0.98448
	DD	0bf7c187ar			; -0.984748
	DD	0bf7c29e5r			; -0.985014
	DD	0bf7c3b28r			; -0.985278
	DD	0bf7c4c44r			; -0.985539
	DD	0bf7c5d3ar			; -0.985798
	DD	0bf7c6e08r			; -0.986054
	DD	0bf7c7eb0r			; -0.986308
	DD	0bf7c8f31r			; -0.98656
	DD	0bf7c9f8ar			; -0.986809
	DD	0bf7cafbdr			; -0.987057
	DD	0bf7cbfc9r			; -0.987301
	DD	0bf7ccfaer			; -0.987544
	DD	0bf7cdf6cr			; -0.987784
	DD	0bf7cef03r			; -0.988022
	DD	0bf7cfe73r			; -0.988258
	DD	0bf7d0dbcr			; -0.988491
	DD	0bf7d1cddr			; -0.988722
	DD	0bf7d2bd8r			; -0.98895
	DD	0bf7d3aacr			; -0.989177
	DD	0bf7d4959r			; -0.9894
	DD	0bf7d57der			; -0.989622
	DD	0bf7d663dr			; -0.989841
	DD	0bf7d7474r			; -0.990058
	DD	0bf7d8285r			; -0.990273
	DD	0bf7d906er			; -0.990485
	DD	0bf7d9e30r			; -0.990695
	DD	0bf7dabccr			; -0.990903
	DD	0bf7db940r			; -0.991108
	DD	0bf7dc68cr			; -0.991311
	DD	0bf7dd3b2r			; -0.991511
	DD	0bf7de0b1r			; -0.99171
	DD	0bf7ded88r			; -0.991906
	DD	0bf7dfa38r			; -0.992099
	DD	0bf7e06c2r			; -0.992291
	DD	0bf7e1324r			; -0.99248
	DD	0bf7e1f5er			; -0.992666
	DD	0bf7e2b72r			; -0.99285
	DD	0bf7e375er			; -0.993032
	DD	0bf7e4323r			; -0.993212
	DD	0bf7e4ec1r			; -0.993389
	DD	0bf7e5a38r			; -0.993564
	DD	0bf7e6588r			; -0.993737
	DD	0bf7e70b0r			; -0.993907
	DD	0bf7e7bb1r			; -0.994075
	DD	0bf7e868br			; -0.99424
	DD	0bf7e913dr			; -0.994404
	DD	0bf7e9bc9r			; -0.994565
	DD	0bf7ea62dr			; -0.994723
	DD	0bf7eb069r			; -0.994879
	DD	0bf7eba7fr			; -0.995033
	DD	0bf7ec46dr			; -0.995185
	DD	0bf7ece34r			; -0.995334
	DD	0bf7ed7d4r			; -0.995481
	DD	0bf7ee14cr			; -0.995625
	DD	0bf7eea9dr			; -0.995767
	DD	0bf7ef3c7r			; -0.995907
	DD	0bf7efcc9r			; -0.996045
	DD	0bf7f05a4r			; -0.99618
	DD	0bf7f0e58r			; -0.996313
	DD	0bf7f16e4r			; -0.996443
	DD	0bf7f1f49r			; -0.996571
	DD	0bf7f2787r			; -0.996697
	DD	0bf7f2f9dr			; -0.99682
	DD	0bf7f378cr			; -0.996941
	DD	0bf7f3f54r			; -0.99706
	DD	0bf7f46f4r			; -0.997176
	DD	0bf7f4e6dr			; -0.99729
	DD	0bf7f55bfr			; -0.997402
	DD	0bf7f5ce9r			; -0.997511
	DD	0bf7f63ecr			; -0.997618
	DD	0bf7f6ac7r			; -0.997723
	DD	0bf7f717br			; -0.997825
	DD	0bf7f7808r			; -0.997925
	DD	0bf7f7e6dr			; -0.998023
	DD	0bf7f84abr			; -0.998118
	DD	0bf7f8ac2r			; -0.998211
	DD	0bf7f90b1r			; -0.998302
	DD	0bf7f9678r			; -0.99839
	DD	0bf7f9c18r			; -0.998476
	DD	0bf7fa191r			; -0.998559
	DD	0bf7fa6e3r			; -0.99864
	DD	0bf7fac0dr			; -0.998719
	DD	0bf7fb10fr			; -0.998795
	DD	0bf7fb5ear			; -0.99887
	DD	0bf7fba9er			; -0.998941
	DD	0bf7fbf2ar			; -0.999011
	DD	0bf7fc38fr			; -0.999078
	DD	0bf7fc7ccr			; -0.999142
	DD	0bf7fcbe2r			; -0.999205
	DD	0bf7fcfd1r			; -0.999265
	DD	0bf7fd397r			; -0.999322
	DD	0bf7fd737r			; -0.999378
	DD	0bf7fdaafr			; -0.999431
	DD	0bf7fde00r			; -0.999481
	DD	0bf7fe129r			; -0.999529
	DD	0bf7fe42br			; -0.999575
	DD	0bf7fe705r			; -0.999619
	DD	0bf7fe9b8r			; -0.99966
	DD	0bf7fec43r			; -0.999699
	DD	0bf7feea7r			; -0.999735
	DD	0bf7ff0e3r			; -0.999769
	DD	0bf7ff2f8r			; -0.999801
	DD	0bf7ff4e6r			; -0.999831
	DD	0bf7ff6acr			; -0.999858
	DD	0bf7ff84ar			; -0.999882
	DD	0bf7ff9c1r			; -0.999905
	DD	0bf7ffb11r			; -0.999925
	DD	0bf7ffc39r			; -0.999942
	DD	0bf7ffd39r			; -0.999958
	DD	0bf7ffe13r			; -0.999971
	DD	0bf7ffec4r			; -0.999981
	DD	0bf7fff4er			; -0.999989
	DD	0bf7fffb1r			; -0.999995
	DD	0bf7fffecr			; -0.999999
	DD	0bf800000r			; -1
	DD	0bf7fffecr			; -0.999999
	DD	0bf7fffb1r			; -0.999995
	DD	0bf7fff4er			; -0.999989
	DD	0bf7ffec4r			; -0.999981
	DD	0bf7ffe13r			; -0.999971
	DD	0bf7ffd39r			; -0.999958
	DD	0bf7ffc39r			; -0.999942
	DD	0bf7ffb11r			; -0.999925
	DD	0bf7ff9c1r			; -0.999905
	DD	0bf7ff84ar			; -0.999882
	DD	0bf7ff6acr			; -0.999858
	DD	0bf7ff4e6r			; -0.999831
	DD	0bf7ff2f8r			; -0.999801
	DD	0bf7ff0e3r			; -0.999769
	DD	0bf7feea7r			; -0.999735
	DD	0bf7fec43r			; -0.999699
	DD	0bf7fe9b8r			; -0.99966
	DD	0bf7fe705r			; -0.999619
	DD	0bf7fe42br			; -0.999575
	DD	0bf7fe129r			; -0.999529
	DD	0bf7fde00r			; -0.999481
	DD	0bf7fdaafr			; -0.999431
	DD	0bf7fd737r			; -0.999378
	DD	0bf7fd397r			; -0.999322
	DD	0bf7fcfd1r			; -0.999265
	DD	0bf7fcbe2r			; -0.999205
	DD	0bf7fc7ccr			; -0.999142
	DD	0bf7fc38fr			; -0.999078
	DD	0bf7fbf2ar			; -0.999011
	DD	0bf7fba9er			; -0.998941
	DD	0bf7fb5ear			; -0.99887
	DD	0bf7fb10fr			; -0.998795
	DD	0bf7fac0dr			; -0.998719
	DD	0bf7fa6e3r			; -0.99864
	DD	0bf7fa191r			; -0.998559
	DD	0bf7f9c18r			; -0.998476
	DD	0bf7f9678r			; -0.99839
	DD	0bf7f90b1r			; -0.998302
	DD	0bf7f8ac2r			; -0.998211
	DD	0bf7f84abr			; -0.998118
	DD	0bf7f7e6dr			; -0.998023
	DD	0bf7f7808r			; -0.997925
	DD	0bf7f717br			; -0.997825
	DD	0bf7f6ac7r			; -0.997723
	DD	0bf7f63ecr			; -0.997618
	DD	0bf7f5ce9r			; -0.997511
	DD	0bf7f55bfr			; -0.997402
	DD	0bf7f4e6dr			; -0.99729
	DD	0bf7f46f4r			; -0.997176
	DD	0bf7f3f54r			; -0.99706
	DD	0bf7f378cr			; -0.996941
	DD	0bf7f2f9dr			; -0.99682
	DD	0bf7f2787r			; -0.996697
	DD	0bf7f1f49r			; -0.996571
	DD	0bf7f16e4r			; -0.996443
	DD	0bf7f0e58r			; -0.996313
	DD	0bf7f05a4r			; -0.99618
	DD	0bf7efcc9r			; -0.996045
	DD	0bf7ef3c7r			; -0.995907
	DD	0bf7eea9dr			; -0.995767
	DD	0bf7ee14cr			; -0.995625
	DD	0bf7ed7d4r			; -0.995481
	DD	0bf7ece34r			; -0.995334
	DD	0bf7ec46dr			; -0.995185
	DD	0bf7eba7fr			; -0.995033
	DD	0bf7eb069r			; -0.994879
	DD	0bf7ea62dr			; -0.994723
	DD	0bf7e9bc9r			; -0.994565
	DD	0bf7e913dr			; -0.994404
	DD	0bf7e868br			; -0.99424
	DD	0bf7e7bb1r			; -0.994075
	DD	0bf7e70b0r			; -0.993907
	DD	0bf7e6588r			; -0.993737
	DD	0bf7e5a38r			; -0.993564
	DD	0bf7e4ec1r			; -0.993389
	DD	0bf7e4323r			; -0.993212
	DD	0bf7e375er			; -0.993032
	DD	0bf7e2b72r			; -0.99285
	DD	0bf7e1f5er			; -0.992666
	DD	0bf7e1324r			; -0.99248
	DD	0bf7e06c2r			; -0.992291
	DD	0bf7dfa38r			; -0.992099
	DD	0bf7ded88r			; -0.991906
	DD	0bf7de0b1r			; -0.99171
	DD	0bf7dd3b2r			; -0.991511
	DD	0bf7dc68cr			; -0.991311
	DD	0bf7db940r			; -0.991108
	DD	0bf7dabccr			; -0.990903
	DD	0bf7d9e30r			; -0.990695
	DD	0bf7d906er			; -0.990485
	DD	0bf7d8285r			; -0.990273
	DD	0bf7d7474r			; -0.990058
	DD	0bf7d663dr			; -0.989841
	DD	0bf7d57der			; -0.989622
	DD	0bf7d4959r			; -0.9894
	DD	0bf7d3aacr			; -0.989177
	DD	0bf7d2bd8r			; -0.98895
	DD	0bf7d1cddr			; -0.988722
	DD	0bf7d0dbcr			; -0.988491
	DD	0bf7cfe73r			; -0.988258
	DD	0bf7cef03r			; -0.988022
	DD	0bf7cdf6cr			; -0.987784
	DD	0bf7ccfaer			; -0.987544
	DD	0bf7cbfc9r			; -0.987301
	DD	0bf7cafbdr			; -0.987057
	DD	0bf7c9f8ar			; -0.986809
	DD	0bf7c8f31r			; -0.98656
	DD	0bf7c7eb0r			; -0.986308
	DD	0bf7c6e08r			; -0.986054
	DD	0bf7c5d3ar			; -0.985798
	DD	0bf7c4c44r			; -0.985539
	DD	0bf7c3b28r			; -0.985278
	DD	0bf7c29e5r			; -0.985014
	DD	0bf7c187ar			; -0.984748
	DD	0bf7c06e9r			; -0.98448
	DD	0bf7bf531r			; -0.98421
	DD	0bf7be353r			; -0.983937
	DD	0bf7bd14dr			; -0.983662
	DD	0bf7bbf20r			; -0.983385
	DD	0bf7baccdr			; -0.983105
	DD	0bf7b9a53r			; -0.982824
	DD	0bf7b87b2r			; -0.982539
	DD	0bf7b74ear			; -0.982253
	DD	0bf7b61fcr			; -0.981964
	DD	0bf7b4ee7r			; -0.981673
	DD	0bf7b3babr			; -0.981379
	DD	0bf7b2848r			; -0.981083
	DD	0bf7b14ber			; -0.980785
	DD	0bf7b010er			; -0.980485
	DD	0bf7aed37r			; -0.980182
	DD	0bf7ad93ar			; -0.979877
	DD	0bf7ac516r			; -0.97957
	DD	0bf7ab0cbr			; -0.97926
	DD	0bf7a9c59r			; -0.978948
	DD	0bf7a87c1r			; -0.978634
	DD	0bf7a7302r			; -0.978317
	DD	0bf7a5e1cr			; -0.977998
	DD	0bf7a4910r			; -0.977677
	DD	0bf7a33ddr			; -0.977354
	DD	0bf7a1e84r			; -0.977028
	DD	0bf7a0904r			; -0.9767
	DD	0bf79f35er			; -0.97637
	DD	0bf79dd91r			; -0.976037
	DD	0bf79c79dr			; -0.975702
	DD	0bf79b183r			; -0.975365
	DD	0bf799b43r			; -0.975025
	DD	0bf7984dcr			; -0.974684
	DD	0bf796e4er			; -0.974339
	DD	0bf79579ar			; -0.973993
	DD	0bf7940c0r			; -0.973644
	DD	0bf7929bfr			; -0.973293
	DD	0bf791298r			; -0.97294
	DD	0bf78fb4ar			; -0.972584
	DD	0bf78e3d6r			; -0.972227
	DD	0bf78cc3br			; -0.971866
	DD	0bf78b47br			; -0.971504
	DD	0bf789c93r			; -0.971139
	DD	0bf788486r			; -0.970772
	DD	0bf786c52r			; -0.970403
	DD	0bf7853f8r			; -0.970031
	DD	0bf783b77r			; -0.969657
	DD	0bf7822d1r			; -0.969281
	DD	0bf780a04r			; -0.968903
	DD	0bf77f110r			; -0.968522
	DD	0bf77d7f7r			; -0.968139
	DD	0bf77beb7r			; -0.967754
	DD	0bf77a551r			; -0.967366
	DD	0bf778bc5r			; -0.966976
	DD	0bf777213r			; -0.966584
	DD	0bf77583ar			; -0.96619
	DD	0bf773e3cr			; -0.965793
	DD	0bf772417r			; -0.965394
	DD	0bf7709ccr			; -0.964993
	DD	0bf76ef5br			; -0.96459
	DD	0bf76d4c4r			; -0.964184
	DD	0bf76ba07r			; -0.963776
	DD	0bf769f24r			; -0.963366
	DD	0bf76841br			; -0.962953
	DD	0bf7668ecr			; -0.962538
	DD	0bf764d97r			; -0.962121
	DD	0bf76321br			; -0.961702
	DD	0bf76167ar			; -0.96128
	DD	0bf75fab3r			; -0.960857
	DD	0bf75dec6r			; -0.960431
	DD	0bf75c2b3r			; -0.960002
	DD	0bf75a67br			; -0.959572
	DD	0bf758a1cr			; -0.959139
	DD	0bf756d97r			; -0.958703
	DD	0bf7550edr			; -0.958266
	DD	0bf75341dr			; -0.957826
	DD	0bf751727r			; -0.957385
	DD	0bf74fa0br			; -0.95694
	DD	0bf74dcc9r			; -0.956494
	DD	0bf74bf62r			; -0.956045
	DD	0bf74a1d5r			; -0.955594
	DD	0bf748422r			; -0.955141
	DD	0bf746649r			; -0.954686
	DD	0bf74484br			; -0.954228
	DD	0bf742a27r			; -0.953768
	DD	0bf740bddr			; -0.953306
	DD	0bf73ed6er			; -0.952842
	DD	0bf73ced9r			; -0.952375
	DD	0bf73b01fr			; -0.951906
	DD	0bf73913fr			; -0.951435
	DD	0bf737239r			; -0.950962
	DD	0bf73530er			; -0.950486
	DD	0bf7333ber			; -0.950008
	DD	0bf731447r			; -0.949528
	DD	0bf72f4acr			; -0.949046
	DD	0bf72d4ebr			; -0.948561
	DD	0bf72b504r			; -0.948075
	DD	0bf7294f8r			; -0.947586
	DD	0bf7274c7r			; -0.947094
	DD	0bf725470r			; -0.946601
	DD	0bf7233f4r			; -0.946105
	DD	0bf721352r			; -0.945607
	DD	0bf71f28cr			; -0.945107
	DD	0bf71d19fr			; -0.944605
	DD	0bf71b08er			; -0.9441
	DD	0bf718f57r			; -0.943593
	DD	0bf716dfbr			; -0.943084
	DD	0bf714c7ar			; -0.942573
	DD	0bf712ad4r			; -0.94206
	DD	0bf710908r			; -0.941544
	DD	0bf70e717r			; -0.941026
	DD	0bf70c501r			; -0.940506
	DD	0bf70a2c6r			; -0.939984
	DD	0bf708066r			; -0.939459
	DD	0bf705de1r			; -0.938932
	DD	0bf703b37r			; -0.938404
	DD	0bf701867r			; -0.937872
	DD	0bf6ff573r			; -0.937339
	DD	0bf6fd25ar			; -0.936803
	DD	0bf6faf1br			; -0.936266
	DD	0bf6f8bb8r			; -0.935726
	DD	0bf6f6830r			; -0.935184
	DD	0bf6f4483r			; -0.934639
	DD	0bf6f20b0r			; -0.934093
	DD	0bf6efcbar			; -0.933544
	DD	0bf6ed89er			; -0.932993
	DD	0bf6eb45dr			; -0.93244
	DD	0bf6e8ff8r			; -0.931884
	DD	0bf6e6b6dr			; -0.931327
	DD	0bf6e46ber			; -0.930767
	DD	0bf6e21ebr			; -0.930205
	DD	0bf6dfcf2r			; -0.929641
	DD	0bf6dd7d5r			; -0.929075
	DD	0bf6db293r			; -0.928506
	DD	0bf6d8d2dr			; -0.927935
	DD	0bf6d67a1r			; -0.927363
	DD	0bf6d41f2r			; -0.926787
	DD	0bf6d1c1dr			; -0.92621
	DD	0bf6cf624r			; -0.925631
	DD	0bf6cd007r			; -0.925049
	DD	0bf6ca9c5r			; -0.924465
	DD	0bf6c835er			; -0.92388
	DD	0bf6c5cd4r			; -0.923291
	DD	0bf6c3624r			; -0.922701
	DD	0bf6c0f50r			; -0.922109
	DD	0bf6be858r			; -0.921514
	DD	0bf6bc13br			; -0.920917
	DD	0bf6b99fbr			; -0.920318
	DD	0bf6b7295r			; -0.919717
	DD	0bf6b4b0cr			; -0.919114
	DD	0bf6b235er			; -0.918508
	DD	0bf6afb8cr			; -0.917901
	DD	0bf6ad395r			; -0.917291
	DD	0bf6aab7br			; -0.916679
	DD	0bf6a833cr			; -0.916065
	DD	0bf6a5ad9r			; -0.915449
	DD	0bf6a3252r			; -0.91483
	DD	0bf6a09a7r			; -0.91421
	DD	0bf69e0d7r			; -0.913587
	DD	0bf69b7e4r			; -0.912962
	DD	0bf698eccr			; -0.912335
	DD	0bf696591r			; -0.911706
	DD	0bf693c32r			; -0.911075
	DD	0bf6912aer			; -0.910441
	DD	0bf68e907r			; -0.909806
	DD	0bf68bf3cr			; -0.909168
	DD	0bf68954cr			; -0.908528
	DD	0bf686b39r			; -0.907886
	DD	0bf684103r			; -0.907242
	DD	0bf6816a8r			; -0.906596
	DD	0bf67ec29r			; -0.905947
	DD	0bf67c187r			; -0.905297
	DD	0bf6796c1r			; -0.904644
	DD	0bf676bd8r			; -0.903989
	DD	0bf6740car			; -0.903332
	DD	0bf671599r			; -0.902673
	DD	0bf66ea45r			; -0.902012
	DD	0bf66beccr			; -0.901349
	DD	0bf669330r			; -0.900683
	DD	0bf666771r			; -0.900016
	DD	0bf663b8er			; -0.899346
	DD	0bf660f88r			; -0.898674
	DD	0bf65e35er			; -0.898001
	DD	0bf65b710r			; -0.897325
	DD	0bf658aa0r			; -0.896646
	DD	0bf655e0br			; -0.895966
	DD	0bf653154r			; -0.895284
	DD	0bf650479r			; -0.894599
	DD	0bf64d77br			; -0.893913
	DD	0bf64aa59r			; -0.893224
	DD	0bf647d14r			; -0.892534
	DD	0bf644facr			; -0.891841
	DD	0bf642221r			; -0.891146
	DD	0bf63f473r			; -0.890449
	DD	0bf63c6a1r			; -0.88975
	DD	0bf6398acr			; -0.889048
	DD	0bf636a95r			; -0.888345
	DD	0bf633c5ar			; -0.88764
	DD	0bf630dfcr			; -0.886932
	DD	0bf62df7br			; -0.886223
	DD	0bf62b0d7r			; -0.885511
	DD	0bf628210r			; -0.884797
	DD	0bf625326r			; -0.884081
	DD	0bf62241ar			; -0.883363
	DD	0bf61f4ear			; -0.882643
	DD	0bf61c598r			; -0.881921
	DD	0bf619622r			; -0.881197
	DD	0bf61668ar			; -0.880471
	DD	0bf6136d0r			; -0.879743
	DD	0bf6106f2r			; -0.879012
	DD	0bf60d6f2r			; -0.87828
	DD	0bf60a6cfr			; -0.877545
	DD	0bf607689r			; -0.876809
	DD	0bf604621r			; -0.87607
	DD	0bf601596r			; -0.875329
	DD	0bf5fe4e9r			; -0.874587
	DD	0bf5fb419r			; -0.873842
	DD	0bf5f8327r			; -0.873095
	DD	0bf5f5212r			; -0.872346
	DD	0bf5f20dbr			; -0.871595
	DD	0bf5eef81r			; -0.870842
	DD	0bf5ebe05r			; -0.870087
	DD	0bf5e8c67r			; -0.86933
	DD	0bf5e5aa6r			; -0.868571
	DD	0bf5e28c3r			; -0.867809
	DD	0bf5df6ber			; -0.867046
	DD	0bf5dc497r			; -0.866281
	DD	0bf5d924dr			; -0.865514
	DD	0bf5d5fe1r			; -0.864744
	DD	0bf5d2d53r			; -0.863973
	DD	0bf5cfaa3r			; -0.863199
	DD	0bf5cc7d1r			; -0.862424
	DD	0bf5c94ddr			; -0.861646
	DD	0bf5c61c7r			; -0.860867
	DD	0bf5c2e8er			; -0.860085
	DD	0bf5bfb34r			; -0.859302
	DD	0bf5bc7b8r			; -0.858516
	DD	0bf5b941ar			; -0.857729
	DD	0bf5b605ar			; -0.856939
	DD	0bf5b2c79r			; -0.856147
	DD	0bf5af875r			; -0.855354
	DD	0bf5ac450r			; -0.854558
	DD	0bf5a9009r			; -0.85376
	DD	0bf5a5ba0r			; -0.852961
	DD	0bf5a2716r			; -0.852159
	DD	0bf59f26ar			; -0.851355
	DD	0bf59bd9cr			; -0.850549
	DD	0bf5988adr			; -0.849742
	DD	0bf59539cr			; -0.848932
	DD	0bf591e6ar			; -0.84812
	DD	0bf58e916r			; -0.847307
	DD	0bf58b3a1r			; -0.846491
	DD	0bf587e0br			; -0.845673
	DD	0bf584853r			; -0.844854
	DD	0bf581279r			; -0.844032
	DD	0bf57dc7fr			; -0.843208
	DD	0bf57a663r			; -0.842383
	DD	0bf577026r			; -0.841555
	DD	0bf5739c7r			; -0.840725
	DD	0bf570348r			; -0.839894
	DD	0bf56cca7r			; -0.83906
	DD	0bf5695e5r			; -0.838225
	DD	0bf565f02r			; -0.837387
	DD	0bf5627fer			; -0.836548
	DD	0bf55f0d9r			; -0.835706
	DD	0bf55b993r			; -0.834863
	DD	0bf55822cr			; -0.834018
	DD	0bf554aa4r			; -0.83317
	DD	0bf5512fbr			; -0.832321
	DD	0bf54db31r			; -0.83147
	DD	0bf54a347r			; -0.830616
	DD	0bf546b3br			; -0.829761
	DD	0bf54330fr			; -0.828904
	DD	0bf53fac3r			; -0.828045
	DD	0bf53c255r			; -0.827184
	DD	0bf5389c7r			; -0.826321
	DD	0bf535118r			; -0.825456
	DD	0bf531849r			; -0.824589
	DD	0bf52df59r			; -0.823721
	DD	0bf52a649r			; -0.82285
	DD	0bf526d18r			; -0.821977
	DD	0bf5233c6r			; -0.821102
	DD	0bf51fa54r			; -0.820226
	DD	0bf51c0c2r			; -0.819348
	DD	0bf518710r			; -0.818467
	DD	0bf514d3dr			; -0.817585
	DD	0bf51134ar			; -0.816701
	DD	0bf50d937r			; -0.815814
	DD	0bf509f03r			; -0.814926
	DD	0bf5064afr			; -0.814036
	DD	0bf502a3br			; -0.813144
	DD	0bf4fefa8r			; -0.812251
	DD	0bf4fb4f4r			; -0.811355
	DD	0bf4f7a1fr			; -0.810457
	DD	0bf4f3f2br			; -0.809558
	DD	0bf4f0417r			; -0.808656
	DD	0bf4ec8e4r			; -0.807753
	DD	0bf4e8d90r			; -0.806848
	DD	0bf4e521cr			; -0.80594
	DD	0bf4e1689r			; -0.805031
	DD	0bf4ddad5r			; -0.80412
	DD	0bf4d9f02r			; -0.803208
	DD	0bf4d6310r			; -0.802293
	DD	0bf4d26fdr			; -0.801376
	DD	0bf4ceacbr			; -0.800458
	DD	0bf4cae79r			; -0.799537
	DD	0bf4c7208r			; -0.798615
	DD	0bf4c3578r			; -0.797691
	DD	0bf4bf8c7r			; -0.796765
	DD	0bf4bbbf8r			; -0.795837
	DD	0bf4b7f09r			; -0.794907
	DD	0bf4b41far			; -0.793975
	DD	0bf4b04ccr			; -0.793042
	DD	0bf4ac77fr			; -0.792107
	DD	0bf4a8a13r			; -0.791169
	DD	0bf4a4c87r			; -0.79023
	DD	0bf4a0edcr			; -0.789289
	DD	0bf49d112r			; -0.788346
	DD	0bf499329r			; -0.787402
	DD	0bf495521r			; -0.786455
	DD	0bf4916far			; -0.785507
	DD	0bf48d8b3r			; -0.784557
	DD	0bf489a4er			; -0.783605
	DD	0bf485bcar			; -0.782651
	DD	0bf481d27r			; -0.781695
	DD	0bf47de65r			; -0.780737
	DD	0bf479f84r			; -0.779778
	DD	0bf476085r			; -0.778817
	DD	0bf472167r			; -0.777853
	DD	0bf46e22ar			; -0.776888
	DD	0bf46a2cer			; -0.775922
	DD	0bf466354r			; -0.774953
	DD	0bf4623bbr			; -0.773983
	DD	0bf45e403r			; -0.77301
	DD	0bf45a42dr			; -0.772036
	DD	0bf456439r			; -0.771061
	DD	0bf452426r			; -0.770083
	DD	0bf44e3f5r			; -0.769103
	DD	0bf44a3a5r			; -0.768122
	DD	0bf446337r			; -0.767139
	DD	0bf4422abr			; -0.766154
	DD	0bf43e200r			; -0.765167
	DD	0bf43a138r			; -0.764179
	DD	0bf436051r			; -0.763188
	DD	0bf431f4cr			; -0.762196
	DD	0bf42de29r			; -0.761202
	DD	0bf429ce8r			; -0.760207
	DD	0bf425b89r			; -0.759209
	DD	0bf421a0br			; -0.75821
	DD	0bf41d870r			; -0.757209
	DD	0bf4196b7r			; -0.756206
	DD	0bf4154e1r			; -0.755201
	DD	0bf4112ecr			; -0.754195
	DD	0bf40d0dar			; -0.753187
	DD	0bf408ea9r			; -0.752177
	DD	0bf404c5cr			; -0.751165
	DD	0bf4009f0r			; -0.750152
	DD	0bf3fc767r			; -0.749136
	DD	0bf3f84c0r			; -0.748119
	DD	0bf3f41fcr			; -0.747101
	DD	0bf3eff1br			; -0.74608
	DD	0bf3ebc1br			; -0.745058
	DD	0bf3e78ffr			; -0.744034
	DD	0bf3e35c5r			; -0.743008
	DD	0bf3df26er			; -0.74198
	DD	0bf3daef9r			; -0.740951
	DD	0bf3d6b67r			; -0.73992
	DD	0bf3d27b8r			; -0.738887
	DD	0bf3ce3ecr			; -0.737853
	DD	0bf3ca003r			; -0.736817
	DD	0bf3c5bfcr			; -0.735779
	DD	0bf3c17d9r			; -0.734739
	DD	0bf3bd398r			; -0.733697
	DD	0bf3b8f3br			; -0.732654
	DD	0bf3b4ac1r			; -0.731609
	DD	0bf3b0629r			; -0.730563
	DD	0bf3ac175r			; -0.729514
	DD	0bf3a7ca4r			; -0.728464
	DD	0bf3a37b7r			; -0.727413
	DD	0bf39f2acr			; -0.726359
	DD	0bf39ad85r			; -0.725304
	DD	0bf396842r			; -0.724247
	DD	0bf3922e1r			; -0.723188
	DD	0bf38dd65r			; -0.722128
	DD	0bf3897cbr			; -0.721066
	DD	0bf385216r			; -0.720003
	DD	0bf380c43r			; -0.718937
	DD	0bf37c655r			; -0.71787
	DD	0bf37804ar			; -0.716801
	DD	0bf373a23r			; -0.715731
	DD	0bf36f3dfr			; -0.714659
	DD	0bf36ad7fr			; -0.713585
	DD	0bf366704r			; -0.712509
	DD	0bf36206cr			; -0.711432
	DD	0bf35d9b8r			; -0.710353
	DD	0bf3592e7r			; -0.709273
	DD	0bf354bfbr			; -0.708191
	DD	0bf3504f3r			; -0.707107
	DD	0bf34bdcfr			; -0.706021
	DD	0bf34768fr			; -0.704934
	DD	0bf342f34r			; -0.703845
	DD	0bf33e7bcr			; -0.702755
	DD	0bf33a029r			; -0.701663
	DD	0bf33587ar			; -0.700569
	DD	0bf3310afr			; -0.699473
	DD	0bf32c8c9r			; -0.698376
	DD	0bf3280c7r			; -0.697277
	DD	0bf3238aar			; -0.696177
	DD	0bf31f071r			; -0.695075
	DD	0bf31a81dr			; -0.693971
	DD	0bf315fadr			; -0.692866
	DD	0bf311722r			; -0.691759
	DD	0bf30ce7cr			; -0.690651
	DD	0bf3085bbr			; -0.689541
	DD	0bf303cder			; -0.688429
	DD	0bf2ff3e6r			; -0.687315
	DD	0bf2faad3r			; -0.6862
	DD	0bf2f61a5r			; -0.685084
	DD	0bf2f185br			; -0.683965
	DD	0bf2ecef7r			; -0.682846
	DD	0bf2e8578r			; -0.681724
	DD	0bf2e3bder			; -0.680601
	DD	0bf2df229r			; -0.679476
	DD	0bf2da859r			; -0.67835
	DD	0bf2d5e6fr			; -0.677222
	DD	0bf2d1469r			; -0.676093
	DD	0bf2cca49r			; -0.674962
	DD	0bf2c800fr			; -0.673829
	DD	0bf2c35b9r			; -0.672695
	DD	0bf2beb4ar			; -0.671559
	DD	0bf2ba0bfr			; -0.670422
	DD	0bf2b561br			; -0.669283
	DD	0bf2b0b5br			; -0.668142
	DD	0bf2ac082r			; -0.667
	DD	0bf2a758er			; -0.665856
	DD	0bf2a2a80r			; -0.664711
	DD	0bf29df57r			; -0.663564
	DD	0bf299415r			; -0.662416
	DD	0bf2948b8r			; -0.661266
	DD	0bf28fd41r			; -0.660114
	DD	0bf28b1b0r			; -0.658961
	DD	0bf286605r			; -0.657807
	DD	0bf281a40r			; -0.656651
	DD	0bf27ce61r			; -0.655493
	DD	0bf278268r			; -0.654334
	DD	0bf273656r			; -0.653173
	DD	0bf26ea2ar			; -0.652011
	DD	0bf269de3r			; -0.650847
	DD	0bf265184r			; -0.649681
	DD	0bf26050ar			; -0.648514
	DD	0bf25b877r			; -0.647346
	DD	0bf256bcbr			; -0.646176
	DD	0bf251f04r			; -0.645005
	DD	0bf24d225r			; -0.643832
	DD	0bf24852cr			; -0.642657
	DD	0bf24381ar			; -0.641481
	DD	0bf23eaeer			; -0.640303
	DD	0bf239da9r			; -0.639124
	DD	0bf23504br			; -0.637944
	DD	0bf2302d3r			; -0.636762
	DD	0bf22b543r			; -0.635578
	DD	0bf226799r			; -0.634393
	DD	0bf2219d7r			; -0.633207
	DD	0bf21cbfbr			; -0.632019
	DD	0bf217e06r			; -0.630829
	DD	0bf212ff9r			; -0.629638
	DD	0bf20e1d2r			; -0.628446
	DD	0bf209393r			; -0.627252
	DD	0bf20453br			; -0.626056
	DD	0bf1ff6cbr			; -0.62486
	DD	0bf1fa841r			; -0.623661
	DD	0bf1f599fr			; -0.622461
	DD	0bf1f0ae5r			; -0.62126
	DD	0bf1ebc12r			; -0.620057
	DD	0bf1e6d26r			; -0.618853
	DD	0bf1e1e22r			; -0.617647
	DD	0bf1dcf06r			; -0.61644
	DD	0bf1d7fd1r			; -0.615232
	DD	0bf1d3084r			; -0.614022
	DD	0bf1ce11fr			; -0.61281
	DD	0bf1c91a2r			; -0.611597
	DD	0bf1c420cr			; -0.610383
	DD	0bf1bf25fr			; -0.609167
	DD	0bf1ba299r			; -0.60795
	DD	0bf1b52bbr			; -0.606731
	DD	0bf1b02c6r			; -0.605511
	DD	0bf1ab2b8r			; -0.60429
	DD	0bf1a6293r			; -0.603067
	DD	0bf1a1255r			; -0.601842
	DD	0bf19c200r			; -0.600616
	DD	0bf197194r			; -0.599389
	DD	0bf19210fr			; -0.598161
	DD	0bf18d073r			; -0.596931
	DD	0bf187fc0r			; -0.595699
	DD	0bf182ef5r			; -0.594467
	DD	0bf17de12r			; -0.593232
	DD	0bf178d18r			; -0.591997
	DD	0bf173c07r			; -0.59076
	DD	0bf16eader			; -0.589521
	DD	0bf16999fr			; -0.588282
	DD	0bf164847r			; -0.58704
	DD	0bf15f6d9r			; -0.585798
	DD	0bf15a554r			; -0.584554
	DD	0bf1553b7r			; -0.583309
	DD	0bf150204r			; -0.582062
	DD	0bf14b039r			; -0.580814
	DD	0bf145e58r			; -0.579565
	DD	0bf140c5fr			; -0.578314
	DD	0bf13ba50r			; -0.577062
	DD	0bf13682ar			; -0.575808
	DD	0bf1315eer			; -0.574553
	DD	0bf12c39ar			; -0.573297
	DD	0bf127130r			; -0.57204
	DD	0bf121eb0r			; -0.570781
	DD	0bf11cc19r			; -0.569521
	DD	0bf11796br			; -0.568259
	DD	0bf1126a7r			; -0.566996
	DD	0bf10d3cdr			; -0.565732
	DD	0bf1080dcr			; -0.564466
	DD	0bf102dd5r			; -0.563199
	DD	0bf0fdab8r			; -0.561931
	DD	0bf0f8784r			; -0.560662
	DD	0bf0f343br			; -0.559391
	DD	0bf0ee0dbr			; -0.558119
	DD	0bf0e8d65r			; -0.556845
	DD	0bf0e39dar			; -0.55557
	DD	0bf0de638r			; -0.554294
	DD	0bf0d9281r			; -0.553017
	DD	0bf0d3eb3r			; -0.551738
	DD	0bf0cead0r			; -0.550458
	DD	0bf0c96d7r			; -0.549177
	DD	0bf0c42c9r			; -0.547894
	DD	0bf0beea5r			; -0.54661
	DD	0bf0b9a6br			; -0.545325
	DD	0bf0b461cr			; -0.544039
	DD	0bf0af1b7r			; -0.542751
	DD	0bf0a9d3dr			; -0.541462
	DD	0bf0a48adr			; -0.540171
	DD	0bf09f409r			; -0.53888
	DD	0bf099f4er			; -0.537587
	DD	0bf094a7fr			; -0.536293
	DD	0bf08f59br			; -0.534998
	DD	0bf08a0a1r			; -0.533701
	DD	0bf084b92r			; -0.532403
	DD	0bf07f66fr			; -0.531104
	DD	0bf07a136r			; -0.529804
	DD	0bf074be8r			; -0.528502
	DD	0bf06f686r			; -0.527199
	DD	0bf06a10er			; -0.525895
	DD	0bf064b82r			; -0.52459
	DD	0bf05f5e2r			; -0.523283
	DD	0bf05a02cr			; -0.521975
	DD	0bf054a62r			; -0.520666
	DD	0bf04f484r			; -0.519356
	DD	0bf049e91r			; -0.518045
	DD	0bf044889r			; -0.516732
	DD	0bf03f26dr			; -0.515418
	DD	0bf039c3dr			; -0.514103
	DD	0bf0345f8r			; -0.512786
	DD	0bf02ef9fr			; -0.511469
	DD	0bf029932r			; -0.51015
	DD	0bf0242b1r			; -0.50883
	DD	0bf01ec1cr			; -0.507509
	DD	0bf019573r			; -0.506187
	DD	0bf013eb5r			; -0.504863
	DD	0bf00e7e4r			; -0.503538
	DD	0bf0090ffr			; -0.502212
	DD	0bf003a06r			; -0.500885
	DD	0beffc5f3r			; -0.499557
	DD	0beff17b2r			; -0.498228
	DD	0befe694ar			; -0.496897
	DD	0befdbabbr			; -0.495565
	DD	0befd0c04r			; -0.494232
	DD	0befc5d27r			; -0.492898
	DD	0befbae22r			; -0.491563
	DD	0befafef7r			; -0.490226
	DD	0befa4fa5r			; -0.488889
	DD	0bef9a02dr			; -0.48755
	DD	0bef8f08er			; -0.48621
	DD	0bef840c8r			; -0.484869
	DD	0bef790dcr			; -0.483527
	DD	0bef6e0cbr			; -0.482184
	DD	0bef63093r			; -0.480839
	DD	0bef58035r			; -0.479494
	DD	0bef4cfb1r			; -0.478147
	DD	0bef41f07r			; -0.476799
	DD	0bef36e38r			; -0.47545
	DD	0bef2bd43r			; -0.4741
	DD	0bef20c29r			; -0.472749
	DD	0bef15aear			; -0.471397
	DD	0bef0a985r			; -0.470043
	DD	0beeff7fbr			; -0.468689
	DD	0beef464cr			; -0.467333
	DD	0beee9479r			; -0.465977
	DD	0beede280r			; -0.464619
	DD	0beed3063r			; -0.46326
	DD	0beec7e21r			; -0.4619
	DD	0beebcbbbr			; -0.460539
	DD	0beeb1930r			; -0.459177
	DD	0beea6681r			; -0.457813
	DD	0bee9b3aer			; -0.456449
	DD	0bee900b7r			; -0.455084
	DD	0bee84d9cr			; -0.453717
	DD	0bee79a5dr			; -0.45235
	DD	0bee6e6fbr			; -0.450981
	DD	0bee63375r			; -0.449611
	DD	0bee57fcbr			; -0.448241
	DD	0bee4cbfer			; -0.446869
	DD	0bee4180er			; -0.445496
	DD	0bee363far			; -0.444122
	DD	0bee2afc4r			; -0.442747
	DD	0bee1fb6ar			; -0.441371
	DD	0bee146eer			; -0.439994
	DD	0bee0924fr			; -0.438616
	DD	0bedfdd8dr			; -0.437237
	DD	0bedf28a9r			; -0.435857
	DD	0bede73a2r			; -0.434476
	DD	0beddbe79r			; -0.433094
	DD	0bedd092er			; -0.431711
	DD	0bedc53c1r			; -0.430326
	DD	0bedb9e31r			; -0.428941
	DD	0bedae880r			; -0.427555
	DD	0beda32adr			; -0.426168
	DD	0bed97cb9r			; -0.42478
	DD	0bed8c6a3r			; -0.42339
	DD	0bed8106br			; -0.422
	DD	0bed75a13r			; -0.420609
	DD	0bed6a399r			; -0.419217
	DD	0bed5ecfdr			; -0.417824
	DD	0bed53641r			; -0.41643
	DD	0bed47f64r			; -0.415034
	DD	0bed3c867r			; -0.413638
	DD	0bed31148r			; -0.412241
	DD	0bed25a09r			; -0.410843
	DD	0bed1a2aar			; -0.409444
	DD	0bed0eb2ar			; -0.408044
	DD	0bed0338ar			; -0.406643
	DD	0becf7bcar			; -0.405241
	DD	0becec3ear			; -0.403838
	DD	0bece0bear			; -0.402435
	DD	0becd53car			; -0.40103
	DD	0becc9b8br			; -0.399624
	DD	0becbe32cr			; -0.398218
	DD	0becb2aaer			; -0.39681
	DD	0beca7210r			; -0.395401
	DD	0bec9b953r			; -0.393992
	DD	0bec90077r			; -0.392582
	DD	0bec8477cr			; -0.39117
	DD	0bec78e62r			; -0.389758
	DD	0bec6d529r			; -0.388345
	DD	0bec61bd2r			; -0.386931
	DD	0bec5625cr			; -0.385516
	DD	0bec4a8c8r			; -0.3841
	DD	0bec3ef15r			; -0.382683
	DD	0bec33544r			; -0.381266
	DD	0bec27b55r			; -0.379847
	DD	0bec1c148r			; -0.378428
	DD	0bec1071er			; -0.377007
	DD	0bec04cd5r			; -0.375586
	DD	0bebf926fr			; -0.374164
	DD	0bebed7ebr			; -0.372741
	DD	0bebe1d4ar			; -0.371317
	DD	0bebd628br			; -0.369892
	DD	0bebca7afr			; -0.368467
	DD	0bebbecb6r			; -0.36704
	DD	0bebb31a0r			; -0.365613
	DD	0beba766er			; -0.364185
	DD	0beb9bb1er			; -0.362756
	DD	0beb8ffb2r			; -0.361326
	DD	0beb8442ar			; -0.359895
	DD	0beb78884r			; -0.358463
	DD	0beb6ccc3r			; -0.357031
	DD	0beb610e6r			; -0.355598
	DD	0beb554ecr			; -0.354164
	DD	0beb498d6r			; -0.352729
	DD	0beb3dca5r			; -0.351293
	DD	0beb32058r			; -0.349856
	DD	0beb263efr			; -0.348419
	DD	0beb1a76br			; -0.34698
	DD	0beb0eacbr			; -0.345541
	DD	0beb02e10r			; -0.344101
	DD	0beaf713ar			; -0.342661
	DD	0beaeb449r			; -0.341219
	DD	0beadf73cr			; -0.339777
	DD	0bead3a15r			; -0.338334
	DD	0beac7cd4r			; -0.33689
	DD	0beabbf77r			; -0.335445
	DD	0beab0201r			; -0.334
	DD	0beaa446fr			; -0.332553
	DD	0bea986c4r			; -0.331106
	DD	0bea8c8fer			; -0.329658
	DD	0bea80b1fr			; -0.32821
	DD	0bea74d25r			; -0.32676
	DD	0bea68f12r			; -0.32531
	DD	0bea5d0e5r			; -0.323859
	DD	0bea5129fr			; -0.322408
	DD	0bea4543fr			; -0.320955
	DD	0bea395c5r			; -0.319502
	DD	0bea2d733r			; -0.318048
	DD	0bea21887r			; -0.316593
	DD	0bea159c2r			; -0.315138
	DD	0bea09ae5r			; -0.313682
	DD	0be9fdbeer			; -0.312225
	DD	0be9f1cdfr			; -0.310767
	DD	0be9e5db8r			; -0.309309
	DD	0be9d9e78r			; -0.30785
	DD	0be9cdf20r			; -0.30639
	DD	0be9c1fafr			; -0.304929
	DD	0be9b6027r			; -0.303468
	DD	0be9aa086r			; -0.302006
	DD	0be99e0cer			; -0.300543
	DD	0be9920fer			; -0.29908
	DD	0be986116r			; -0.297616
	DD	0be97a117r			; -0.296151
	DD	0be96e100r			; -0.294685
	DD	0be9620d2r			; -0.293219
	DD	0be95608dr			; -0.291752
	DD	0be94a031r			; -0.290285
	DD	0be93dfbfr			; -0.288816
	DD	0be931f35r			; -0.287347
	DD	0be925e94r			; -0.285878
	DD	0be919dddr			; -0.284408
	DD	0be90dd10r			; -0.282937
	DD	0be901c2cr			; -0.281465
	DD	0be8f5b32r			; -0.279993
	DD	0be8e9a22r			; -0.27852
	DD	0be8dd8fcr			; -0.277046
	DD	0be8d17c0r			; -0.275572
	DD	0be8c566er			; -0.274097
	DD	0be8b9507r			; -0.272621
	DD	0be8ad38ar			; -0.271145
	DD	0be8a11f7r			; -0.269668
	DD	0be895050r			; -0.268191
	DD	0be888e93r			; -0.266713
	DD	0be87ccc1r			; -0.265234
	DD	0be870adar			; -0.263755
	DD	0be8648dfr			; -0.262275
	DD	0be8586cer			; -0.260794
	DD	0be84c4aar			; -0.259313
	DD	0be840270r			; -0.257831
	DD	0be834022r			; -0.256349
	DD	0be827dc0r			; -0.254866
	DD	0be81bb4ar			; -0.253382
	DD	0be80f8c0r			; -0.251898
	DD	0be803622r			; -0.250413
	DD	0be7ee6e1r			; -0.248928
	DD	0be7d6156r			; -0.247442
	DD	0be7bdba4r			; -0.245955
	DD	0be7a55cbr			; -0.244468
	DD	0be78cfccr			; -0.24298
	DD	0be7749a6r			; -0.241492
	DD	0be75c35ar			; -0.240003
	DD	0be743ce8r			; -0.238514
	DD	0be72b651r			; -0.237024
	DD	0be712f94r			; -0.235533
	DD	0be6fa8b2r			; -0.234042
	DD	0be6e21abr			; -0.23255
	DD	0be6c9a7fr			; -0.231058
	DD	0be6b132fr			; -0.229565
	DD	0be698bbar			; -0.228072
	DD	0be680422r			; -0.226578
	DD	0be667c66r			; -0.225084
	DD	0be64f486r			; -0.223589
	DD	0be636c83r			; -0.222094
	DD	0be61e45cr			; -0.220598
	DD	0be605c13r			; -0.219101
	DD	0be5ed3a8r			; -0.217604
	DD	0be5d4b1ar			; -0.216107
	DD	0be5bc26ar			; -0.214609
	DD	0be5a3997r			; -0.21311
	DD	0be58b0a4r			; -0.211611
	DD	0be57278fr			; -0.210112
	DD	0be559e58r			; -0.208612
	DD	0be541501r			; -0.207111
	DD	0be528b89r			; -0.20561
	DD	0be5101f1r			; -0.204109
	DD	0be4f7838r			; -0.202607
	DD	0be4dee60r			; -0.201105
	DD	0be4c6467r			; -0.199602
	DD	0be4ada4fr			; -0.198098
	DD	0be495018r			; -0.196595
	DD	0be47c5c2r			; -0.19509
	DD	0be463b4dr			; -0.193586
	DD	0be44b0b9r			; -0.19208
	DD	0be432607r			; -0.190575
	DD	0be419b37r			; -0.189069
	DD	0be401049r			; -0.187562
	DD	0be3e853er			; -0.186055
	DD	0be3cfa15r			; -0.184548
	DD	0be3b6ecfr			; -0.18304
	DD	0be39e36cr			; -0.181532
	DD	0be3857ecr			; -0.180023
	DD	0be36cc50r			; -0.178514
	DD	0be354098r			; -0.177004
	DD	0be33b4c4r			; -0.175494
	DD	0be3228d4r			; -0.173984
	DD	0be309cc9r			; -0.172473
	DD	0be2f10a2r			; -0.170962
	DD	0be2d8461r			; -0.16945
	DD	0be2bf804r			; -0.167938
	DD	0be2a6b8dr			; -0.166426
	DD	0be28defcr			; -0.164913
	DD	0be275251r			; -0.1634
	DD	0be25c58cr			; -0.161886
	DD	0be2438adr			; -0.160372
	DD	0be22abb6r			; -0.158858
	DD	0be211ea5r			; -0.157343
	DD	0be1f917br			; -0.155828
	DD	0be1e0438r			; -0.154313
	DD	0be1c76der			; -0.152797
	DD	0be1ae96br			; -0.151281
	DD	0be195be0r			; -0.149765
	DD	0be17ce3dr			; -0.148248
	DD	0be164083r			; -0.14673
	DD	0be14b2b2r			; -0.145213
	DD	0be1324car			; -0.143695
	DD	0be1196ccr			; -0.142177
	DD	0be1008b7r			; -0.140658
	DD	0be0e7a8br			; -0.139139
	DD	0be0cec4ar			; -0.13762
	DD	0be0b5df3r			; -0.136101
	DD	0be09cf86r			; -0.134581
	DD	0be084105r			; -0.133061
	DD	0be06b26er			; -0.13154
	DD	0be0523c2r			; -0.130019
	DD	0be039502r			; -0.128498
	DD	0be02062er			; -0.126977
	DD	0be007745r			; -0.125455
	DD	0bdfdd092r			; -0.123933
	DD	0bdfab273r			; -0.122411
	DD	0bdf7942cr			; -0.120888
	DD	0bdf475c0r			; -0.119365
	DD	0bdf1572er			; -0.117842
	DD	0bdee3876r			; -0.116319
	DD	0bdeb199ar			; -0.114795
	DD	0bde7fa9ar			; -0.113271
	DD	0bde4db76r			; -0.111747
	DD	0bde1bc2er			; -0.110222
	DD	0bdde9cc4r			; -0.108697
	DD	0bddb7d37r			; -0.107172
	DD	0bdd85d89r			; -0.105647
	DD	0bdd53db9r			; -0.104122
	DD	0bdd21dc8r			; -0.102596
	DD	0bdcefdb7r			; -0.10107
	DD	0bdcbdd86r			; -0.0995436
	DD	0bdc8bd36r			; -0.0980171
	DD	0bdc59cc6r			; -0.0964904
	DD	0bdc27c39r			; -0.0949635
	DD	0bdbf5b8dr			; -0.0934363
	DD	0bdbc3ac3r			; -0.091909
	DD	0bdb919ddr			; -0.0903814
	DD	0bdb5f8dar			; -0.0888536
	DD	0bdb2d7bbr			; -0.0873255
	DD	0bdafb680r			; -0.0857973
	DD	0bdac952br			; -0.0842689
	DD	0bda973bar			; -0.0827403
	DD	0bda65230r			; -0.0812114
	DD	0bda3308cr			; -0.0796824
	DD	0bda00ecfr			; -0.0781532
	DD	0bd9cecf9r			; -0.0766239
	DD	0bd99cb0ar			; -0.0750943
	DD	0bd96a905r			; -0.0735646
	DD	0bd9386e7r			; -0.0720346
	DD	0bd9064b4r			; -0.0705046
	DD	0bd8d426ar			; -0.0689743
	DD	0bd8a200ar			; -0.0674439
	DD	0bd86fd94r			; -0.0659133
	DD	0bd83db0ar			; -0.0643826
	DD	0bd80b86cr			; -0.0628518
	DD	0bd7b2b74r			; -0.0613207
	DD	0bd74e5e9r			; -0.0597896
	DD	0bd6ea038r			; -0.0582583
	DD	0bd685a62r			; -0.0567268
	DD	0bd621469r			; -0.0551952
	DD	0bd5bce4cr			; -0.0536635
	DD	0bd55880er			; -0.0521317
	DD	0bd4f41afr			; -0.0505998
	DD	0bd48fb30r			; -0.0490677
	DD	0bd42b491r			; -0.0475355
	DD	0bd3c6dd5r			; -0.0460032
	DD	0bd3626fcr			; -0.0444708
	DD	0bd2fe007r			; -0.0429383
	DD	0bd2998f6r			; -0.0414056
	DD	0bd2351cbr			; -0.0398729
	DD	0bd1d0a88r			; -0.0383401
	DD	0bd16c32cr			; -0.0368072
	DD	0bd107bb8r			; -0.0352742
	DD	0bd0a342fr			; -0.0337412
	DD	0bd03ec90r			; -0.032208
	DD	0bcfb49bar			; -0.0306748
	DD	0bceeba2cr			; -0.0291415
	DD	0bce22a7ar			; -0.0276081
	DD	0bcd59aa6r			; -0.0260747
	DD	0bcc90ab0r			; -0.0245412
	DD	0bcbc7a9br			; -0.0230077
	DD	0bcafea69r			; -0.0214741
	DD	0bca35a1cr			; -0.0199404
	DD	0bc96c9b6r			; -0.0184067
	DD	0bc8a3938r			; -0.016873
	DD	0bc7b514br			; -0.0153392
	DD	0bc622fffr			; -0.0138054
	DD	0bc490e90r			; -0.0122715
	DD	0bc2fed02r			; -0.0107377
	DD	0bc16cb58r			; -0.00920375
	DD	0bbfb5330r			; -0.00766983
	DD	0bbc90f88r			; -0.00613588
	DD	0bb96cbc1r			; -0.00460193
	DD	0bb490fc6r			; -0.00306796
	DD	0bac90fd5r			; -0.00153398
	DD	0a553c800r			; -1.83691e-16
	DD	03ac90fd5r			; 0.00153398
	DD	03b490fc6r			; 0.00306796
	DD	03b96cbc1r			; 0.00460193
	DD	03bc90f88r			; 0.00613588
	DD	03bfb5330r			; 0.00766983
	DD	03c16cb58r			; 0.00920375
	DD	03c2fed02r			; 0.0107377
	DD	03c490e90r			; 0.0122715
	DD	03c622fffr			; 0.0138054
	DD	03c7b514br			; 0.0153392
	DD	03c8a3938r			; 0.016873
	DD	03c96c9b6r			; 0.0184067
	DD	03ca35a1cr			; 0.0199404
	DD	03cafea69r			; 0.0214741
	DD	03cbc7a9br			; 0.0230077
	DD	03cc90ab0r			; 0.0245412
	DD	03cd59aa6r			; 0.0260747
	DD	03ce22a7ar			; 0.0276081
	DD	03ceeba2cr			; 0.0291415
	DD	03cfb49bar			; 0.0306748
	DD	03d03ec90r			; 0.032208
	DD	03d0a342fr			; 0.0337412
	DD	03d107bb8r			; 0.0352742
	DD	03d16c32cr			; 0.0368072
	DD	03d1d0a88r			; 0.0383401
	DD	03d2351cbr			; 0.0398729
	DD	03d2998f6r			; 0.0414056
	DD	03d2fe007r			; 0.0429383
	DD	03d3626fcr			; 0.0444708
	DD	03d3c6dd5r			; 0.0460032
	DD	03d42b491r			; 0.0475355
	DD	03d48fb30r			; 0.0490677
	DD	03d4f41afr			; 0.0505998
	DD	03d55880er			; 0.0521317
	DD	03d5bce4cr			; 0.0536635
	DD	03d621469r			; 0.0551952
	DD	03d685a62r			; 0.0567268
	DD	03d6ea038r			; 0.0582583
	DD	03d74e5e9r			; 0.0597896
	DD	03d7b2b74r			; 0.0613207
	DD	03d80b86cr			; 0.0628518
	DD	03d83db0ar			; 0.0643826
	DD	03d86fd94r			; 0.0659133
	DD	03d8a200ar			; 0.0674439
	DD	03d8d426ar			; 0.0689743
	DD	03d9064b4r			; 0.0705046
	DD	03d9386e7r			; 0.0720346
	DD	03d96a905r			; 0.0735646
	DD	03d99cb0ar			; 0.0750943
	DD	03d9cecf9r			; 0.0766239
	DD	03da00ecfr			; 0.0781532
	DD	03da3308cr			; 0.0796824
	DD	03da65230r			; 0.0812114
	DD	03da973bar			; 0.0827403
	DD	03dac952br			; 0.0842689
	DD	03dafb680r			; 0.0857973
	DD	03db2d7bbr			; 0.0873255
	DD	03db5f8dar			; 0.0888536
	DD	03db919ddr			; 0.0903814
	DD	03dbc3ac3r			; 0.091909
	DD	03dbf5b8dr			; 0.0934363
	DD	03dc27c39r			; 0.0949635
	DD	03dc59cc6r			; 0.0964904
	DD	03dc8bd36r			; 0.0980171
	DD	03dcbdd86r			; 0.0995436
	DD	03dcefdb7r			; 0.10107
	DD	03dd21dc8r			; 0.102596
	DD	03dd53db9r			; 0.104122
	DD	03dd85d89r			; 0.105647
	DD	03ddb7d37r			; 0.107172
	DD	03dde9cc4r			; 0.108697
	DD	03de1bc2er			; 0.110222
	DD	03de4db76r			; 0.111747
	DD	03de7fa9ar			; 0.113271
	DD	03deb199ar			; 0.114795
	DD	03dee3876r			; 0.116319
	DD	03df1572er			; 0.117842
	DD	03df475c0r			; 0.119365
	DD	03df7942cr			; 0.120888
	DD	03dfab273r			; 0.122411
	DD	03dfdd092r			; 0.123933
	DD	03e007745r			; 0.125455
	DD	03e02062er			; 0.126977
	DD	03e039502r			; 0.128498
	DD	03e0523c2r			; 0.130019
	DD	03e06b26er			; 0.13154
	DD	03e084105r			; 0.133061
	DD	03e09cf86r			; 0.134581
	DD	03e0b5df3r			; 0.136101
	DD	03e0cec4ar			; 0.13762
	DD	03e0e7a8br			; 0.139139
	DD	03e1008b7r			; 0.140658
	DD	03e1196ccr			; 0.142177
	DD	03e1324car			; 0.143695
	DD	03e14b2b2r			; 0.145213
	DD	03e164083r			; 0.14673
	DD	03e17ce3dr			; 0.148248
	DD	03e195be0r			; 0.149765
	DD	03e1ae96br			; 0.151281
	DD	03e1c76der			; 0.152797
	DD	03e1e0438r			; 0.154313
	DD	03e1f917br			; 0.155828
	DD	03e211ea5r			; 0.157343
	DD	03e22abb6r			; 0.158858
	DD	03e2438adr			; 0.160372
	DD	03e25c58cr			; 0.161886
	DD	03e275251r			; 0.1634
	DD	03e28defcr			; 0.164913
	DD	03e2a6b8dr			; 0.166426
	DD	03e2bf804r			; 0.167938
	DD	03e2d8461r			; 0.16945
	DD	03e2f10a2r			; 0.170962
	DD	03e309cc9r			; 0.172473
	DD	03e3228d4r			; 0.173984
	DD	03e33b4c4r			; 0.175494
	DD	03e354098r			; 0.177004
	DD	03e36cc50r			; 0.178514
	DD	03e3857ecr			; 0.180023
	DD	03e39e36cr			; 0.181532
	DD	03e3b6ecfr			; 0.18304
	DD	03e3cfa15r			; 0.184548
	DD	03e3e853er			; 0.186055
	DD	03e401049r			; 0.187562
	DD	03e419b37r			; 0.189069
	DD	03e432607r			; 0.190575
	DD	03e44b0b9r			; 0.19208
	DD	03e463b4dr			; 0.193586
	DD	03e47c5c2r			; 0.19509
	DD	03e495018r			; 0.196595
	DD	03e4ada4fr			; 0.198098
	DD	03e4c6467r			; 0.199602
	DD	03e4dee60r			; 0.201105
	DD	03e4f7838r			; 0.202607
	DD	03e5101f1r			; 0.204109
	DD	03e528b89r			; 0.20561
	DD	03e541501r			; 0.207111
	DD	03e559e58r			; 0.208612
	DD	03e57278fr			; 0.210112
	DD	03e58b0a4r			; 0.211611
	DD	03e5a3997r			; 0.21311
	DD	03e5bc26ar			; 0.214609
	DD	03e5d4b1ar			; 0.216107
	DD	03e5ed3a8r			; 0.217604
	DD	03e605c13r			; 0.219101
	DD	03e61e45cr			; 0.220598
	DD	03e636c83r			; 0.222094
	DD	03e64f486r			; 0.223589
	DD	03e667c66r			; 0.225084
	DD	03e680422r			; 0.226578
	DD	03e698bbar			; 0.228072
	DD	03e6b132fr			; 0.229565
	DD	03e6c9a7fr			; 0.231058
	DD	03e6e21abr			; 0.23255
	DD	03e6fa8b2r			; 0.234042
	DD	03e712f94r			; 0.235533
	DD	03e72b651r			; 0.237024
	DD	03e743ce8r			; 0.238514
	DD	03e75c35ar			; 0.240003
	DD	03e7749a6r			; 0.241492
	DD	03e78cfccr			; 0.24298
	DD	03e7a55cbr			; 0.244468
	DD	03e7bdba4r			; 0.245955
	DD	03e7d6156r			; 0.247442
	DD	03e7ee6e1r			; 0.248928
	DD	03e803622r			; 0.250413
	DD	03e80f8c0r			; 0.251898
	DD	03e81bb4ar			; 0.253382
	DD	03e827dc0r			; 0.254866
	DD	03e834022r			; 0.256349
	DD	03e840270r			; 0.257831
	DD	03e84c4aar			; 0.259313
	DD	03e8586cer			; 0.260794
	DD	03e8648dfr			; 0.262275
	DD	03e870adar			; 0.263755
	DD	03e87ccc1r			; 0.265234
	DD	03e888e93r			; 0.266713
	DD	03e895050r			; 0.268191
	DD	03e8a11f7r			; 0.269668
	DD	03e8ad38ar			; 0.271145
	DD	03e8b9507r			; 0.272621
	DD	03e8c566er			; 0.274097
	DD	03e8d17c0r			; 0.275572
	DD	03e8dd8fcr			; 0.277046
	DD	03e8e9a22r			; 0.27852
	DD	03e8f5b32r			; 0.279993
	DD	03e901c2cr			; 0.281465
	DD	03e90dd10r			; 0.282937
	DD	03e919dddr			; 0.284408
	DD	03e925e94r			; 0.285878
	DD	03e931f35r			; 0.287347
	DD	03e93dfbfr			; 0.288816
	DD	03e94a031r			; 0.290285
	DD	03e95608dr			; 0.291752
	DD	03e9620d2r			; 0.293219
	DD	03e96e100r			; 0.294685
	DD	03e97a117r			; 0.296151
	DD	03e986116r			; 0.297616
	DD	03e9920fer			; 0.29908
	DD	03e99e0cer			; 0.300543
	DD	03e9aa086r			; 0.302006
	DD	03e9b6027r			; 0.303468
	DD	03e9c1fafr			; 0.304929
	DD	03e9cdf20r			; 0.30639
	DD	03e9d9e78r			; 0.30785
	DD	03e9e5db8r			; 0.309309
	DD	03e9f1cdfr			; 0.310767
	DD	03e9fdbeer			; 0.312225
	DD	03ea09ae5r			; 0.313682
	DD	03ea159c2r			; 0.315138
	DD	03ea21887r			; 0.316593
	DD	03ea2d733r			; 0.318048
	DD	03ea395c5r			; 0.319502
	DD	03ea4543fr			; 0.320955
	DD	03ea5129fr			; 0.322408
	DD	03ea5d0e5r			; 0.323859
	DD	03ea68f12r			; 0.32531
	DD	03ea74d25r			; 0.32676
	DD	03ea80b1fr			; 0.32821
	DD	03ea8c8fer			; 0.329658
	DD	03ea986c4r			; 0.331106
	DD	03eaa446fr			; 0.332553
	DD	03eab0201r			; 0.334
	DD	03eabbf77r			; 0.335445
	DD	03eac7cd4r			; 0.33689
	DD	03ead3a15r			; 0.338334
	DD	03eadf73cr			; 0.339777
	DD	03eaeb449r			; 0.341219
	DD	03eaf713ar			; 0.342661
	DD	03eb02e10r			; 0.344101
	DD	03eb0eacbr			; 0.345541
	DD	03eb1a76br			; 0.34698
	DD	03eb263efr			; 0.348419
	DD	03eb32058r			; 0.349856
	DD	03eb3dca5r			; 0.351293
	DD	03eb498d6r			; 0.352729
	DD	03eb554ecr			; 0.354164
	DD	03eb610e6r			; 0.355598
	DD	03eb6ccc3r			; 0.357031
	DD	03eb78884r			; 0.358463
	DD	03eb8442ar			; 0.359895
	DD	03eb8ffb2r			; 0.361326
	DD	03eb9bb1er			; 0.362756
	DD	03eba766er			; 0.364185
	DD	03ebb31a0r			; 0.365613
	DD	03ebbecb6r			; 0.36704
	DD	03ebca7afr			; 0.368467
	DD	03ebd628br			; 0.369892
	DD	03ebe1d4ar			; 0.371317
	DD	03ebed7ebr			; 0.372741
	DD	03ebf926fr			; 0.374164
	DD	03ec04cd5r			; 0.375586
	DD	03ec1071er			; 0.377007
	DD	03ec1c148r			; 0.378428
	DD	03ec27b55r			; 0.379847
	DD	03ec33544r			; 0.381266
	DD	03ec3ef15r			; 0.382683
	DD	03ec4a8c8r			; 0.3841
	DD	03ec5625cr			; 0.385516
	DD	03ec61bd2r			; 0.386931
	DD	03ec6d529r			; 0.388345
	DD	03ec78e62r			; 0.389758
	DD	03ec8477cr			; 0.39117
	DD	03ec90077r			; 0.392582
	DD	03ec9b953r			; 0.393992
	DD	03eca7210r			; 0.395401
	DD	03ecb2aaer			; 0.39681
	DD	03ecbe32cr			; 0.398218
	DD	03ecc9b8br			; 0.399624
	DD	03ecd53car			; 0.40103
	DD	03ece0bear			; 0.402435
	DD	03ecec3ear			; 0.403838
	DD	03ecf7bcar			; 0.405241
	DD	03ed0338ar			; 0.406643
	DD	03ed0eb2ar			; 0.408044
	DD	03ed1a2aar			; 0.409444
	DD	03ed25a09r			; 0.410843
	DD	03ed31148r			; 0.412241
	DD	03ed3c867r			; 0.413638
	DD	03ed47f64r			; 0.415034
	DD	03ed53641r			; 0.41643
	DD	03ed5ecfdr			; 0.417824
	DD	03ed6a399r			; 0.419217
	DD	03ed75a13r			; 0.420609
	DD	03ed8106br			; 0.422
	DD	03ed8c6a3r			; 0.42339
	DD	03ed97cb9r			; 0.42478
	DD	03eda32adr			; 0.426168
	DD	03edae880r			; 0.427555
	DD	03edb9e31r			; 0.428941
	DD	03edc53c1r			; 0.430326
	DD	03edd092er			; 0.431711
	DD	03eddbe79r			; 0.433094
	DD	03ede73a2r			; 0.434476
	DD	03edf28a9r			; 0.435857
	DD	03edfdd8dr			; 0.437237
	DD	03ee0924fr			; 0.438616
	DD	03ee146eer			; 0.439994
	DD	03ee1fb6ar			; 0.441371
	DD	03ee2afc4r			; 0.442747
	DD	03ee363far			; 0.444122
	DD	03ee4180er			; 0.445496
	DD	03ee4cbfer			; 0.446869
	DD	03ee57fcbr			; 0.448241
	DD	03ee63375r			; 0.449611
	DD	03ee6e6fbr			; 0.450981
	DD	03ee79a5dr			; 0.45235
	DD	03ee84d9cr			; 0.453717
	DD	03ee900b7r			; 0.455084
	DD	03ee9b3aer			; 0.456449
	DD	03eea6681r			; 0.457813
	DD	03eeb1930r			; 0.459177
	DD	03eebcbbbr			; 0.460539
	DD	03eec7e21r			; 0.4619
	DD	03eed3063r			; 0.46326
	DD	03eede280r			; 0.464619
	DD	03eee9479r			; 0.465977
	DD	03eef464cr			; 0.467333
	DD	03eeff7fbr			; 0.468689
	DD	03ef0a985r			; 0.470043
	DD	03ef15aear			; 0.471397
	DD	03ef20c29r			; 0.472749
	DD	03ef2bd43r			; 0.4741
	DD	03ef36e38r			; 0.47545
	DD	03ef41f07r			; 0.476799
	DD	03ef4cfb1r			; 0.478147
	DD	03ef58035r			; 0.479494
	DD	03ef63093r			; 0.480839
	DD	03ef6e0cbr			; 0.482184
	DD	03ef790dcr			; 0.483527
	DD	03ef840c8r			; 0.484869
	DD	03ef8f08er			; 0.48621
	DD	03ef9a02dr			; 0.48755
	DD	03efa4fa5r			; 0.488889
	DD	03efafef7r			; 0.490226
	DD	03efbae22r			; 0.491563
	DD	03efc5d27r			; 0.492898
	DD	03efd0c04r			; 0.494232
	DD	03efdbabbr			; 0.495565
	DD	03efe694ar			; 0.496897
	DD	03eff17b2r			; 0.498228
	DD	03effc5f3r			; 0.499557
	DD	03f003a06r			; 0.500885
	DD	03f0090ffr			; 0.502212
	DD	03f00e7e4r			; 0.503538
	DD	03f013eb5r			; 0.504863
	DD	03f019573r			; 0.506187
	DD	03f01ec1cr			; 0.507509
	DD	03f0242b1r			; 0.50883
	DD	03f029932r			; 0.51015
	DD	03f02ef9fr			; 0.511469
	DD	03f0345f8r			; 0.512786
	DD	03f039c3dr			; 0.514103
	DD	03f03f26dr			; 0.515418
	DD	03f044889r			; 0.516732
	DD	03f049e91r			; 0.518045
	DD	03f04f484r			; 0.519356
	DD	03f054a62r			; 0.520666
	DD	03f05a02cr			; 0.521975
	DD	03f05f5e2r			; 0.523283
	DD	03f064b82r			; 0.52459
	DD	03f06a10er			; 0.525895
	DD	03f06f686r			; 0.527199
	DD	03f074be8r			; 0.528502
	DD	03f07a136r			; 0.529804
	DD	03f07f66fr			; 0.531104
	DD	03f084b92r			; 0.532403
	DD	03f08a0a1r			; 0.533701
	DD	03f08f59br			; 0.534998
	DD	03f094a7fr			; 0.536293
	DD	03f099f4er			; 0.537587
	DD	03f09f409r			; 0.53888
	DD	03f0a48adr			; 0.540171
	DD	03f0a9d3dr			; 0.541462
	DD	03f0af1b7r			; 0.542751
	DD	03f0b461cr			; 0.544039
	DD	03f0b9a6br			; 0.545325
	DD	03f0beea5r			; 0.54661
	DD	03f0c42c9r			; 0.547894
	DD	03f0c96d7r			; 0.549177
	DD	03f0cead0r			; 0.550458
	DD	03f0d3eb3r			; 0.551738
	DD	03f0d9281r			; 0.553017
	DD	03f0de638r			; 0.554294
	DD	03f0e39dar			; 0.55557
	DD	03f0e8d65r			; 0.556845
	DD	03f0ee0dbr			; 0.558119
	DD	03f0f343br			; 0.559391
	DD	03f0f8784r			; 0.560662
	DD	03f0fdab8r			; 0.561931
	DD	03f102dd5r			; 0.563199
	DD	03f1080dcr			; 0.564466
	DD	03f10d3cdr			; 0.565732
	DD	03f1126a7r			; 0.566996
	DD	03f11796br			; 0.568259
	DD	03f11cc19r			; 0.569521
	DD	03f121eb0r			; 0.570781
	DD	03f127130r			; 0.57204
	DD	03f12c39ar			; 0.573297
	DD	03f1315eer			; 0.574553
	DD	03f13682ar			; 0.575808
	DD	03f13ba50r			; 0.577062
	DD	03f140c5fr			; 0.578314
	DD	03f145e58r			; 0.579565
	DD	03f14b039r			; 0.580814
	DD	03f150204r			; 0.582062
	DD	03f1553b7r			; 0.583309
	DD	03f15a554r			; 0.584554
	DD	03f15f6d9r			; 0.585798
	DD	03f164847r			; 0.58704
	DD	03f16999fr			; 0.588282
	DD	03f16eader			; 0.589521
	DD	03f173c07r			; 0.59076
	DD	03f178d18r			; 0.591997
	DD	03f17de12r			; 0.593232
	DD	03f182ef5r			; 0.594467
	DD	03f187fc0r			; 0.595699
	DD	03f18d073r			; 0.596931
	DD	03f19210fr			; 0.598161
	DD	03f197194r			; 0.599389
	DD	03f19c200r			; 0.600616
	DD	03f1a1255r			; 0.601842
	DD	03f1a6293r			; 0.603067
	DD	03f1ab2b8r			; 0.60429
	DD	03f1b02c6r			; 0.605511
	DD	03f1b52bbr			; 0.606731
	DD	03f1ba299r			; 0.60795
	DD	03f1bf25fr			; 0.609167
	DD	03f1c420cr			; 0.610383
	DD	03f1c91a2r			; 0.611597
	DD	03f1ce11fr			; 0.61281
	DD	03f1d3084r			; 0.614022
	DD	03f1d7fd1r			; 0.615232
	DD	03f1dcf06r			; 0.61644
	DD	03f1e1e22r			; 0.617647
	DD	03f1e6d26r			; 0.618853
	DD	03f1ebc12r			; 0.620057
	DD	03f1f0ae5r			; 0.62126
	DD	03f1f599fr			; 0.622461
	DD	03f1fa841r			; 0.623661
	DD	03f1ff6cbr			; 0.62486
	DD	03f20453br			; 0.626056
	DD	03f209393r			; 0.627252
	DD	03f20e1d2r			; 0.628446
	DD	03f212ff9r			; 0.629638
	DD	03f217e06r			; 0.630829
	DD	03f21cbfbr			; 0.632019
	DD	03f2219d7r			; 0.633207
	DD	03f226799r			; 0.634393
	DD	03f22b543r			; 0.635578
	DD	03f2302d3r			; 0.636762
	DD	03f23504br			; 0.637944
	DD	03f239da9r			; 0.639124
	DD	03f23eaeer			; 0.640303
	DD	03f24381ar			; 0.641481
	DD	03f24852cr			; 0.642657
	DD	03f24d225r			; 0.643832
	DD	03f251f04r			; 0.645005
	DD	03f256bcbr			; 0.646176
	DD	03f25b877r			; 0.647346
	DD	03f26050ar			; 0.648514
	DD	03f265184r			; 0.649681
	DD	03f269de3r			; 0.650847
	DD	03f26ea2ar			; 0.652011
	DD	03f273656r			; 0.653173
	DD	03f278268r			; 0.654334
	DD	03f27ce61r			; 0.655493
	DD	03f281a40r			; 0.656651
	DD	03f286605r			; 0.657807
	DD	03f28b1b0r			; 0.658961
	DD	03f28fd41r			; 0.660114
	DD	03f2948b8r			; 0.661266
	DD	03f299415r			; 0.662416
	DD	03f29df57r			; 0.663564
	DD	03f2a2a80r			; 0.664711
	DD	03f2a758er			; 0.665856
	DD	03f2ac082r			; 0.667
	DD	03f2b0b5br			; 0.668142
	DD	03f2b561br			; 0.669283
	DD	03f2ba0bfr			; 0.670422
	DD	03f2beb4ar			; 0.671559
	DD	03f2c35b9r			; 0.672695
	DD	03f2c800fr			; 0.673829
	DD	03f2cca49r			; 0.674962
	DD	03f2d1469r			; 0.676093
	DD	03f2d5e6fr			; 0.677222
	DD	03f2da859r			; 0.67835
	DD	03f2df229r			; 0.679476
	DD	03f2e3bder			; 0.680601
	DD	03f2e8578r			; 0.681724
	DD	03f2ecef7r			; 0.682846
	DD	03f2f185br			; 0.683965
	DD	03f2f61a5r			; 0.685084
	DD	03f2faad3r			; 0.6862
	DD	03f2ff3e6r			; 0.687315
	DD	03f303cder			; 0.688429
	DD	03f3085bbr			; 0.689541
	DD	03f30ce7cr			; 0.690651
	DD	03f311722r			; 0.691759
	DD	03f315fadr			; 0.692866
	DD	03f31a81dr			; 0.693971
	DD	03f31f071r			; 0.695075
	DD	03f3238aar			; 0.696177
	DD	03f3280c7r			; 0.697277
	DD	03f32c8c9r			; 0.698376
	DD	03f3310afr			; 0.699473
	DD	03f33587ar			; 0.700569
	DD	03f33a029r			; 0.701663
	DD	03f33e7bcr			; 0.702755
	DD	03f342f34r			; 0.703845
	DD	03f34768fr			; 0.704934
	DD	03f34bdcfr			; 0.706021
	DD	03f3504f3r			; 0.707107
	DD	03f354bfbr			; 0.708191
	DD	03f3592e7r			; 0.709273
	DD	03f35d9b8r			; 0.710353
	DD	03f36206cr			; 0.711432
	DD	03f366704r			; 0.712509
	DD	03f36ad7fr			; 0.713585
	DD	03f36f3dfr			; 0.714659
	DD	03f373a23r			; 0.715731
	DD	03f37804ar			; 0.716801
	DD	03f37c655r			; 0.71787
	DD	03f380c43r			; 0.718937
	DD	03f385216r			; 0.720003
	DD	03f3897cbr			; 0.721066
	DD	03f38dd65r			; 0.722128
	DD	03f3922e1r			; 0.723188
	DD	03f396842r			; 0.724247
	DD	03f39ad85r			; 0.725304
	DD	03f39f2acr			; 0.726359
	DD	03f3a37b7r			; 0.727413
	DD	03f3a7ca4r			; 0.728464
	DD	03f3ac175r			; 0.729514
	DD	03f3b0629r			; 0.730563
	DD	03f3b4ac1r			; 0.731609
	DD	03f3b8f3br			; 0.732654
	DD	03f3bd398r			; 0.733697
	DD	03f3c17d9r			; 0.734739
	DD	03f3c5bfcr			; 0.735779
	DD	03f3ca003r			; 0.736817
	DD	03f3ce3ecr			; 0.737853
	DD	03f3d27b8r			; 0.738887
	DD	03f3d6b67r			; 0.73992
	DD	03f3daef9r			; 0.740951
	DD	03f3df26er			; 0.74198
	DD	03f3e35c5r			; 0.743008
	DD	03f3e78ffr			; 0.744034
	DD	03f3ebc1br			; 0.745058
	DD	03f3eff1br			; 0.74608
	DD	03f3f41fcr			; 0.747101
	DD	03f3f84c0r			; 0.748119
	DD	03f3fc767r			; 0.749136
	DD	03f4009f0r			; 0.750152
	DD	03f404c5cr			; 0.751165
	DD	03f408ea9r			; 0.752177
	DD	03f40d0dar			; 0.753187
	DD	03f4112ecr			; 0.754195
	DD	03f4154e1r			; 0.755201
	DD	03f4196b7r			; 0.756206
	DD	03f41d870r			; 0.757209
	DD	03f421a0br			; 0.75821
	DD	03f425b89r			; 0.759209
	DD	03f429ce8r			; 0.760207
	DD	03f42de29r			; 0.761202
	DD	03f431f4cr			; 0.762196
	DD	03f436051r			; 0.763188
	DD	03f43a138r			; 0.764179
	DD	03f43e200r			; 0.765167
	DD	03f4422abr			; 0.766154
	DD	03f446337r			; 0.767139
	DD	03f44a3a5r			; 0.768122
	DD	03f44e3f5r			; 0.769103
	DD	03f452426r			; 0.770083
	DD	03f456439r			; 0.771061
	DD	03f45a42dr			; 0.772036
	DD	03f45e403r			; 0.77301
	DD	03f4623bbr			; 0.773983
	DD	03f466354r			; 0.774953
	DD	03f46a2cer			; 0.775922
	DD	03f46e22ar			; 0.776888
	DD	03f472167r			; 0.777853
	DD	03f476085r			; 0.778817
	DD	03f479f84r			; 0.779778
	DD	03f47de65r			; 0.780737
	DD	03f481d27r			; 0.781695
	DD	03f485bcar			; 0.782651
	DD	03f489a4er			; 0.783605
	DD	03f48d8b3r			; 0.784557
	DD	03f4916far			; 0.785507
	DD	03f495521r			; 0.786455
	DD	03f499329r			; 0.787402
	DD	03f49d112r			; 0.788346
	DD	03f4a0edcr			; 0.789289
	DD	03f4a4c87r			; 0.79023
	DD	03f4a8a13r			; 0.791169
	DD	03f4ac77fr			; 0.792107
	DD	03f4b04ccr			; 0.793042
	DD	03f4b41far			; 0.793975
	DD	03f4b7f09r			; 0.794907
	DD	03f4bbbf8r			; 0.795837
	DD	03f4bf8c7r			; 0.796765
	DD	03f4c3578r			; 0.797691
	DD	03f4c7208r			; 0.798615
	DD	03f4cae79r			; 0.799537
	DD	03f4ceacbr			; 0.800458
	DD	03f4d26fdr			; 0.801376
	DD	03f4d6310r			; 0.802293
	DD	03f4d9f02r			; 0.803208
	DD	03f4ddad5r			; 0.80412
	DD	03f4e1689r			; 0.805031
	DD	03f4e521cr			; 0.80594
	DD	03f4e8d90r			; 0.806848
	DD	03f4ec8e4r			; 0.807753
	DD	03f4f0417r			; 0.808656
	DD	03f4f3f2br			; 0.809558
	DD	03f4f7a1fr			; 0.810457
	DD	03f4fb4f4r			; 0.811355
	DD	03f4fefa8r			; 0.812251
	DD	03f502a3br			; 0.813144
	DD	03f5064afr			; 0.814036
	DD	03f509f03r			; 0.814926
	DD	03f50d937r			; 0.815814
	DD	03f51134ar			; 0.816701
	DD	03f514d3dr			; 0.817585
	DD	03f518710r			; 0.818467
	DD	03f51c0c2r			; 0.819348
	DD	03f51fa54r			; 0.820226
	DD	03f5233c6r			; 0.821102
	DD	03f526d18r			; 0.821977
	DD	03f52a649r			; 0.82285
	DD	03f52df59r			; 0.823721
	DD	03f531849r			; 0.824589
	DD	03f535118r			; 0.825456
	DD	03f5389c7r			; 0.826321
	DD	03f53c255r			; 0.827184
	DD	03f53fac3r			; 0.828045
	DD	03f54330fr			; 0.828904
	DD	03f546b3br			; 0.829761
	DD	03f54a347r			; 0.830616
	DD	03f54db31r			; 0.83147
	DD	03f5512fbr			; 0.832321
	DD	03f554aa4r			; 0.83317
	DD	03f55822cr			; 0.834018
	DD	03f55b993r			; 0.834863
	DD	03f55f0d9r			; 0.835706
	DD	03f5627fer			; 0.836548
	DD	03f565f02r			; 0.837387
	DD	03f5695e5r			; 0.838225
	DD	03f56cca7r			; 0.83906
	DD	03f570348r			; 0.839894
	DD	03f5739c7r			; 0.840725
	DD	03f577026r			; 0.841555
	DD	03f57a663r			; 0.842383
	DD	03f57dc7fr			; 0.843208
	DD	03f581279r			; 0.844032
	DD	03f584853r			; 0.844854
	DD	03f587e0br			; 0.845673
	DD	03f58b3a1r			; 0.846491
	DD	03f58e916r			; 0.847307
	DD	03f591e6ar			; 0.84812
	DD	03f59539cr			; 0.848932
	DD	03f5988adr			; 0.849742
	DD	03f59bd9cr			; 0.850549
	DD	03f59f26ar			; 0.851355
	DD	03f5a2716r			; 0.852159
	DD	03f5a5ba0r			; 0.852961
	DD	03f5a9009r			; 0.85376
	DD	03f5ac450r			; 0.854558
	DD	03f5af875r			; 0.855354
	DD	03f5b2c79r			; 0.856147
	DD	03f5b605ar			; 0.856939
	DD	03f5b941ar			; 0.857729
	DD	03f5bc7b8r			; 0.858516
	DD	03f5bfb34r			; 0.859302
	DD	03f5c2e8er			; 0.860085
	DD	03f5c61c7r			; 0.860867
	DD	03f5c94ddr			; 0.861646
	DD	03f5cc7d1r			; 0.862424
	DD	03f5cfaa3r			; 0.863199
	DD	03f5d2d53r			; 0.863973
	DD	03f5d5fe1r			; 0.864744
	DD	03f5d924dr			; 0.865514
	DD	03f5dc497r			; 0.866281
	DD	03f5df6ber			; 0.867046
	DD	03f5e28c3r			; 0.867809
	DD	03f5e5aa6r			; 0.868571
	DD	03f5e8c67r			; 0.86933
	DD	03f5ebe05r			; 0.870087
	DD	03f5eef81r			; 0.870842
	DD	03f5f20dbr			; 0.871595
	DD	03f5f5212r			; 0.872346
	DD	03f5f8327r			; 0.873095
	DD	03f5fb419r			; 0.873842
	DD	03f5fe4e9r			; 0.874587
	DD	03f601596r			; 0.875329
	DD	03f604621r			; 0.87607
	DD	03f607689r			; 0.876809
	DD	03f60a6cfr			; 0.877545
	DD	03f60d6f2r			; 0.87828
	DD	03f6106f2r			; 0.879012
	DD	03f6136d0r			; 0.879743
	DD	03f61668ar			; 0.880471
	DD	03f619622r			; 0.881197
	DD	03f61c598r			; 0.881921
	DD	03f61f4ear			; 0.882643
	DD	03f62241ar			; 0.883363
	DD	03f625326r			; 0.884081
	DD	03f628210r			; 0.884797
	DD	03f62b0d7r			; 0.885511
	DD	03f62df7br			; 0.886223
	DD	03f630dfcr			; 0.886932
	DD	03f633c5ar			; 0.88764
	DD	03f636a95r			; 0.888345
	DD	03f6398acr			; 0.889048
	DD	03f63c6a1r			; 0.88975
	DD	03f63f473r			; 0.890449
	DD	03f642221r			; 0.891146
	DD	03f644facr			; 0.891841
	DD	03f647d14r			; 0.892534
	DD	03f64aa59r			; 0.893224
	DD	03f64d77br			; 0.893913
	DD	03f650479r			; 0.894599
	DD	03f653154r			; 0.895284
	DD	03f655e0br			; 0.895966
	DD	03f658aa0r			; 0.896646
	DD	03f65b710r			; 0.897325
	DD	03f65e35er			; 0.898001
	DD	03f660f88r			; 0.898674
	DD	03f663b8er			; 0.899346
	DD	03f666771r			; 0.900016
	DD	03f669330r			; 0.900683
	DD	03f66beccr			; 0.901349
	DD	03f66ea45r			; 0.902012
	DD	03f671599r			; 0.902673
	DD	03f6740car			; 0.903332
	DD	03f676bd8r			; 0.903989
	DD	03f6796c1r			; 0.904644
	DD	03f67c187r			; 0.905297
	DD	03f67ec29r			; 0.905947
	DD	03f6816a8r			; 0.906596
	DD	03f684103r			; 0.907242
	DD	03f686b39r			; 0.907886
	DD	03f68954cr			; 0.908528
	DD	03f68bf3cr			; 0.909168
	DD	03f68e907r			; 0.909806
	DD	03f6912aer			; 0.910441
	DD	03f693c32r			; 0.911075
	DD	03f696591r			; 0.911706
	DD	03f698eccr			; 0.912335
	DD	03f69b7e4r			; 0.912962
	DD	03f69e0d7r			; 0.913587
	DD	03f6a09a7r			; 0.91421
	DD	03f6a3252r			; 0.91483
	DD	03f6a5ad9r			; 0.915449
	DD	03f6a833cr			; 0.916065
	DD	03f6aab7br			; 0.916679
	DD	03f6ad395r			; 0.917291
	DD	03f6afb8cr			; 0.917901
	DD	03f6b235er			; 0.918508
	DD	03f6b4b0cr			; 0.919114
	DD	03f6b7295r			; 0.919717
	DD	03f6b99fbr			; 0.920318
	DD	03f6bc13br			; 0.920917
	DD	03f6be858r			; 0.921514
	DD	03f6c0f50r			; 0.922109
	DD	03f6c3624r			; 0.922701
	DD	03f6c5cd4r			; 0.923291
	DD	03f6c835er			; 0.92388
	DD	03f6ca9c5r			; 0.924465
	DD	03f6cd007r			; 0.925049
	DD	03f6cf624r			; 0.925631
	DD	03f6d1c1dr			; 0.92621
	DD	03f6d41f2r			; 0.926787
	DD	03f6d67a1r			; 0.927363
	DD	03f6d8d2dr			; 0.927935
	DD	03f6db293r			; 0.928506
	DD	03f6dd7d5r			; 0.929075
	DD	03f6dfcf2r			; 0.929641
	DD	03f6e21ebr			; 0.930205
	DD	03f6e46ber			; 0.930767
	DD	03f6e6b6dr			; 0.931327
	DD	03f6e8ff8r			; 0.931884
	DD	03f6eb45dr			; 0.93244
	DD	03f6ed89er			; 0.932993
	DD	03f6efcbar			; 0.933544
	DD	03f6f20b0r			; 0.934093
	DD	03f6f4483r			; 0.934639
	DD	03f6f6830r			; 0.935184
	DD	03f6f8bb8r			; 0.935726
	DD	03f6faf1br			; 0.936266
	DD	03f6fd25ar			; 0.936803
	DD	03f6ff573r			; 0.937339
	DD	03f701867r			; 0.937872
	DD	03f703b37r			; 0.938404
	DD	03f705de1r			; 0.938932
	DD	03f708066r			; 0.939459
	DD	03f70a2c6r			; 0.939984
	DD	03f70c501r			; 0.940506
	DD	03f70e717r			; 0.941026
	DD	03f710908r			; 0.941544
	DD	03f712ad4r			; 0.94206
	DD	03f714c7ar			; 0.942573
	DD	03f716dfbr			; 0.943084
	DD	03f718f57r			; 0.943593
	DD	03f71b08er			; 0.9441
	DD	03f71d19fr			; 0.944605
	DD	03f71f28cr			; 0.945107
	DD	03f721352r			; 0.945607
	DD	03f7233f4r			; 0.946105
	DD	03f725470r			; 0.946601
	DD	03f7274c7r			; 0.947094
	DD	03f7294f8r			; 0.947586
	DD	03f72b504r			; 0.948075
	DD	03f72d4ebr			; 0.948561
	DD	03f72f4acr			; 0.949046
	DD	03f731447r			; 0.949528
	DD	03f7333ber			; 0.950008
	DD	03f73530er			; 0.950486
	DD	03f737239r			; 0.950962
	DD	03f73913fr			; 0.951435
	DD	03f73b01fr			; 0.951906
	DD	03f73ced9r			; 0.952375
	DD	03f73ed6er			; 0.952842
	DD	03f740bddr			; 0.953306
	DD	03f742a27r			; 0.953768
	DD	03f74484br			; 0.954228
	DD	03f746649r			; 0.954686
	DD	03f748422r			; 0.955141
	DD	03f74a1d5r			; 0.955594
	DD	03f74bf62r			; 0.956045
	DD	03f74dcc9r			; 0.956494
	DD	03f74fa0br			; 0.95694
	DD	03f751727r			; 0.957385
	DD	03f75341dr			; 0.957826
	DD	03f7550edr			; 0.958266
	DD	03f756d97r			; 0.958703
	DD	03f758a1cr			; 0.959139
	DD	03f75a67br			; 0.959572
	DD	03f75c2b3r			; 0.960002
	DD	03f75dec6r			; 0.960431
	DD	03f75fab3r			; 0.960857
	DD	03f76167ar			; 0.96128
	DD	03f76321br			; 0.961702
	DD	03f764d97r			; 0.962121
	DD	03f7668ecr			; 0.962538
	DD	03f76841br			; 0.962953
	DD	03f769f24r			; 0.963366
	DD	03f76ba07r			; 0.963776
	DD	03f76d4c4r			; 0.964184
	DD	03f76ef5br			; 0.96459
	DD	03f7709ccr			; 0.964993
	DD	03f772417r			; 0.965394
	DD	03f773e3cr			; 0.965793
	DD	03f77583ar			; 0.96619
	DD	03f777213r			; 0.966584
	DD	03f778bc5r			; 0.966976
	DD	03f77a551r			; 0.967366
	DD	03f77beb7r			; 0.967754
	DD	03f77d7f7r			; 0.968139
	DD	03f77f110r			; 0.968522
	DD	03f780a04r			; 0.968903
	DD	03f7822d1r			; 0.969281
	DD	03f783b77r			; 0.969657
	DD	03f7853f8r			; 0.970031
	DD	03f786c52r			; 0.970403
	DD	03f788486r			; 0.970772
	DD	03f789c93r			; 0.971139
	DD	03f78b47br			; 0.971504
	DD	03f78cc3br			; 0.971866
	DD	03f78e3d6r			; 0.972227
	DD	03f78fb4ar			; 0.972584
	DD	03f791298r			; 0.97294
	DD	03f7929bfr			; 0.973293
	DD	03f7940c0r			; 0.973644
	DD	03f79579ar			; 0.973993
	DD	03f796e4er			; 0.974339
	DD	03f7984dcr			; 0.974684
	DD	03f799b43r			; 0.975025
	DD	03f79b183r			; 0.975365
	DD	03f79c79dr			; 0.975702
	DD	03f79dd91r			; 0.976037
	DD	03f79f35er			; 0.97637
	DD	03f7a0904r			; 0.9767
	DD	03f7a1e84r			; 0.977028
	DD	03f7a33ddr			; 0.977354
	DD	03f7a4910r			; 0.977677
	DD	03f7a5e1cr			; 0.977998
	DD	03f7a7302r			; 0.978317
	DD	03f7a87c1r			; 0.978634
	DD	03f7a9c59r			; 0.978948
	DD	03f7ab0cbr			; 0.97926
	DD	03f7ac516r			; 0.97957
	DD	03f7ad93ar			; 0.979877
	DD	03f7aed37r			; 0.980182
	DD	03f7b010er			; 0.980485
	DD	03f7b14ber			; 0.980785
	DD	03f7b2848r			; 0.981083
	DD	03f7b3babr			; 0.981379
	DD	03f7b4ee7r			; 0.981673
	DD	03f7b61fcr			; 0.981964
	DD	03f7b74ear			; 0.982253
	DD	03f7b87b2r			; 0.982539
	DD	03f7b9a53r			; 0.982824
	DD	03f7baccdr			; 0.983105
	DD	03f7bbf20r			; 0.983385
	DD	03f7bd14dr			; 0.983662
	DD	03f7be353r			; 0.983937
	DD	03f7bf531r			; 0.98421
	DD	03f7c06e9r			; 0.98448
	DD	03f7c187ar			; 0.984748
	DD	03f7c29e5r			; 0.985014
	DD	03f7c3b28r			; 0.985278
	DD	03f7c4c44r			; 0.985539
	DD	03f7c5d3ar			; 0.985798
	DD	03f7c6e08r			; 0.986054
	DD	03f7c7eb0r			; 0.986308
	DD	03f7c8f31r			; 0.98656
	DD	03f7c9f8ar			; 0.986809
	DD	03f7cafbdr			; 0.987057
	DD	03f7cbfc9r			; 0.987301
	DD	03f7ccfaer			; 0.987544
	DD	03f7cdf6cr			; 0.987784
	DD	03f7cef03r			; 0.988022
	DD	03f7cfe73r			; 0.988258
	DD	03f7d0dbcr			; 0.988491
	DD	03f7d1cddr			; 0.988722
	DD	03f7d2bd8r			; 0.98895
	DD	03f7d3aacr			; 0.989177
	DD	03f7d4959r			; 0.9894
	DD	03f7d57der			; 0.989622
	DD	03f7d663dr			; 0.989841
	DD	03f7d7474r			; 0.990058
	DD	03f7d8285r			; 0.990273
	DD	03f7d906er			; 0.990485
	DD	03f7d9e30r			; 0.990695
	DD	03f7dabccr			; 0.990903
	DD	03f7db940r			; 0.991108
	DD	03f7dc68cr			; 0.991311
	DD	03f7dd3b2r			; 0.991511
	DD	03f7de0b1r			; 0.99171
	DD	03f7ded88r			; 0.991906
	DD	03f7dfa38r			; 0.992099
	DD	03f7e06c2r			; 0.992291
	DD	03f7e1324r			; 0.99248
	DD	03f7e1f5er			; 0.992666
	DD	03f7e2b72r			; 0.99285
	DD	03f7e375er			; 0.993032
	DD	03f7e4323r			; 0.993212
	DD	03f7e4ec1r			; 0.993389
	DD	03f7e5a38r			; 0.993564
	DD	03f7e6588r			; 0.993737
	DD	03f7e70b0r			; 0.993907
	DD	03f7e7bb1r			; 0.994075
	DD	03f7e868br			; 0.99424
	DD	03f7e913dr			; 0.994404
	DD	03f7e9bc9r			; 0.994565
	DD	03f7ea62dr			; 0.994723
	DD	03f7eb069r			; 0.994879
	DD	03f7eba7fr			; 0.995033
	DD	03f7ec46dr			; 0.995185
	DD	03f7ece34r			; 0.995334
	DD	03f7ed7d4r			; 0.995481
	DD	03f7ee14cr			; 0.995625
	DD	03f7eea9dr			; 0.995767
	DD	03f7ef3c7r			; 0.995907
	DD	03f7efcc9r			; 0.996045
	DD	03f7f05a4r			; 0.99618
	DD	03f7f0e58r			; 0.996313
	DD	03f7f16e4r			; 0.996443
	DD	03f7f1f49r			; 0.996571
	DD	03f7f2787r			; 0.996697
	DD	03f7f2f9dr			; 0.99682
	DD	03f7f378cr			; 0.996941
	DD	03f7f3f54r			; 0.99706
	DD	03f7f46f4r			; 0.997176
	DD	03f7f4e6dr			; 0.99729
	DD	03f7f55bfr			; 0.997402
	DD	03f7f5ce9r			; 0.997511
	DD	03f7f63ecr			; 0.997618
	DD	03f7f6ac7r			; 0.997723
	DD	03f7f717br			; 0.997825
	DD	03f7f7808r			; 0.997925
	DD	03f7f7e6dr			; 0.998023
	DD	03f7f84abr			; 0.998118
	DD	03f7f8ac2r			; 0.998211
	DD	03f7f90b1r			; 0.998302
	DD	03f7f9678r			; 0.99839
	DD	03f7f9c18r			; 0.998476
	DD	03f7fa191r			; 0.998559
	DD	03f7fa6e3r			; 0.99864
	DD	03f7fac0dr			; 0.998719
	DD	03f7fb10fr			; 0.998795
	DD	03f7fb5ear			; 0.99887
	DD	03f7fba9er			; 0.998941
	DD	03f7fbf2ar			; 0.999011
	DD	03f7fc38fr			; 0.999078
	DD	03f7fc7ccr			; 0.999142
	DD	03f7fcbe2r			; 0.999205
	DD	03f7fcfd1r			; 0.999265
	DD	03f7fd397r			; 0.999322
	DD	03f7fd737r			; 0.999378
	DD	03f7fdaafr			; 0.999431
	DD	03f7fde00r			; 0.999481
	DD	03f7fe129r			; 0.999529
	DD	03f7fe42br			; 0.999575
	DD	03f7fe705r			; 0.999619
	DD	03f7fe9b8r			; 0.99966
	DD	03f7fec43r			; 0.999699
	DD	03f7feea7r			; 0.999735
	DD	03f7ff0e3r			; 0.999769
	DD	03f7ff2f8r			; 0.999801
	DD	03f7ff4e6r			; 0.999831
	DD	03f7ff6acr			; 0.999858
	DD	03f7ff84ar			; 0.999882
	DD	03f7ff9c1r			; 0.999905
	DD	03f7ffb11r			; 0.999925
	DD	03f7ffc39r			; 0.999942
	DD	03f7ffd39r			; 0.999958
	DD	03f7ffe13r			; 0.999971
	DD	03f7ffec4r			; 0.999981
	DD	03f7fff4er			; 0.999989
	DD	03f7fffb1r			; 0.999995
	DD	03f7fffecr			; 0.999999
?g_fIdvSinTable@@3QBMB DD 000000000r		; 0	; g_fIdvSinTable
	DD	03ac90fd5r			; 0.00153398
	DD	03b490fc6r			; 0.00306796
	DD	03b96cbc1r			; 0.00460193
	DD	03bc90f88r			; 0.00613588
	DD	03bfb5330r			; 0.00766983
	DD	03c16cb58r			; 0.00920375
	DD	03c2fed02r			; 0.0107377
	DD	03c490e90r			; 0.0122715
	DD	03c622fffr			; 0.0138054
	DD	03c7b514br			; 0.0153392
	DD	03c8a3938r			; 0.016873
	DD	03c96c9b6r			; 0.0184067
	DD	03ca35a1cr			; 0.0199404
	DD	03cafea69r			; 0.0214741
	DD	03cbc7a9br			; 0.0230077
	DD	03cc90ab0r			; 0.0245412
	DD	03cd59aa6r			; 0.0260747
	DD	03ce22a7ar			; 0.0276081
	DD	03ceeba2cr			; 0.0291415
	DD	03cfb49bar			; 0.0306748
	DD	03d03ec90r			; 0.032208
	DD	03d0a342fr			; 0.0337412
	DD	03d107bb8r			; 0.0352742
	DD	03d16c32cr			; 0.0368072
	DD	03d1d0a88r			; 0.0383401
	DD	03d2351cbr			; 0.0398729
	DD	03d2998f6r			; 0.0414056
	DD	03d2fe007r			; 0.0429383
	DD	03d3626fcr			; 0.0444708
	DD	03d3c6dd5r			; 0.0460032
	DD	03d42b491r			; 0.0475355
	DD	03d48fb30r			; 0.0490677
	DD	03d4f41afr			; 0.0505998
	DD	03d55880er			; 0.0521317
	DD	03d5bce4cr			; 0.0536635
	DD	03d621469r			; 0.0551952
	DD	03d685a62r			; 0.0567268
	DD	03d6ea038r			; 0.0582583
	DD	03d74e5e9r			; 0.0597896
	DD	03d7b2b74r			; 0.0613207
	DD	03d80b86cr			; 0.0628518
	DD	03d83db0ar			; 0.0643826
	DD	03d86fd94r			; 0.0659133
	DD	03d8a200ar			; 0.0674439
	DD	03d8d426ar			; 0.0689743
	DD	03d9064b4r			; 0.0705046
	DD	03d9386e7r			; 0.0720346
	DD	03d96a905r			; 0.0735646
	DD	03d99cb0ar			; 0.0750943
	DD	03d9cecf9r			; 0.0766239
	DD	03da00ecfr			; 0.0781532
	DD	03da3308cr			; 0.0796824
	DD	03da65230r			; 0.0812114
	DD	03da973bar			; 0.0827403
	DD	03dac952br			; 0.0842689
	DD	03dafb680r			; 0.0857973
	DD	03db2d7bbr			; 0.0873255
	DD	03db5f8dar			; 0.0888536
	DD	03db919ddr			; 0.0903814
	DD	03dbc3ac3r			; 0.091909
	DD	03dbf5b8dr			; 0.0934363
	DD	03dc27c39r			; 0.0949635
	DD	03dc59cc6r			; 0.0964904
	DD	03dc8bd36r			; 0.0980171
	DD	03dcbdd86r			; 0.0995436
	DD	03dcefdb7r			; 0.10107
	DD	03dd21dc8r			; 0.102596
	DD	03dd53db9r			; 0.104122
	DD	03dd85d89r			; 0.105647
	DD	03ddb7d37r			; 0.107172
	DD	03dde9cc4r			; 0.108697
	DD	03de1bc2er			; 0.110222
	DD	03de4db76r			; 0.111747
	DD	03de7fa9ar			; 0.113271
	DD	03deb199ar			; 0.114795
	DD	03dee3876r			; 0.116319
	DD	03df1572er			; 0.117842
	DD	03df475c0r			; 0.119365
	DD	03df7942cr			; 0.120888
	DD	03dfab273r			; 0.122411
	DD	03dfdd092r			; 0.123933
	DD	03e007745r			; 0.125455
	DD	03e02062er			; 0.126977
	DD	03e039502r			; 0.128498
	DD	03e0523c2r			; 0.130019
	DD	03e06b26er			; 0.13154
	DD	03e084105r			; 0.133061
	DD	03e09cf86r			; 0.134581
	DD	03e0b5df3r			; 0.136101
	DD	03e0cec4ar			; 0.13762
	DD	03e0e7a8br			; 0.139139
	DD	03e1008b7r			; 0.140658
	DD	03e1196ccr			; 0.142177
	DD	03e1324car			; 0.143695
	DD	03e14b2b2r			; 0.145213
	DD	03e164083r			; 0.14673
	DD	03e17ce3dr			; 0.148248
	DD	03e195be0r			; 0.149765
	DD	03e1ae96br			; 0.151281
	DD	03e1c76der			; 0.152797
	DD	03e1e0438r			; 0.154313
	DD	03e1f917br			; 0.155828
	DD	03e211ea5r			; 0.157343
	DD	03e22abb6r			; 0.158858
	DD	03e2438adr			; 0.160372
	DD	03e25c58cr			; 0.161886
	DD	03e275251r			; 0.1634
	DD	03e28defcr			; 0.164913
	DD	03e2a6b8dr			; 0.166426
	DD	03e2bf804r			; 0.167938
	DD	03e2d8461r			; 0.16945
	DD	03e2f10a2r			; 0.170962
	DD	03e309cc9r			; 0.172473
	DD	03e3228d4r			; 0.173984
	DD	03e33b4c4r			; 0.175494
	DD	03e354098r			; 0.177004
	DD	03e36cc50r			; 0.178514
	DD	03e3857ecr			; 0.180023
	DD	03e39e36cr			; 0.181532
	DD	03e3b6ecfr			; 0.18304
	DD	03e3cfa15r			; 0.184548
	DD	03e3e853er			; 0.186055
	DD	03e401049r			; 0.187562
	DD	03e419b37r			; 0.189069
	DD	03e432607r			; 0.190575
	DD	03e44b0b9r			; 0.19208
	DD	03e463b4dr			; 0.193586
	DD	03e47c5c2r			; 0.19509
	DD	03e495018r			; 0.196595
	DD	03e4ada4fr			; 0.198098
	DD	03e4c6467r			; 0.199602
	DD	03e4dee60r			; 0.201105
	DD	03e4f7838r			; 0.202607
	DD	03e5101f1r			; 0.204109
	DD	03e528b89r			; 0.20561
	DD	03e541501r			; 0.207111
	DD	03e559e58r			; 0.208612
	DD	03e57278fr			; 0.210112
	DD	03e58b0a4r			; 0.211611
	DD	03e5a3997r			; 0.21311
	DD	03e5bc26ar			; 0.214609
	DD	03e5d4b1ar			; 0.216107
	DD	03e5ed3a8r			; 0.217604
	DD	03e605c13r			; 0.219101
	DD	03e61e45cr			; 0.220598
	DD	03e636c83r			; 0.222094
	DD	03e64f486r			; 0.223589
	DD	03e667c66r			; 0.225084
	DD	03e680422r			; 0.226578
	DD	03e698bbar			; 0.228072
	DD	03e6b132fr			; 0.229565
	DD	03e6c9a7fr			; 0.231058
	DD	03e6e21abr			; 0.23255
	DD	03e6fa8b2r			; 0.234042
	DD	03e712f94r			; 0.235533
	DD	03e72b651r			; 0.237024
	DD	03e743ce8r			; 0.238514
	DD	03e75c35ar			; 0.240003
	DD	03e7749a6r			; 0.241492
	DD	03e78cfccr			; 0.24298
	DD	03e7a55cbr			; 0.244468
	DD	03e7bdba4r			; 0.245955
	DD	03e7d6156r			; 0.247442
	DD	03e7ee6e1r			; 0.248928
	DD	03e803622r			; 0.250413
	DD	03e80f8c0r			; 0.251898
	DD	03e81bb4ar			; 0.253382
	DD	03e827dc0r			; 0.254866
	DD	03e834022r			; 0.256349
	DD	03e840270r			; 0.257831
	DD	03e84c4aar			; 0.259313
	DD	03e8586cer			; 0.260794
	DD	03e8648dfr			; 0.262275
	DD	03e870adar			; 0.263755
	DD	03e87ccc1r			; 0.265234
	DD	03e888e93r			; 0.266713
	DD	03e895050r			; 0.268191
	DD	03e8a11f7r			; 0.269668
	DD	03e8ad38ar			; 0.271145
	DD	03e8b9507r			; 0.272621
	DD	03e8c566er			; 0.274097
	DD	03e8d17c0r			; 0.275572
	DD	03e8dd8fcr			; 0.277046
	DD	03e8e9a22r			; 0.27852
	DD	03e8f5b32r			; 0.279993
	DD	03e901c2cr			; 0.281465
	DD	03e90dd10r			; 0.282937
	DD	03e919dddr			; 0.284408
	DD	03e925e94r			; 0.285878
	DD	03e931f35r			; 0.287347
	DD	03e93dfbfr			; 0.288816
	DD	03e94a031r			; 0.290285
	DD	03e95608dr			; 0.291752
	DD	03e9620d2r			; 0.293219
	DD	03e96e100r			; 0.294685
	DD	03e97a117r			; 0.296151
	DD	03e986116r			; 0.297616
	DD	03e9920fer			; 0.29908
	DD	03e99e0cer			; 0.300543
	DD	03e9aa086r			; 0.302006
	DD	03e9b6027r			; 0.303468
	DD	03e9c1fafr			; 0.304929
	DD	03e9cdf20r			; 0.30639
	DD	03e9d9e78r			; 0.30785
	DD	03e9e5db8r			; 0.309309
	DD	03e9f1cdfr			; 0.310767
	DD	03e9fdbeer			; 0.312225
	DD	03ea09ae5r			; 0.313682
	DD	03ea159c2r			; 0.315138
	DD	03ea21887r			; 0.316593
	DD	03ea2d733r			; 0.318048
	DD	03ea395c5r			; 0.319502
	DD	03ea4543fr			; 0.320955
	DD	03ea5129fr			; 0.322408
	DD	03ea5d0e5r			; 0.323859
	DD	03ea68f12r			; 0.32531
	DD	03ea74d25r			; 0.32676
	DD	03ea80b1fr			; 0.32821
	DD	03ea8c8fer			; 0.329658
	DD	03ea986c4r			; 0.331106
	DD	03eaa446fr			; 0.332553
	DD	03eab0201r			; 0.334
	DD	03eabbf77r			; 0.335445
	DD	03eac7cd4r			; 0.33689
	DD	03ead3a15r			; 0.338334
	DD	03eadf73cr			; 0.339777
	DD	03eaeb449r			; 0.341219
	DD	03eaf713ar			; 0.342661
	DD	03eb02e10r			; 0.344101
	DD	03eb0eacbr			; 0.345541
	DD	03eb1a76br			; 0.34698
	DD	03eb263efr			; 0.348419
	DD	03eb32058r			; 0.349856
	DD	03eb3dca5r			; 0.351293
	DD	03eb498d6r			; 0.352729
	DD	03eb554ecr			; 0.354164
	DD	03eb610e6r			; 0.355598
	DD	03eb6ccc3r			; 0.357031
	DD	03eb78884r			; 0.358463
	DD	03eb8442ar			; 0.359895
	DD	03eb8ffb2r			; 0.361326
	DD	03eb9bb1er			; 0.362756
	DD	03eba766er			; 0.364185
	DD	03ebb31a0r			; 0.365613
	DD	03ebbecb6r			; 0.36704
	DD	03ebca7afr			; 0.368467
	DD	03ebd628br			; 0.369892
	DD	03ebe1d4ar			; 0.371317
	DD	03ebed7ebr			; 0.372741
	DD	03ebf926fr			; 0.374164
	DD	03ec04cd5r			; 0.375586
	DD	03ec1071er			; 0.377007
	DD	03ec1c148r			; 0.378428
	DD	03ec27b55r			; 0.379847
	DD	03ec33544r			; 0.381266
	DD	03ec3ef15r			; 0.382683
	DD	03ec4a8c8r			; 0.3841
	DD	03ec5625cr			; 0.385516
	DD	03ec61bd2r			; 0.386931
	DD	03ec6d529r			; 0.388345
	DD	03ec78e62r			; 0.389758
	DD	03ec8477cr			; 0.39117
	DD	03ec90077r			; 0.392582
	DD	03ec9b953r			; 0.393992
	DD	03eca7210r			; 0.395401
	DD	03ecb2aaer			; 0.39681
	DD	03ecbe32cr			; 0.398218
	DD	03ecc9b8br			; 0.399624
	DD	03ecd53car			; 0.40103
	DD	03ece0bear			; 0.402435
	DD	03ecec3ear			; 0.403838
	DD	03ecf7bcar			; 0.405241
	DD	03ed0338ar			; 0.406643
	DD	03ed0eb2ar			; 0.408044
	DD	03ed1a2aar			; 0.409444
	DD	03ed25a09r			; 0.410843
	DD	03ed31148r			; 0.412241
	DD	03ed3c867r			; 0.413638
	DD	03ed47f64r			; 0.415034
	DD	03ed53641r			; 0.41643
	DD	03ed5ecfdr			; 0.417824
	DD	03ed6a399r			; 0.419217
	DD	03ed75a13r			; 0.420609
	DD	03ed8106br			; 0.422
	DD	03ed8c6a3r			; 0.42339
	DD	03ed97cb9r			; 0.42478
	DD	03eda32adr			; 0.426168
	DD	03edae880r			; 0.427555
	DD	03edb9e31r			; 0.428941
	DD	03edc53c1r			; 0.430326
	DD	03edd092er			; 0.431711
	DD	03eddbe79r			; 0.433094
	DD	03ede73a2r			; 0.434476
	DD	03edf28a9r			; 0.435857
	DD	03edfdd8dr			; 0.437237
	DD	03ee0924fr			; 0.438616
	DD	03ee146eer			; 0.439994
	DD	03ee1fb6ar			; 0.441371
	DD	03ee2afc4r			; 0.442747
	DD	03ee363far			; 0.444122
	DD	03ee4180er			; 0.445496
	DD	03ee4cbfer			; 0.446869
	DD	03ee57fcbr			; 0.448241
	DD	03ee63375r			; 0.449611
	DD	03ee6e6fbr			; 0.450981
	DD	03ee79a5dr			; 0.45235
	DD	03ee84d9cr			; 0.453717
	DD	03ee900b7r			; 0.455084
	DD	03ee9b3aer			; 0.456449
	DD	03eea6681r			; 0.457813
	DD	03eeb1930r			; 0.459177
	DD	03eebcbbbr			; 0.460539
	DD	03eec7e21r			; 0.4619
	DD	03eed3063r			; 0.46326
	DD	03eede280r			; 0.464619
	DD	03eee9479r			; 0.465977
	DD	03eef464cr			; 0.467333
	DD	03eeff7fbr			; 0.468689
	DD	03ef0a985r			; 0.470043
	DD	03ef15aear			; 0.471397
	DD	03ef20c29r			; 0.472749
	DD	03ef2bd43r			; 0.4741
	DD	03ef36e38r			; 0.47545
	DD	03ef41f07r			; 0.476799
	DD	03ef4cfb1r			; 0.478147
	DD	03ef58035r			; 0.479494
	DD	03ef63093r			; 0.480839
	DD	03ef6e0cbr			; 0.482184
	DD	03ef790dcr			; 0.483527
	DD	03ef840c8r			; 0.484869
	DD	03ef8f08er			; 0.48621
	DD	03ef9a02dr			; 0.48755
	DD	03efa4fa5r			; 0.488889
	DD	03efafef7r			; 0.490226
	DD	03efbae22r			; 0.491563
	DD	03efc5d27r			; 0.492898
	DD	03efd0c04r			; 0.494232
	DD	03efdbabbr			; 0.495565
	DD	03efe694ar			; 0.496897
	DD	03eff17b2r			; 0.498228
	DD	03effc5f3r			; 0.499557
	DD	03f003a06r			; 0.500885
	DD	03f0090ffr			; 0.502212
	DD	03f00e7e4r			; 0.503538
	DD	03f013eb5r			; 0.504863
	DD	03f019573r			; 0.506187
	DD	03f01ec1cr			; 0.507509
	DD	03f0242b1r			; 0.50883
	DD	03f029932r			; 0.51015
	DD	03f02ef9fr			; 0.511469
	DD	03f0345f8r			; 0.512786
	DD	03f039c3dr			; 0.514103
	DD	03f03f26dr			; 0.515418
	DD	03f044889r			; 0.516732
	DD	03f049e91r			; 0.518045
	DD	03f04f484r			; 0.519356
	DD	03f054a62r			; 0.520666
	DD	03f05a02cr			; 0.521975
	DD	03f05f5e2r			; 0.523283
	DD	03f064b82r			; 0.52459
	DD	03f06a10er			; 0.525895
	DD	03f06f686r			; 0.527199
	DD	03f074be8r			; 0.528502
	DD	03f07a136r			; 0.529804
	DD	03f07f66fr			; 0.531104
	DD	03f084b92r			; 0.532403
	DD	03f08a0a1r			; 0.533701
	DD	03f08f59br			; 0.534998
	DD	03f094a7fr			; 0.536293
	DD	03f099f4er			; 0.537587
	DD	03f09f409r			; 0.53888
	DD	03f0a48adr			; 0.540171
	DD	03f0a9d3dr			; 0.541462
	DD	03f0af1b7r			; 0.542751
	DD	03f0b461cr			; 0.544039
	DD	03f0b9a6br			; 0.545325
	DD	03f0beea5r			; 0.54661
	DD	03f0c42c9r			; 0.547894
	DD	03f0c96d7r			; 0.549177
	DD	03f0cead0r			; 0.550458
	DD	03f0d3eb3r			; 0.551738
	DD	03f0d9281r			; 0.553017
	DD	03f0de638r			; 0.554294
	DD	03f0e39dar			; 0.55557
	DD	03f0e8d65r			; 0.556845
	DD	03f0ee0dbr			; 0.558119
	DD	03f0f343br			; 0.559391
	DD	03f0f8784r			; 0.560662
	DD	03f0fdab8r			; 0.561931
	DD	03f102dd5r			; 0.563199
	DD	03f1080dcr			; 0.564466
	DD	03f10d3cdr			; 0.565732
	DD	03f1126a7r			; 0.566996
	DD	03f11796br			; 0.568259
	DD	03f11cc19r			; 0.569521
	DD	03f121eb0r			; 0.570781
	DD	03f127130r			; 0.57204
	DD	03f12c39ar			; 0.573297
	DD	03f1315eer			; 0.574553
	DD	03f13682ar			; 0.575808
	DD	03f13ba50r			; 0.577062
	DD	03f140c5fr			; 0.578314
	DD	03f145e58r			; 0.579565
	DD	03f14b039r			; 0.580814
	DD	03f150204r			; 0.582062
	DD	03f1553b7r			; 0.583309
	DD	03f15a554r			; 0.584554
	DD	03f15f6d9r			; 0.585798
	DD	03f164847r			; 0.58704
	DD	03f16999fr			; 0.588282
	DD	03f16eader			; 0.589521
	DD	03f173c07r			; 0.59076
	DD	03f178d18r			; 0.591997
	DD	03f17de12r			; 0.593232
	DD	03f182ef5r			; 0.594467
	DD	03f187fc0r			; 0.595699
	DD	03f18d073r			; 0.596931
	DD	03f19210fr			; 0.598161
	DD	03f197194r			; 0.599389
	DD	03f19c200r			; 0.600616
	DD	03f1a1255r			; 0.601842
	DD	03f1a6293r			; 0.603067
	DD	03f1ab2b8r			; 0.60429
	DD	03f1b02c6r			; 0.605511
	DD	03f1b52bbr			; 0.606731
	DD	03f1ba299r			; 0.60795
	DD	03f1bf25fr			; 0.609167
	DD	03f1c420cr			; 0.610383
	DD	03f1c91a2r			; 0.611597
	DD	03f1ce11fr			; 0.61281
	DD	03f1d3084r			; 0.614022
	DD	03f1d7fd1r			; 0.615232
	DD	03f1dcf06r			; 0.61644
	DD	03f1e1e22r			; 0.617647
	DD	03f1e6d26r			; 0.618853
	DD	03f1ebc12r			; 0.620057
	DD	03f1f0ae5r			; 0.62126
	DD	03f1f599fr			; 0.622461
	DD	03f1fa841r			; 0.623661
	DD	03f1ff6cbr			; 0.62486
	DD	03f20453br			; 0.626056
	DD	03f209393r			; 0.627252
	DD	03f20e1d2r			; 0.628446
	DD	03f212ff9r			; 0.629638
	DD	03f217e06r			; 0.630829
	DD	03f21cbfbr			; 0.632019
	DD	03f2219d7r			; 0.633207
	DD	03f226799r			; 0.634393
	DD	03f22b543r			; 0.635578
	DD	03f2302d3r			; 0.636762
	DD	03f23504br			; 0.637944
	DD	03f239da9r			; 0.639124
	DD	03f23eaeer			; 0.640303
	DD	03f24381ar			; 0.641481
	DD	03f24852cr			; 0.642657
	DD	03f24d225r			; 0.643832
	DD	03f251f04r			; 0.645005
	DD	03f256bcbr			; 0.646176
	DD	03f25b877r			; 0.647346
	DD	03f26050ar			; 0.648514
	DD	03f265184r			; 0.649681
	DD	03f269de3r			; 0.650847
	DD	03f26ea2ar			; 0.652011
	DD	03f273656r			; 0.653173
	DD	03f278268r			; 0.654334
	DD	03f27ce61r			; 0.655493
	DD	03f281a40r			; 0.656651
	DD	03f286605r			; 0.657807
	DD	03f28b1b0r			; 0.658961
	DD	03f28fd41r			; 0.660114
	DD	03f2948b8r			; 0.661266
	DD	03f299415r			; 0.662416
	DD	03f29df57r			; 0.663564
	DD	03f2a2a80r			; 0.664711
	DD	03f2a758er			; 0.665856
	DD	03f2ac082r			; 0.667
	DD	03f2b0b5br			; 0.668142
	DD	03f2b561br			; 0.669283
	DD	03f2ba0bfr			; 0.670422
	DD	03f2beb4ar			; 0.671559
	DD	03f2c35b9r			; 0.672695
	DD	03f2c800fr			; 0.673829
	DD	03f2cca49r			; 0.674962
	DD	03f2d1469r			; 0.676093
	DD	03f2d5e6fr			; 0.677222
	DD	03f2da859r			; 0.67835
	DD	03f2df229r			; 0.679476
	DD	03f2e3bder			; 0.680601
	DD	03f2e8578r			; 0.681724
	DD	03f2ecef7r			; 0.682846
	DD	03f2f185br			; 0.683965
	DD	03f2f61a5r			; 0.685084
	DD	03f2faad3r			; 0.6862
	DD	03f2ff3e6r			; 0.687315
	DD	03f303cder			; 0.688429
	DD	03f3085bbr			; 0.689541
	DD	03f30ce7cr			; 0.690651
	DD	03f311722r			; 0.691759
	DD	03f315fadr			; 0.692866
	DD	03f31a81dr			; 0.693971
	DD	03f31f071r			; 0.695075
	DD	03f3238aar			; 0.696177
	DD	03f3280c7r			; 0.697277
	DD	03f32c8c9r			; 0.698376
	DD	03f3310afr			; 0.699473
	DD	03f33587ar			; 0.700569
	DD	03f33a029r			; 0.701663
	DD	03f33e7bcr			; 0.702755
	DD	03f342f34r			; 0.703845
	DD	03f34768fr			; 0.704934
	DD	03f34bdcfr			; 0.706021
	DD	03f3504f3r			; 0.707107
	DD	03f354bfbr			; 0.708191
	DD	03f3592e7r			; 0.709273
	DD	03f35d9b8r			; 0.710353
	DD	03f36206cr			; 0.711432
	DD	03f366704r			; 0.712509
	DD	03f36ad7fr			; 0.713585
	DD	03f36f3dfr			; 0.714659
	DD	03f373a23r			; 0.715731
	DD	03f37804ar			; 0.716801
	DD	03f37c655r			; 0.71787
	DD	03f380c43r			; 0.718937
	DD	03f385216r			; 0.720003
	DD	03f3897cbr			; 0.721066
	DD	03f38dd65r			; 0.722128
	DD	03f3922e1r			; 0.723188
	DD	03f396842r			; 0.724247
	DD	03f39ad85r			; 0.725304
	DD	03f39f2acr			; 0.726359
	DD	03f3a37b7r			; 0.727413
	DD	03f3a7ca4r			; 0.728464
	DD	03f3ac175r			; 0.729514
	DD	03f3b0629r			; 0.730563
	DD	03f3b4ac1r			; 0.731609
	DD	03f3b8f3br			; 0.732654
	DD	03f3bd398r			; 0.733697
	DD	03f3c17d9r			; 0.734739
	DD	03f3c5bfcr			; 0.735779
	DD	03f3ca003r			; 0.736817
	DD	03f3ce3ecr			; 0.737853
	DD	03f3d27b8r			; 0.738887
	DD	03f3d6b67r			; 0.73992
	DD	03f3daef9r			; 0.740951
	DD	03f3df26er			; 0.74198
	DD	03f3e35c5r			; 0.743008
	DD	03f3e78ffr			; 0.744034
	DD	03f3ebc1br			; 0.745058
	DD	03f3eff1br			; 0.74608
	DD	03f3f41fcr			; 0.747101
	DD	03f3f84c0r			; 0.748119
	DD	03f3fc767r			; 0.749136
	DD	03f4009f0r			; 0.750152
	DD	03f404c5cr			; 0.751165
	DD	03f408ea9r			; 0.752177
	DD	03f40d0dar			; 0.753187
	DD	03f4112ecr			; 0.754195
	DD	03f4154e1r			; 0.755201
	DD	03f4196b7r			; 0.756206
	DD	03f41d870r			; 0.757209
	DD	03f421a0br			; 0.75821
	DD	03f425b89r			; 0.759209
	DD	03f429ce8r			; 0.760207
	DD	03f42de29r			; 0.761202
	DD	03f431f4cr			; 0.762196
	DD	03f436051r			; 0.763188
	DD	03f43a138r			; 0.764179
	DD	03f43e200r			; 0.765167
	DD	03f4422abr			; 0.766154
	DD	03f446337r			; 0.767139
	DD	03f44a3a5r			; 0.768122
	DD	03f44e3f5r			; 0.769103
	DD	03f452426r			; 0.770083
	DD	03f456439r			; 0.771061
	DD	03f45a42dr			; 0.772036
	DD	03f45e403r			; 0.77301
	DD	03f4623bbr			; 0.773983
	DD	03f466354r			; 0.774953
	DD	03f46a2cer			; 0.775922
	DD	03f46e22ar			; 0.776888
	DD	03f472167r			; 0.777853
	DD	03f476085r			; 0.778817
	DD	03f479f84r			; 0.779778
	DD	03f47de65r			; 0.780737
	DD	03f481d27r			; 0.781695
	DD	03f485bcar			; 0.782651
	DD	03f489a4er			; 0.783605
	DD	03f48d8b3r			; 0.784557
	DD	03f4916far			; 0.785507
	DD	03f495521r			; 0.786455
	DD	03f499329r			; 0.787402
	DD	03f49d112r			; 0.788346
	DD	03f4a0edcr			; 0.789289
	DD	03f4a4c87r			; 0.79023
	DD	03f4a8a13r			; 0.791169
	DD	03f4ac77fr			; 0.792107
	DD	03f4b04ccr			; 0.793042
	DD	03f4b41far			; 0.793975
	DD	03f4b7f09r			; 0.794907
	DD	03f4bbbf8r			; 0.795837
	DD	03f4bf8c7r			; 0.796765
	DD	03f4c3578r			; 0.797691
	DD	03f4c7208r			; 0.798615
	DD	03f4cae79r			; 0.799537
	DD	03f4ceacbr			; 0.800458
	DD	03f4d26fdr			; 0.801376
	DD	03f4d6310r			; 0.802293
	DD	03f4d9f02r			; 0.803208
	DD	03f4ddad5r			; 0.80412
	DD	03f4e1689r			; 0.805031
	DD	03f4e521cr			; 0.80594
	DD	03f4e8d90r			; 0.806848
	DD	03f4ec8e4r			; 0.807753
	DD	03f4f0417r			; 0.808656
	DD	03f4f3f2br			; 0.809558
	DD	03f4f7a1fr			; 0.810457
	DD	03f4fb4f4r			; 0.811355
	DD	03f4fefa8r			; 0.812251
	DD	03f502a3br			; 0.813144
	DD	03f5064afr			; 0.814036
	DD	03f509f03r			; 0.814926
	DD	03f50d937r			; 0.815814
	DD	03f51134ar			; 0.816701
	DD	03f514d3dr			; 0.817585
	DD	03f518710r			; 0.818467
	DD	03f51c0c2r			; 0.819348
	DD	03f51fa54r			; 0.820226
	DD	03f5233c6r			; 0.821102
	DD	03f526d18r			; 0.821977
	DD	03f52a649r			; 0.82285
	DD	03f52df59r			; 0.823721
	DD	03f531849r			; 0.824589
	DD	03f535118r			; 0.825456
	DD	03f5389c7r			; 0.826321
	DD	03f53c255r			; 0.827184
	DD	03f53fac3r			; 0.828045
	DD	03f54330fr			; 0.828904
	DD	03f546b3br			; 0.829761
	DD	03f54a347r			; 0.830616
	DD	03f54db31r			; 0.83147
	DD	03f5512fbr			; 0.832321
	DD	03f554aa4r			; 0.83317
	DD	03f55822cr			; 0.834018
	DD	03f55b993r			; 0.834863
	DD	03f55f0d9r			; 0.835706
	DD	03f5627fer			; 0.836548
	DD	03f565f02r			; 0.837387
	DD	03f5695e5r			; 0.838225
	DD	03f56cca7r			; 0.83906
	DD	03f570348r			; 0.839894
	DD	03f5739c7r			; 0.840725
	DD	03f577026r			; 0.841555
	DD	03f57a663r			; 0.842383
	DD	03f57dc7fr			; 0.843208
	DD	03f581279r			; 0.844032
	DD	03f584853r			; 0.844854
	DD	03f587e0br			; 0.845673
	DD	03f58b3a1r			; 0.846491
	DD	03f58e916r			; 0.847307
	DD	03f591e6ar			; 0.84812
	DD	03f59539cr			; 0.848932
	DD	03f5988adr			; 0.849742
	DD	03f59bd9cr			; 0.850549
	DD	03f59f26ar			; 0.851355
	DD	03f5a2716r			; 0.852159
	DD	03f5a5ba0r			; 0.852961
	DD	03f5a9009r			; 0.85376
	DD	03f5ac450r			; 0.854558
	DD	03f5af875r			; 0.855354
	DD	03f5b2c79r			; 0.856147
	DD	03f5b605ar			; 0.856939
	DD	03f5b941ar			; 0.857729
	DD	03f5bc7b8r			; 0.858516
	DD	03f5bfb34r			; 0.859302
	DD	03f5c2e8er			; 0.860085
	DD	03f5c61c7r			; 0.860867
	DD	03f5c94ddr			; 0.861646
	DD	03f5cc7d1r			; 0.862424
	DD	03f5cfaa3r			; 0.863199
	DD	03f5d2d53r			; 0.863973
	DD	03f5d5fe1r			; 0.864744
	DD	03f5d924dr			; 0.865514
	DD	03f5dc497r			; 0.866281
	DD	03f5df6ber			; 0.867046
	DD	03f5e28c3r			; 0.867809
	DD	03f5e5aa6r			; 0.868571
	DD	03f5e8c67r			; 0.86933
	DD	03f5ebe05r			; 0.870087
	DD	03f5eef81r			; 0.870842
	DD	03f5f20dbr			; 0.871595
	DD	03f5f5212r			; 0.872346
	DD	03f5f8327r			; 0.873095
	DD	03f5fb419r			; 0.873842
	DD	03f5fe4e9r			; 0.874587
	DD	03f601596r			; 0.875329
	DD	03f604621r			; 0.87607
	DD	03f607689r			; 0.876809
	DD	03f60a6cfr			; 0.877545
	DD	03f60d6f2r			; 0.87828
	DD	03f6106f2r			; 0.879012
	DD	03f6136d0r			; 0.879743
	DD	03f61668ar			; 0.880471
	DD	03f619622r			; 0.881197
	DD	03f61c598r			; 0.881921
	DD	03f61f4ear			; 0.882643
	DD	03f62241ar			; 0.883363
	DD	03f625326r			; 0.884081
	DD	03f628210r			; 0.884797
	DD	03f62b0d7r			; 0.885511
	DD	03f62df7br			; 0.886223
	DD	03f630dfcr			; 0.886932
	DD	03f633c5ar			; 0.88764
	DD	03f636a95r			; 0.888345
	DD	03f6398acr			; 0.889048
	DD	03f63c6a1r			; 0.88975
	DD	03f63f473r			; 0.890449
	DD	03f642221r			; 0.891146
	DD	03f644facr			; 0.891841
	DD	03f647d14r			; 0.892534
	DD	03f64aa59r			; 0.893224
	DD	03f64d77br			; 0.893913
	DD	03f650479r			; 0.894599
	DD	03f653154r			; 0.895284
	DD	03f655e0br			; 0.895966
	DD	03f658aa0r			; 0.896646
	DD	03f65b710r			; 0.897325
	DD	03f65e35er			; 0.898001
	DD	03f660f88r			; 0.898674
	DD	03f663b8er			; 0.899346
	DD	03f666771r			; 0.900016
	DD	03f669330r			; 0.900683
	DD	03f66beccr			; 0.901349
	DD	03f66ea45r			; 0.902012
	DD	03f671599r			; 0.902673
	DD	03f6740car			; 0.903332
	DD	03f676bd8r			; 0.903989
	DD	03f6796c1r			; 0.904644
	DD	03f67c187r			; 0.905297
	DD	03f67ec29r			; 0.905947
	DD	03f6816a8r			; 0.906596
	DD	03f684103r			; 0.907242
	DD	03f686b39r			; 0.907886
	DD	03f68954cr			; 0.908528
	DD	03f68bf3cr			; 0.909168
	DD	03f68e907r			; 0.909806
	DD	03f6912aer			; 0.910441
	DD	03f693c32r			; 0.911075
	DD	03f696591r			; 0.911706
	DD	03f698eccr			; 0.912335
	DD	03f69b7e4r			; 0.912962
	DD	03f69e0d7r			; 0.913587
	DD	03f6a09a7r			; 0.91421
	DD	03f6a3252r			; 0.91483
	DD	03f6a5ad9r			; 0.915449
	DD	03f6a833cr			; 0.916065
	DD	03f6aab7br			; 0.916679
	DD	03f6ad395r			; 0.917291
	DD	03f6afb8cr			; 0.917901
	DD	03f6b235er			; 0.918508
	DD	03f6b4b0cr			; 0.919114
	DD	03f6b7295r			; 0.919717
	DD	03f6b99fbr			; 0.920318
	DD	03f6bc13br			; 0.920917
	DD	03f6be858r			; 0.921514
	DD	03f6c0f50r			; 0.922109
	DD	03f6c3624r			; 0.922701
	DD	03f6c5cd4r			; 0.923291
	DD	03f6c835er			; 0.92388
	DD	03f6ca9c5r			; 0.924465
	DD	03f6cd007r			; 0.925049
	DD	03f6cf624r			; 0.925631
	DD	03f6d1c1dr			; 0.92621
	DD	03f6d41f2r			; 0.926787
	DD	03f6d67a1r			; 0.927363
	DD	03f6d8d2dr			; 0.927935
	DD	03f6db293r			; 0.928506
	DD	03f6dd7d5r			; 0.929075
	DD	03f6dfcf2r			; 0.929641
	DD	03f6e21ebr			; 0.930205
	DD	03f6e46ber			; 0.930767
	DD	03f6e6b6dr			; 0.931327
	DD	03f6e8ff8r			; 0.931884
	DD	03f6eb45dr			; 0.93244
	DD	03f6ed89er			; 0.932993
	DD	03f6efcbar			; 0.933544
	DD	03f6f20b0r			; 0.934093
	DD	03f6f4483r			; 0.934639
	DD	03f6f6830r			; 0.935184
	DD	03f6f8bb8r			; 0.935726
	DD	03f6faf1br			; 0.936266
	DD	03f6fd25ar			; 0.936803
	DD	03f6ff573r			; 0.937339
	DD	03f701867r			; 0.937872
	DD	03f703b37r			; 0.938404
	DD	03f705de1r			; 0.938932
	DD	03f708066r			; 0.939459
	DD	03f70a2c6r			; 0.939984
	DD	03f70c501r			; 0.940506
	DD	03f70e717r			; 0.941026
	DD	03f710908r			; 0.941544
	DD	03f712ad4r			; 0.94206
	DD	03f714c7ar			; 0.942573
	DD	03f716dfbr			; 0.943084
	DD	03f718f57r			; 0.943593
	DD	03f71b08er			; 0.9441
	DD	03f71d19fr			; 0.944605
	DD	03f71f28cr			; 0.945107
	DD	03f721352r			; 0.945607
	DD	03f7233f4r			; 0.946105
	DD	03f725470r			; 0.946601
	DD	03f7274c7r			; 0.947094
	DD	03f7294f8r			; 0.947586
	DD	03f72b504r			; 0.948075
	DD	03f72d4ebr			; 0.948561
	DD	03f72f4acr			; 0.949046
	DD	03f731447r			; 0.949528
	DD	03f7333ber			; 0.950008
	DD	03f73530er			; 0.950486
	DD	03f737239r			; 0.950962
	DD	03f73913fr			; 0.951435
	DD	03f73b01fr			; 0.951906
	DD	03f73ced9r			; 0.952375
	DD	03f73ed6er			; 0.952842
	DD	03f740bddr			; 0.953306
	DD	03f742a27r			; 0.953768
	DD	03f74484br			; 0.954228
	DD	03f746649r			; 0.954686
	DD	03f748422r			; 0.955141
	DD	03f74a1d5r			; 0.955594
	DD	03f74bf62r			; 0.956045
	DD	03f74dcc9r			; 0.956494
	DD	03f74fa0br			; 0.95694
	DD	03f751727r			; 0.957385
	DD	03f75341dr			; 0.957826
	DD	03f7550edr			; 0.958266
	DD	03f756d97r			; 0.958703
	DD	03f758a1cr			; 0.959139
	DD	03f75a67br			; 0.959572
	DD	03f75c2b3r			; 0.960002
	DD	03f75dec6r			; 0.960431
	DD	03f75fab3r			; 0.960857
	DD	03f76167ar			; 0.96128
	DD	03f76321br			; 0.961702
	DD	03f764d97r			; 0.962121
	DD	03f7668ecr			; 0.962538
	DD	03f76841br			; 0.962953
	DD	03f769f24r			; 0.963366
	DD	03f76ba07r			; 0.963776
	DD	03f76d4c4r			; 0.964184
	DD	03f76ef5br			; 0.96459
	DD	03f7709ccr			; 0.964993
	DD	03f772417r			; 0.965394
	DD	03f773e3cr			; 0.965793
	DD	03f77583ar			; 0.96619
	DD	03f777213r			; 0.966584
	DD	03f778bc5r			; 0.966976
	DD	03f77a551r			; 0.967366
	DD	03f77beb7r			; 0.967754
	DD	03f77d7f7r			; 0.968139
	DD	03f77f110r			; 0.968522
	DD	03f780a04r			; 0.968903
	DD	03f7822d1r			; 0.969281
	DD	03f783b77r			; 0.969657
	DD	03f7853f8r			; 0.970031
	DD	03f786c52r			; 0.970403
	DD	03f788486r			; 0.970772
	DD	03f789c93r			; 0.971139
	DD	03f78b47br			; 0.971504
	DD	03f78cc3br			; 0.971866
	DD	03f78e3d6r			; 0.972227
	DD	03f78fb4ar			; 0.972584
	DD	03f791298r			; 0.97294
	DD	03f7929bfr			; 0.973293
	DD	03f7940c0r			; 0.973644
	DD	03f79579ar			; 0.973993
	DD	03f796e4er			; 0.974339
	DD	03f7984dcr			; 0.974684
	DD	03f799b43r			; 0.975025
	DD	03f79b183r			; 0.975365
	DD	03f79c79dr			; 0.975702
	DD	03f79dd91r			; 0.976037
	DD	03f79f35er			; 0.97637
	DD	03f7a0904r			; 0.9767
	DD	03f7a1e84r			; 0.977028
	DD	03f7a33ddr			; 0.977354
	DD	03f7a4910r			; 0.977677
	DD	03f7a5e1cr			; 0.977998
	DD	03f7a7302r			; 0.978317
	DD	03f7a87c1r			; 0.978634
	DD	03f7a9c59r			; 0.978948
	DD	03f7ab0cbr			; 0.97926
	DD	03f7ac516r			; 0.97957
	DD	03f7ad93ar			; 0.979877
	DD	03f7aed37r			; 0.980182
	DD	03f7b010er			; 0.980485
	DD	03f7b14ber			; 0.980785
	DD	03f7b2848r			; 0.981083
	DD	03f7b3babr			; 0.981379
	DD	03f7b4ee7r			; 0.981673
	DD	03f7b61fcr			; 0.981964
	DD	03f7b74ear			; 0.982253
	DD	03f7b87b2r			; 0.982539
	DD	03f7b9a53r			; 0.982824
	DD	03f7baccdr			; 0.983105
	DD	03f7bbf20r			; 0.983385
	DD	03f7bd14dr			; 0.983662
	DD	03f7be353r			; 0.983937
	DD	03f7bf531r			; 0.98421
	DD	03f7c06e9r			; 0.98448
	DD	03f7c187ar			; 0.984748
	DD	03f7c29e5r			; 0.985014
	DD	03f7c3b28r			; 0.985278
	DD	03f7c4c44r			; 0.985539
	DD	03f7c5d3ar			; 0.985798
	DD	03f7c6e08r			; 0.986054
	DD	03f7c7eb0r			; 0.986308
	DD	03f7c8f31r			; 0.98656
	DD	03f7c9f8ar			; 0.986809
	DD	03f7cafbdr			; 0.987057
	DD	03f7cbfc9r			; 0.987301
	DD	03f7ccfaer			; 0.987544
	DD	03f7cdf6cr			; 0.987784
	DD	03f7cef03r			; 0.988022
	DD	03f7cfe73r			; 0.988258
	DD	03f7d0dbcr			; 0.988491
	DD	03f7d1cddr			; 0.988722
	DD	03f7d2bd8r			; 0.98895
	DD	03f7d3aacr			; 0.989177
	DD	03f7d4959r			; 0.9894
	DD	03f7d57der			; 0.989622
	DD	03f7d663dr			; 0.989841
	DD	03f7d7474r			; 0.990058
	DD	03f7d8285r			; 0.990273
	DD	03f7d906er			; 0.990485
	DD	03f7d9e30r			; 0.990695
	DD	03f7dabccr			; 0.990903
	DD	03f7db940r			; 0.991108
	DD	03f7dc68cr			; 0.991311
	DD	03f7dd3b2r			; 0.991511
	DD	03f7de0b1r			; 0.99171
	DD	03f7ded88r			; 0.991906
	DD	03f7dfa38r			; 0.992099
	DD	03f7e06c2r			; 0.992291
	DD	03f7e1324r			; 0.99248
	DD	03f7e1f5er			; 0.992666
	DD	03f7e2b72r			; 0.99285
	DD	03f7e375er			; 0.993032
	DD	03f7e4323r			; 0.993212
	DD	03f7e4ec1r			; 0.993389
	DD	03f7e5a38r			; 0.993564
	DD	03f7e6588r			; 0.993737
	DD	03f7e70b0r			; 0.993907
	DD	03f7e7bb1r			; 0.994075
	DD	03f7e868br			; 0.99424
	DD	03f7e913dr			; 0.994404
	DD	03f7e9bc9r			; 0.994565
	DD	03f7ea62dr			; 0.994723
	DD	03f7eb069r			; 0.994879
	DD	03f7eba7fr			; 0.995033
	DD	03f7ec46dr			; 0.995185
	DD	03f7ece34r			; 0.995334
	DD	03f7ed7d4r			; 0.995481
	DD	03f7ee14cr			; 0.995625
	DD	03f7eea9dr			; 0.995767
	DD	03f7ef3c7r			; 0.995907
	DD	03f7efcc9r			; 0.996045
	DD	03f7f05a4r			; 0.99618
	DD	03f7f0e58r			; 0.996313
	DD	03f7f16e4r			; 0.996443
	DD	03f7f1f49r			; 0.996571
	DD	03f7f2787r			; 0.996697
	DD	03f7f2f9dr			; 0.99682
	DD	03f7f378cr			; 0.996941
	DD	03f7f3f54r			; 0.99706
	DD	03f7f46f4r			; 0.997176
	DD	03f7f4e6dr			; 0.99729
	DD	03f7f55bfr			; 0.997402
	DD	03f7f5ce9r			; 0.997511
	DD	03f7f63ecr			; 0.997618
	DD	03f7f6ac7r			; 0.997723
	DD	03f7f717br			; 0.997825
	DD	03f7f7808r			; 0.997925
	DD	03f7f7e6dr			; 0.998023
	DD	03f7f84abr			; 0.998118
	DD	03f7f8ac2r			; 0.998211
	DD	03f7f90b1r			; 0.998302
	DD	03f7f9678r			; 0.99839
	DD	03f7f9c18r			; 0.998476
	DD	03f7fa191r			; 0.998559
	DD	03f7fa6e3r			; 0.99864
	DD	03f7fac0dr			; 0.998719
	DD	03f7fb10fr			; 0.998795
	DD	03f7fb5ear			; 0.99887
	DD	03f7fba9er			; 0.998941
	DD	03f7fbf2ar			; 0.999011
	DD	03f7fc38fr			; 0.999078
	DD	03f7fc7ccr			; 0.999142
	DD	03f7fcbe2r			; 0.999205
	DD	03f7fcfd1r			; 0.999265
	DD	03f7fd397r			; 0.999322
	DD	03f7fd737r			; 0.999378
	DD	03f7fdaafr			; 0.999431
	DD	03f7fde00r			; 0.999481
	DD	03f7fe129r			; 0.999529
	DD	03f7fe42br			; 0.999575
	DD	03f7fe705r			; 0.999619
	DD	03f7fe9b8r			; 0.99966
	DD	03f7fec43r			; 0.999699
	DD	03f7feea7r			; 0.999735
	DD	03f7ff0e3r			; 0.999769
	DD	03f7ff2f8r			; 0.999801
	DD	03f7ff4e6r			; 0.999831
	DD	03f7ff6acr			; 0.999858
	DD	03f7ff84ar			; 0.999882
	DD	03f7ff9c1r			; 0.999905
	DD	03f7ffb11r			; 0.999925
	DD	03f7ffc39r			; 0.999942
	DD	03f7ffd39r			; 0.999958
	DD	03f7ffe13r			; 0.999971
	DD	03f7ffec4r			; 0.999981
	DD	03f7fff4er			; 0.999989
	DD	03f7fffb1r			; 0.999995
	DD	03f7fffecr			; 0.999999
	DD	03f800000r			; 1
	DD	03f7fffecr			; 0.999999
	DD	03f7fffb1r			; 0.999995
	DD	03f7fff4er			; 0.999989
	DD	03f7ffec4r			; 0.999981
	DD	03f7ffe13r			; 0.999971
	DD	03f7ffd39r			; 0.999958
	DD	03f7ffc39r			; 0.999942
	DD	03f7ffb11r			; 0.999925
	DD	03f7ff9c1r			; 0.999905
	DD	03f7ff84ar			; 0.999882
	DD	03f7ff6acr			; 0.999858
	DD	03f7ff4e6r			; 0.999831
	DD	03f7ff2f8r			; 0.999801
	DD	03f7ff0e3r			; 0.999769
	DD	03f7feea7r			; 0.999735
	DD	03f7fec43r			; 0.999699
	DD	03f7fe9b8r			; 0.99966
	DD	03f7fe705r			; 0.999619
	DD	03f7fe42br			; 0.999575
	DD	03f7fe129r			; 0.999529
	DD	03f7fde00r			; 0.999481
	DD	03f7fdaafr			; 0.999431
	DD	03f7fd737r			; 0.999378
	DD	03f7fd397r			; 0.999322
	DD	03f7fcfd1r			; 0.999265
	DD	03f7fcbe2r			; 0.999205
	DD	03f7fc7ccr			; 0.999142
	DD	03f7fc38fr			; 0.999078
	DD	03f7fbf2ar			; 0.999011
	DD	03f7fba9er			; 0.998941
	DD	03f7fb5ear			; 0.99887
	DD	03f7fb10fr			; 0.998795
	DD	03f7fac0dr			; 0.998719
	DD	03f7fa6e3r			; 0.99864
	DD	03f7fa191r			; 0.998559
	DD	03f7f9c18r			; 0.998476
	DD	03f7f9678r			; 0.99839
	DD	03f7f90b1r			; 0.998302
	DD	03f7f8ac2r			; 0.998211
	DD	03f7f84abr			; 0.998118
	DD	03f7f7e6dr			; 0.998023
	DD	03f7f7808r			; 0.997925
	DD	03f7f717br			; 0.997825
	DD	03f7f6ac7r			; 0.997723
	DD	03f7f63ecr			; 0.997618
	DD	03f7f5ce9r			; 0.997511
	DD	03f7f55bfr			; 0.997402
	DD	03f7f4e6dr			; 0.99729
	DD	03f7f46f4r			; 0.997176
	DD	03f7f3f54r			; 0.99706
	DD	03f7f378cr			; 0.996941
	DD	03f7f2f9dr			; 0.99682
	DD	03f7f2787r			; 0.996697
	DD	03f7f1f49r			; 0.996571
	DD	03f7f16e4r			; 0.996443
	DD	03f7f0e58r			; 0.996313
	DD	03f7f05a4r			; 0.99618
	DD	03f7efcc9r			; 0.996045
	DD	03f7ef3c7r			; 0.995907
	DD	03f7eea9dr			; 0.995767
	DD	03f7ee14cr			; 0.995625
	DD	03f7ed7d4r			; 0.995481
	DD	03f7ece34r			; 0.995334
	DD	03f7ec46dr			; 0.995185
	DD	03f7eba7fr			; 0.995033
	DD	03f7eb069r			; 0.994879
	DD	03f7ea62dr			; 0.994723
	DD	03f7e9bc9r			; 0.994565
	DD	03f7e913dr			; 0.994404
	DD	03f7e868br			; 0.99424
	DD	03f7e7bb1r			; 0.994075
	DD	03f7e70b0r			; 0.993907
	DD	03f7e6588r			; 0.993737
	DD	03f7e5a38r			; 0.993564
	DD	03f7e4ec1r			; 0.993389
	DD	03f7e4323r			; 0.993212
	DD	03f7e375er			; 0.993032
	DD	03f7e2b72r			; 0.99285
	DD	03f7e1f5er			; 0.992666
	DD	03f7e1324r			; 0.99248
	DD	03f7e06c2r			; 0.992291
	DD	03f7dfa38r			; 0.992099
	DD	03f7ded88r			; 0.991906
	DD	03f7de0b1r			; 0.99171
	DD	03f7dd3b2r			; 0.991511
	DD	03f7dc68cr			; 0.991311
	DD	03f7db940r			; 0.991108
	DD	03f7dabccr			; 0.990903
	DD	03f7d9e30r			; 0.990695
	DD	03f7d906er			; 0.990485
	DD	03f7d8285r			; 0.990273
	DD	03f7d7474r			; 0.990058
	DD	03f7d663dr			; 0.989841
	DD	03f7d57der			; 0.989622
	DD	03f7d4959r			; 0.9894
	DD	03f7d3aacr			; 0.989177
	DD	03f7d2bd8r			; 0.98895
	DD	03f7d1cddr			; 0.988722
	DD	03f7d0dbcr			; 0.988491
	DD	03f7cfe73r			; 0.988258
	DD	03f7cef03r			; 0.988022
	DD	03f7cdf6cr			; 0.987784
	DD	03f7ccfaer			; 0.987544
	DD	03f7cbfc9r			; 0.987301
	DD	03f7cafbdr			; 0.987057
	DD	03f7c9f8ar			; 0.986809
	DD	03f7c8f31r			; 0.98656
	DD	03f7c7eb0r			; 0.986308
	DD	03f7c6e08r			; 0.986054
	DD	03f7c5d3ar			; 0.985798
	DD	03f7c4c44r			; 0.985539
	DD	03f7c3b28r			; 0.985278
	DD	03f7c29e5r			; 0.985014
	DD	03f7c187ar			; 0.984748
	DD	03f7c06e9r			; 0.98448
	DD	03f7bf531r			; 0.98421
	DD	03f7be353r			; 0.983937
	DD	03f7bd14dr			; 0.983662
	DD	03f7bbf20r			; 0.983385
	DD	03f7baccdr			; 0.983105
	DD	03f7b9a53r			; 0.982824
	DD	03f7b87b2r			; 0.982539
	DD	03f7b74ear			; 0.982253
	DD	03f7b61fcr			; 0.981964
	DD	03f7b4ee7r			; 0.981673
	DD	03f7b3babr			; 0.981379
	DD	03f7b2848r			; 0.981083
	DD	03f7b14ber			; 0.980785
	DD	03f7b010er			; 0.980485
	DD	03f7aed37r			; 0.980182
	DD	03f7ad93ar			; 0.979877
	DD	03f7ac516r			; 0.97957
	DD	03f7ab0cbr			; 0.97926
	DD	03f7a9c59r			; 0.978948
	DD	03f7a87c1r			; 0.978634
	DD	03f7a7302r			; 0.978317
	DD	03f7a5e1cr			; 0.977998
	DD	03f7a4910r			; 0.977677
	DD	03f7a33ddr			; 0.977354
	DD	03f7a1e84r			; 0.977028
	DD	03f7a0904r			; 0.9767
	DD	03f79f35er			; 0.97637
	DD	03f79dd91r			; 0.976037
	DD	03f79c79dr			; 0.975702
	DD	03f79b183r			; 0.975365
	DD	03f799b43r			; 0.975025
	DD	03f7984dcr			; 0.974684
	DD	03f796e4er			; 0.974339
	DD	03f79579ar			; 0.973993
	DD	03f7940c0r			; 0.973644
	DD	03f7929bfr			; 0.973293
	DD	03f791298r			; 0.97294
	DD	03f78fb4ar			; 0.972584
	DD	03f78e3d6r			; 0.972227
	DD	03f78cc3br			; 0.971866
	DD	03f78b47br			; 0.971504
	DD	03f789c93r			; 0.971139
	DD	03f788486r			; 0.970772
	DD	03f786c52r			; 0.970403
	DD	03f7853f8r			; 0.970031
	DD	03f783b77r			; 0.969657
	DD	03f7822d1r			; 0.969281
	DD	03f780a04r			; 0.968903
	DD	03f77f110r			; 0.968522
	DD	03f77d7f7r			; 0.968139
	DD	03f77beb7r			; 0.967754
	DD	03f77a551r			; 0.967366
	DD	03f778bc5r			; 0.966976
	DD	03f777213r			; 0.966584
	DD	03f77583ar			; 0.96619
	DD	03f773e3cr			; 0.965793
	DD	03f772417r			; 0.965394
	DD	03f7709ccr			; 0.964993
	DD	03f76ef5br			; 0.96459
	DD	03f76d4c4r			; 0.964184
	DD	03f76ba07r			; 0.963776
	DD	03f769f24r			; 0.963366
	DD	03f76841br			; 0.962953
	DD	03f7668ecr			; 0.962538
	DD	03f764d97r			; 0.962121
	DD	03f76321br			; 0.961702
	DD	03f76167ar			; 0.96128
	DD	03f75fab3r			; 0.960857
	DD	03f75dec6r			; 0.960431
	DD	03f75c2b3r			; 0.960002
	DD	03f75a67br			; 0.959572
	DD	03f758a1cr			; 0.959139
	DD	03f756d97r			; 0.958703
	DD	03f7550edr			; 0.958266
	DD	03f75341dr			; 0.957826
	DD	03f751727r			; 0.957385
	DD	03f74fa0br			; 0.95694
	DD	03f74dcc9r			; 0.956494
	DD	03f74bf62r			; 0.956045
	DD	03f74a1d5r			; 0.955594
	DD	03f748422r			; 0.955141
	DD	03f746649r			; 0.954686
	DD	03f74484br			; 0.954228
	DD	03f742a27r			; 0.953768
	DD	03f740bddr			; 0.953306
	DD	03f73ed6er			; 0.952842
	DD	03f73ced9r			; 0.952375
	DD	03f73b01fr			; 0.951906
	DD	03f73913fr			; 0.951435
	DD	03f737239r			; 0.950962
	DD	03f73530er			; 0.950486
	DD	03f7333ber			; 0.950008
	DD	03f731447r			; 0.949528
	DD	03f72f4acr			; 0.949046
	DD	03f72d4ebr			; 0.948561
	DD	03f72b504r			; 0.948075
	DD	03f7294f8r			; 0.947586
	DD	03f7274c7r			; 0.947094
	DD	03f725470r			; 0.946601
	DD	03f7233f4r			; 0.946105
	DD	03f721352r			; 0.945607
	DD	03f71f28cr			; 0.945107
	DD	03f71d19fr			; 0.944605
	DD	03f71b08er			; 0.9441
	DD	03f718f57r			; 0.943593
	DD	03f716dfbr			; 0.943084
	DD	03f714c7ar			; 0.942573
	DD	03f712ad4r			; 0.94206
	DD	03f710908r			; 0.941544
	DD	03f70e717r			; 0.941026
	DD	03f70c501r			; 0.940506
	DD	03f70a2c6r			; 0.939984
	DD	03f708066r			; 0.939459
	DD	03f705de1r			; 0.938932
	DD	03f703b37r			; 0.938404
	DD	03f701867r			; 0.937872
	DD	03f6ff573r			; 0.937339
	DD	03f6fd25ar			; 0.936803
	DD	03f6faf1br			; 0.936266
	DD	03f6f8bb8r			; 0.935726
	DD	03f6f6830r			; 0.935184
	DD	03f6f4483r			; 0.934639
	DD	03f6f20b0r			; 0.934093
	DD	03f6efcbar			; 0.933544
	DD	03f6ed89er			; 0.932993
	DD	03f6eb45dr			; 0.93244
	DD	03f6e8ff8r			; 0.931884
	DD	03f6e6b6dr			; 0.931327
	DD	03f6e46ber			; 0.930767
	DD	03f6e21ebr			; 0.930205
	DD	03f6dfcf2r			; 0.929641
	DD	03f6dd7d5r			; 0.929075
	DD	03f6db293r			; 0.928506
	DD	03f6d8d2dr			; 0.927935
	DD	03f6d67a1r			; 0.927363
	DD	03f6d41f2r			; 0.926787
	DD	03f6d1c1dr			; 0.92621
	DD	03f6cf624r			; 0.925631
	DD	03f6cd007r			; 0.925049
	DD	03f6ca9c5r			; 0.924465
	DD	03f6c835er			; 0.92388
	DD	03f6c5cd4r			; 0.923291
	DD	03f6c3624r			; 0.922701
	DD	03f6c0f50r			; 0.922109
	DD	03f6be858r			; 0.921514
	DD	03f6bc13br			; 0.920917
	DD	03f6b99fbr			; 0.920318
	DD	03f6b7295r			; 0.919717
	DD	03f6b4b0cr			; 0.919114
	DD	03f6b235er			; 0.918508
	DD	03f6afb8cr			; 0.917901
	DD	03f6ad395r			; 0.917291
	DD	03f6aab7br			; 0.916679
	DD	03f6a833cr			; 0.916065
	DD	03f6a5ad9r			; 0.915449
	DD	03f6a3252r			; 0.91483
	DD	03f6a09a7r			; 0.91421
	DD	03f69e0d7r			; 0.913587
	DD	03f69b7e4r			; 0.912962
	DD	03f698eccr			; 0.912335
	DD	03f696591r			; 0.911706
	DD	03f693c32r			; 0.911075
	DD	03f6912aer			; 0.910441
	DD	03f68e907r			; 0.909806
	DD	03f68bf3cr			; 0.909168
	DD	03f68954cr			; 0.908528
	DD	03f686b39r			; 0.907886
	DD	03f684103r			; 0.907242
	DD	03f6816a8r			; 0.906596
	DD	03f67ec29r			; 0.905947
	DD	03f67c187r			; 0.905297
	DD	03f6796c1r			; 0.904644
	DD	03f676bd8r			; 0.903989
	DD	03f6740car			; 0.903332
	DD	03f671599r			; 0.902673
	DD	03f66ea45r			; 0.902012
	DD	03f66beccr			; 0.901349
	DD	03f669330r			; 0.900683
	DD	03f666771r			; 0.900016
	DD	03f663b8er			; 0.899346
	DD	03f660f88r			; 0.898674
	DD	03f65e35er			; 0.898001
	DD	03f65b710r			; 0.897325
	DD	03f658aa0r			; 0.896646
	DD	03f655e0br			; 0.895966
	DD	03f653154r			; 0.895284
	DD	03f650479r			; 0.894599
	DD	03f64d77br			; 0.893913
	DD	03f64aa59r			; 0.893224
	DD	03f647d14r			; 0.892534
	DD	03f644facr			; 0.891841
	DD	03f642221r			; 0.891146
	DD	03f63f473r			; 0.890449
	DD	03f63c6a1r			; 0.88975
	DD	03f6398acr			; 0.889048
	DD	03f636a95r			; 0.888345
	DD	03f633c5ar			; 0.88764
	DD	03f630dfcr			; 0.886932
	DD	03f62df7br			; 0.886223
	DD	03f62b0d7r			; 0.885511
	DD	03f628210r			; 0.884797
	DD	03f625326r			; 0.884081
	DD	03f62241ar			; 0.883363
	DD	03f61f4ear			; 0.882643
	DD	03f61c598r			; 0.881921
	DD	03f619622r			; 0.881197
	DD	03f61668ar			; 0.880471
	DD	03f6136d0r			; 0.879743
	DD	03f6106f2r			; 0.879012
	DD	03f60d6f2r			; 0.87828
	DD	03f60a6cfr			; 0.877545
	DD	03f607689r			; 0.876809
	DD	03f604621r			; 0.87607
	DD	03f601596r			; 0.875329
	DD	03f5fe4e9r			; 0.874587
	DD	03f5fb419r			; 0.873842
	DD	03f5f8327r			; 0.873095
	DD	03f5f5212r			; 0.872346
	DD	03f5f20dbr			; 0.871595
	DD	03f5eef81r			; 0.870842
	DD	03f5ebe05r			; 0.870087
	DD	03f5e8c67r			; 0.86933
	DD	03f5e5aa6r			; 0.868571
	DD	03f5e28c3r			; 0.867809
	DD	03f5df6ber			; 0.867046
	DD	03f5dc497r			; 0.866281
	DD	03f5d924dr			; 0.865514
	DD	03f5d5fe1r			; 0.864744
	DD	03f5d2d53r			; 0.863973
	DD	03f5cfaa3r			; 0.863199
	DD	03f5cc7d1r			; 0.862424
	DD	03f5c94ddr			; 0.861646
	DD	03f5c61c7r			; 0.860867
	DD	03f5c2e8er			; 0.860085
	DD	03f5bfb34r			; 0.859302
	DD	03f5bc7b8r			; 0.858516
	DD	03f5b941ar			; 0.857729
	DD	03f5b605ar			; 0.856939
	DD	03f5b2c79r			; 0.856147
	DD	03f5af875r			; 0.855354
	DD	03f5ac450r			; 0.854558
	DD	03f5a9009r			; 0.85376
	DD	03f5a5ba0r			; 0.852961
	DD	03f5a2716r			; 0.852159
	DD	03f59f26ar			; 0.851355
	DD	03f59bd9cr			; 0.850549
	DD	03f5988adr			; 0.849742
	DD	03f59539cr			; 0.848932
	DD	03f591e6ar			; 0.84812
	DD	03f58e916r			; 0.847307
	DD	03f58b3a1r			; 0.846491
	DD	03f587e0br			; 0.845673
	DD	03f584853r			; 0.844854
	DD	03f581279r			; 0.844032
	DD	03f57dc7fr			; 0.843208
	DD	03f57a663r			; 0.842383
	DD	03f577026r			; 0.841555
	DD	03f5739c7r			; 0.840725
	DD	03f570348r			; 0.839894
	DD	03f56cca7r			; 0.83906
	DD	03f5695e5r			; 0.838225
	DD	03f565f02r			; 0.837387
	DD	03f5627fer			; 0.836548
	DD	03f55f0d9r			; 0.835706
	DD	03f55b993r			; 0.834863
	DD	03f55822cr			; 0.834018
	DD	03f554aa4r			; 0.83317
	DD	03f5512fbr			; 0.832321
	DD	03f54db31r			; 0.83147
	DD	03f54a347r			; 0.830616
	DD	03f546b3br			; 0.829761
	DD	03f54330fr			; 0.828904
	DD	03f53fac3r			; 0.828045
	DD	03f53c255r			; 0.827184
	DD	03f5389c7r			; 0.826321
	DD	03f535118r			; 0.825456
	DD	03f531849r			; 0.824589
	DD	03f52df59r			; 0.823721
	DD	03f52a649r			; 0.82285
	DD	03f526d18r			; 0.821977
	DD	03f5233c6r			; 0.821102
	DD	03f51fa54r			; 0.820226
	DD	03f51c0c2r			; 0.819348
	DD	03f518710r			; 0.818467
	DD	03f514d3dr			; 0.817585
	DD	03f51134ar			; 0.816701
	DD	03f50d937r			; 0.815814
	DD	03f509f03r			; 0.814926
	DD	03f5064afr			; 0.814036
	DD	03f502a3br			; 0.813144
	DD	03f4fefa8r			; 0.812251
	DD	03f4fb4f4r			; 0.811355
	DD	03f4f7a1fr			; 0.810457
	DD	03f4f3f2br			; 0.809558
	DD	03f4f0417r			; 0.808656
	DD	03f4ec8e4r			; 0.807753
	DD	03f4e8d90r			; 0.806848
	DD	03f4e521cr			; 0.80594
	DD	03f4e1689r			; 0.805031
	DD	03f4ddad5r			; 0.80412
	DD	03f4d9f02r			; 0.803208
	DD	03f4d6310r			; 0.802293
	DD	03f4d26fdr			; 0.801376
	DD	03f4ceacbr			; 0.800458
	DD	03f4cae79r			; 0.799537
	DD	03f4c7208r			; 0.798615
	DD	03f4c3578r			; 0.797691
	DD	03f4bf8c7r			; 0.796765
	DD	03f4bbbf8r			; 0.795837
	DD	03f4b7f09r			; 0.794907
	DD	03f4b41far			; 0.793975
	DD	03f4b04ccr			; 0.793042
	DD	03f4ac77fr			; 0.792107
	DD	03f4a8a13r			; 0.791169
	DD	03f4a4c87r			; 0.79023
	DD	03f4a0edcr			; 0.789289
	DD	03f49d112r			; 0.788346
	DD	03f499329r			; 0.787402
	DD	03f495521r			; 0.786455
	DD	03f4916far			; 0.785507
	DD	03f48d8b3r			; 0.784557
	DD	03f489a4er			; 0.783605
	DD	03f485bcar			; 0.782651
	DD	03f481d27r			; 0.781695
	DD	03f47de65r			; 0.780737
	DD	03f479f84r			; 0.779778
	DD	03f476085r			; 0.778817
	DD	03f472167r			; 0.777853
	DD	03f46e22ar			; 0.776888
	DD	03f46a2cer			; 0.775922
	DD	03f466354r			; 0.774953
	DD	03f4623bbr			; 0.773983
	DD	03f45e403r			; 0.77301
	DD	03f45a42dr			; 0.772036
	DD	03f456439r			; 0.771061
	DD	03f452426r			; 0.770083
	DD	03f44e3f5r			; 0.769103
	DD	03f44a3a5r			; 0.768122
	DD	03f446337r			; 0.767139
	DD	03f4422abr			; 0.766154
	DD	03f43e200r			; 0.765167
	DD	03f43a138r			; 0.764179
	DD	03f436051r			; 0.763188
	DD	03f431f4cr			; 0.762196
	DD	03f42de29r			; 0.761202
	DD	03f429ce8r			; 0.760207
	DD	03f425b89r			; 0.759209
	DD	03f421a0br			; 0.75821
	DD	03f41d870r			; 0.757209
	DD	03f4196b7r			; 0.756206
	DD	03f4154e1r			; 0.755201
	DD	03f4112ecr			; 0.754195
	DD	03f40d0dar			; 0.753187
	DD	03f408ea9r			; 0.752177
	DD	03f404c5cr			; 0.751165
	DD	03f4009f0r			; 0.750152
	DD	03f3fc767r			; 0.749136
	DD	03f3f84c0r			; 0.748119
	DD	03f3f41fcr			; 0.747101
	DD	03f3eff1br			; 0.74608
	DD	03f3ebc1br			; 0.745058
	DD	03f3e78ffr			; 0.744034
	DD	03f3e35c5r			; 0.743008
	DD	03f3df26er			; 0.74198
	DD	03f3daef9r			; 0.740951
	DD	03f3d6b67r			; 0.73992
	DD	03f3d27b8r			; 0.738887
	DD	03f3ce3ecr			; 0.737853
	DD	03f3ca003r			; 0.736817
	DD	03f3c5bfcr			; 0.735779
	DD	03f3c17d9r			; 0.734739
	DD	03f3bd398r			; 0.733697
	DD	03f3b8f3br			; 0.732654
	DD	03f3b4ac1r			; 0.731609
	DD	03f3b0629r			; 0.730563
	DD	03f3ac175r			; 0.729514
	DD	03f3a7ca4r			; 0.728464
	DD	03f3a37b7r			; 0.727413
	DD	03f39f2acr			; 0.726359
	DD	03f39ad85r			; 0.725304
	DD	03f396842r			; 0.724247
	DD	03f3922e1r			; 0.723188
	DD	03f38dd65r			; 0.722128
	DD	03f3897cbr			; 0.721066
	DD	03f385216r			; 0.720003
	DD	03f380c43r			; 0.718937
	DD	03f37c655r			; 0.71787
	DD	03f37804ar			; 0.716801
	DD	03f373a23r			; 0.715731
	DD	03f36f3dfr			; 0.714659
	DD	03f36ad7fr			; 0.713585
	DD	03f366704r			; 0.712509
	DD	03f36206cr			; 0.711432
	DD	03f35d9b8r			; 0.710353
	DD	03f3592e7r			; 0.709273
	DD	03f354bfbr			; 0.708191
	DD	03f3504f3r			; 0.707107
	DD	03f34bdcfr			; 0.706021
	DD	03f34768fr			; 0.704934
	DD	03f342f34r			; 0.703845
	DD	03f33e7bcr			; 0.702755
	DD	03f33a029r			; 0.701663
	DD	03f33587ar			; 0.700569
	DD	03f3310afr			; 0.699473
	DD	03f32c8c9r			; 0.698376
	DD	03f3280c7r			; 0.697277
	DD	03f3238aar			; 0.696177
	DD	03f31f071r			; 0.695075
	DD	03f31a81dr			; 0.693971
	DD	03f315fadr			; 0.692866
	DD	03f311722r			; 0.691759
	DD	03f30ce7cr			; 0.690651
	DD	03f3085bbr			; 0.689541
	DD	03f303cder			; 0.688429
	DD	03f2ff3e6r			; 0.687315
	DD	03f2faad3r			; 0.6862
	DD	03f2f61a5r			; 0.685084
	DD	03f2f185br			; 0.683965
	DD	03f2ecef7r			; 0.682846
	DD	03f2e8578r			; 0.681724
	DD	03f2e3bder			; 0.680601
	DD	03f2df229r			; 0.679476
	DD	03f2da859r			; 0.67835
	DD	03f2d5e6fr			; 0.677222
	DD	03f2d1469r			; 0.676093
	DD	03f2cca49r			; 0.674962
	DD	03f2c800fr			; 0.673829
	DD	03f2c35b9r			; 0.672695
	DD	03f2beb4ar			; 0.671559
	DD	03f2ba0bfr			; 0.670422
	DD	03f2b561br			; 0.669283
	DD	03f2b0b5br			; 0.668142
	DD	03f2ac082r			; 0.667
	DD	03f2a758er			; 0.665856
	DD	03f2a2a80r			; 0.664711
	DD	03f29df57r			; 0.663564
	DD	03f299415r			; 0.662416
	DD	03f2948b8r			; 0.661266
	DD	03f28fd41r			; 0.660114
	DD	03f28b1b0r			; 0.658961
	DD	03f286605r			; 0.657807
	DD	03f281a40r			; 0.656651
	DD	03f27ce61r			; 0.655493
	DD	03f278268r			; 0.654334
	DD	03f273656r			; 0.653173
	DD	03f26ea2ar			; 0.652011
	DD	03f269de3r			; 0.650847
	DD	03f265184r			; 0.649681
	DD	03f26050ar			; 0.648514
	DD	03f25b877r			; 0.647346
	DD	03f256bcbr			; 0.646176
	DD	03f251f04r			; 0.645005
	DD	03f24d225r			; 0.643832
	DD	03f24852cr			; 0.642657
	DD	03f24381ar			; 0.641481
	DD	03f23eaeer			; 0.640303
	DD	03f239da9r			; 0.639124
	DD	03f23504br			; 0.637944
	DD	03f2302d3r			; 0.636762
	DD	03f22b543r			; 0.635578
	DD	03f226799r			; 0.634393
	DD	03f2219d7r			; 0.633207
	DD	03f21cbfbr			; 0.632019
	DD	03f217e06r			; 0.630829
	DD	03f212ff9r			; 0.629638
	DD	03f20e1d2r			; 0.628446
	DD	03f209393r			; 0.627252
	DD	03f20453br			; 0.626056
	DD	03f1ff6cbr			; 0.62486
	DD	03f1fa841r			; 0.623661
	DD	03f1f599fr			; 0.622461
	DD	03f1f0ae5r			; 0.62126
	DD	03f1ebc12r			; 0.620057
	DD	03f1e6d26r			; 0.618853
	DD	03f1e1e22r			; 0.617647
	DD	03f1dcf06r			; 0.61644
	DD	03f1d7fd1r			; 0.615232
	DD	03f1d3084r			; 0.614022
	DD	03f1ce11fr			; 0.61281
	DD	03f1c91a2r			; 0.611597
	DD	03f1c420cr			; 0.610383
	DD	03f1bf25fr			; 0.609167
	DD	03f1ba299r			; 0.60795
	DD	03f1b52bbr			; 0.606731
	DD	03f1b02c6r			; 0.605511
	DD	03f1ab2b8r			; 0.60429
	DD	03f1a6293r			; 0.603067
	DD	03f1a1255r			; 0.601842
	DD	03f19c200r			; 0.600616
	DD	03f197194r			; 0.599389
	DD	03f19210fr			; 0.598161
	DD	03f18d073r			; 0.596931
	DD	03f187fc0r			; 0.595699
	DD	03f182ef5r			; 0.594467
	DD	03f17de12r			; 0.593232
	DD	03f178d18r			; 0.591997
	DD	03f173c07r			; 0.59076
	DD	03f16eader			; 0.589521
	DD	03f16999fr			; 0.588282
	DD	03f164847r			; 0.58704
	DD	03f15f6d9r			; 0.585798
	DD	03f15a554r			; 0.584554
	DD	03f1553b7r			; 0.583309
	DD	03f150204r			; 0.582062
	DD	03f14b039r			; 0.580814
	DD	03f145e58r			; 0.579565
	DD	03f140c5fr			; 0.578314
	DD	03f13ba50r			; 0.577062
	DD	03f13682ar			; 0.575808
	DD	03f1315eer			; 0.574553
	DD	03f12c39ar			; 0.573297
	DD	03f127130r			; 0.57204
	DD	03f121eb0r			; 0.570781
	DD	03f11cc19r			; 0.569521
	DD	03f11796br			; 0.568259
	DD	03f1126a7r			; 0.566996
	DD	03f10d3cdr			; 0.565732
	DD	03f1080dcr			; 0.564466
	DD	03f102dd5r			; 0.563199
	DD	03f0fdab8r			; 0.561931
	DD	03f0f8784r			; 0.560662
	DD	03f0f343br			; 0.559391
	DD	03f0ee0dbr			; 0.558119
	DD	03f0e8d65r			; 0.556845
	DD	03f0e39dar			; 0.55557
	DD	03f0de638r			; 0.554294
	DD	03f0d9281r			; 0.553017
	DD	03f0d3eb3r			; 0.551738
	DD	03f0cead0r			; 0.550458
	DD	03f0c96d7r			; 0.549177
	DD	03f0c42c9r			; 0.547894
	DD	03f0beea5r			; 0.54661
	DD	03f0b9a6br			; 0.545325
	DD	03f0b461cr			; 0.544039
	DD	03f0af1b7r			; 0.542751
	DD	03f0a9d3dr			; 0.541462
	DD	03f0a48adr			; 0.540171
	DD	03f09f409r			; 0.53888
	DD	03f099f4er			; 0.537587
	DD	03f094a7fr			; 0.536293
	DD	03f08f59br			; 0.534998
	DD	03f08a0a1r			; 0.533701
	DD	03f084b92r			; 0.532403
	DD	03f07f66fr			; 0.531104
	DD	03f07a136r			; 0.529804
	DD	03f074be8r			; 0.528502
	DD	03f06f686r			; 0.527199
	DD	03f06a10er			; 0.525895
	DD	03f064b82r			; 0.52459
	DD	03f05f5e2r			; 0.523283
	DD	03f05a02cr			; 0.521975
	DD	03f054a62r			; 0.520666
	DD	03f04f484r			; 0.519356
	DD	03f049e91r			; 0.518045
	DD	03f044889r			; 0.516732
	DD	03f03f26dr			; 0.515418
	DD	03f039c3dr			; 0.514103
	DD	03f0345f8r			; 0.512786
	DD	03f02ef9fr			; 0.511469
	DD	03f029932r			; 0.51015
	DD	03f0242b1r			; 0.50883
	DD	03f01ec1cr			; 0.507509
	DD	03f019573r			; 0.506187
	DD	03f013eb5r			; 0.504863
	DD	03f00e7e4r			; 0.503538
	DD	03f0090ffr			; 0.502212
	DD	03f003a06r			; 0.500885
	DD	03effc5f3r			; 0.499557
	DD	03eff17b2r			; 0.498228
	DD	03efe694ar			; 0.496897
	DD	03efdbabbr			; 0.495565
	DD	03efd0c04r			; 0.494232
	DD	03efc5d27r			; 0.492898
	DD	03efbae22r			; 0.491563
	DD	03efafef7r			; 0.490226
	DD	03efa4fa5r			; 0.488889
	DD	03ef9a02dr			; 0.48755
	DD	03ef8f08er			; 0.48621
	DD	03ef840c8r			; 0.484869
	DD	03ef790dcr			; 0.483527
	DD	03ef6e0cbr			; 0.482184
	DD	03ef63093r			; 0.480839
	DD	03ef58035r			; 0.479494
	DD	03ef4cfb1r			; 0.478147
	DD	03ef41f07r			; 0.476799
	DD	03ef36e38r			; 0.47545
	DD	03ef2bd43r			; 0.4741
	DD	03ef20c29r			; 0.472749
	DD	03ef15aear			; 0.471397
	DD	03ef0a985r			; 0.470043
	DD	03eeff7fbr			; 0.468689
	DD	03eef464cr			; 0.467333
	DD	03eee9479r			; 0.465977
	DD	03eede280r			; 0.464619
	DD	03eed3063r			; 0.46326
	DD	03eec7e21r			; 0.4619
	DD	03eebcbbbr			; 0.460539
	DD	03eeb1930r			; 0.459177
	DD	03eea6681r			; 0.457813
	DD	03ee9b3aer			; 0.456449
	DD	03ee900b7r			; 0.455084
	DD	03ee84d9cr			; 0.453717
	DD	03ee79a5dr			; 0.45235
	DD	03ee6e6fbr			; 0.450981
	DD	03ee63375r			; 0.449611
	DD	03ee57fcbr			; 0.448241
	DD	03ee4cbfer			; 0.446869
	DD	03ee4180er			; 0.445496
	DD	03ee363far			; 0.444122
	DD	03ee2afc4r			; 0.442747
	DD	03ee1fb6ar			; 0.441371
	DD	03ee146eer			; 0.439994
	DD	03ee0924fr			; 0.438616
	DD	03edfdd8dr			; 0.437237
	DD	03edf28a9r			; 0.435857
	DD	03ede73a2r			; 0.434476
	DD	03eddbe79r			; 0.433094
	DD	03edd092er			; 0.431711
	DD	03edc53c1r			; 0.430326
	DD	03edb9e31r			; 0.428941
	DD	03edae880r			; 0.427555
	DD	03eda32adr			; 0.426168
	DD	03ed97cb9r			; 0.42478
	DD	03ed8c6a3r			; 0.42339
	DD	03ed8106br			; 0.422
	DD	03ed75a13r			; 0.420609
	DD	03ed6a399r			; 0.419217
	DD	03ed5ecfdr			; 0.417824
	DD	03ed53641r			; 0.41643
	DD	03ed47f64r			; 0.415034
	DD	03ed3c867r			; 0.413638
	DD	03ed31148r			; 0.412241
	DD	03ed25a09r			; 0.410843
	DD	03ed1a2aar			; 0.409444
	DD	03ed0eb2ar			; 0.408044
	DD	03ed0338ar			; 0.406643
	DD	03ecf7bcar			; 0.405241
	DD	03ecec3ear			; 0.403838
	DD	03ece0bear			; 0.402435
	DD	03ecd53car			; 0.40103
	DD	03ecc9b8br			; 0.399624
	DD	03ecbe32cr			; 0.398218
	DD	03ecb2aaer			; 0.39681
	DD	03eca7210r			; 0.395401
	DD	03ec9b953r			; 0.393992
	DD	03ec90077r			; 0.392582
	DD	03ec8477cr			; 0.39117
	DD	03ec78e62r			; 0.389758
	DD	03ec6d529r			; 0.388345
	DD	03ec61bd2r			; 0.386931
	DD	03ec5625cr			; 0.385516
	DD	03ec4a8c8r			; 0.3841
	DD	03ec3ef15r			; 0.382683
	DD	03ec33544r			; 0.381266
	DD	03ec27b55r			; 0.379847
	DD	03ec1c148r			; 0.378428
	DD	03ec1071er			; 0.377007
	DD	03ec04cd5r			; 0.375586
	DD	03ebf926fr			; 0.374164
	DD	03ebed7ebr			; 0.372741
	DD	03ebe1d4ar			; 0.371317
	DD	03ebd628br			; 0.369892
	DD	03ebca7afr			; 0.368467
	DD	03ebbecb6r			; 0.36704
	DD	03ebb31a0r			; 0.365613
	DD	03eba766er			; 0.364185
	DD	03eb9bb1er			; 0.362756
	DD	03eb8ffb2r			; 0.361326
	DD	03eb8442ar			; 0.359895
	DD	03eb78884r			; 0.358463
	DD	03eb6ccc3r			; 0.357031
	DD	03eb610e6r			; 0.355598
	DD	03eb554ecr			; 0.354164
	DD	03eb498d6r			; 0.352729
	DD	03eb3dca5r			; 0.351293
	DD	03eb32058r			; 0.349856
	DD	03eb263efr			; 0.348419
	DD	03eb1a76br			; 0.34698
	DD	03eb0eacbr			; 0.345541
	DD	03eb02e10r			; 0.344101
	DD	03eaf713ar			; 0.342661
	DD	03eaeb449r			; 0.341219
	DD	03eadf73cr			; 0.339777
	DD	03ead3a15r			; 0.338334
	DD	03eac7cd4r			; 0.33689
	DD	03eabbf77r			; 0.335445
	DD	03eab0201r			; 0.334
	DD	03eaa446fr			; 0.332553
	DD	03ea986c4r			; 0.331106
	DD	03ea8c8fer			; 0.329658
	DD	03ea80b1fr			; 0.32821
	DD	03ea74d25r			; 0.32676
	DD	03ea68f12r			; 0.32531
	DD	03ea5d0e5r			; 0.323859
	DD	03ea5129fr			; 0.322408
	DD	03ea4543fr			; 0.320955
	DD	03ea395c5r			; 0.319502
	DD	03ea2d733r			; 0.318048
	DD	03ea21887r			; 0.316593
	DD	03ea159c2r			; 0.315138
	DD	03ea09ae5r			; 0.313682
	DD	03e9fdbeer			; 0.312225
	DD	03e9f1cdfr			; 0.310767
	DD	03e9e5db8r			; 0.309309
	DD	03e9d9e78r			; 0.30785
	DD	03e9cdf20r			; 0.30639
	DD	03e9c1fafr			; 0.304929
	DD	03e9b6027r			; 0.303468
	DD	03e9aa086r			; 0.302006
	DD	03e99e0cer			; 0.300543
	DD	03e9920fer			; 0.29908
	DD	03e986116r			; 0.297616
	DD	03e97a117r			; 0.296151
	DD	03e96e100r			; 0.294685
	DD	03e9620d2r			; 0.293219
	DD	03e95608dr			; 0.291752
	DD	03e94a031r			; 0.290285
	DD	03e93dfbfr			; 0.288816
	DD	03e931f35r			; 0.287347
	DD	03e925e94r			; 0.285878
	DD	03e919dddr			; 0.284408
	DD	03e90dd10r			; 0.282937
	DD	03e901c2cr			; 0.281465
	DD	03e8f5b32r			; 0.279993
	DD	03e8e9a22r			; 0.27852
	DD	03e8dd8fcr			; 0.277046
	DD	03e8d17c0r			; 0.275572
	DD	03e8c566er			; 0.274097
	DD	03e8b9507r			; 0.272621
	DD	03e8ad38ar			; 0.271145
	DD	03e8a11f7r			; 0.269668
	DD	03e895050r			; 0.268191
	DD	03e888e93r			; 0.266713
	DD	03e87ccc1r			; 0.265234
	DD	03e870adar			; 0.263755
	DD	03e8648dfr			; 0.262275
	DD	03e8586cer			; 0.260794
	DD	03e84c4aar			; 0.259313
	DD	03e840270r			; 0.257831
	DD	03e834022r			; 0.256349
	DD	03e827dc0r			; 0.254866
	DD	03e81bb4ar			; 0.253382
	DD	03e80f8c0r			; 0.251898
	DD	03e803622r			; 0.250413
	DD	03e7ee6e1r			; 0.248928
	DD	03e7d6156r			; 0.247442
	DD	03e7bdba4r			; 0.245955
	DD	03e7a55cbr			; 0.244468
	DD	03e78cfccr			; 0.24298
	DD	03e7749a6r			; 0.241492
	DD	03e75c35ar			; 0.240003
	DD	03e743ce8r			; 0.238514
	DD	03e72b651r			; 0.237024
	DD	03e712f94r			; 0.235533
	DD	03e6fa8b2r			; 0.234042
	DD	03e6e21abr			; 0.23255
	DD	03e6c9a7fr			; 0.231058
	DD	03e6b132fr			; 0.229565
	DD	03e698bbar			; 0.228072
	DD	03e680422r			; 0.226578
	DD	03e667c66r			; 0.225084
	DD	03e64f486r			; 0.223589
	DD	03e636c83r			; 0.222094
	DD	03e61e45cr			; 0.220598
	DD	03e605c13r			; 0.219101
	DD	03e5ed3a8r			; 0.217604
	DD	03e5d4b1ar			; 0.216107
	DD	03e5bc26ar			; 0.214609
	DD	03e5a3997r			; 0.21311
	DD	03e58b0a4r			; 0.211611
	DD	03e57278fr			; 0.210112
	DD	03e559e58r			; 0.208612
	DD	03e541501r			; 0.207111
	DD	03e528b89r			; 0.20561
	DD	03e5101f1r			; 0.204109
	DD	03e4f7838r			; 0.202607
	DD	03e4dee60r			; 0.201105
	DD	03e4c6467r			; 0.199602
	DD	03e4ada4fr			; 0.198098
	DD	03e495018r			; 0.196595
	DD	03e47c5c2r			; 0.19509
	DD	03e463b4dr			; 0.193586
	DD	03e44b0b9r			; 0.19208
	DD	03e432607r			; 0.190575
	DD	03e419b37r			; 0.189069
	DD	03e401049r			; 0.187562
	DD	03e3e853er			; 0.186055
	DD	03e3cfa15r			; 0.184548
	DD	03e3b6ecfr			; 0.18304
	DD	03e39e36cr			; 0.181532
	DD	03e3857ecr			; 0.180023
	DD	03e36cc50r			; 0.178514
	DD	03e354098r			; 0.177004
	DD	03e33b4c4r			; 0.175494
	DD	03e3228d4r			; 0.173984
	DD	03e309cc9r			; 0.172473
	DD	03e2f10a2r			; 0.170962
	DD	03e2d8461r			; 0.16945
	DD	03e2bf804r			; 0.167938
	DD	03e2a6b8dr			; 0.166426
	DD	03e28defcr			; 0.164913
	DD	03e275251r			; 0.1634
	DD	03e25c58cr			; 0.161886
	DD	03e2438adr			; 0.160372
	DD	03e22abb6r			; 0.158858
	DD	03e211ea5r			; 0.157343
	DD	03e1f917br			; 0.155828
	DD	03e1e0438r			; 0.154313
	DD	03e1c76der			; 0.152797
	DD	03e1ae96br			; 0.151281
	DD	03e195be0r			; 0.149765
	DD	03e17ce3dr			; 0.148248
	DD	03e164083r			; 0.14673
	DD	03e14b2b2r			; 0.145213
	DD	03e1324car			; 0.143695
	DD	03e1196ccr			; 0.142177
	DD	03e1008b7r			; 0.140658
	DD	03e0e7a8br			; 0.139139
	DD	03e0cec4ar			; 0.13762
	DD	03e0b5df3r			; 0.136101
	DD	03e09cf86r			; 0.134581
	DD	03e084105r			; 0.133061
	DD	03e06b26er			; 0.13154
	DD	03e0523c2r			; 0.130019
	DD	03e039502r			; 0.128498
	DD	03e02062er			; 0.126977
	DD	03e007745r			; 0.125455
	DD	03dfdd092r			; 0.123933
	DD	03dfab273r			; 0.122411
	DD	03df7942cr			; 0.120888
	DD	03df475c0r			; 0.119365
	DD	03df1572er			; 0.117842
	DD	03dee3876r			; 0.116319
	DD	03deb199ar			; 0.114795
	DD	03de7fa9ar			; 0.113271
	DD	03de4db76r			; 0.111747
	DD	03de1bc2er			; 0.110222
	DD	03dde9cc4r			; 0.108697
	DD	03ddb7d37r			; 0.107172
	DD	03dd85d89r			; 0.105647
	DD	03dd53db9r			; 0.104122
	DD	03dd21dc8r			; 0.102596
	DD	03dcefdb7r			; 0.10107
	DD	03dcbdd86r			; 0.0995436
	DD	03dc8bd36r			; 0.0980171
	DD	03dc59cc6r			; 0.0964904
	DD	03dc27c39r			; 0.0949635
	DD	03dbf5b8dr			; 0.0934363
	DD	03dbc3ac3r			; 0.091909
	DD	03db919ddr			; 0.0903814
	DD	03db5f8dar			; 0.0888536
	DD	03db2d7bbr			; 0.0873255
	DD	03dafb680r			; 0.0857973
	DD	03dac952br			; 0.0842689
	DD	03da973bar			; 0.0827403
	DD	03da65230r			; 0.0812114
	DD	03da3308cr			; 0.0796824
	DD	03da00ecfr			; 0.0781532
	DD	03d9cecf9r			; 0.0766239
	DD	03d99cb0ar			; 0.0750943
	DD	03d96a905r			; 0.0735646
	DD	03d9386e7r			; 0.0720346
	DD	03d9064b4r			; 0.0705046
	DD	03d8d426ar			; 0.0689743
	DD	03d8a200ar			; 0.0674439
	DD	03d86fd94r			; 0.0659133
	DD	03d83db0ar			; 0.0643826
	DD	03d80b86cr			; 0.0628518
	DD	03d7b2b74r			; 0.0613207
	DD	03d74e5e9r			; 0.0597896
	DD	03d6ea038r			; 0.0582583
	DD	03d685a62r			; 0.0567268
	DD	03d621469r			; 0.0551952
	DD	03d5bce4cr			; 0.0536635
	DD	03d55880er			; 0.0521317
	DD	03d4f41afr			; 0.0505998
	DD	03d48fb30r			; 0.0490677
	DD	03d42b491r			; 0.0475355
	DD	03d3c6dd5r			; 0.0460032
	DD	03d3626fcr			; 0.0444708
	DD	03d2fe007r			; 0.0429383
	DD	03d2998f6r			; 0.0414056
	DD	03d2351cbr			; 0.0398729
	DD	03d1d0a88r			; 0.0383401
	DD	03d16c32cr			; 0.0368072
	DD	03d107bb8r			; 0.0352742
	DD	03d0a342fr			; 0.0337412
	DD	03d03ec90r			; 0.032208
	DD	03cfb49bar			; 0.0306748
	DD	03ceeba2cr			; 0.0291415
	DD	03ce22a7ar			; 0.0276081
	DD	03cd59aa6r			; 0.0260747
	DD	03cc90ab0r			; 0.0245412
	DD	03cbc7a9br			; 0.0230077
	DD	03cafea69r			; 0.0214741
	DD	03ca35a1cr			; 0.0199404
	DD	03c96c9b6r			; 0.0184067
	DD	03c8a3938r			; 0.016873
	DD	03c7b514br			; 0.0153392
	DD	03c622fffr			; 0.0138054
	DD	03c490e90r			; 0.0122715
	DD	03c2fed02r			; 0.0107377
	DD	03c16cb58r			; 0.00920375
	DD	03bfb5330r			; 0.00766983
	DD	03bc90f88r			; 0.00613588
	DD	03b96cbc1r			; 0.00460193
	DD	03b490fc6r			; 0.00306796
	DD	03ac90fd5r			; 0.00153398
	DD	0250d3000r			; 1.22461e-16
	DD	0bac90fd5r			; -0.00153398
	DD	0bb490fc6r			; -0.00306796
	DD	0bb96cbc1r			; -0.00460193
	DD	0bbc90f88r			; -0.00613588
	DD	0bbfb5330r			; -0.00766983
	DD	0bc16cb58r			; -0.00920375
	DD	0bc2fed02r			; -0.0107377
	DD	0bc490e90r			; -0.0122715
	DD	0bc622fffr			; -0.0138054
	DD	0bc7b514br			; -0.0153392
	DD	0bc8a3938r			; -0.016873
	DD	0bc96c9b6r			; -0.0184067
	DD	0bca35a1cr			; -0.0199404
	DD	0bcafea69r			; -0.0214741
	DD	0bcbc7a9br			; -0.0230077
	DD	0bcc90ab0r			; -0.0245412
	DD	0bcd59aa6r			; -0.0260747
	DD	0bce22a7ar			; -0.0276081
	DD	0bceeba2cr			; -0.0291415
	DD	0bcfb49bar			; -0.0306748
	DD	0bd03ec90r			; -0.032208
	DD	0bd0a342fr			; -0.0337412
	DD	0bd107bb8r			; -0.0352742
	DD	0bd16c32cr			; -0.0368072
	DD	0bd1d0a88r			; -0.0383401
	DD	0bd2351cbr			; -0.0398729
	DD	0bd2998f6r			; -0.0414056
	DD	0bd2fe007r			; -0.0429383
	DD	0bd3626fcr			; -0.0444708
	DD	0bd3c6dd5r			; -0.0460032
	DD	0bd42b491r			; -0.0475355
	DD	0bd48fb30r			; -0.0490677
	DD	0bd4f41afr			; -0.0505998
	DD	0bd55880er			; -0.0521317
	DD	0bd5bce4cr			; -0.0536635
	DD	0bd621469r			; -0.0551952
	DD	0bd685a62r			; -0.0567268
	DD	0bd6ea038r			; -0.0582583
	DD	0bd74e5e9r			; -0.0597896
	DD	0bd7b2b74r			; -0.0613207
	DD	0bd80b86cr			; -0.0628518
	DD	0bd83db0ar			; -0.0643826
	DD	0bd86fd94r			; -0.0659133
	DD	0bd8a200ar			; -0.0674439
	DD	0bd8d426ar			; -0.0689743
	DD	0bd9064b4r			; -0.0705046
	DD	0bd9386e7r			; -0.0720346
	DD	0bd96a905r			; -0.0735646
	DD	0bd99cb0ar			; -0.0750943
	DD	0bd9cecf9r			; -0.0766239
	DD	0bda00ecfr			; -0.0781532
	DD	0bda3308cr			; -0.0796824
	DD	0bda65230r			; -0.0812114
	DD	0bda973bar			; -0.0827403
	DD	0bdac952br			; -0.0842689
	DD	0bdafb680r			; -0.0857973
	DD	0bdb2d7bbr			; -0.0873255
	DD	0bdb5f8dar			; -0.0888536
	DD	0bdb919ddr			; -0.0903814
	DD	0bdbc3ac3r			; -0.091909
	DD	0bdbf5b8dr			; -0.0934363
	DD	0bdc27c39r			; -0.0949635
	DD	0bdc59cc6r			; -0.0964904
	DD	0bdc8bd36r			; -0.0980171
	DD	0bdcbdd86r			; -0.0995436
	DD	0bdcefdb7r			; -0.10107
	DD	0bdd21dc8r			; -0.102596
	DD	0bdd53db9r			; -0.104122
	DD	0bdd85d89r			; -0.105647
	DD	0bddb7d37r			; -0.107172
	DD	0bdde9cc4r			; -0.108697
	DD	0bde1bc2er			; -0.110222
	DD	0bde4db76r			; -0.111747
	DD	0bde7fa9ar			; -0.113271
	DD	0bdeb199ar			; -0.114795
	DD	0bdee3876r			; -0.116319
	DD	0bdf1572er			; -0.117842
	DD	0bdf475c0r			; -0.119365
	DD	0bdf7942cr			; -0.120888
	DD	0bdfab273r			; -0.122411
	DD	0bdfdd092r			; -0.123933
	DD	0be007745r			; -0.125455
	DD	0be02062er			; -0.126977
	DD	0be039502r			; -0.128498
	DD	0be0523c2r			; -0.130019
	DD	0be06b26er			; -0.13154
	DD	0be084105r			; -0.133061
	DD	0be09cf86r			; -0.134581
	DD	0be0b5df3r			; -0.136101
	DD	0be0cec4ar			; -0.13762
	DD	0be0e7a8br			; -0.139139
	DD	0be1008b7r			; -0.140658
	DD	0be1196ccr			; -0.142177
	DD	0be1324car			; -0.143695
	DD	0be14b2b2r			; -0.145213
	DD	0be164083r			; -0.14673
	DD	0be17ce3dr			; -0.148248
	DD	0be195be0r			; -0.149765
	DD	0be1ae96br			; -0.151281
	DD	0be1c76der			; -0.152797
	DD	0be1e0438r			; -0.154313
	DD	0be1f917br			; -0.155828
	DD	0be211ea5r			; -0.157343
	DD	0be22abb6r			; -0.158858
	DD	0be2438adr			; -0.160372
	DD	0be25c58cr			; -0.161886
	DD	0be275251r			; -0.1634
	DD	0be28defcr			; -0.164913
	DD	0be2a6b8dr			; -0.166426
	DD	0be2bf804r			; -0.167938
	DD	0be2d8461r			; -0.16945
	DD	0be2f10a2r			; -0.170962
	DD	0be309cc9r			; -0.172473
	DD	0be3228d4r			; -0.173984
	DD	0be33b4c4r			; -0.175494
	DD	0be354098r			; -0.177004
	DD	0be36cc50r			; -0.178514
	DD	0be3857ecr			; -0.180023
	DD	0be39e36cr			; -0.181532
	DD	0be3b6ecfr			; -0.18304
	DD	0be3cfa15r			; -0.184548
	DD	0be3e853er			; -0.186055
	DD	0be401049r			; -0.187562
	DD	0be419b37r			; -0.189069
	DD	0be432607r			; -0.190575
	DD	0be44b0b9r			; -0.19208
	DD	0be463b4dr			; -0.193586
	DD	0be47c5c2r			; -0.19509
	DD	0be495018r			; -0.196595
	DD	0be4ada4fr			; -0.198098
	DD	0be4c6467r			; -0.199602
	DD	0be4dee60r			; -0.201105
	DD	0be4f7838r			; -0.202607
	DD	0be5101f1r			; -0.204109
	DD	0be528b89r			; -0.20561
	DD	0be541501r			; -0.207111
	DD	0be559e58r			; -0.208612
	DD	0be57278fr			; -0.210112
	DD	0be58b0a4r			; -0.211611
	DD	0be5a3997r			; -0.21311
	DD	0be5bc26ar			; -0.214609
	DD	0be5d4b1ar			; -0.216107
	DD	0be5ed3a8r			; -0.217604
	DD	0be605c13r			; -0.219101
	DD	0be61e45cr			; -0.220598
	DD	0be636c83r			; -0.222094
	DD	0be64f486r			; -0.223589
	DD	0be667c66r			; -0.225084
	DD	0be680422r			; -0.226578
	DD	0be698bbar			; -0.228072
	DD	0be6b132fr			; -0.229565
	DD	0be6c9a7fr			; -0.231058
	DD	0be6e21abr			; -0.23255
	DD	0be6fa8b2r			; -0.234042
	DD	0be712f94r			; -0.235533
	DD	0be72b651r			; -0.237024
	DD	0be743ce8r			; -0.238514
	DD	0be75c35ar			; -0.240003
	DD	0be7749a6r			; -0.241492
	DD	0be78cfccr			; -0.24298
	DD	0be7a55cbr			; -0.244468
	DD	0be7bdba4r			; -0.245955
	DD	0be7d6156r			; -0.247442
	DD	0be7ee6e1r			; -0.248928
	DD	0be803622r			; -0.250413
	DD	0be80f8c0r			; -0.251898
	DD	0be81bb4ar			; -0.253382
	DD	0be827dc0r			; -0.254866
	DD	0be834022r			; -0.256349
	DD	0be840270r			; -0.257831
	DD	0be84c4aar			; -0.259313
	DD	0be8586cer			; -0.260794
	DD	0be8648dfr			; -0.262275
	DD	0be870adar			; -0.263755
	DD	0be87ccc1r			; -0.265234
	DD	0be888e93r			; -0.266713
	DD	0be895050r			; -0.268191
	DD	0be8a11f7r			; -0.269668
	DD	0be8ad38ar			; -0.271145
	DD	0be8b9507r			; -0.272621
	DD	0be8c566er			; -0.274097
	DD	0be8d17c0r			; -0.275572
	DD	0be8dd8fcr			; -0.277046
	DD	0be8e9a22r			; -0.27852
	DD	0be8f5b32r			; -0.279993
	DD	0be901c2cr			; -0.281465
	DD	0be90dd10r			; -0.282937
	DD	0be919dddr			; -0.284408
	DD	0be925e94r			; -0.285878
	DD	0be931f35r			; -0.287347
	DD	0be93dfbfr			; -0.288816
	DD	0be94a031r			; -0.290285
	DD	0be95608dr			; -0.291752
	DD	0be9620d2r			; -0.293219
	DD	0be96e100r			; -0.294685
	DD	0be97a117r			; -0.296151
	DD	0be986116r			; -0.297616
	DD	0be9920fer			; -0.29908
	DD	0be99e0cer			; -0.300543
	DD	0be9aa086r			; -0.302006
	DD	0be9b6027r			; -0.303468
	DD	0be9c1fafr			; -0.304929
	DD	0be9cdf20r			; -0.30639
	DD	0be9d9e78r			; -0.30785
	DD	0be9e5db8r			; -0.309309
	DD	0be9f1cdfr			; -0.310767
	DD	0be9fdbeer			; -0.312225
	DD	0bea09ae5r			; -0.313682
	DD	0bea159c2r			; -0.315138
	DD	0bea21887r			; -0.316593
	DD	0bea2d733r			; -0.318048
	DD	0bea395c5r			; -0.319502
	DD	0bea4543fr			; -0.320955
	DD	0bea5129fr			; -0.322408
	DD	0bea5d0e5r			; -0.323859
	DD	0bea68f12r			; -0.32531
	DD	0bea74d25r			; -0.32676
	DD	0bea80b1fr			; -0.32821
	DD	0bea8c8fer			; -0.329658
	DD	0bea986c4r			; -0.331106
	DD	0beaa446fr			; -0.332553
	DD	0beab0201r			; -0.334
	DD	0beabbf77r			; -0.335445
	DD	0beac7cd4r			; -0.33689
	DD	0bead3a15r			; -0.338334
	DD	0beadf73cr			; -0.339777
	DD	0beaeb449r			; -0.341219
	DD	0beaf713ar			; -0.342661
	DD	0beb02e10r			; -0.344101
	DD	0beb0eacbr			; -0.345541
	DD	0beb1a76br			; -0.34698
	DD	0beb263efr			; -0.348419
	DD	0beb32058r			; -0.349856
	DD	0beb3dca5r			; -0.351293
	DD	0beb498d6r			; -0.352729
	DD	0beb554ecr			; -0.354164
	DD	0beb610e6r			; -0.355598
	DD	0beb6ccc3r			; -0.357031
	DD	0beb78884r			; -0.358463
	DD	0beb8442ar			; -0.359895
	DD	0beb8ffb2r			; -0.361326
	DD	0beb9bb1er			; -0.362756
	DD	0beba766er			; -0.364185
	DD	0bebb31a0r			; -0.365613
	DD	0bebbecb6r			; -0.36704
	DD	0bebca7afr			; -0.368467
	DD	0bebd628br			; -0.369892
	DD	0bebe1d4ar			; -0.371317
	DD	0bebed7ebr			; -0.372741
	DD	0bebf926fr			; -0.374164
	DD	0bec04cd5r			; -0.375586
	DD	0bec1071er			; -0.377007
	DD	0bec1c148r			; -0.378428
	DD	0bec27b55r			; -0.379847
	DD	0bec33544r			; -0.381266
	DD	0bec3ef15r			; -0.382683
	DD	0bec4a8c8r			; -0.3841
	DD	0bec5625cr			; -0.385516
	DD	0bec61bd2r			; -0.386931
	DD	0bec6d529r			; -0.388345
	DD	0bec78e62r			; -0.389758
	DD	0bec8477cr			; -0.39117
	DD	0bec90077r			; -0.392582
	DD	0bec9b953r			; -0.393992
	DD	0beca7210r			; -0.395401
	DD	0becb2aaer			; -0.39681
	DD	0becbe32cr			; -0.398218
	DD	0becc9b8br			; -0.399624
	DD	0becd53car			; -0.40103
	DD	0bece0bear			; -0.402435
	DD	0becec3ear			; -0.403838
	DD	0becf7bcar			; -0.405241
	DD	0bed0338ar			; -0.406643
	DD	0bed0eb2ar			; -0.408044
	DD	0bed1a2aar			; -0.409444
	DD	0bed25a09r			; -0.410843
	DD	0bed31148r			; -0.412241
	DD	0bed3c867r			; -0.413638
	DD	0bed47f64r			; -0.415034
	DD	0bed53641r			; -0.41643
	DD	0bed5ecfdr			; -0.417824
	DD	0bed6a399r			; -0.419217
	DD	0bed75a13r			; -0.420609
	DD	0bed8106br			; -0.422
	DD	0bed8c6a3r			; -0.42339
	DD	0bed97cb9r			; -0.42478
	DD	0beda32adr			; -0.426168
	DD	0bedae880r			; -0.427555
	DD	0bedb9e31r			; -0.428941
	DD	0bedc53c1r			; -0.430326
	DD	0bedd092er			; -0.431711
	DD	0beddbe79r			; -0.433094
	DD	0bede73a2r			; -0.434476
	DD	0bedf28a9r			; -0.435857
	DD	0bedfdd8dr			; -0.437237
	DD	0bee0924fr			; -0.438616
	DD	0bee146eer			; -0.439994
	DD	0bee1fb6ar			; -0.441371
	DD	0bee2afc4r			; -0.442747
	DD	0bee363far			; -0.444122
	DD	0bee4180er			; -0.445496
	DD	0bee4cbfer			; -0.446869
	DD	0bee57fcbr			; -0.448241
	DD	0bee63375r			; -0.449611
	DD	0bee6e6fbr			; -0.450981
	DD	0bee79a5dr			; -0.45235
	DD	0bee84d9cr			; -0.453717
	DD	0bee900b7r			; -0.455084
	DD	0bee9b3aer			; -0.456449
	DD	0beea6681r			; -0.457813
	DD	0beeb1930r			; -0.459177
	DD	0beebcbbbr			; -0.460539
	DD	0beec7e21r			; -0.4619
	DD	0beed3063r			; -0.46326
	DD	0beede280r			; -0.464619
	DD	0beee9479r			; -0.465977
	DD	0beef464cr			; -0.467333
	DD	0beeff7fbr			; -0.468689
	DD	0bef0a985r			; -0.470043
	DD	0bef15aear			; -0.471397
	DD	0bef20c29r			; -0.472749
	DD	0bef2bd43r			; -0.4741
	DD	0bef36e38r			; -0.47545
	DD	0bef41f07r			; -0.476799
	DD	0bef4cfb1r			; -0.478147
	DD	0bef58035r			; -0.479494
	DD	0bef63093r			; -0.480839
	DD	0bef6e0cbr			; -0.482184
	DD	0bef790dcr			; -0.483527
	DD	0bef840c8r			; -0.484869
	DD	0bef8f08er			; -0.48621
	DD	0bef9a02dr			; -0.48755
	DD	0befa4fa5r			; -0.488889
	DD	0befafef7r			; -0.490226
	DD	0befbae22r			; -0.491563
	DD	0befc5d27r			; -0.492898
	DD	0befd0c04r			; -0.494232
	DD	0befdbabbr			; -0.495565
	DD	0befe694ar			; -0.496897
	DD	0beff17b2r			; -0.498228
	DD	0beffc5f3r			; -0.499557
	DD	0bf003a06r			; -0.500885
	DD	0bf0090ffr			; -0.502212
	DD	0bf00e7e4r			; -0.503538
	DD	0bf013eb5r			; -0.504863
	DD	0bf019573r			; -0.506187
	DD	0bf01ec1cr			; -0.507509
	DD	0bf0242b1r			; -0.50883
	DD	0bf029932r			; -0.51015
	DD	0bf02ef9fr			; -0.511469
	DD	0bf0345f8r			; -0.512786
	DD	0bf039c3dr			; -0.514103
	DD	0bf03f26dr			; -0.515418
	DD	0bf044889r			; -0.516732
	DD	0bf049e91r			; -0.518045
	DD	0bf04f484r			; -0.519356
	DD	0bf054a62r			; -0.520666
	DD	0bf05a02cr			; -0.521975
	DD	0bf05f5e2r			; -0.523283
	DD	0bf064b82r			; -0.52459
	DD	0bf06a10er			; -0.525895
	DD	0bf06f686r			; -0.527199
	DD	0bf074be8r			; -0.528502
	DD	0bf07a136r			; -0.529804
	DD	0bf07f66fr			; -0.531104
	DD	0bf084b92r			; -0.532403
	DD	0bf08a0a1r			; -0.533701
	DD	0bf08f59br			; -0.534998
	DD	0bf094a7fr			; -0.536293
	DD	0bf099f4er			; -0.537587
	DD	0bf09f409r			; -0.53888
	DD	0bf0a48adr			; -0.540171
	DD	0bf0a9d3dr			; -0.541462
	DD	0bf0af1b7r			; -0.542751
	DD	0bf0b461cr			; -0.544039
	DD	0bf0b9a6br			; -0.545325
	DD	0bf0beea5r			; -0.54661
	DD	0bf0c42c9r			; -0.547894
	DD	0bf0c96d7r			; -0.549177
	DD	0bf0cead0r			; -0.550458
	DD	0bf0d3eb3r			; -0.551738
	DD	0bf0d9281r			; -0.553017
	DD	0bf0de638r			; -0.554294
	DD	0bf0e39dar			; -0.55557
	DD	0bf0e8d65r			; -0.556845
	DD	0bf0ee0dbr			; -0.558119
	DD	0bf0f343br			; -0.559391
	DD	0bf0f8784r			; -0.560662
	DD	0bf0fdab8r			; -0.561931
	DD	0bf102dd5r			; -0.563199
	DD	0bf1080dcr			; -0.564466
	DD	0bf10d3cdr			; -0.565732
	DD	0bf1126a7r			; -0.566996
	DD	0bf11796br			; -0.568259
	DD	0bf11cc19r			; -0.569521
	DD	0bf121eb0r			; -0.570781
	DD	0bf127130r			; -0.57204
	DD	0bf12c39ar			; -0.573297
	DD	0bf1315eer			; -0.574553
	DD	0bf13682ar			; -0.575808
	DD	0bf13ba50r			; -0.577062
	DD	0bf140c5fr			; -0.578314
	DD	0bf145e58r			; -0.579565
	DD	0bf14b039r			; -0.580814
	DD	0bf150204r			; -0.582062
	DD	0bf1553b7r			; -0.583309
	DD	0bf15a554r			; -0.584554
	DD	0bf15f6d9r			; -0.585798
	DD	0bf164847r			; -0.58704
	DD	0bf16999fr			; -0.588282
	DD	0bf16eader			; -0.589521
	DD	0bf173c07r			; -0.59076
	DD	0bf178d18r			; -0.591997
	DD	0bf17de12r			; -0.593232
	DD	0bf182ef5r			; -0.594467
	DD	0bf187fc0r			; -0.595699
	DD	0bf18d073r			; -0.596931
	DD	0bf19210fr			; -0.598161
	DD	0bf197194r			; -0.599389
	DD	0bf19c200r			; -0.600616
	DD	0bf1a1255r			; -0.601842
	DD	0bf1a6293r			; -0.603067
	DD	0bf1ab2b8r			; -0.60429
	DD	0bf1b02c6r			; -0.605511
	DD	0bf1b52bbr			; -0.606731
	DD	0bf1ba299r			; -0.60795
	DD	0bf1bf25fr			; -0.609167
	DD	0bf1c420cr			; -0.610383
	DD	0bf1c91a2r			; -0.611597
	DD	0bf1ce11fr			; -0.61281
	DD	0bf1d3084r			; -0.614022
	DD	0bf1d7fd1r			; -0.615232
	DD	0bf1dcf06r			; -0.61644
	DD	0bf1e1e22r			; -0.617647
	DD	0bf1e6d26r			; -0.618853
	DD	0bf1ebc12r			; -0.620057
	DD	0bf1f0ae5r			; -0.62126
	DD	0bf1f599fr			; -0.622461
	DD	0bf1fa841r			; -0.623661
	DD	0bf1ff6cbr			; -0.62486
	DD	0bf20453br			; -0.626056
	DD	0bf209393r			; -0.627252
	DD	0bf20e1d2r			; -0.628446
	DD	0bf212ff9r			; -0.629638
	DD	0bf217e06r			; -0.630829
	DD	0bf21cbfbr			; -0.632019
	DD	0bf2219d7r			; -0.633207
	DD	0bf226799r			; -0.634393
	DD	0bf22b543r			; -0.635578
	DD	0bf2302d3r			; -0.636762
	DD	0bf23504br			; -0.637944
	DD	0bf239da9r			; -0.639124
	DD	0bf23eaeer			; -0.640303
	DD	0bf24381ar			; -0.641481
	DD	0bf24852cr			; -0.642657
	DD	0bf24d225r			; -0.643832
	DD	0bf251f04r			; -0.645005
	DD	0bf256bcbr			; -0.646176
	DD	0bf25b877r			; -0.647346
	DD	0bf26050ar			; -0.648514
	DD	0bf265184r			; -0.649681
	DD	0bf269de3r			; -0.650847
	DD	0bf26ea2ar			; -0.652011
	DD	0bf273656r			; -0.653173
	DD	0bf278268r			; -0.654334
	DD	0bf27ce61r			; -0.655493
	DD	0bf281a40r			; -0.656651
	DD	0bf286605r			; -0.657807
	DD	0bf28b1b0r			; -0.658961
	DD	0bf28fd41r			; -0.660114
	DD	0bf2948b8r			; -0.661266
	DD	0bf299415r			; -0.662416
	DD	0bf29df57r			; -0.663564
	DD	0bf2a2a80r			; -0.664711
	DD	0bf2a758er			; -0.665856
	DD	0bf2ac082r			; -0.667
	DD	0bf2b0b5br			; -0.668142
	DD	0bf2b561br			; -0.669283
	DD	0bf2ba0bfr			; -0.670422
	DD	0bf2beb4ar			; -0.671559
	DD	0bf2c35b9r			; -0.672695
	DD	0bf2c800fr			; -0.673829
	DD	0bf2cca49r			; -0.674962
	DD	0bf2d1469r			; -0.676093
	DD	0bf2d5e6fr			; -0.677222
	DD	0bf2da859r			; -0.67835
	DD	0bf2df229r			; -0.679476
	DD	0bf2e3bder			; -0.680601
	DD	0bf2e8578r			; -0.681724
	DD	0bf2ecef7r			; -0.682846
	DD	0bf2f185br			; -0.683965
	DD	0bf2f61a5r			; -0.685084
	DD	0bf2faad3r			; -0.6862
	DD	0bf2ff3e6r			; -0.687315
	DD	0bf303cder			; -0.688429
	DD	0bf3085bbr			; -0.689541
	DD	0bf30ce7cr			; -0.690651
	DD	0bf311722r			; -0.691759
	DD	0bf315fadr			; -0.692866
	DD	0bf31a81dr			; -0.693971
	DD	0bf31f071r			; -0.695075
	DD	0bf3238aar			; -0.696177
	DD	0bf3280c7r			; -0.697277
	DD	0bf32c8c9r			; -0.698376
	DD	0bf3310afr			; -0.699473
	DD	0bf33587ar			; -0.700569
	DD	0bf33a029r			; -0.701663
	DD	0bf33e7bcr			; -0.702755
	DD	0bf342f34r			; -0.703845
	DD	0bf34768fr			; -0.704934
	DD	0bf34bdcfr			; -0.706021
	DD	0bf3504f3r			; -0.707107
	DD	0bf354bfbr			; -0.708191
	DD	0bf3592e7r			; -0.709273
	DD	0bf35d9b8r			; -0.710353
	DD	0bf36206cr			; -0.711432
	DD	0bf366704r			; -0.712509
	DD	0bf36ad7fr			; -0.713585
	DD	0bf36f3dfr			; -0.714659
	DD	0bf373a23r			; -0.715731
	DD	0bf37804ar			; -0.716801
	DD	0bf37c655r			; -0.71787
	DD	0bf380c43r			; -0.718937
	DD	0bf385216r			; -0.720003
	DD	0bf3897cbr			; -0.721066
	DD	0bf38dd65r			; -0.722128
	DD	0bf3922e1r			; -0.723188
	DD	0bf396842r			; -0.724247
	DD	0bf39ad85r			; -0.725304
	DD	0bf39f2acr			; -0.726359
	DD	0bf3a37b7r			; -0.727413
	DD	0bf3a7ca4r			; -0.728464
	DD	0bf3ac175r			; -0.729514
	DD	0bf3b0629r			; -0.730563
	DD	0bf3b4ac1r			; -0.731609
	DD	0bf3b8f3br			; -0.732654
	DD	0bf3bd398r			; -0.733697
	DD	0bf3c17d9r			; -0.734739
	DD	0bf3c5bfcr			; -0.735779
	DD	0bf3ca003r			; -0.736817
	DD	0bf3ce3ecr			; -0.737853
	DD	0bf3d27b8r			; -0.738887
	DD	0bf3d6b67r			; -0.73992
	DD	0bf3daef9r			; -0.740951
	DD	0bf3df26er			; -0.74198
	DD	0bf3e35c5r			; -0.743008
	DD	0bf3e78ffr			; -0.744034
	DD	0bf3ebc1br			; -0.745058
	DD	0bf3eff1br			; -0.74608
	DD	0bf3f41fcr			; -0.747101
	DD	0bf3f84c0r			; -0.748119
	DD	0bf3fc767r			; -0.749136
	DD	0bf4009f0r			; -0.750152
	DD	0bf404c5cr			; -0.751165
	DD	0bf408ea9r			; -0.752177
	DD	0bf40d0dar			; -0.753187
	DD	0bf4112ecr			; -0.754195
	DD	0bf4154e1r			; -0.755201
	DD	0bf4196b7r			; -0.756206
	DD	0bf41d870r			; -0.757209
	DD	0bf421a0br			; -0.75821
	DD	0bf425b89r			; -0.759209
	DD	0bf429ce8r			; -0.760207
	DD	0bf42de29r			; -0.761202
	DD	0bf431f4cr			; -0.762196
	DD	0bf436051r			; -0.763188
	DD	0bf43a138r			; -0.764179
	DD	0bf43e200r			; -0.765167
	DD	0bf4422abr			; -0.766154
	DD	0bf446337r			; -0.767139
	DD	0bf44a3a5r			; -0.768122
	DD	0bf44e3f5r			; -0.769103
	DD	0bf452426r			; -0.770083
	DD	0bf456439r			; -0.771061
	DD	0bf45a42dr			; -0.772036
	DD	0bf45e403r			; -0.77301
	DD	0bf4623bbr			; -0.773983
	DD	0bf466354r			; -0.774953
	DD	0bf46a2cer			; -0.775922
	DD	0bf46e22ar			; -0.776888
	DD	0bf472167r			; -0.777853
	DD	0bf476085r			; -0.778817
	DD	0bf479f84r			; -0.779778
	DD	0bf47de65r			; -0.780737
	DD	0bf481d27r			; -0.781695
	DD	0bf485bcar			; -0.782651
	DD	0bf489a4er			; -0.783605
	DD	0bf48d8b3r			; -0.784557
	DD	0bf4916far			; -0.785507
	DD	0bf495521r			; -0.786455
	DD	0bf499329r			; -0.787402
	DD	0bf49d112r			; -0.788346
	DD	0bf4a0edcr			; -0.789289
	DD	0bf4a4c87r			; -0.79023
	DD	0bf4a8a13r			; -0.791169
	DD	0bf4ac77fr			; -0.792107
	DD	0bf4b04ccr			; -0.793042
	DD	0bf4b41far			; -0.793975
	DD	0bf4b7f09r			; -0.794907
	DD	0bf4bbbf8r			; -0.795837
	DD	0bf4bf8c7r			; -0.796765
	DD	0bf4c3578r			; -0.797691
	DD	0bf4c7208r			; -0.798615
	DD	0bf4cae79r			; -0.799537
	DD	0bf4ceacbr			; -0.800458
	DD	0bf4d26fdr			; -0.801376
	DD	0bf4d6310r			; -0.802293
	DD	0bf4d9f02r			; -0.803208
	DD	0bf4ddad5r			; -0.80412
	DD	0bf4e1689r			; -0.805031
	DD	0bf4e521cr			; -0.80594
	DD	0bf4e8d90r			; -0.806848
	DD	0bf4ec8e4r			; -0.807753
	DD	0bf4f0417r			; -0.808656
	DD	0bf4f3f2br			; -0.809558
	DD	0bf4f7a1fr			; -0.810457
	DD	0bf4fb4f4r			; -0.811355
	DD	0bf4fefa8r			; -0.812251
	DD	0bf502a3br			; -0.813144
	DD	0bf5064afr			; -0.814036
	DD	0bf509f03r			; -0.814926
	DD	0bf50d937r			; -0.815814
	DD	0bf51134ar			; -0.816701
	DD	0bf514d3dr			; -0.817585
	DD	0bf518710r			; -0.818467
	DD	0bf51c0c2r			; -0.819348
	DD	0bf51fa54r			; -0.820226
	DD	0bf5233c6r			; -0.821102
	DD	0bf526d18r			; -0.821977
	DD	0bf52a649r			; -0.82285
	DD	0bf52df59r			; -0.823721
	DD	0bf531849r			; -0.824589
	DD	0bf535118r			; -0.825456
	DD	0bf5389c7r			; -0.826321
	DD	0bf53c255r			; -0.827184
	DD	0bf53fac3r			; -0.828045
	DD	0bf54330fr			; -0.828904
	DD	0bf546b3br			; -0.829761
	DD	0bf54a347r			; -0.830616
	DD	0bf54db31r			; -0.83147
	DD	0bf5512fbr			; -0.832321
	DD	0bf554aa4r			; -0.83317
	DD	0bf55822cr			; -0.834018
	DD	0bf55b993r			; -0.834863
	DD	0bf55f0d9r			; -0.835706
	DD	0bf5627fer			; -0.836548
	DD	0bf565f02r			; -0.837387
	DD	0bf5695e5r			; -0.838225
	DD	0bf56cca7r			; -0.83906
	DD	0bf570348r			; -0.839894
	DD	0bf5739c7r			; -0.840725
	DD	0bf577026r			; -0.841555
	DD	0bf57a663r			; -0.842383
	DD	0bf57dc7fr			; -0.843208
	DD	0bf581279r			; -0.844032
	DD	0bf584853r			; -0.844854
	DD	0bf587e0br			; -0.845673
	DD	0bf58b3a1r			; -0.846491
	DD	0bf58e916r			; -0.847307
	DD	0bf591e6ar			; -0.84812
	DD	0bf59539cr			; -0.848932
	DD	0bf5988adr			; -0.849742
	DD	0bf59bd9cr			; -0.850549
	DD	0bf59f26ar			; -0.851355
	DD	0bf5a2716r			; -0.852159
	DD	0bf5a5ba0r			; -0.852961
	DD	0bf5a9009r			; -0.85376
	DD	0bf5ac450r			; -0.854558
	DD	0bf5af875r			; -0.855354
	DD	0bf5b2c79r			; -0.856147
	DD	0bf5b605ar			; -0.856939
	DD	0bf5b941ar			; -0.857729
	DD	0bf5bc7b8r			; -0.858516
	DD	0bf5bfb34r			; -0.859302
	DD	0bf5c2e8er			; -0.860085
	DD	0bf5c61c7r			; -0.860867
	DD	0bf5c94ddr			; -0.861646
	DD	0bf5cc7d1r			; -0.862424
	DD	0bf5cfaa3r			; -0.863199
	DD	0bf5d2d53r			; -0.863973
	DD	0bf5d5fe1r			; -0.864744
	DD	0bf5d924dr			; -0.865514
	DD	0bf5dc497r			; -0.866281
	DD	0bf5df6ber			; -0.867046
	DD	0bf5e28c3r			; -0.867809
	DD	0bf5e5aa6r			; -0.868571
	DD	0bf5e8c67r			; -0.86933
	DD	0bf5ebe05r			; -0.870087
	DD	0bf5eef81r			; -0.870842
	DD	0bf5f20dbr			; -0.871595
	DD	0bf5f5212r			; -0.872346
	DD	0bf5f8327r			; -0.873095
	DD	0bf5fb419r			; -0.873842
	DD	0bf5fe4e9r			; -0.874587
	DD	0bf601596r			; -0.875329
	DD	0bf604621r			; -0.87607
	DD	0bf607689r			; -0.876809
	DD	0bf60a6cfr			; -0.877545
	DD	0bf60d6f2r			; -0.87828
	DD	0bf6106f2r			; -0.879012
	DD	0bf6136d0r			; -0.879743
	DD	0bf61668ar			; -0.880471
	DD	0bf619622r			; -0.881197
	DD	0bf61c598r			; -0.881921
	DD	0bf61f4ear			; -0.882643
	DD	0bf62241ar			; -0.883363
	DD	0bf625326r			; -0.884081
	DD	0bf628210r			; -0.884797
	DD	0bf62b0d7r			; -0.885511
	DD	0bf62df7br			; -0.886223
	DD	0bf630dfcr			; -0.886932
	DD	0bf633c5ar			; -0.88764
	DD	0bf636a95r			; -0.888345
	DD	0bf6398acr			; -0.889048
	DD	0bf63c6a1r			; -0.88975
	DD	0bf63f473r			; -0.890449
	DD	0bf642221r			; -0.891146
	DD	0bf644facr			; -0.891841
	DD	0bf647d14r			; -0.892534
	DD	0bf64aa59r			; -0.893224
	DD	0bf64d77br			; -0.893913
	DD	0bf650479r			; -0.894599
	DD	0bf653154r			; -0.895284
	DD	0bf655e0br			; -0.895966
	DD	0bf658aa0r			; -0.896646
	DD	0bf65b710r			; -0.897325
	DD	0bf65e35er			; -0.898001
	DD	0bf660f88r			; -0.898674
	DD	0bf663b8er			; -0.899346
	DD	0bf666771r			; -0.900016
	DD	0bf669330r			; -0.900683
	DD	0bf66beccr			; -0.901349
	DD	0bf66ea45r			; -0.902012
	DD	0bf671599r			; -0.902673
	DD	0bf6740car			; -0.903332
	DD	0bf676bd8r			; -0.903989
	DD	0bf6796c1r			; -0.904644
	DD	0bf67c187r			; -0.905297
	DD	0bf67ec29r			; -0.905947
	DD	0bf6816a8r			; -0.906596
	DD	0bf684103r			; -0.907242
	DD	0bf686b39r			; -0.907886
	DD	0bf68954cr			; -0.908528
	DD	0bf68bf3cr			; -0.909168
	DD	0bf68e907r			; -0.909806
	DD	0bf6912aer			; -0.910441
	DD	0bf693c32r			; -0.911075
	DD	0bf696591r			; -0.911706
	DD	0bf698eccr			; -0.912335
	DD	0bf69b7e4r			; -0.912962
	DD	0bf69e0d7r			; -0.913587
	DD	0bf6a09a7r			; -0.91421
	DD	0bf6a3252r			; -0.91483
	DD	0bf6a5ad9r			; -0.915449
	DD	0bf6a833cr			; -0.916065
	DD	0bf6aab7br			; -0.916679
	DD	0bf6ad395r			; -0.917291
	DD	0bf6afb8cr			; -0.917901
	DD	0bf6b235er			; -0.918508
	DD	0bf6b4b0cr			; -0.919114
	DD	0bf6b7295r			; -0.919717
	DD	0bf6b99fbr			; -0.920318
	DD	0bf6bc13br			; -0.920917
	DD	0bf6be858r			; -0.921514
	DD	0bf6c0f50r			; -0.922109
	DD	0bf6c3624r			; -0.922701
	DD	0bf6c5cd4r			; -0.923291
	DD	0bf6c835er			; -0.92388
	DD	0bf6ca9c5r			; -0.924465
	DD	0bf6cd007r			; -0.925049
	DD	0bf6cf624r			; -0.925631
	DD	0bf6d1c1dr			; -0.92621
	DD	0bf6d41f2r			; -0.926787
	DD	0bf6d67a1r			; -0.927363
	DD	0bf6d8d2dr			; -0.927935
	DD	0bf6db293r			; -0.928506
	DD	0bf6dd7d5r			; -0.929075
	DD	0bf6dfcf2r			; -0.929641
	DD	0bf6e21ebr			; -0.930205
	DD	0bf6e46ber			; -0.930767
	DD	0bf6e6b6dr			; -0.931327
	DD	0bf6e8ff8r			; -0.931884
	DD	0bf6eb45dr			; -0.93244
	DD	0bf6ed89er			; -0.932993
	DD	0bf6efcbar			; -0.933544
	DD	0bf6f20b0r			; -0.934093
	DD	0bf6f4483r			; -0.934639
	DD	0bf6f6830r			; -0.935184
	DD	0bf6f8bb8r			; -0.935726
	DD	0bf6faf1br			; -0.936266
	DD	0bf6fd25ar			; -0.936803
	DD	0bf6ff573r			; -0.937339
	DD	0bf701867r			; -0.937872
	DD	0bf703b37r			; -0.938404
	DD	0bf705de1r			; -0.938932
	DD	0bf708066r			; -0.939459
	DD	0bf70a2c6r			; -0.939984
	DD	0bf70c501r			; -0.940506
	DD	0bf70e717r			; -0.941026
	DD	0bf710908r			; -0.941544
	DD	0bf712ad4r			; -0.94206
	DD	0bf714c7ar			; -0.942573
	DD	0bf716dfbr			; -0.943084
	DD	0bf718f57r			; -0.943593
	DD	0bf71b08er			; -0.9441
	DD	0bf71d19fr			; -0.944605
	DD	0bf71f28cr			; -0.945107
	DD	0bf721352r			; -0.945607
	DD	0bf7233f4r			; -0.946105
	DD	0bf725470r			; -0.946601
	DD	0bf7274c7r			; -0.947094
	DD	0bf7294f8r			; -0.947586
	DD	0bf72b504r			; -0.948075
	DD	0bf72d4ebr			; -0.948561
	DD	0bf72f4acr			; -0.949046
	DD	0bf731447r			; -0.949528
	DD	0bf7333ber			; -0.950008
	DD	0bf73530er			; -0.950486
	DD	0bf737239r			; -0.950962
	DD	0bf73913fr			; -0.951435
	DD	0bf73b01fr			; -0.951906
	DD	0bf73ced9r			; -0.952375
	DD	0bf73ed6er			; -0.952842
	DD	0bf740bddr			; -0.953306
	DD	0bf742a27r			; -0.953768
	DD	0bf74484br			; -0.954228
	DD	0bf746649r			; -0.954686
	DD	0bf748422r			; -0.955141
	DD	0bf74a1d5r			; -0.955594
	DD	0bf74bf62r			; -0.956045
	DD	0bf74dcc9r			; -0.956494
	DD	0bf74fa0br			; -0.95694
	DD	0bf751727r			; -0.957385
	DD	0bf75341dr			; -0.957826
	DD	0bf7550edr			; -0.958266
	DD	0bf756d97r			; -0.958703
	DD	0bf758a1cr			; -0.959139
	DD	0bf75a67br			; -0.959572
	DD	0bf75c2b3r			; -0.960002
	DD	0bf75dec6r			; -0.960431
	DD	0bf75fab3r			; -0.960857
	DD	0bf76167ar			; -0.96128
	DD	0bf76321br			; -0.961702
	DD	0bf764d97r			; -0.962121
	DD	0bf7668ecr			; -0.962538
	DD	0bf76841br			; -0.962953
	DD	0bf769f24r			; -0.963366
	DD	0bf76ba07r			; -0.963776
	DD	0bf76d4c4r			; -0.964184
	DD	0bf76ef5br			; -0.96459
	DD	0bf7709ccr			; -0.964993
	DD	0bf772417r			; -0.965394
	DD	0bf773e3cr			; -0.965793
	DD	0bf77583ar			; -0.96619
	DD	0bf777213r			; -0.966584
	DD	0bf778bc5r			; -0.966976
	DD	0bf77a551r			; -0.967366
	DD	0bf77beb7r			; -0.967754
	DD	0bf77d7f7r			; -0.968139
	DD	0bf77f110r			; -0.968522
	DD	0bf780a04r			; -0.968903
	DD	0bf7822d1r			; -0.969281
	DD	0bf783b77r			; -0.969657
	DD	0bf7853f8r			; -0.970031
	DD	0bf786c52r			; -0.970403
	DD	0bf788486r			; -0.970772
	DD	0bf789c93r			; -0.971139
	DD	0bf78b47br			; -0.971504
	DD	0bf78cc3br			; -0.971866
	DD	0bf78e3d6r			; -0.972227
	DD	0bf78fb4ar			; -0.972584
	DD	0bf791298r			; -0.97294
	DD	0bf7929bfr			; -0.973293
	DD	0bf7940c0r			; -0.973644
	DD	0bf79579ar			; -0.973993
	DD	0bf796e4er			; -0.974339
	DD	0bf7984dcr			; -0.974684
	DD	0bf799b43r			; -0.975025
	DD	0bf79b183r			; -0.975365
	DD	0bf79c79dr			; -0.975702
	DD	0bf79dd91r			; -0.976037
	DD	0bf79f35er			; -0.97637
	DD	0bf7a0904r			; -0.9767
	DD	0bf7a1e84r			; -0.977028
	DD	0bf7a33ddr			; -0.977354
	DD	0bf7a4910r			; -0.977677
	DD	0bf7a5e1cr			; -0.977998
	DD	0bf7a7302r			; -0.978317
	DD	0bf7a87c1r			; -0.978634
	DD	0bf7a9c59r			; -0.978948
	DD	0bf7ab0cbr			; -0.97926
	DD	0bf7ac516r			; -0.97957
	DD	0bf7ad93ar			; -0.979877
	DD	0bf7aed37r			; -0.980182
	DD	0bf7b010er			; -0.980485
	DD	0bf7b14ber			; -0.980785
	DD	0bf7b2848r			; -0.981083
	DD	0bf7b3babr			; -0.981379
	DD	0bf7b4ee7r			; -0.981673
	DD	0bf7b61fcr			; -0.981964
	DD	0bf7b74ear			; -0.982253
	DD	0bf7b87b2r			; -0.982539
	DD	0bf7b9a53r			; -0.982824
	DD	0bf7baccdr			; -0.983105
	DD	0bf7bbf20r			; -0.983385
	DD	0bf7bd14dr			; -0.983662
	DD	0bf7be353r			; -0.983937
	DD	0bf7bf531r			; -0.98421
	DD	0bf7c06e9r			; -0.98448
	DD	0bf7c187ar			; -0.984748
	DD	0bf7c29e5r			; -0.985014
	DD	0bf7c3b28r			; -0.985278
	DD	0bf7c4c44r			; -0.985539
	DD	0bf7c5d3ar			; -0.985798
	DD	0bf7c6e08r			; -0.986054
	DD	0bf7c7eb0r			; -0.986308
	DD	0bf7c8f31r			; -0.98656
	DD	0bf7c9f8ar			; -0.986809
	DD	0bf7cafbdr			; -0.987057
	DD	0bf7cbfc9r			; -0.987301
	DD	0bf7ccfaer			; -0.987544
	DD	0bf7cdf6cr			; -0.987784
	DD	0bf7cef03r			; -0.988022
	DD	0bf7cfe73r			; -0.988258
	DD	0bf7d0dbcr			; -0.988491
	DD	0bf7d1cddr			; -0.988722
	DD	0bf7d2bd8r			; -0.98895
	DD	0bf7d3aacr			; -0.989177
	DD	0bf7d4959r			; -0.9894
	DD	0bf7d57der			; -0.989622
	DD	0bf7d663dr			; -0.989841
	DD	0bf7d7474r			; -0.990058
	DD	0bf7d8285r			; -0.990273
	DD	0bf7d906er			; -0.990485
	DD	0bf7d9e30r			; -0.990695
	DD	0bf7dabccr			; -0.990903
	DD	0bf7db940r			; -0.991108
	DD	0bf7dc68cr			; -0.991311
	DD	0bf7dd3b2r			; -0.991511
	DD	0bf7de0b1r			; -0.99171
	DD	0bf7ded88r			; -0.991906
	DD	0bf7dfa38r			; -0.992099
	DD	0bf7e06c2r			; -0.992291
	DD	0bf7e1324r			; -0.99248
	DD	0bf7e1f5er			; -0.992666
	DD	0bf7e2b72r			; -0.99285
	DD	0bf7e375er			; -0.993032
	DD	0bf7e4323r			; -0.993212
	DD	0bf7e4ec1r			; -0.993389
	DD	0bf7e5a38r			; -0.993564
	DD	0bf7e6588r			; -0.993737
	DD	0bf7e70b0r			; -0.993907
	DD	0bf7e7bb1r			; -0.994075
	DD	0bf7e868br			; -0.99424
	DD	0bf7e913dr			; -0.994404
	DD	0bf7e9bc9r			; -0.994565
	DD	0bf7ea62dr			; -0.994723
	DD	0bf7eb069r			; -0.994879
	DD	0bf7eba7fr			; -0.995033
	DD	0bf7ec46dr			; -0.995185
	DD	0bf7ece34r			; -0.995334
	DD	0bf7ed7d4r			; -0.995481
	DD	0bf7ee14cr			; -0.995625
	DD	0bf7eea9dr			; -0.995767
	DD	0bf7ef3c7r			; -0.995907
	DD	0bf7efcc9r			; -0.996045
	DD	0bf7f05a4r			; -0.99618
	DD	0bf7f0e58r			; -0.996313
	DD	0bf7f16e4r			; -0.996443
	DD	0bf7f1f49r			; -0.996571
	DD	0bf7f2787r			; -0.996697
	DD	0bf7f2f9dr			; -0.99682
	DD	0bf7f378cr			; -0.996941
	DD	0bf7f3f54r			; -0.99706
	DD	0bf7f46f4r			; -0.997176
	DD	0bf7f4e6dr			; -0.99729
	DD	0bf7f55bfr			; -0.997402
	DD	0bf7f5ce9r			; -0.997511
	DD	0bf7f63ecr			; -0.997618
	DD	0bf7f6ac7r			; -0.997723
	DD	0bf7f717br			; -0.997825
	DD	0bf7f7808r			; -0.997925
	DD	0bf7f7e6dr			; -0.998023
	DD	0bf7f84abr			; -0.998118
	DD	0bf7f8ac2r			; -0.998211
	DD	0bf7f90b1r			; -0.998302
	DD	0bf7f9678r			; -0.99839
	DD	0bf7f9c18r			; -0.998476
	DD	0bf7fa191r			; -0.998559
	DD	0bf7fa6e3r			; -0.99864
	DD	0bf7fac0dr			; -0.998719
	DD	0bf7fb10fr			; -0.998795
	DD	0bf7fb5ear			; -0.99887
	DD	0bf7fba9er			; -0.998941
	DD	0bf7fbf2ar			; -0.999011
	DD	0bf7fc38fr			; -0.999078
	DD	0bf7fc7ccr			; -0.999142
	DD	0bf7fcbe2r			; -0.999205
	DD	0bf7fcfd1r			; -0.999265
	DD	0bf7fd397r			; -0.999322
	DD	0bf7fd737r			; -0.999378
	DD	0bf7fdaafr			; -0.999431
	DD	0bf7fde00r			; -0.999481
	DD	0bf7fe129r			; -0.999529
	DD	0bf7fe42br			; -0.999575
	DD	0bf7fe705r			; -0.999619
	DD	0bf7fe9b8r			; -0.99966
	DD	0bf7fec43r			; -0.999699
	DD	0bf7feea7r			; -0.999735
	DD	0bf7ff0e3r			; -0.999769
	DD	0bf7ff2f8r			; -0.999801
	DD	0bf7ff4e6r			; -0.999831
	DD	0bf7ff6acr			; -0.999858
	DD	0bf7ff84ar			; -0.999882
	DD	0bf7ff9c1r			; -0.999905
	DD	0bf7ffb11r			; -0.999925
	DD	0bf7ffc39r			; -0.999942
	DD	0bf7ffd39r			; -0.999958
	DD	0bf7ffe13r			; -0.999971
	DD	0bf7ffec4r			; -0.999981
	DD	0bf7fff4er			; -0.999989
	DD	0bf7fffb1r			; -0.999995
	DD	0bf7fffecr			; -0.999999
	DD	0bf800000r			; -1
	DD	0bf7fffecr			; -0.999999
	DD	0bf7fffb1r			; -0.999995
	DD	0bf7fff4er			; -0.999989
	DD	0bf7ffec4r			; -0.999981
	DD	0bf7ffe13r			; -0.999971
	DD	0bf7ffd39r			; -0.999958
	DD	0bf7ffc39r			; -0.999942
	DD	0bf7ffb11r			; -0.999925
	DD	0bf7ff9c1r			; -0.999905
	DD	0bf7ff84ar			; -0.999882
	DD	0bf7ff6acr			; -0.999858
	DD	0bf7ff4e6r			; -0.999831
	DD	0bf7ff2f8r			; -0.999801
	DD	0bf7ff0e3r			; -0.999769
	DD	0bf7feea7r			; -0.999735
	DD	0bf7fec43r			; -0.999699
	DD	0bf7fe9b8r			; -0.99966
	DD	0bf7fe705r			; -0.999619
	DD	0bf7fe42br			; -0.999575
	DD	0bf7fe129r			; -0.999529
	DD	0bf7fde00r			; -0.999481
	DD	0bf7fdaafr			; -0.999431
	DD	0bf7fd737r			; -0.999378
	DD	0bf7fd397r			; -0.999322
	DD	0bf7fcfd1r			; -0.999265
	DD	0bf7fcbe2r			; -0.999205
	DD	0bf7fc7ccr			; -0.999142
	DD	0bf7fc38fr			; -0.999078
	DD	0bf7fbf2ar			; -0.999011
	DD	0bf7fba9er			; -0.998941
	DD	0bf7fb5ear			; -0.99887
	DD	0bf7fb10fr			; -0.998795
	DD	0bf7fac0dr			; -0.998719
	DD	0bf7fa6e3r			; -0.99864
	DD	0bf7fa191r			; -0.998559
	DD	0bf7f9c18r			; -0.998476
	DD	0bf7f9678r			; -0.99839
	DD	0bf7f90b1r			; -0.998302
	DD	0bf7f8ac2r			; -0.998211
	DD	0bf7f84abr			; -0.998118
	DD	0bf7f7e6dr			; -0.998023
	DD	0bf7f7808r			; -0.997925
	DD	0bf7f717br			; -0.997825
	DD	0bf7f6ac7r			; -0.997723
	DD	0bf7f63ecr			; -0.997618
	DD	0bf7f5ce9r			; -0.997511
	DD	0bf7f55bfr			; -0.997402
	DD	0bf7f4e6dr			; -0.99729
	DD	0bf7f46f4r			; -0.997176
	DD	0bf7f3f54r			; -0.99706
	DD	0bf7f378cr			; -0.996941
	DD	0bf7f2f9dr			; -0.99682
	DD	0bf7f2787r			; -0.996697
	DD	0bf7f1f49r			; -0.996571
	DD	0bf7f16e4r			; -0.996443
	DD	0bf7f0e58r			; -0.996313
	DD	0bf7f05a4r			; -0.99618
	DD	0bf7efcc9r			; -0.996045
	DD	0bf7ef3c7r			; -0.995907
	DD	0bf7eea9dr			; -0.995767
	DD	0bf7ee14cr			; -0.995625
	DD	0bf7ed7d4r			; -0.995481
	DD	0bf7ece34r			; -0.995334
	DD	0bf7ec46dr			; -0.995185
	DD	0bf7eba7fr			; -0.995033
	DD	0bf7eb069r			; -0.994879
	DD	0bf7ea62dr			; -0.994723
	DD	0bf7e9bc9r			; -0.994565
	DD	0bf7e913dr			; -0.994404
	DD	0bf7e868br			; -0.99424
	DD	0bf7e7bb1r			; -0.994075
	DD	0bf7e70b0r			; -0.993907
	DD	0bf7e6588r			; -0.993737
	DD	0bf7e5a38r			; -0.993564
	DD	0bf7e4ec1r			; -0.993389
	DD	0bf7e4323r			; -0.993212
	DD	0bf7e375er			; -0.993032
	DD	0bf7e2b72r			; -0.99285
	DD	0bf7e1f5er			; -0.992666
	DD	0bf7e1324r			; -0.99248
	DD	0bf7e06c2r			; -0.992291
	DD	0bf7dfa38r			; -0.992099
	DD	0bf7ded88r			; -0.991906
	DD	0bf7de0b1r			; -0.99171
	DD	0bf7dd3b2r			; -0.991511
	DD	0bf7dc68cr			; -0.991311
	DD	0bf7db940r			; -0.991108
	DD	0bf7dabccr			; -0.990903
	DD	0bf7d9e30r			; -0.990695
	DD	0bf7d906er			; -0.990485
	DD	0bf7d8285r			; -0.990273
	DD	0bf7d7474r			; -0.990058
	DD	0bf7d663dr			; -0.989841
	DD	0bf7d57der			; -0.989622
	DD	0bf7d4959r			; -0.9894
	DD	0bf7d3aacr			; -0.989177
	DD	0bf7d2bd8r			; -0.98895
	DD	0bf7d1cddr			; -0.988722
	DD	0bf7d0dbcr			; -0.988491
	DD	0bf7cfe73r			; -0.988258
	DD	0bf7cef03r			; -0.988022
	DD	0bf7cdf6cr			; -0.987784
	DD	0bf7ccfaer			; -0.987544
	DD	0bf7cbfc9r			; -0.987301
	DD	0bf7cafbdr			; -0.987057
	DD	0bf7c9f8ar			; -0.986809
	DD	0bf7c8f31r			; -0.98656
	DD	0bf7c7eb0r			; -0.986308
	DD	0bf7c6e08r			; -0.986054
	DD	0bf7c5d3ar			; -0.985798
	DD	0bf7c4c44r			; -0.985539
	DD	0bf7c3b28r			; -0.985278
	DD	0bf7c29e5r			; -0.985014
	DD	0bf7c187ar			; -0.984748
	DD	0bf7c06e9r			; -0.98448
	DD	0bf7bf531r			; -0.98421
	DD	0bf7be353r			; -0.983937
	DD	0bf7bd14dr			; -0.983662
	DD	0bf7bbf20r			; -0.983385
	DD	0bf7baccdr			; -0.983105
	DD	0bf7b9a53r			; -0.982824
	DD	0bf7b87b2r			; -0.982539
	DD	0bf7b74ear			; -0.982253
	DD	0bf7b61fcr			; -0.981964
	DD	0bf7b4ee7r			; -0.981673
	DD	0bf7b3babr			; -0.981379
	DD	0bf7b2848r			; -0.981083
	DD	0bf7b14ber			; -0.980785
	DD	0bf7b010er			; -0.980485
	DD	0bf7aed37r			; -0.980182
	DD	0bf7ad93ar			; -0.979877
	DD	0bf7ac516r			; -0.97957
	DD	0bf7ab0cbr			; -0.97926
	DD	0bf7a9c59r			; -0.978948
	DD	0bf7a87c1r			; -0.978634
	DD	0bf7a7302r			; -0.978317
	DD	0bf7a5e1cr			; -0.977998
	DD	0bf7a4910r			; -0.977677
	DD	0bf7a33ddr			; -0.977354
	DD	0bf7a1e84r			; -0.977028
	DD	0bf7a0904r			; -0.9767
	DD	0bf79f35er			; -0.97637
	DD	0bf79dd91r			; -0.976037
	DD	0bf79c79dr			; -0.975702
	DD	0bf79b183r			; -0.975365
	DD	0bf799b43r			; -0.975025
	DD	0bf7984dcr			; -0.974684
	DD	0bf796e4er			; -0.974339
	DD	0bf79579ar			; -0.973993
	DD	0bf7940c0r			; -0.973644
	DD	0bf7929bfr			; -0.973293
	DD	0bf791298r			; -0.97294
	DD	0bf78fb4ar			; -0.972584
	DD	0bf78e3d6r			; -0.972227
	DD	0bf78cc3br			; -0.971866
	DD	0bf78b47br			; -0.971504
	DD	0bf789c93r			; -0.971139
	DD	0bf788486r			; -0.970772
	DD	0bf786c52r			; -0.970403
	DD	0bf7853f8r			; -0.970031
	DD	0bf783b77r			; -0.969657
	DD	0bf7822d1r			; -0.969281
	DD	0bf780a04r			; -0.968903
	DD	0bf77f110r			; -0.968522
	DD	0bf77d7f7r			; -0.968139
	DD	0bf77beb7r			; -0.967754
	DD	0bf77a551r			; -0.967366
	DD	0bf778bc5r			; -0.966976
	DD	0bf777213r			; -0.966584
	DD	0bf77583ar			; -0.96619
	DD	0bf773e3cr			; -0.965793
	DD	0bf772417r			; -0.965394
	DD	0bf7709ccr			; -0.964993
	DD	0bf76ef5br			; -0.96459
	DD	0bf76d4c4r			; -0.964184
	DD	0bf76ba07r			; -0.963776
	DD	0bf769f24r			; -0.963366
	DD	0bf76841br			; -0.962953
	DD	0bf7668ecr			; -0.962538
	DD	0bf764d97r			; -0.962121
	DD	0bf76321br			; -0.961702
	DD	0bf76167ar			; -0.96128
	DD	0bf75fab3r			; -0.960857
	DD	0bf75dec6r			; -0.960431
	DD	0bf75c2b3r			; -0.960002
	DD	0bf75a67br			; -0.959572
	DD	0bf758a1cr			; -0.959139
	DD	0bf756d97r			; -0.958703
	DD	0bf7550edr			; -0.958266
	DD	0bf75341dr			; -0.957826
	DD	0bf751727r			; -0.957385
	DD	0bf74fa0br			; -0.95694
	DD	0bf74dcc9r			; -0.956494
	DD	0bf74bf62r			; -0.956045
	DD	0bf74a1d5r			; -0.955594
	DD	0bf748422r			; -0.955141
	DD	0bf746649r			; -0.954686
	DD	0bf74484br			; -0.954228
	DD	0bf742a27r			; -0.953768
	DD	0bf740bddr			; -0.953306
	DD	0bf73ed6er			; -0.952842
	DD	0bf73ced9r			; -0.952375
	DD	0bf73b01fr			; -0.951906
	DD	0bf73913fr			; -0.951435
	DD	0bf737239r			; -0.950962
	DD	0bf73530er			; -0.950486
	DD	0bf7333ber			; -0.950008
	DD	0bf731447r			; -0.949528
	DD	0bf72f4acr			; -0.949046
	DD	0bf72d4ebr			; -0.948561
	DD	0bf72b504r			; -0.948075
	DD	0bf7294f8r			; -0.947586
	DD	0bf7274c7r			; -0.947094
	DD	0bf725470r			; -0.946601
	DD	0bf7233f4r			; -0.946105
	DD	0bf721352r			; -0.945607
	DD	0bf71f28cr			; -0.945107
	DD	0bf71d19fr			; -0.944605
	DD	0bf71b08er			; -0.9441
	DD	0bf718f57r			; -0.943593
	DD	0bf716dfbr			; -0.943084
	DD	0bf714c7ar			; -0.942573
	DD	0bf712ad4r			; -0.94206
	DD	0bf710908r			; -0.941544
	DD	0bf70e717r			; -0.941026
	DD	0bf70c501r			; -0.940506
	DD	0bf70a2c6r			; -0.939984
	DD	0bf708066r			; -0.939459
	DD	0bf705de1r			; -0.938932
	DD	0bf703b37r			; -0.938404
	DD	0bf701867r			; -0.937872
	DD	0bf6ff573r			; -0.937339
	DD	0bf6fd25ar			; -0.936803
	DD	0bf6faf1br			; -0.936266
	DD	0bf6f8bb8r			; -0.935726
	DD	0bf6f6830r			; -0.935184
	DD	0bf6f4483r			; -0.934639
	DD	0bf6f20b0r			; -0.934093
	DD	0bf6efcbar			; -0.933544
	DD	0bf6ed89er			; -0.932993
	DD	0bf6eb45dr			; -0.93244
	DD	0bf6e8ff8r			; -0.931884
	DD	0bf6e6b6dr			; -0.931327
	DD	0bf6e46ber			; -0.930767
	DD	0bf6e21ebr			; -0.930205
	DD	0bf6dfcf2r			; -0.929641
	DD	0bf6dd7d5r			; -0.929075
	DD	0bf6db293r			; -0.928506
	DD	0bf6d8d2dr			; -0.927935
	DD	0bf6d67a1r			; -0.927363
	DD	0bf6d41f2r			; -0.926787
	DD	0bf6d1c1dr			; -0.92621
	DD	0bf6cf624r			; -0.925631
	DD	0bf6cd007r			; -0.925049
	DD	0bf6ca9c5r			; -0.924465
	DD	0bf6c835er			; -0.92388
	DD	0bf6c5cd4r			; -0.923291
	DD	0bf6c3624r			; -0.922701
	DD	0bf6c0f50r			; -0.922109
	DD	0bf6be858r			; -0.921514
	DD	0bf6bc13br			; -0.920917
	DD	0bf6b99fbr			; -0.920318
	DD	0bf6b7295r			; -0.919717
	DD	0bf6b4b0cr			; -0.919114
	DD	0bf6b235er			; -0.918508
	DD	0bf6afb8cr			; -0.917901
	DD	0bf6ad395r			; -0.917291
	DD	0bf6aab7br			; -0.916679
	DD	0bf6a833cr			; -0.916065
	DD	0bf6a5ad9r			; -0.915449
	DD	0bf6a3252r			; -0.91483
	DD	0bf6a09a7r			; -0.91421
	DD	0bf69e0d7r			; -0.913587
	DD	0bf69b7e4r			; -0.912962
	DD	0bf698eccr			; -0.912335
	DD	0bf696591r			; -0.911706
	DD	0bf693c32r			; -0.911075
	DD	0bf6912aer			; -0.910441
	DD	0bf68e907r			; -0.909806
	DD	0bf68bf3cr			; -0.909168
	DD	0bf68954cr			; -0.908528
	DD	0bf686b39r			; -0.907886
	DD	0bf684103r			; -0.907242
	DD	0bf6816a8r			; -0.906596
	DD	0bf67ec29r			; -0.905947
	DD	0bf67c187r			; -0.905297
	DD	0bf6796c1r			; -0.904644
	DD	0bf676bd8r			; -0.903989
	DD	0bf6740car			; -0.903332
	DD	0bf671599r			; -0.902673
	DD	0bf66ea45r			; -0.902012
	DD	0bf66beccr			; -0.901349
	DD	0bf669330r			; -0.900683
	DD	0bf666771r			; -0.900016
	DD	0bf663b8er			; -0.899346
	DD	0bf660f88r			; -0.898674
	DD	0bf65e35er			; -0.898001
	DD	0bf65b710r			; -0.897325
	DD	0bf658aa0r			; -0.896646
	DD	0bf655e0br			; -0.895966
	DD	0bf653154r			; -0.895284
	DD	0bf650479r			; -0.894599
	DD	0bf64d77br			; -0.893913
	DD	0bf64aa59r			; -0.893224
	DD	0bf647d14r			; -0.892534
	DD	0bf644facr			; -0.891841
	DD	0bf642221r			; -0.891146
	DD	0bf63f473r			; -0.890449
	DD	0bf63c6a1r			; -0.88975
	DD	0bf6398acr			; -0.889048
	DD	0bf636a95r			; -0.888345
	DD	0bf633c5ar			; -0.88764
	DD	0bf630dfcr			; -0.886932
	DD	0bf62df7br			; -0.886223
	DD	0bf62b0d7r			; -0.885511
	DD	0bf628210r			; -0.884797
	DD	0bf625326r			; -0.884081
	DD	0bf62241ar			; -0.883363
	DD	0bf61f4ear			; -0.882643
	DD	0bf61c598r			; -0.881921
	DD	0bf619622r			; -0.881197
	DD	0bf61668ar			; -0.880471
	DD	0bf6136d0r			; -0.879743
	DD	0bf6106f2r			; -0.879012
	DD	0bf60d6f2r			; -0.87828
	DD	0bf60a6cfr			; -0.877545
	DD	0bf607689r			; -0.876809
	DD	0bf604621r			; -0.87607
	DD	0bf601596r			; -0.875329
	DD	0bf5fe4e9r			; -0.874587
	DD	0bf5fb419r			; -0.873842
	DD	0bf5f8327r			; -0.873095
	DD	0bf5f5212r			; -0.872346
	DD	0bf5f20dbr			; -0.871595
	DD	0bf5eef81r			; -0.870842
	DD	0bf5ebe05r			; -0.870087
	DD	0bf5e8c67r			; -0.86933
	DD	0bf5e5aa6r			; -0.868571
	DD	0bf5e28c3r			; -0.867809
	DD	0bf5df6ber			; -0.867046
	DD	0bf5dc497r			; -0.866281
	DD	0bf5d924dr			; -0.865514
	DD	0bf5d5fe1r			; -0.864744
	DD	0bf5d2d53r			; -0.863973
	DD	0bf5cfaa3r			; -0.863199
	DD	0bf5cc7d1r			; -0.862424
	DD	0bf5c94ddr			; -0.861646
	DD	0bf5c61c7r			; -0.860867
	DD	0bf5c2e8er			; -0.860085
	DD	0bf5bfb34r			; -0.859302
	DD	0bf5bc7b8r			; -0.858516
	DD	0bf5b941ar			; -0.857729
	DD	0bf5b605ar			; -0.856939
	DD	0bf5b2c79r			; -0.856147
	DD	0bf5af875r			; -0.855354
	DD	0bf5ac450r			; -0.854558
	DD	0bf5a9009r			; -0.85376
	DD	0bf5a5ba0r			; -0.852961
	DD	0bf5a2716r			; -0.852159
	DD	0bf59f26ar			; -0.851355
	DD	0bf59bd9cr			; -0.850549
	DD	0bf5988adr			; -0.849742
	DD	0bf59539cr			; -0.848932
	DD	0bf591e6ar			; -0.84812
	DD	0bf58e916r			; -0.847307
	DD	0bf58b3a1r			; -0.846491
	DD	0bf587e0br			; -0.845673
	DD	0bf584853r			; -0.844854
	DD	0bf581279r			; -0.844032
	DD	0bf57dc7fr			; -0.843208
	DD	0bf57a663r			; -0.842383
	DD	0bf577026r			; -0.841555
	DD	0bf5739c7r			; -0.840725
	DD	0bf570348r			; -0.839894
	DD	0bf56cca7r			; -0.83906
	DD	0bf5695e5r			; -0.838225
	DD	0bf565f02r			; -0.837387
	DD	0bf5627fer			; -0.836548
	DD	0bf55f0d9r			; -0.835706
	DD	0bf55b993r			; -0.834863
	DD	0bf55822cr			; -0.834018
	DD	0bf554aa4r			; -0.83317
	DD	0bf5512fbr			; -0.832321
	DD	0bf54db31r			; -0.83147
	DD	0bf54a347r			; -0.830616
	DD	0bf546b3br			; -0.829761
	DD	0bf54330fr			; -0.828904
	DD	0bf53fac3r			; -0.828045
	DD	0bf53c255r			; -0.827184
	DD	0bf5389c7r			; -0.826321
	DD	0bf535118r			; -0.825456
	DD	0bf531849r			; -0.824589
	DD	0bf52df59r			; -0.823721
	DD	0bf52a649r			; -0.82285
	DD	0bf526d18r			; -0.821977
	DD	0bf5233c6r			; -0.821102
	DD	0bf51fa54r			; -0.820226
	DD	0bf51c0c2r			; -0.819348
	DD	0bf518710r			; -0.818467
	DD	0bf514d3dr			; -0.817585
	DD	0bf51134ar			; -0.816701
	DD	0bf50d937r			; -0.815814
	DD	0bf509f03r			; -0.814926
	DD	0bf5064afr			; -0.814036
	DD	0bf502a3br			; -0.813144
	DD	0bf4fefa8r			; -0.812251
	DD	0bf4fb4f4r			; -0.811355
	DD	0bf4f7a1fr			; -0.810457
	DD	0bf4f3f2br			; -0.809558
	DD	0bf4f0417r			; -0.808656
	DD	0bf4ec8e4r			; -0.807753
	DD	0bf4e8d90r			; -0.806848
	DD	0bf4e521cr			; -0.80594
	DD	0bf4e1689r			; -0.805031
	DD	0bf4ddad5r			; -0.80412
	DD	0bf4d9f02r			; -0.803208
	DD	0bf4d6310r			; -0.802293
	DD	0bf4d26fdr			; -0.801376
	DD	0bf4ceacbr			; -0.800458
	DD	0bf4cae79r			; -0.799537
	DD	0bf4c7208r			; -0.798615
	DD	0bf4c3578r			; -0.797691
	DD	0bf4bf8c7r			; -0.796765
	DD	0bf4bbbf8r			; -0.795837
	DD	0bf4b7f09r			; -0.794907
	DD	0bf4b41far			; -0.793975
	DD	0bf4b04ccr			; -0.793042
	DD	0bf4ac77fr			; -0.792107
	DD	0bf4a8a13r			; -0.791169
	DD	0bf4a4c87r			; -0.79023
	DD	0bf4a0edcr			; -0.789289
	DD	0bf49d112r			; -0.788346
	DD	0bf499329r			; -0.787402
	DD	0bf495521r			; -0.786455
	DD	0bf4916far			; -0.785507
	DD	0bf48d8b3r			; -0.784557
	DD	0bf489a4er			; -0.783605
	DD	0bf485bcar			; -0.782651
	DD	0bf481d27r			; -0.781695
	DD	0bf47de65r			; -0.780737
	DD	0bf479f84r			; -0.779778
	DD	0bf476085r			; -0.778817
	DD	0bf472167r			; -0.777853
	DD	0bf46e22ar			; -0.776888
	DD	0bf46a2cer			; -0.775922
	DD	0bf466354r			; -0.774953
	DD	0bf4623bbr			; -0.773983
	DD	0bf45e403r			; -0.77301
	DD	0bf45a42dr			; -0.772036
	DD	0bf456439r			; -0.771061
	DD	0bf452426r			; -0.770083
	DD	0bf44e3f5r			; -0.769103
	DD	0bf44a3a5r			; -0.768122
	DD	0bf446337r			; -0.767139
	DD	0bf4422abr			; -0.766154
	DD	0bf43e200r			; -0.765167
	DD	0bf43a138r			; -0.764179
	DD	0bf436051r			; -0.763188
	DD	0bf431f4cr			; -0.762196
	DD	0bf42de29r			; -0.761202
	DD	0bf429ce8r			; -0.760207
	DD	0bf425b89r			; -0.759209
	DD	0bf421a0br			; -0.75821
	DD	0bf41d870r			; -0.757209
	DD	0bf4196b7r			; -0.756206
	DD	0bf4154e1r			; -0.755201
	DD	0bf4112ecr			; -0.754195
	DD	0bf40d0dar			; -0.753187
	DD	0bf408ea9r			; -0.752177
	DD	0bf404c5cr			; -0.751165
	DD	0bf4009f0r			; -0.750152
	DD	0bf3fc767r			; -0.749136
	DD	0bf3f84c0r			; -0.748119
	DD	0bf3f41fcr			; -0.747101
	DD	0bf3eff1br			; -0.74608
	DD	0bf3ebc1br			; -0.745058
	DD	0bf3e78ffr			; -0.744034
	DD	0bf3e35c5r			; -0.743008
	DD	0bf3df26er			; -0.74198
	DD	0bf3daef9r			; -0.740951
	DD	0bf3d6b67r			; -0.73992
	DD	0bf3d27b8r			; -0.738887
	DD	0bf3ce3ecr			; -0.737853
	DD	0bf3ca003r			; -0.736817
	DD	0bf3c5bfcr			; -0.735779
	DD	0bf3c17d9r			; -0.734739
	DD	0bf3bd398r			; -0.733697
	DD	0bf3b8f3br			; -0.732654
	DD	0bf3b4ac1r			; -0.731609
	DD	0bf3b0629r			; -0.730563
	DD	0bf3ac175r			; -0.729514
	DD	0bf3a7ca4r			; -0.728464
	DD	0bf3a37b7r			; -0.727413
	DD	0bf39f2acr			; -0.726359
	DD	0bf39ad85r			; -0.725304
	DD	0bf396842r			; -0.724247
	DD	0bf3922e1r			; -0.723188
	DD	0bf38dd65r			; -0.722128
	DD	0bf3897cbr			; -0.721066
	DD	0bf385216r			; -0.720003
	DD	0bf380c43r			; -0.718937
	DD	0bf37c655r			; -0.71787
	DD	0bf37804ar			; -0.716801
	DD	0bf373a23r			; -0.715731
	DD	0bf36f3dfr			; -0.714659
	DD	0bf36ad7fr			; -0.713585
	DD	0bf366704r			; -0.712509
	DD	0bf36206cr			; -0.711432
	DD	0bf35d9b8r			; -0.710353
	DD	0bf3592e7r			; -0.709273
	DD	0bf354bfbr			; -0.708191
	DD	0bf3504f3r			; -0.707107
	DD	0bf34bdcfr			; -0.706021
	DD	0bf34768fr			; -0.704934
	DD	0bf342f34r			; -0.703845
	DD	0bf33e7bcr			; -0.702755
	DD	0bf33a029r			; -0.701663
	DD	0bf33587ar			; -0.700569
	DD	0bf3310afr			; -0.699473
	DD	0bf32c8c9r			; -0.698376
	DD	0bf3280c7r			; -0.697277
	DD	0bf3238aar			; -0.696177
	DD	0bf31f071r			; -0.695075
	DD	0bf31a81dr			; -0.693971
	DD	0bf315fadr			; -0.692866
	DD	0bf311722r			; -0.691759
	DD	0bf30ce7cr			; -0.690651
	DD	0bf3085bbr			; -0.689541
	DD	0bf303cder			; -0.688429
	DD	0bf2ff3e6r			; -0.687315
	DD	0bf2faad3r			; -0.6862
	DD	0bf2f61a5r			; -0.685084
	DD	0bf2f185br			; -0.683965
	DD	0bf2ecef7r			; -0.682846
	DD	0bf2e8578r			; -0.681724
	DD	0bf2e3bder			; -0.680601
	DD	0bf2df229r			; -0.679476
	DD	0bf2da859r			; -0.67835
	DD	0bf2d5e6fr			; -0.677222
	DD	0bf2d1469r			; -0.676093
	DD	0bf2cca49r			; -0.674962
	DD	0bf2c800fr			; -0.673829
	DD	0bf2c35b9r			; -0.672695
	DD	0bf2beb4ar			; -0.671559
	DD	0bf2ba0bfr			; -0.670422
	DD	0bf2b561br			; -0.669283
	DD	0bf2b0b5br			; -0.668142
	DD	0bf2ac082r			; -0.667
	DD	0bf2a758er			; -0.665856
	DD	0bf2a2a80r			; -0.664711
	DD	0bf29df57r			; -0.663564
	DD	0bf299415r			; -0.662416
	DD	0bf2948b8r			; -0.661266
	DD	0bf28fd41r			; -0.660114
	DD	0bf28b1b0r			; -0.658961
	DD	0bf286605r			; -0.657807
	DD	0bf281a40r			; -0.656651
	DD	0bf27ce61r			; -0.655493
	DD	0bf278268r			; -0.654334
	DD	0bf273656r			; -0.653173
	DD	0bf26ea2ar			; -0.652011
	DD	0bf269de3r			; -0.650847
	DD	0bf265184r			; -0.649681
	DD	0bf26050ar			; -0.648514
	DD	0bf25b877r			; -0.647346
	DD	0bf256bcbr			; -0.646176
	DD	0bf251f04r			; -0.645005
	DD	0bf24d225r			; -0.643832
	DD	0bf24852cr			; -0.642657
	DD	0bf24381ar			; -0.641481
	DD	0bf23eaeer			; -0.640303
	DD	0bf239da9r			; -0.639124
	DD	0bf23504br			; -0.637944
	DD	0bf2302d3r			; -0.636762
	DD	0bf22b543r			; -0.635578
	DD	0bf226799r			; -0.634393
	DD	0bf2219d7r			; -0.633207
	DD	0bf21cbfbr			; -0.632019
	DD	0bf217e06r			; -0.630829
	DD	0bf212ff9r			; -0.629638
	DD	0bf20e1d2r			; -0.628446
	DD	0bf209393r			; -0.627252
	DD	0bf20453br			; -0.626056
	DD	0bf1ff6cbr			; -0.62486
	DD	0bf1fa841r			; -0.623661
	DD	0bf1f599fr			; -0.622461
	DD	0bf1f0ae5r			; -0.62126
	DD	0bf1ebc12r			; -0.620057
	DD	0bf1e6d26r			; -0.618853
	DD	0bf1e1e22r			; -0.617647
	DD	0bf1dcf06r			; -0.61644
	DD	0bf1d7fd1r			; -0.615232
	DD	0bf1d3084r			; -0.614022
	DD	0bf1ce11fr			; -0.61281
	DD	0bf1c91a2r			; -0.611597
	DD	0bf1c420cr			; -0.610383
	DD	0bf1bf25fr			; -0.609167
	DD	0bf1ba299r			; -0.60795
	DD	0bf1b52bbr			; -0.606731
	DD	0bf1b02c6r			; -0.605511
	DD	0bf1ab2b8r			; -0.60429
	DD	0bf1a6293r			; -0.603067
	DD	0bf1a1255r			; -0.601842
	DD	0bf19c200r			; -0.600616
	DD	0bf197194r			; -0.599389
	DD	0bf19210fr			; -0.598161
	DD	0bf18d073r			; -0.596931
	DD	0bf187fc0r			; -0.595699
	DD	0bf182ef5r			; -0.594467
	DD	0bf17de12r			; -0.593232
	DD	0bf178d18r			; -0.591997
	DD	0bf173c07r			; -0.59076
	DD	0bf16eader			; -0.589521
	DD	0bf16999fr			; -0.588282
	DD	0bf164847r			; -0.58704
	DD	0bf15f6d9r			; -0.585798
	DD	0bf15a554r			; -0.584554
	DD	0bf1553b7r			; -0.583309
	DD	0bf150204r			; -0.582062
	DD	0bf14b039r			; -0.580814
	DD	0bf145e58r			; -0.579565
	DD	0bf140c5fr			; -0.578314
	DD	0bf13ba50r			; -0.577062
	DD	0bf13682ar			; -0.575808
	DD	0bf1315eer			; -0.574553
	DD	0bf12c39ar			; -0.573297
	DD	0bf127130r			; -0.57204
	DD	0bf121eb0r			; -0.570781
	DD	0bf11cc19r			; -0.569521
	DD	0bf11796br			; -0.568259
	DD	0bf1126a7r			; -0.566996
	DD	0bf10d3cdr			; -0.565732
	DD	0bf1080dcr			; -0.564466
	DD	0bf102dd5r			; -0.563199
	DD	0bf0fdab8r			; -0.561931
	DD	0bf0f8784r			; -0.560662
	DD	0bf0f343br			; -0.559391
	DD	0bf0ee0dbr			; -0.558119
	DD	0bf0e8d65r			; -0.556845
	DD	0bf0e39dar			; -0.55557
	DD	0bf0de638r			; -0.554294
	DD	0bf0d9281r			; -0.553017
	DD	0bf0d3eb3r			; -0.551738
	DD	0bf0cead0r			; -0.550458
	DD	0bf0c96d7r			; -0.549177
	DD	0bf0c42c9r			; -0.547894
	DD	0bf0beea5r			; -0.54661
	DD	0bf0b9a6br			; -0.545325
	DD	0bf0b461cr			; -0.544039
	DD	0bf0af1b7r			; -0.542751
	DD	0bf0a9d3dr			; -0.541462
	DD	0bf0a48adr			; -0.540171
	DD	0bf09f409r			; -0.53888
	DD	0bf099f4er			; -0.537587
	DD	0bf094a7fr			; -0.536293
	DD	0bf08f59br			; -0.534998
	DD	0bf08a0a1r			; -0.533701
	DD	0bf084b92r			; -0.532403
	DD	0bf07f66fr			; -0.531104
	DD	0bf07a136r			; -0.529804
	DD	0bf074be8r			; -0.528502
	DD	0bf06f686r			; -0.527199
	DD	0bf06a10er			; -0.525895
	DD	0bf064b82r			; -0.52459
	DD	0bf05f5e2r			; -0.523283
	DD	0bf05a02cr			; -0.521975
	DD	0bf054a62r			; -0.520666
	DD	0bf04f484r			; -0.519356
	DD	0bf049e91r			; -0.518045
	DD	0bf044889r			; -0.516732
	DD	0bf03f26dr			; -0.515418
	DD	0bf039c3dr			; -0.514103
	DD	0bf0345f8r			; -0.512786
	DD	0bf02ef9fr			; -0.511469
	DD	0bf029932r			; -0.51015
	DD	0bf0242b1r			; -0.50883
	DD	0bf01ec1cr			; -0.507509
	DD	0bf019573r			; -0.506187
	DD	0bf013eb5r			; -0.504863
	DD	0bf00e7e4r			; -0.503538
	DD	0bf0090ffr			; -0.502212
	DD	0bf003a06r			; -0.500885
	DD	0beffc5f3r			; -0.499557
	DD	0beff17b2r			; -0.498228
	DD	0befe694ar			; -0.496897
	DD	0befdbabbr			; -0.495565
	DD	0befd0c04r			; -0.494232
	DD	0befc5d27r			; -0.492898
	DD	0befbae22r			; -0.491563
	DD	0befafef7r			; -0.490226
	DD	0befa4fa5r			; -0.488889
	DD	0bef9a02dr			; -0.48755
	DD	0bef8f08er			; -0.48621
	DD	0bef840c8r			; -0.484869
	DD	0bef790dcr			; -0.483527
	DD	0bef6e0cbr			; -0.482184
	DD	0bef63093r			; -0.480839
	DD	0bef58035r			; -0.479494
	DD	0bef4cfb1r			; -0.478147
	DD	0bef41f07r			; -0.476799
	DD	0bef36e38r			; -0.47545
	DD	0bef2bd43r			; -0.4741
	DD	0bef20c29r			; -0.472749
	DD	0bef15aear			; -0.471397
	DD	0bef0a985r			; -0.470043
	DD	0beeff7fbr			; -0.468689
	DD	0beef464cr			; -0.467333
	DD	0beee9479r			; -0.465977
	DD	0beede280r			; -0.464619
	DD	0beed3063r			; -0.46326
	DD	0beec7e21r			; -0.4619
	DD	0beebcbbbr			; -0.460539
	DD	0beeb1930r			; -0.459177
	DD	0beea6681r			; -0.457813
	DD	0bee9b3aer			; -0.456449
	DD	0bee900b7r			; -0.455084
	DD	0bee84d9cr			; -0.453717
	DD	0bee79a5dr			; -0.45235
	DD	0bee6e6fbr			; -0.450981
	DD	0bee63375r			; -0.449611
	DD	0bee57fcbr			; -0.448241
	DD	0bee4cbfer			; -0.446869
	DD	0bee4180er			; -0.445496
	DD	0bee363far			; -0.444122
	DD	0bee2afc4r			; -0.442747
	DD	0bee1fb6ar			; -0.441371
	DD	0bee146eer			; -0.439994
	DD	0bee0924fr			; -0.438616
	DD	0bedfdd8dr			; -0.437237
	DD	0bedf28a9r			; -0.435857
	DD	0bede73a2r			; -0.434476
	DD	0beddbe79r			; -0.433094
	DD	0bedd092er			; -0.431711
	DD	0bedc53c1r			; -0.430326
	DD	0bedb9e31r			; -0.428941
	DD	0bedae880r			; -0.427555
	DD	0beda32adr			; -0.426168
	DD	0bed97cb9r			; -0.42478
	DD	0bed8c6a3r			; -0.42339
	DD	0bed8106br			; -0.422
	DD	0bed75a13r			; -0.420609
	DD	0bed6a399r			; -0.419217
	DD	0bed5ecfdr			; -0.417824
	DD	0bed53641r			; -0.41643
	DD	0bed47f64r			; -0.415034
	DD	0bed3c867r			; -0.413638
	DD	0bed31148r			; -0.412241
	DD	0bed25a09r			; -0.410843
	DD	0bed1a2aar			; -0.409444
	DD	0bed0eb2ar			; -0.408044
	DD	0bed0338ar			; -0.406643
	DD	0becf7bcar			; -0.405241
	DD	0becec3ear			; -0.403838
	DD	0bece0bear			; -0.402435
	DD	0becd53car			; -0.40103
	DD	0becc9b8br			; -0.399624
	DD	0becbe32cr			; -0.398218
	DD	0becb2aaer			; -0.39681
	DD	0beca7210r			; -0.395401
	DD	0bec9b953r			; -0.393992
	DD	0bec90077r			; -0.392582
	DD	0bec8477cr			; -0.39117
	DD	0bec78e62r			; -0.389758
	DD	0bec6d529r			; -0.388345
	DD	0bec61bd2r			; -0.386931
	DD	0bec5625cr			; -0.385516
	DD	0bec4a8c8r			; -0.3841
	DD	0bec3ef15r			; -0.382683
	DD	0bec33544r			; -0.381266
	DD	0bec27b55r			; -0.379847
	DD	0bec1c148r			; -0.378428
	DD	0bec1071er			; -0.377007
	DD	0bec04cd5r			; -0.375586
	DD	0bebf926fr			; -0.374164
	DD	0bebed7ebr			; -0.372741
	DD	0bebe1d4ar			; -0.371317
	DD	0bebd628br			; -0.369892
	DD	0bebca7afr			; -0.368467
	DD	0bebbecb6r			; -0.36704
	DD	0bebb31a0r			; -0.365613
	DD	0beba766er			; -0.364185
	DD	0beb9bb1er			; -0.362756
	DD	0beb8ffb2r			; -0.361326
	DD	0beb8442ar			; -0.359895
	DD	0beb78884r			; -0.358463
	DD	0beb6ccc3r			; -0.357031
	DD	0beb610e6r			; -0.355598
	DD	0beb554ecr			; -0.354164
	DD	0beb498d6r			; -0.352729
	DD	0beb3dca5r			; -0.351293
	DD	0beb32058r			; -0.349856
	DD	0beb263efr			; -0.348419
	DD	0beb1a76br			; -0.34698
	DD	0beb0eacbr			; -0.345541
	DD	0beb02e10r			; -0.344101
	DD	0beaf713ar			; -0.342661
	DD	0beaeb449r			; -0.341219
	DD	0beadf73cr			; -0.339777
	DD	0bead3a15r			; -0.338334
	DD	0beac7cd4r			; -0.33689
	DD	0beabbf77r			; -0.335445
	DD	0beab0201r			; -0.334
	DD	0beaa446fr			; -0.332553
	DD	0bea986c4r			; -0.331106
	DD	0bea8c8fer			; -0.329658
	DD	0bea80b1fr			; -0.32821
	DD	0bea74d25r			; -0.32676
	DD	0bea68f12r			; -0.32531
	DD	0bea5d0e5r			; -0.323859
	DD	0bea5129fr			; -0.322408
	DD	0bea4543fr			; -0.320955
	DD	0bea395c5r			; -0.319502
	DD	0bea2d733r			; -0.318048
	DD	0bea21887r			; -0.316593
	DD	0bea159c2r			; -0.315138
	DD	0bea09ae5r			; -0.313682
	DD	0be9fdbeer			; -0.312225
	DD	0be9f1cdfr			; -0.310767
	DD	0be9e5db8r			; -0.309309
	DD	0be9d9e78r			; -0.30785
	DD	0be9cdf20r			; -0.30639
	DD	0be9c1fafr			; -0.304929
	DD	0be9b6027r			; -0.303468
	DD	0be9aa086r			; -0.302006
	DD	0be99e0cer			; -0.300543
	DD	0be9920fer			; -0.29908
	DD	0be986116r			; -0.297616
	DD	0be97a117r			; -0.296151
	DD	0be96e100r			; -0.294685
	DD	0be9620d2r			; -0.293219
	DD	0be95608dr			; -0.291752
	DD	0be94a031r			; -0.290285
	DD	0be93dfbfr			; -0.288816
	DD	0be931f35r			; -0.287347
	DD	0be925e94r			; -0.285878
	DD	0be919dddr			; -0.284408
	DD	0be90dd10r			; -0.282937
	DD	0be901c2cr			; -0.281465
	DD	0be8f5b32r			; -0.279993
	DD	0be8e9a22r			; -0.27852
	DD	0be8dd8fcr			; -0.277046
	DD	0be8d17c0r			; -0.275572
	DD	0be8c566er			; -0.274097
	DD	0be8b9507r			; -0.272621
	DD	0be8ad38ar			; -0.271145
	DD	0be8a11f7r			; -0.269668
	DD	0be895050r			; -0.268191
	DD	0be888e93r			; -0.266713
	DD	0be87ccc1r			; -0.265234
	DD	0be870adar			; -0.263755
	DD	0be8648dfr			; -0.262275
	DD	0be8586cer			; -0.260794
	DD	0be84c4aar			; -0.259313
	DD	0be840270r			; -0.257831
	DD	0be834022r			; -0.256349
	DD	0be827dc0r			; -0.254866
	DD	0be81bb4ar			; -0.253382
	DD	0be80f8c0r			; -0.251898
	DD	0be803622r			; -0.250413
	DD	0be7ee6e1r			; -0.248928
	DD	0be7d6156r			; -0.247442
	DD	0be7bdba4r			; -0.245955
	DD	0be7a55cbr			; -0.244468
	DD	0be78cfccr			; -0.24298
	DD	0be7749a6r			; -0.241492
	DD	0be75c35ar			; -0.240003
	DD	0be743ce8r			; -0.238514
	DD	0be72b651r			; -0.237024
	DD	0be712f94r			; -0.235533
	DD	0be6fa8b2r			; -0.234042
	DD	0be6e21abr			; -0.23255
	DD	0be6c9a7fr			; -0.231058
	DD	0be6b132fr			; -0.229565
	DD	0be698bbar			; -0.228072
	DD	0be680422r			; -0.226578
	DD	0be667c66r			; -0.225084
	DD	0be64f486r			; -0.223589
	DD	0be636c83r			; -0.222094
	DD	0be61e45cr			; -0.220598
	DD	0be605c13r			; -0.219101
	DD	0be5ed3a8r			; -0.217604
	DD	0be5d4b1ar			; -0.216107
	DD	0be5bc26ar			; -0.214609
	DD	0be5a3997r			; -0.21311
	DD	0be58b0a4r			; -0.211611
	DD	0be57278fr			; -0.210112
	DD	0be559e58r			; -0.208612
	DD	0be541501r			; -0.207111
	DD	0be528b89r			; -0.20561
	DD	0be5101f1r			; -0.204109
	DD	0be4f7838r			; -0.202607
	DD	0be4dee60r			; -0.201105
	DD	0be4c6467r			; -0.199602
	DD	0be4ada4fr			; -0.198098
	DD	0be495018r			; -0.196595
	DD	0be47c5c2r			; -0.19509
	DD	0be463b4dr			; -0.193586
	DD	0be44b0b9r			; -0.19208
	DD	0be432607r			; -0.190575
	DD	0be419b37r			; -0.189069
	DD	0be401049r			; -0.187562
	DD	0be3e853er			; -0.186055
	DD	0be3cfa15r			; -0.184548
	DD	0be3b6ecfr			; -0.18304
	DD	0be39e36cr			; -0.181532
	DD	0be3857ecr			; -0.180023
	DD	0be36cc50r			; -0.178514
	DD	0be354098r			; -0.177004
	DD	0be33b4c4r			; -0.175494
	DD	0be3228d4r			; -0.173984
	DD	0be309cc9r			; -0.172473
	DD	0be2f10a2r			; -0.170962
	DD	0be2d8461r			; -0.16945
	DD	0be2bf804r			; -0.167938
	DD	0be2a6b8dr			; -0.166426
	DD	0be28defcr			; -0.164913
	DD	0be275251r			; -0.1634
	DD	0be25c58cr			; -0.161886
	DD	0be2438adr			; -0.160372
	DD	0be22abb6r			; -0.158858
	DD	0be211ea5r			; -0.157343
	DD	0be1f917br			; -0.155828
	DD	0be1e0438r			; -0.154313
	DD	0be1c76der			; -0.152797
	DD	0be1ae96br			; -0.151281
	DD	0be195be0r			; -0.149765
	DD	0be17ce3dr			; -0.148248
	DD	0be164083r			; -0.14673
	DD	0be14b2b2r			; -0.145213
	DD	0be1324car			; -0.143695
	DD	0be1196ccr			; -0.142177
	DD	0be1008b7r			; -0.140658
	DD	0be0e7a8br			; -0.139139
	DD	0be0cec4ar			; -0.13762
	DD	0be0b5df3r			; -0.136101
	DD	0be09cf86r			; -0.134581
	DD	0be084105r			; -0.133061
	DD	0be06b26er			; -0.13154
	DD	0be0523c2r			; -0.130019
	DD	0be039502r			; -0.128498
	DD	0be02062er			; -0.126977
	DD	0be007745r			; -0.125455
	DD	0bdfdd092r			; -0.123933
	DD	0bdfab273r			; -0.122411
	DD	0bdf7942cr			; -0.120888
	DD	0bdf475c0r			; -0.119365
	DD	0bdf1572er			; -0.117842
	DD	0bdee3876r			; -0.116319
	DD	0bdeb199ar			; -0.114795
	DD	0bde7fa9ar			; -0.113271
	DD	0bde4db76r			; -0.111747
	DD	0bde1bc2er			; -0.110222
	DD	0bdde9cc4r			; -0.108697
	DD	0bddb7d37r			; -0.107172
	DD	0bdd85d89r			; -0.105647
	DD	0bdd53db9r			; -0.104122
	DD	0bdd21dc8r			; -0.102596
	DD	0bdcefdb7r			; -0.10107
	DD	0bdcbdd86r			; -0.0995436
	DD	0bdc8bd36r			; -0.0980171
	DD	0bdc59cc6r			; -0.0964904
	DD	0bdc27c39r			; -0.0949635
	DD	0bdbf5b8dr			; -0.0934363
	DD	0bdbc3ac3r			; -0.091909
	DD	0bdb919ddr			; -0.0903814
	DD	0bdb5f8dar			; -0.0888536
	DD	0bdb2d7bbr			; -0.0873255
	DD	0bdafb680r			; -0.0857973
	DD	0bdac952br			; -0.0842689
	DD	0bda973bar			; -0.0827403
	DD	0bda65230r			; -0.0812114
	DD	0bda3308cr			; -0.0796824
	DD	0bda00ecfr			; -0.0781532
	DD	0bd9cecf9r			; -0.0766239
	DD	0bd99cb0ar			; -0.0750943
	DD	0bd96a905r			; -0.0735646
	DD	0bd9386e7r			; -0.0720346
	DD	0bd9064b4r			; -0.0705046
	DD	0bd8d426ar			; -0.0689743
	DD	0bd8a200ar			; -0.0674439
	DD	0bd86fd94r			; -0.0659133
	DD	0bd83db0ar			; -0.0643826
	DD	0bd80b86cr			; -0.0628518
	DD	0bd7b2b74r			; -0.0613207
	DD	0bd74e5e9r			; -0.0597896
	DD	0bd6ea038r			; -0.0582583
	DD	0bd685a62r			; -0.0567268
	DD	0bd621469r			; -0.0551952
	DD	0bd5bce4cr			; -0.0536635
	DD	0bd55880er			; -0.0521317
	DD	0bd4f41afr			; -0.0505998
	DD	0bd48fb30r			; -0.0490677
	DD	0bd42b491r			; -0.0475355
	DD	0bd3c6dd5r			; -0.0460032
	DD	0bd3626fcr			; -0.0444708
	DD	0bd2fe007r			; -0.0429383
	DD	0bd2998f6r			; -0.0414056
	DD	0bd2351cbr			; -0.0398729
	DD	0bd1d0a88r			; -0.0383401
	DD	0bd16c32cr			; -0.0368072
	DD	0bd107bb8r			; -0.0352742
	DD	0bd0a342fr			; -0.0337412
	DD	0bd03ec90r			; -0.032208
	DD	0bcfb49bar			; -0.0306748
	DD	0bceeba2cr			; -0.0291415
	DD	0bce22a7ar			; -0.0276081
	DD	0bcd59aa6r			; -0.0260747
	DD	0bcc90ab0r			; -0.0245412
	DD	0bcbc7a9br			; -0.0230077
	DD	0bcafea69r			; -0.0214741
	DD	0bca35a1cr			; -0.0199404
	DD	0bc96c9b6r			; -0.0184067
	DD	0bc8a3938r			; -0.016873
	DD	0bc7b514br			; -0.0153392
	DD	0bc622fffr			; -0.0138054
	DD	0bc490e90r			; -0.0122715
	DD	0bc2fed02r			; -0.0107377
	DD	0bc16cb58r			; -0.00920375
	DD	0bbfb5330r			; -0.00766983
	DD	0bbc90f88r			; -0.00613588
	DD	0bb96cbc1r			; -0.00460193
	DD	0bb490fc6r			; -0.00306796
	DD	0bac90fd5r			; -0.00153398
?g_fIdvTanTable@@3QBMB DD 000000000r		; 0	; g_fIdvTanTable
	DD	03ac90fe5r			; 0.00153398
	DD	03b491004r			; 0.00306797
	DD	03b96cc2ar			; 0.00460197
	DD	03bc91080r			; 0.006136
	DD	03bfb5514r			; 0.00767005
	DD	03c16ccfbr			; 0.00920414
	DD	03c2fef9ar			; 0.0107383
	DD	03c491270r			; 0.0122725
	DD	03c623584r			; 0.0138067
	DD	03c7b58ddr			; 0.015341
	DD	03c8a3e42r			; 0.0168754
	DD	03c96d040r			; 0.0184098
	DD	03ca3626dr			; 0.0199444
	DD	03caff4ccr			; 0.021479
	DD	03cbc8762r			; 0.0230138
	DD	03cc91a31r			; 0.0245486
	DD	03cd5ad3fr			; 0.0260836
	DD	03ce2408er			; 0.0276187
	DD	03ceed424r			; 0.0291539
	DD	03cfb6803r			; 0.0306892
	DD	03d03fe18r			; 0.0322247
	DD	03d0a4857r			; 0.0337604
	DD	03d1092c1r			; 0.0352962
	DD	03d16dd57r			; 0.0368322
	DD	03d1d281cr			; 0.0383683
	DD	03d237312r			; 0.0399047
	DD	03d29be3ar			; 0.0414412
	DD	03d300997r			; 0.0429779
	DD	03d36552ar			; 0.0445148
	DD	03d3ca0f5r			; 0.0460519
	DD	03d42ecfar			; 0.0475893
	DD	03d49393cr			; 0.0491268
	DD	03d4f85bcr			; 0.0506646
	DD	03d55d27dr			; 0.0522027
	DD	03d5c1f7fr			; 0.053741
	DD	03d626cc5r			; 0.0552795
	DD	03d68ba52r			; 0.0568183
	DD	03d6f0826r			; 0.0583574
	DD	03d755645r			; 0.0598967
	DD	03d7ba4afr			; 0.0614364
	DD	03d80f9b4r			; 0.0629763
	DD	03d842138r			; 0.0645165
	DD	03d8748e5r			; 0.066057
	DD	03d8a70bcr			; 0.0675978
	DD	03d8d98ber			; 0.069139
	DD	03d90c0ebr			; 0.0706805
	DD	03d93e946r			; 0.0722223
	DD	03d9711cer			; 0.0737644
	DD	03d9a3a86r			; 0.0753069
	DD	03d9d636dr			; 0.0768498
	DD	03da08c85r			; 0.078393
	DD	03da3b5cfr			; 0.0799366
	DD	03da6df4br			; 0.0814806
	DD	03daa08fbr			; 0.0830249
	DD	03dad32e1r			; 0.0845697
	DD	03db05cfcr			; 0.0861149
	DD	03db3874dr			; 0.0876604
	DD	03db6b1d7r			; 0.0892064
	DD	03db9dc99r			; 0.0907528
	DD	03dbd0796r			; 0.0922996
	DD	03dc032cdr			; 0.0938469
	DD	03dc35e3fr			; 0.0953946
	DD	03dc689efr			; 0.0969428
	DD	03dc9b5dcr			; 0.0984914
	DD	03dcce209r			; 0.100041
	DD	03dd00e75r			; 0.10159
	DD	03dd33b22r			; 0.10314
	DD	03dd66810r			; 0.104691
	DD	03dd99542r			; 0.106242
	DD	03ddcc2b7r			; 0.107793
	DD	03ddff072r			; 0.109345
	DD	03de31e72r			; 0.110898
	DD	03de64cb9r			; 0.112451
	DD	03de97b48r			; 0.114005
	DD	03decaa20r			; 0.115559
	DD	03defd942r			; 0.117114
	DD	03df308afr			; 0.118669
	DD	03df63868r			; 0.120225
	DD	03df9686er			; 0.121781
	DD	03dfc98c2r			; 0.123338
	DD	03dffc965r			; 0.124896
	DD	03e017d2cr			; 0.126454
	DD	03e0315cer			; 0.128013
	DD	03e04ae9ar			; 0.129572
	DD	03e06478fr			; 0.131132
	DD	03e07e0aer			; 0.132693
	DD	03e0979f7r			; 0.134254
	DD	03e0b136cr			; 0.135816
	DD	03e0cad0dr			; 0.137379
	DD	03e0e46d9r			; 0.138942
	DD	03e0fe0d3r			; 0.140506
	DD	03e117afar			; 0.142071
	DD	03e13154er			; 0.143636
	DD	03e14afd1r			; 0.145202
	DD	03e164a83r			; 0.146769
	DD	03e17e564r			; 0.148336
	DD	03e198074r			; 0.149904
	DD	03e1b1bb6r			; 0.151473
	DD	03e1cb728r			; 0.153042
	DD	03e1e52ccr			; 0.154613
	DD	03e1feea1r			; 0.156184
	DD	03e218aaar			; 0.157756
	DD	03e2326e5r			; 0.159328
	DD	03e24c354r			; 0.160901
	DD	03e265ff7r			; 0.162475
	DD	03e27fccer			; 0.16405
	DD	03e2999dbr			; 0.165626
	DD	03e2b371er			; 0.167202
	DD	03e2cd497r			; 0.16878
	DD	03e2e7246r			; 0.170358
	DD	03e30102er			; 0.171937
	DD	03e31ae4dr			; 0.173516
	DD	03e334ca4r			; 0.175097
	DD	03e34eb34r			; 0.176678
	DD	03e3689fer			; 0.178261
	DD	03e382902r			; 0.179844
	DD	03e39c841r			; 0.181428
	DD	03e3b67bbr			; 0.183013
	DD	03e3d0771r			; 0.184599
	DD	03e3ea763r			; 0.186185
	DD	03e404791r			; 0.187773
	DD	03e41e7fer			; 0.189362
	DD	03e4388a8r			; 0.190951
	DD	03e452990r			; 0.192541
	DD	03e46cab8r			; 0.194133
	DD	03e486c1fr			; 0.195725
	DD	03e4a0dc7r			; 0.197318
	DD	03e4bafafr			; 0.198912
	DD	03e4d51d9r			; 0.200508
	DD	03e4ef444r			; 0.202104
	DD	03e5096f2r			; 0.203701
	DD	03e5239e3r			; 0.205299
	DD	03e53dd17r			; 0.206898
	DD	03e558090r			; 0.208498
	DD	03e57244dr			; 0.210099
	DD	03e58c84fr			; 0.211702
	DD	03e5a6c98r			; 0.213305
	DD	03e5c1127r			; 0.214909
	DD	03e5db5fdr			; 0.216515
	DD	03e5f5b1ar			; 0.218121
	DD	03e610080r			; 0.219728
	DD	03e62a62er			; 0.221337
	DD	03e644c26r			; 0.222947
	DD	03e65f267r			; 0.224558
	DD	03e6798f3r			; 0.226169
	DD	03e693fcbr			; 0.227782
	DD	03e6ae6edr			; 0.229397
	DD	03e6c8e5dr			; 0.231012
	DD	03e6e3619r			; 0.232628
	DD	03e6fde22r			; 0.234246
	DD	03e718679r			; 0.235865
	DD	03e732f20r			; 0.237484
	DD	03e74d815r			; 0.239106
	DD	03e76815ar			; 0.240728
	DD	03e782af0r			; 0.242351
	DD	03e79d4d6r			; 0.243976
	DD	03e7b7f0fr			; 0.245602
	DD	03e7d2999r			; 0.247229
	DD	03e7ed477r			; 0.248857
	DD	03e803fd4r			; 0.250487
	DD	03e811596r			; 0.252118
	DD	03e81eb83r			; 0.25375
	DD	03e82c19ar			; 0.255383
	DD	03e8397ddr			; 0.257018
	DD	03e846e4ar			; 0.258654
	DD	03e8544e4r			; 0.260291
	DD	03e861ba9r			; 0.26193
	DD	03e86f29ar			; 0.26357
	DD	03e87c9b8r			; 0.265211
	DD	03e88a103r			; 0.266853
	DD	03e89787br			; 0.268497
	DD	03e8a5020r			; 0.270143
	DD	03e8b27f3r			; 0.271789
	DD	03e8bfff4r			; 0.273437
	DD	03e8cd824r			; 0.275087
	DD	03e8db082r			; 0.276737
	DD	03e8e890fr			; 0.278389
	DD	03e8f61ccr			; 0.280043
	DD	03e903ab8r			; 0.281698
	DD	03e9113d5r			; 0.283354
	DD	03e91ed21r			; 0.285012
	DD	03e92c69fr			; 0.286672
	DD	03e93a04dr			; 0.288332
	DD	03e947a2dr			; 0.289995
	DD	03e95543er			; 0.291658
	DD	03e962e82r			; 0.293324
	DD	03e9708f7r			; 0.29499
	DD	03e97e3a0r			; 0.296659
	DD	03e98be7br			; 0.298328
	DD	03e999989r			; 0.3
	DD	03e9a74ccr			; 0.301672
	DD	03e9b5042r			; 0.303347
	DD	03e9c2becr			; 0.305023
	DD	03e9d07cbr			; 0.3067
	DD	03e9de3dfr			; 0.308379
	DD	03e9ec029r			; 0.31006
	DD	03e9f9ca8r			; 0.311742
	DD	03ea0795dr			; 0.313426
	DD	03ea15648r			; 0.315111
	DD	03ea2336br			; 0.316799
	DD	03ea310c4r			; 0.318487
	DD	03ea3ee54r			; 0.320178
	DD	03ea4cc1dr			; 0.32187
	DD	03ea5aa1dr			; 0.323563
	DD	03ea68856r			; 0.325259
	DD	03ea766c8r			; 0.326956
	DD	03ea84573r			; 0.328655
	DD	03ea92457r			; 0.330355
	DD	03eaa0375r			; 0.332058
	DD	03eaae2cer			; 0.333762
	DD	03eabc261r			; 0.335467
	DD	03eaca22fr			; 0.337175
	DD	03ead8238r			; 0.338884
	DD	03eae627dr			; 0.340595
	DD	03eaf42fer			; 0.342308
	DD	03eb023bbr			; 0.344023
	DD	03eb104b5r			; 0.345739
	DD	03eb1e5ecr			; 0.347457
	DD	03eb2c761r			; 0.349177
	DD	03eb3a913r			; 0.350899
	DD	03eb48b04r			; 0.352623
	DD	03eb56d34r			; 0.354349
	DD	03eb64fa2r			; 0.356076
	DD	03eb73250r			; 0.357806
	DD	03eb8153dr			; 0.359537
	DD	03eb8f86br			; 0.36127
	DD	03eb9dbd9r			; 0.363005
	DD	03ebabf88r			; 0.364743
	DD	03ebba378r			; 0.366482
	DD	03ebc87aar			; 0.368223
	DD	03ebd6c1er			; 0.369965
	DD	03ebe50d4r			; 0.37171
	DD	03ebf35cdr			; 0.373457
	DD	03ec01b0ar			; 0.375206
	DD	03ec10089r			; 0.376957
	DD	03ec1e64dr			; 0.37871
	DD	03ec2cc56r			; 0.380465
	DD	03ec3b2a3r			; 0.382222
	DD	03ec49935r			; 0.383981
	DD	03ec5800dr			; 0.385743
	DD	03ec6672ar			; 0.387506
	DD	03ec74e8fr			; 0.389271
	DD	03ec8363ar			; 0.391039
	DD	03ec91e2cr			; 0.392808
	DD	03eca0666r			; 0.39458
	DD	03ecaeee7r			; 0.396354
	DD	03ecbd7b1r			; 0.39813
	DD	03eccc0c4r			; 0.399908
	DD	03ecdaa21r			; 0.401689
	DD	03ece93c7r			; 0.403471
	DD	03ecf7db7r			; 0.405256
	DD	03ed067f1r			; 0.407043
	DD	03ed15277r			; 0.408832
	DD	03ed23d47r			; 0.410624
	DD	03ed32864r			; 0.412418
	DD	03ed413cdr			; 0.414214
	DD	03ed4ff82r			; 0.416012
	DD	03ed5eb85r			; 0.417812
	DD	03ed6d7d5r			; 0.419615
	DD	03ed7c473r			; 0.421421
	DD	03ed8b15fr			; 0.423228
	DD	03ed99e9ar			; 0.425038
	DD	03eda8c24r			; 0.42685
	DD	03edb79fer			; 0.428665
	DD	03edc6828r			; 0.430482
	DD	03edd56a3r			; 0.432302
	DD	03ede456fr			; 0.434123
	DD	03edf348cr			; 0.435948
	DD	03ee023fbr			; 0.437775
	DD	03ee113bdr			; 0.439604
	DD	03ee203d1r			; 0.441435
	DD	03ee2f439r			; 0.44327
	DD	03ee3e4f4r			; 0.445106
	DD	03ee4d604r			; 0.446945
	DD	03ee5c768r			; 0.448787
	DD	03ee6b922r			; 0.450631
	DD	03ee7ab31r			; 0.452478
	DD	03ee89d96r			; 0.454327
	DD	03ee99051r			; 0.456179
	DD	03eea8364r			; 0.458034
	DD	03eeb76cer			; 0.459891
	DD	03eec6a90r			; 0.461751
	DD	03eed5eabr			; 0.463613
	DD	03eee531fr			; 0.465478
	DD	03eef47ecr			; 0.467346
	DD	03ef03d13r			; 0.469216
	DD	03ef13294r			; 0.471089
	DD	03ef22870r			; 0.472965
	DD	03ef31ea8r			; 0.474843
	DD	03ef4153cr			; 0.476725
	DD	03ef50c2cr			; 0.478608
	DD	03ef60378r			; 0.480495
	DD	03ef6fb23r			; 0.482385
	DD	03ef7f32br			; 0.484277
	DD	03ef8eb91r			; 0.486172
	DD	03ef9e457r			; 0.48807
	DD	03efadd7cr			; 0.489971
	DD	03efbd701r			; 0.491875
	DD	03efcd0e6r			; 0.493781
	DD	03efdcb2cr			; 0.495691
	DD	03efec5d4r			; 0.497603
	DD	03effc0der			; 0.499518
	DD	03f005e25r			; 0.501437
	DD	03f00dc0dr			; 0.503358
	DD	03f015a26r			; 0.505282
	DD	03f01d872r			; 0.507209
	DD	03f0256f0r			; 0.509139
	DD	03f02d5a1r			; 0.511072
	DD	03f035484r			; 0.513008
	DD	03f03d39br			; 0.514948
	DD	03f0452e5r			; 0.51689
	DD	03f04d263r			; 0.518835
	DD	03f055215r			; 0.520784
	DD	03f05d1fbr			; 0.522735
	DD	03f065215r			; 0.52469
	DD	03f06d265r			; 0.526648
	DD	03f0752e9r			; 0.528609
	DD	03f07d3a3r			; 0.530573
	DD	03f085493r			; 0.532541
	DD	03f08d5b9r			; 0.534511
	DD	03f095715r			; 0.536485
	DD	03f09d8a7r			; 0.538462
	DD	03f0a5a70r			; 0.540442
	DD	03f0adc71r			; 0.542426
	DD	03f0b5ea9r			; 0.544413
	DD	03f0be118r			; 0.546403
	DD	03f0c63c0r			; 0.548397
	DD	03f0ce6a0r			; 0.550394
	DD	03f0d69b9r			; 0.552394
	DD	03f0ded0ar			; 0.554398
	DD	03f0e7095r			; 0.556405
	DD	03f0ef459r			; 0.558416
	DD	03f0f7857r			; 0.56043
	DD	03f0ffc8fr			; 0.562447
	DD	03f108102r			; 0.564469
	DD	03f1105afr			; 0.566493
	DD	03f118a98r			; 0.568521
	DD	03f120fbcr			; 0.570553
	DD	03f12951cr			; 0.572588
	DD	03f131ab7r			; 0.574626
	DD	03f13a08fr			; 0.576669
	DD	03f1426a4r			; 0.578715
	DD	03f14acf6r			; 0.580764
	DD	03f153385r			; 0.582817
	DD	03f15ba52r			; 0.584874
	DD	03f16415cr			; 0.586935
	DD	03f16c8a5r			; 0.588999
	DD	03f17502dr			; 0.591067
	DD	03f17d7f3r			; 0.593139
	DD	03f185ff9r			; 0.595214
	DD	03f18e83fr			; 0.597294
	DD	03f1970c4r			; 0.599377
	DD	03f19f98ar			; 0.601464
	DD	03f1a8291r			; 0.603555
	DD	03f1b0bd8r			; 0.605649
	DD	03f1b9561r			; 0.607748
	DD	03f1c1f2cr			; 0.609851
	DD	03f1ca938r			; 0.611957
	DD	03f1d3387r			; 0.614067
	DD	03f1dbe19r			; 0.616182
	DD	03f1e48eer			; 0.6183
	DD	03f1ed407r			; 0.620423
	DD	03f1f5f63r			; 0.622549
	DD	03f1feb03r			; 0.62468
	DD	03f2076e9r			; 0.626814
	DD	03f210313r			; 0.628953
	DD	03f218f82r			; 0.631096
	DD	03f221c37r			; 0.633243
	DD	03f22a932r			; 0.635394
	DD	03f233673r			; 0.63755
	DD	03f23c3fcr			; 0.639709
	DD	03f2451cbr			; 0.641873
	DD	03f24dfe2r			; 0.644041
	DD	03f256e41r			; 0.646214
	DD	03f25fce8r			; 0.64839
	DD	03f268bd8r			; 0.650571
	DD	03f271b11r			; 0.652757
	DD	03f27aa94r			; 0.654947
	DD	03f283a60r			; 0.657141
	DD	03f28ca77r			; 0.659339
	DD	03f295ad9r			; 0.661542
	DD	03f29eb85r			; 0.66375
	DD	03f2a7c7dr			; 0.665962
	DD	03f2b0dc1r			; 0.668179
	DD	03f2b9f52r			; 0.6704
	DD	03f2c312fr			; 0.672625
	DD	03f2cc359r			; 0.674856
	DD	03f2d55d0r			; 0.677091
	DD	03f2de896r			; 0.67933
	DD	03f2e7baar			; 0.681574
	DD	03f2f0f0dr			; 0.683823
	DD	03f2fa2bfr			; 0.686077
	DD	03f3036c1r			; 0.688335
	DD	03f30cb13r			; 0.690599
	DD	03f315fb5r			; 0.692867
	DD	03f31f4a9r			; 0.695139
	DD	03f3289edr			; 0.697417
	DD	03f331f84r			; 0.6997
	DD	03f33b56dr			; 0.701987
	DD	03f344ba9r			; 0.704279
	DD	03f34e238r			; 0.706577
	DD	03f35791ar			; 0.708879
	DD	03f361051r			; 0.711186
	DD	03f36a7dcr			; 0.713499
	DD	03f373fbcr			; 0.715816
	DD	03f37d7f2r			; 0.718139
	DD	03f38707dr			; 0.720466
	DD	03f39095fr			; 0.722799
	DD	03f39a298r			; 0.725137
	DD	03f3a3c28r			; 0.72748
	DD	03f3ad610r			; 0.729829
	DD	03f3b7051r			; 0.732183
	DD	03f3c0aear			; 0.734542
	DD	03f3ca5ddr			; 0.736906
	DD	03f3d4129r			; 0.739276
	DD	03f3ddccfr			; 0.741651
	DD	03f3e78d1r			; 0.744031
	DD	03f3f152dr			; 0.746417
	DD	03f3fb1e6r			; 0.748808
	DD	03f404efar			; 0.751205
	DD	03f40ec6cr			; 0.753608
	DD	03f418a3ar			; 0.756015
	DD	03f422867r			; 0.758429
	DD	03f42c6f2r			; 0.760848
	DD	03f4365dcr			; 0.763273
	DD	03f440525r			; 0.765703
	DD	03f44a4cer			; 0.76814
	DD	03f4544d7r			; 0.770582
	DD	03f45e541r			; 0.773029
	DD	03f46860dr			; 0.775483
	DD	03f47273br			; 0.777942
	DD	03f47c8ccr			; 0.780408
	DD	03f486ac0r			; 0.782879
	DD	03f490d17r			; 0.785356
	DD	03f49afd3r			; 0.787839
	DD	03f4a52f3r			; 0.790328
	DD	03f4af679r			; 0.792823
	DD	03f4b9a65r			; 0.795325
	DD	03f4c3eb7r			; 0.797832
	DD	03f4ce370r			; 0.800345
	DD	03f4d8892r			; 0.802865
	DD	03f4e2e1br			; 0.805391
	DD	03f4ed40dr			; 0.807923
	DD	03f4f7a69r			; 0.810462
	DD	03f50212er			; 0.813006
	DD	03f50c85fr			; 0.815557
	DD	03f516ffar			; 0.818115
	DD	03f521801r			; 0.820679
	DD	03f52c075r			; 0.823249
	DD	03f536956r			; 0.825826
	DD	03f5412a4r			; 0.828409
	DD	03f54bc61r			; 0.830999
	DD	03f55668dr			; 0.833596
	DD	03f561128r			; 0.836199
	DD	03f56bc34r			; 0.838809
	DD	03f5767b0r			; 0.841426
	DD	03f58139er			; 0.844049
	DD	03f58bffdr			; 0.84668
	DD	03f596cd0r			; 0.849317
	DD	03f5a1a16r			; 0.851961
	DD	03f5ac7d0r			; 0.854611
	DD	03f5b75ffr			; 0.857269
	DD	03f5c24a4r			; 0.859934
	DD	03f5cd3ber			; 0.862606
	DD	03f5d834fr			; 0.865285
	DD	03f5e3358r			; 0.867971
	DD	03f5ee3d9r			; 0.870664
	DD	03f5f94d3r			; 0.873365
	DD	03f604646r			; 0.876072
	DD	03f60f834r			; 0.878787
	DD	03f61aa9cr			; 0.88151
	DD	03f625d80r			; 0.884239
	DD	03f6310e1r			; 0.886976
	DD	03f63c4bfr			; 0.889721
	DD	03f64791ar			; 0.892473
	DD	03f652df5r			; 0.895232
	DD	03f65e34er			; 0.898
	DD	03f669928r			; 0.900774
	DD	03f674f82r			; 0.903557
	DD	03f68065er			; 0.906347
	DD	03f68bdbdr			; 0.909145
	DD	03f69759er			; 0.911951
	DD	03f6a2e04r			; 0.914765
	DD	03f6ae6eer			; 0.917586
	DD	03f6ba05dr			; 0.920416
	DD	03f6c5a53r			; 0.923253
	DD	03f6d14d0r			; 0.926099
	DD	03f6dcfd4r			; 0.928952
	DD	03f6e8b62r			; 0.931814
	DD	03f6f4778r			; 0.934684
	DD	03f700419r			; 0.937563
	DD	03f70c145r			; 0.940449
	DD	03f717efdr			; 0.943344
	DD	03f723d42r			; 0.946247
	DD	03f72fc15r			; 0.949159
	DD	03f73bb75r			; 0.952079
	DD	03f747b66r			; 0.955008
	DD	03f753be6r			; 0.957945
	DD	03f75fcf7r			; 0.960891
	DD	03f76be9br			; 0.963846
	DD	03f7780d1r			; 0.966809
	DD	03f78439br			; 0.969782
	DD	03f7906f9r			; 0.972763
	DD	03f79caedr			; 0.975753
	DD	03f7a8f77r			; 0.978752
	DD	03f7b5499r			; 0.98176
	DD	03f7c1a53r			; 0.984777
	DD	03f7ce0a6r			; 0.987803
	DD	03f7da793r			; 0.990838
	DD	03f7e6f1br			; 0.993883
	DD	03f7f373fr			; 0.996937
	DD	03f800000r			; 1
	DD	03f8064afr			; 1.00307
	DD	03f80c9aer			; 1.00615
	DD	03f812efdr			; 1.00925
	DD	03f81949dr			; 1.01235
	DD	03f81fa8dr			; 1.01546
	DD	03f8260cer			; 1.01858
	DD	03f82c762r			; 1.02171
	DD	03f832e48r			; 1.02485
	DD	03f839581r			; 1.028
	DD	03f83fd0dr			; 1.03116
	DD	03f8464eer			; 1.03433
	DD	03f84cd23r			; 1.03751
	DD	03f8535adr			; 1.0407
	DD	03f859e8cr			; 1.0439
	DD	03f8607c2r			; 1.04711
	DD	03f86714fr			; 1.05033
	DD	03f86db32r			; 1.05356
	DD	03f87456dr			; 1.05681
	DD	03f87b001r			; 1.06006
	DD	03f881aeer			; 1.06332
	DD	03f888634r			; 1.0666
	DD	03f88f1d4r			; 1.06988
	DD	03f895dcer			; 1.07318
	DD	03f89ca24r			; 1.07648
	DD	03f8a36d5r			; 1.0798
	DD	03f8aa3e3r			; 1.08313
	DD	03f8b114er			; 1.08647
	DD	03f8b7f16r			; 1.08982
	DD	03f8bed3dr			; 1.09318
	DD	03f8c5bc2r			; 1.09655
	DD	03f8ccaa6r			; 1.09993
	DD	03f8d39ebr			; 1.10333
	DD	03f8da990r			; 1.10674
	DD	03f8e1996r			; 1.11016
	DD	03f8e89fer			; 1.11359
	DD	03f8efac8r			; 1.11703
	DD	03f8f6bf6r			; 1.12048
	DD	03f8fdd88r			; 1.12395
	DD	03f904f7dr			; 1.12743
	DD	03f90c1d8r			; 1.13092
	DD	03f913499r			; 1.13442
	DD	03f91a7c0r			; 1.13793
	DD	03f921b4er			; 1.14146
	DD	03f928f44r			; 1.145
	DD	03f9303a3r			; 1.14855
	DD	03f93786ar			; 1.15211
	DD	03f93ed9cr			; 1.15569
	DD	03f946338r			; 1.15928
	DD	03f94d93fr			; 1.16288
	DD	03f954fb3r			; 1.16649
	DD	03f95c693r			; 1.17012
	DD	03f963de0r			; 1.17376
	DD	03f96b59cr			; 1.17742
	DD	03f972dc6r			; 1.18108
	DD	03f97a660r			; 1.18476
	DD	03f981f6br			; 1.18846
	DD	03f9898e7r			; 1.19217
	DD	03f9912d5r			; 1.19589
	DD	03f998d35r			; 1.19962
	DD	03f9a0809r			; 1.20337
	DD	03f9a8352r			; 1.20713
	DD	03f9aff0fr			; 1.21091
	DD	03f9b7b42r			; 1.2147
	DD	03f9bf7ecr			; 1.2185
	DD	03f9c750er			; 1.22232
	DD	03f9cf2a8r			; 1.22616
	DD	03f9d70bbr			; 1.23
	DD	03f9def48r			; 1.23386
	DD	03f9e6e50r			; 1.23774
	DD	03f9eedd4r			; 1.24163
	DD	03f9f6dd4r			; 1.24554
	DD	03f9fee52r			; 1.24946
	DD	03fa06f4er			; 1.2534
	DD	03fa0f0car			; 1.25735
	DD	03fa172c5r			; 1.26131
	DD	03fa1f541r			; 1.2653
	DD	03fa27840r			; 1.26929
	DD	03fa2fbc1r			; 1.27331
	DD	03fa37fc6r			; 1.27734
	DD	03fa40450r			; 1.28138
	DD	03fa4895fr			; 1.28544
	DD	03fa50ef5r			; 1.28952
	DD	03fa59513r			; 1.29361
	DD	03fa61bb9r			; 1.29772
	DD	03fa6a2e8r			; 1.30185
	DD	03fa72aa2r			; 1.30599
	DD	03fa7b2e8r			; 1.31015
	DD	03fa83bbar			; 1.31432
	DD	03fa8c519r			; 1.31851
	DD	03fa94f08r			; 1.32272
	DD	03fa9d985r			; 1.32695
	DD	03faa6494r			; 1.33119
	DD	03faaf034r			; 1.33546
	DD	03fab7c66r			; 1.33973
	DD	03fac092dr			; 1.34403
	DD	03fac9689r			; 1.34834
	DD	03fad247ar			; 1.35268
	DD	03fadb303r			; 1.35703
	DD	03fae4224r			; 1.36139
	DD	03faed1der			; 1.36578
	DD	03faf6232r			; 1.37018
	DD	03faff323r			; 1.37461
	DD	03fb084b0r			; 1.37905
	DD	03fb116dbr			; 1.38351
	DD	03fb1a9a5r			; 1.38799
	DD	03fb23d10r			; 1.39249
	DD	03fb2d11cr			; 1.39701
	DD	03fb365cbr			; 1.40154
	DD	03fb3fb1er			; 1.4061
	DD	03fb49117r			; 1.41068
	DD	03fb527b6r			; 1.41527
	DD	03fb5befcr			; 1.41989
	DD	03fb656ecr			; 1.42453
	DD	03fb6ef86r			; 1.42918
	DD	03fb788ccr			; 1.43386
	DD	03fb822ber			; 1.43856
	DD	03fb8bd5fr			; 1.44328
	DD	03fb958b0r			; 1.44802
	DD	03fb9f4b2r			; 1.45278
	DD	03fba9166r			; 1.45756
	DD	03fbb2ecer			; 1.46237
	DD	03fbbccebr			; 1.46719
	DD	03fbc6bbfr			; 1.47204
	DD	03fbd0b4ar			; 1.47691
	DD	03fbdab90r			; 1.4818
	DD	03fbe4c90r			; 1.48671
	DD	03fbeee4dr			; 1.49165
	DD	03fbf90c7r			; 1.49661
	DD	03fc03401r			; 1.50159
	DD	03fc0d7fcr			; 1.50659
	DD	03fc17cb9r			; 1.51162
	DD	03fc2223br			; 1.51667
	DD	03fc2c882r			; 1.52174
	DD	03fc36f90r			; 1.52684
	DD	03fc41767r			; 1.53196
	DD	03fc4c009r			; 1.53711
	DD	03fc56976r			; 1.54228
	DD	03fc613b1r			; 1.54748
	DD	03fc6bebcr			; 1.5527
	DD	03fc76a98r			; 1.55794
	DD	03fc81746r			; 1.56321
	DD	03fc8c4c9r			; 1.56851
	DD	03fc97322r			; 1.57383
	DD	03fca2254r			; 1.57917
	DD	03fcad25fr			; 1.58455
	DD	03fcb8345r			; 1.58994
	DD	03fcc350ar			; 1.59537
	DD	03fcce7adr			; 1.60082
	DD	03fcd9b32r			; 1.6063
	DD	03fce4f99r			; 1.6118
	DD	03fcf04e6r			; 1.61734
	DD	03fcfbb19r			; 1.6229
	DD	03fd07236r			; 1.62849
	DD	03fd12a3dr			; 1.6341
	DD	03fd1e331r			; 1.63975
	DD	03fd29d13r			; 1.64542
	DD	03fd357e7r			; 1.65112
	DD	03fd413adr			; 1.65685
	DD	03fd4d069r			; 1.66261
	DD	03fd58e1br			; 1.6684
	DD	03fd64cc7r			; 1.67422
	DD	03fd70c6er			; 1.68007
	DD	03fd7cd12r			; 1.68595
	DD	03fd88eb6r			; 1.69186
	DD	03fd9515dr			; 1.6978
	DD	03fda1507r			; 1.70377
	DD	03fdad9b8r			; 1.70977
	DD	03fdb9f72r			; 1.7158
	DD	03fdc6637r			; 1.72187
	DD	03fdd2e09r			; 1.72797
	DD	03fddf6ecr			; 1.7341
	DD	03fdec0e0r			; 1.74026
	DD	03fdf8bear			; 1.74646
	DD	03fe0580br			; 1.75269
	DD	03fe12545r			; 1.75895
	DD	03fe1f39cr			; 1.76525
	DD	03fe2c312r			; 1.77158
	DD	03fe393a9r			; 1.77794
	DD	03fe46564r			; 1.78434
	DD	03fe53846r			; 1.79078
	DD	03fe60c51r			; 1.79725
	DD	03fe6e188r			; 1.80376
	DD	03fe7b7efr			; 1.8103
	DD	03fe88f87r			; 1.81688
	DD	03fe96853r			; 1.8235
	DD	03fea4257r			; 1.83015
	DD	03feb1d95r			; 1.83684
	DD	03febfa11r			; 1.84357
	DD	03fecd7ccr			; 1.85034
	DD	03fedb6cbr			; 1.85714
	DD	03fee9710r			; 1.86399
	DD	03fef789er			; 1.87087
	DD	03ff05b78r			; 1.87779
	DD	03ff13fa2r			; 1.88475
	DD	03ff2251fr			; 1.89176
	DD	03ff30bf2r			; 1.8988
	DD	03ff3f41dr			; 1.90589
	DD	03ff4dda6r			; 1.91301
	DD	03ff5c88er			; 1.92018
	DD	03ff6b4dar			; 1.92739
	DD	03ff7a28cr			; 1.93465
	DD	03ff891a9r			; 1.94195
	DD	03ff98234r			; 1.94929
	DD	03ffa7430r			; 1.95667
	DD	03ffb67a0r			; 1.9641
	DD	03ffc5c8ar			; 1.97157
	DD	03ffd52f0r			; 1.97909
	DD	03ffe4ad6r			; 1.98666
	DD	03fff4440r			; 1.99427
	DD	040001f99r			; 2.00193
	DD	040009dd8r			; 2.00963
	DD	040011cder			; 2.01739
	DD	040019cafr			; 2.02519
	DD	040021d4cr			; 2.03304
	DD	040029eb6r			; 2.04094
	DD	0400320f1r			; 2.04889
	DD	04003a3fer			; 2.05688
	DD	0400427dfr			; 2.06493
	DD	04004ac97r			; 2.07303
	DD	040053227r			; 2.08119
	DD	04005b893r			; 2.08939
	DD	040063fdcr			; 2.09765
	DD	04006c804r			; 2.10596
	DD	04007510fr			; 2.11432
	DD	04007dafdr			; 2.12274
	DD	0400865d3r			; 2.13121
	DD	04008f192r			; 2.13974
	DD	040097e3cr			; 2.14833
	DD	0400a0bd4r			; 2.15697
	DD	0400a9a5dr			; 2.16567
	DD	0400b29d9r			; 2.17443
	DD	0400bba4cr			; 2.18325
	DD	0400c4bb6r			; 2.19212
	DD	0400cde1cr			; 2.20106
	DD	0400d7180r			; 2.21005
	DD	0400e05e4r			; 2.21911
	DD	0400e9b4cr			; 2.22823
	DD	0400f31bbr			; 2.23741
	DD	0400fc932r			; 2.24665
	DD	0401061b6r			; 2.25596
	DD	04010fb49r			; 2.26534
	DD	0401195eer			; 2.27478
	DD	0401231a9r			; 2.28428
	DD	04012ce7cr			; 2.29385
	DD	040136c6ar			; 2.30349
	DD	040140b77r			; 2.3132
	DD	04014aba6r			; 2.32298
	DD	040154cfbr			; 2.33282
	DD	04015ef78r			; 2.34274
	DD	040169321r			; 2.35273
	DD	0401737f9r			; 2.36279
	DD	04017de05r			; 2.37293
	DD	040188547r			; 2.38313
	DD	040192dc3r			; 2.39342
	DD	04019d77er			; 2.40378
	DD	0401a827ar			; 2.41421
	DD	0401b2ebbr			; 2.42473
	DD	0401bdc46r			; 2.43532
	DD	0401c8b1dr			; 2.44599
	DD	0401d3b46r			; 2.45674
	DD	0401decc4r			; 2.46758
	DD	0401e9f9cr			; 2.47849
	DD	0401f53d1r			; 2.48949
	DD	040200967r			; 2.50057
	DD	04020c064r			; 2.51174
	DD	0402178cbr			; 2.523
	DD	0402232a0r			; 2.53434
	DD	04022ede9r			; 2.54577
	DD	04023aaaar			; 2.55729
	DD	0402468e8r			; 2.5689
	DD	0402528a7r			; 2.58061
	DD	04025e9ecr			; 2.5924
	DD	04026acbcr			; 2.60429
	DD	04027711dr			; 2.61628
	DD	040283712r			; 2.62836
	DD	04028fea2r			; 2.64054
	DD	04029c7d1r			; 2.65282
	DD	0402a92a6r			; 2.6652
	DD	0402b5f24r			; 2.67768
	DD	0402c2d52r			; 2.69027
	DD	0402cfd36r			; 2.70295
	DD	0402dced5r			; 2.71575
	DD	0402ea235r			; 2.72865
	DD	0402f775cr			; 2.74166
	DD	040304e50r			; 2.75478
	DD	040312717r			; 2.76801
	DD	0403201b7r			; 2.78135
	DD	04032de36r			; 2.79481
	DD	04033bc9cr			; 2.80839
	DD	040349cefr			; 2.82208
	DD	040357f34r			; 2.83589
	DD	040366375r			; 2.84982
	DD	0403749b6r			; 2.86387
	DD	0403831ffr			; 2.87805
	DD	040391c58r			; 2.89235
	DD	0403a08c7r			; 2.90679
	DD	0403af755r			; 2.92135
	DD	0403be808r			; 2.93604
	DD	0403cdae9r			; 2.95086
	DD	0403dd000r			; 2.96582
	DD	0403ec754r			; 2.98092
	DD	0403fc0edr			; 2.99615
	DD	04040bcd5r			; 3.01153
	DD	04041bb13r			; 3.02704
	DD	04042bbb1r			; 3.04271
	DD	04043beb7r			; 3.05852
	DD	04044c42er			; 3.07447
	DD	04045cc1fr			; 3.09058
	DD	04046d694r			; 3.10685
	DD	04047e396r			; 3.12327
	DD	04048f32fr			; 3.13984
	DD	0404a056ar			; 3.15658
	DD	0404b1a4fr			; 3.17348
	DD	0404c31ear			; 3.19055
	DD	0404d4c45r			; 3.20778
	DD	0404e696br			; 3.22518
	DD	0404f8967r			; 3.24276
	DD	04050ac44r			; 3.26051
	DD	04051d20dr			; 3.27845
	DD	04052facfr			; 3.29656
	DD	040542695r			; 3.31485
	DD	04055556cr			; 3.33334
	DD	04056875fr			; 3.35201
	DD	04057bc7cr			; 3.37088
	DD	04058f4d0r			; 3.38994
	DD	0405a3068r			; 3.4092
	DD	0405b6f51r			; 3.42867
	DD	0405cb199r			; 3.44834
	DD	0405df74fr			; 3.46822
	DD	0405f4081r			; 3.48831
	DD	040608d3er			; 3.50862
	DD	04061dd94r			; 3.52915
	DD	040633194r			; 3.5499
	DD	04064894dr			; 3.57088
	DD	04065e4cfr			; 3.59209
	DD	04067442br			; 3.61354
	DD	04068a772r			; 3.63522
	DD	0406a0eb5r			; 3.65715
	DD	0406b7a05r			; 3.67932
	DD	0406ce976r			; 3.70175
	DD	0406e5d19r			; 3.72443
	DD	0406fd501r			; 3.74738
	DD	040715142r			; 3.77058
	DD	04072d1efr			; 3.79406
	DD	04074571er			; 3.81782
	DD	04075e0e2r			; 3.84185
	DD	040776f52r			; 3.86617
	DD	040790282r			; 3.89078
	DD	0407a9a8br			; 3.91568
	DD	0407c3781r			; 3.94089
	DD	0407dd97er			; 3.9664
	DD	0407f8098r			; 3.99222
	DD	040809675r			; 4.01837
	DD	040816f46r			; 4.04483
	DD	040824acbr			; 4.07163
	DD	040832914r			; 4.09876
	DD	040840a2cr			; 4.12624
	DD	04084ee23r			; 4.15407
	DD	04085d506r			; 4.18225
	DD	04086bee4r			; 4.2108
	DD	04087abcdr			; 4.23972
	DD	040889bd0r			; 4.26902
	DD	040898efcr			; 4.2987
	DD	0408a8564r			; 4.32878
	DD	0408b7f16r			; 4.35926
	DD	0408c7c26r			; 4.39015
	DD	0408d7ca3r			; 4.42146
	DD	0408e80a2r			; 4.4532
	DD	0408f8834r			; 4.48538
	DD	04090936dr			; 4.518
	DD	04091a261r			; 4.55107
	DD	04092b524r			; 4.58461
	DD	04093cbccr			; 4.61863
	DD	04094e66er			; 4.65313
	DD	04096051fr			; 4.68813
	DD	0409727f9r			; 4.72363
	DD	040984f11r			; 4.75965
	DD	040997a80r			; 4.7962
	DD	0409aaa60r			; 4.8333
	DD	0409bdecar			; 4.87095
	DD	0409d17d8r			; 4.90916
	DD	0409e55a7r			; 4.94796
	DD	0409f9852r			; 4.98734
	DD	040a0dff7r			; 5.02734
	DD	040a22cb4r			; 5.06796
	DD	040a37ea7r			; 5.10921
	DD	040a4d5f1r			; 5.15112
	DD	040a632b4r			; 5.19369
	DD	040a79510r			; 5.23695
	DD	040a8fd29r			; 5.2809
	DD	040aa6b25r			; 5.32558
	DD	040abdf27r			; 5.37099
	DD	040ad5958r			; 5.41716
	DD	040aed9e0r			; 5.4641
	DD	040b060e8r			; 5.51183
	DD	040b1ee9br			; 5.56038
	DD	040b38325r			; 5.60976
	DD	040b51eb6r			; 5.66
	DD	040b6c17cr			; 5.71112
	DD	040b86ba9r			; 5.76314
	DD	040ba1d70r			; 5.81609
	DD	040bbd707r			; 5.87
	DD	040bd98a4r			; 5.92488
	DD	040bf6280r			; 5.98077
	DD	040c134d7r			; 6.0377
	DD	040c30fe6r			; 6.09569
	DD	040c4f3edr			; 6.15478
	DD	040c6e12er			; 6.21499
	DD	040c8d7eer			; 6.27636
	DD	040cad874r			; 6.33892
	DD	040cce30br			; 6.40272
	DD	040cef800r			; 6.46777
	DD	040d117a3r			; 6.53414
	DD	040d34249r			; 6.60184
	DD	040d57848r			; 6.67093
	DD	040d7b9far			; 6.74145
	DD	040da07c0r			; 6.81345
	DD	040dc61fbr			; 6.88696
	DD	040dec912r			; 6.96204
	DD	040e13d71r			; 7.03875
	DD	040e3bf88r			; 7.11713
	DD	040e64fcbr			; 7.19724
	DD	040e8eeb5r			; 7.27914
	DD	040eb9cc7r			; 7.36289
	DD	040ee5a85r			; 7.44855
	DD	040f1287br			; 7.53619
	DD	040f4073dr			; 7.62588
	DD	040f6f764r			; 7.7177
	DD	040f9f991r			; 7.81171
	DD	040fd0e6cr			; 7.90801
	DD	041001b53r			; 8.00667
	DD	04101b97er			; 8.10779
	DD	041036216r			; 8.21145
	DD	041051585r			; 8.31775
	DD	04106d434r			; 8.42681
	DD	041089e96r			; 8.53872
	DD	0410a7524r			; 8.6536
	DD	0410c585ar			; 8.77157
	DD	0410e48bfr			; 8.89276
	DD	0411046dfr			; 9.0173
	DD	04112534er			; 9.14534
	DD	041146eaar			; 9.27702
	DD	041169998r			; 9.4125
	DD	04118d4c9r			; 9.55195
	DD	0411b20f6r			; 9.69555
	DD	0411d7ee7r			; 9.84348
	DD	0411fef6br			; 9.99595
	DD	041227363r			; 10.1532
	DD	041250bbbr			; 10.3154
	DD	04127b970r			; 10.4828
	DD	0412a7d8fr			; 10.6557
	DD	0412d5937r			; 10.8343
	DD	041304d99r			; 11.0189
	DD	041335bfer			; 11.21
	DD	0413685c4r			; 11.4077
	DD	04139cc63r			; 11.6124
	DD	0413d316cr			; 11.8246
	DD	04140b692r			; 12.0446
	DD	041445da5r			; 12.2729
	DD	04148289ar			; 12.5099
	DD	0414c198dr			; 12.7562
	DD	0415032c7r			; 13.0124
	DD	0415476ber			; 13.279
	DD	04158e81er			; 13.5567
	DD	0415d89cer			; 13.8461
	DD	041625ef3r			; 14.1482
	DD	041676afcr			; 14.4636
	DD	0416cb1a8r			; 14.7934
	DD	04172370dr			; 15.1384
	DD	04177ffa7r			; 15.4999
	DD	0417e105fr			; 15.879
	DD	041823750r			; 16.277
	DD	041859030r			; 16.6954
	DD	04189161ar			; 17.1358
	DD	0418cccb7r			; 17.6
	DD	04190b815r			; 18.0899
	DD	04194dcbar			; 18.6078
	DD	041993fb2r			; 19.1561
	DD	0419de6a9r			; 19.7376
	DD	041a2d7ffr			; 20.3555
	DD	041a81ae7r			; 21.0131
	DD	041adb787r			; 21.7146
	DD	041b3b729r			; 22.4644
	DD	041ba2468r			; 23.2678
	DD	041c10b71r			; 24.1306
	DD	041c87a53r			; 25.0597
	DD	041d0815br			; 26.0632
	DD	041d9338dr			; 27.1502
	DD	041e2a73cr			; 28.3317
	DD	041ecf6ccr			; 29.6205
	DD	041f841a6r			; 31.0321
	DD	0420256bdr			; 32.5847
	DD	0420933f5r			; 34.3007
	DD	04210d45dr			; 36.2074
	DD	042195a68r			; 38.3383
	DD	04222f123r			; 40.7355
	DD	0422dcf18r			; 43.4522
	DD	0423a3a66r			; 46.557
	DD	042488ebfr			; 50.1394
	DD	042594667r			; 54.3188
	DD	0426d0814r			; 59.2579
	DD	042825e98r			; 65.1848
	DD	04290db6fr			; 72.4286
	DD	042a2f76br			; 81.4832
	DD	042ba3fe6r			; 93.1248
	DD	042d94b1dr			; 108.647
	DD	04302608er			; 130.377
	DD	04322f8fdr			; 162.973
	DD	043594c4br			; 217.298
	DD	043a2f962r			; 325.948
	DD	04422f97br			; 651.898
	DD	05a6816aar			; 1.63318e+16
	DD	0c422f97br			; -651.898
	DD	0c3a2f962r			; -325.948
	DD	0c3594c4br			; -217.298
	DD	0c322f8fdr			; -162.973
	DD	0c302608er			; -130.377
	DD	0c2d94b1dr			; -108.647
	DD	0c2ba3fe6r			; -93.1248
	DD	0c2a2f76br			; -81.4832
	DD	0c290db6fr			; -72.4286
	DD	0c2825e98r			; -65.1848
	DD	0c26d0814r			; -59.2579
	DD	0c2594667r			; -54.3188
	DD	0c2488ebfr			; -50.1394
	DD	0c23a3a66r			; -46.557
	DD	0c22dcf18r			; -43.4522
	DD	0c222f123r			; -40.7355
	DD	0c2195a68r			; -38.3383
	DD	0c210d45dr			; -36.2074
	DD	0c20933f5r			; -34.3007
	DD	0c20256bdr			; -32.5847
	DD	0c1f841a6r			; -31.0321
	DD	0c1ecf6ccr			; -29.6205
	DD	0c1e2a73cr			; -28.3317
	DD	0c1d9338dr			; -27.1502
	DD	0c1d0815br			; -26.0632
	DD	0c1c87a53r			; -25.0597
	DD	0c1c10b71r			; -24.1306
	DD	0c1ba2468r			; -23.2678
	DD	0c1b3b729r			; -22.4644
	DD	0c1adb787r			; -21.7146
	DD	0c1a81ae7r			; -21.0131
	DD	0c1a2d7ffr			; -20.3555
	DD	0c19de6a9r			; -19.7376
	DD	0c1993fb2r			; -19.1561
	DD	0c194dcbar			; -18.6078
	DD	0c190b815r			; -18.0899
	DD	0c18cccb7r			; -17.6
	DD	0c189161ar			; -17.1358
	DD	0c1859030r			; -16.6954
	DD	0c1823750r			; -16.277
	DD	0c17e105fr			; -15.879
	DD	0c177ffa7r			; -15.4999
	DD	0c172370dr			; -15.1384
	DD	0c16cb1a8r			; -14.7934
	DD	0c1676afcr			; -14.4636
	DD	0c1625ef3r			; -14.1482
	DD	0c15d89cer			; -13.8461
	DD	0c158e81er			; -13.5567
	DD	0c15476ber			; -13.279
	DD	0c15032c7r			; -13.0124
	DD	0c14c198dr			; -12.7562
	DD	0c148289ar			; -12.5099
	DD	0c1445da5r			; -12.2729
	DD	0c140b692r			; -12.0446
	DD	0c13d316cr			; -11.8246
	DD	0c139cc63r			; -11.6124
	DD	0c13685c4r			; -11.4077
	DD	0c1335bfer			; -11.21
	DD	0c1304d99r			; -11.0189
	DD	0c12d5937r			; -10.8343
	DD	0c12a7d8fr			; -10.6557
	DD	0c127b970r			; -10.4828
	DD	0c1250bbbr			; -10.3154
	DD	0c1227363r			; -10.1532
	DD	0c11fef6br			; -9.99595
	DD	0c11d7ee7r			; -9.84348
	DD	0c11b20f6r			; -9.69555
	DD	0c118d4c9r			; -9.55195
	DD	0c1169998r			; -9.4125
	DD	0c1146eaar			; -9.27702
	DD	0c112534er			; -9.14534
	DD	0c11046dfr			; -9.0173
	DD	0c10e48bfr			; -8.89276
	DD	0c10c585ar			; -8.77157
	DD	0c10a7524r			; -8.6536
	DD	0c1089e96r			; -8.53872
	DD	0c106d434r			; -8.42681
	DD	0c1051585r			; -8.31775
	DD	0c1036216r			; -8.21145
	DD	0c101b97er			; -8.10779
	DD	0c1001b53r			; -8.00667
	DD	0c0fd0e6cr			; -7.90801
	DD	0c0f9f991r			; -7.81171
	DD	0c0f6f764r			; -7.7177
	DD	0c0f4073dr			; -7.62588
	DD	0c0f1287br			; -7.53619
	DD	0c0ee5a85r			; -7.44855
	DD	0c0eb9cc7r			; -7.36289
	DD	0c0e8eeb5r			; -7.27914
	DD	0c0e64fcbr			; -7.19724
	DD	0c0e3bf88r			; -7.11713
	DD	0c0e13d71r			; -7.03875
	DD	0c0dec912r			; -6.96204
	DD	0c0dc61fbr			; -6.88696
	DD	0c0da07c0r			; -6.81345
	DD	0c0d7b9far			; -6.74145
	DD	0c0d57848r			; -6.67093
	DD	0c0d34249r			; -6.60184
	DD	0c0d117a3r			; -6.53414
	DD	0c0cef800r			; -6.46777
	DD	0c0cce30br			; -6.40272
	DD	0c0cad874r			; -6.33892
	DD	0c0c8d7eer			; -6.27636
	DD	0c0c6e12er			; -6.21499
	DD	0c0c4f3edr			; -6.15478
	DD	0c0c30fe6r			; -6.09569
	DD	0c0c134d7r			; -6.0377
	DD	0c0bf6280r			; -5.98077
	DD	0c0bd98a4r			; -5.92488
	DD	0c0bbd707r			; -5.87
	DD	0c0ba1d70r			; -5.81609
	DD	0c0b86ba9r			; -5.76314
	DD	0c0b6c17cr			; -5.71112
	DD	0c0b51eb6r			; -5.66
	DD	0c0b38325r			; -5.60976
	DD	0c0b1ee9br			; -5.56038
	DD	0c0b060e8r			; -5.51183
	DD	0c0aed9e0r			; -5.4641
	DD	0c0ad5958r			; -5.41716
	DD	0c0abdf27r			; -5.37099
	DD	0c0aa6b25r			; -5.32558
	DD	0c0a8fd29r			; -5.2809
	DD	0c0a79510r			; -5.23695
	DD	0c0a632b4r			; -5.19369
	DD	0c0a4d5f1r			; -5.15112
	DD	0c0a37ea7r			; -5.10921
	DD	0c0a22cb4r			; -5.06796
	DD	0c0a0dff7r			; -5.02734
	DD	0c09f9852r			; -4.98734
	DD	0c09e55a7r			; -4.94796
	DD	0c09d17d8r			; -4.90916
	DD	0c09bdecar			; -4.87095
	DD	0c09aaa60r			; -4.8333
	DD	0c0997a80r			; -4.7962
	DD	0c0984f11r			; -4.75965
	DD	0c09727f9r			; -4.72363
	DD	0c096051fr			; -4.68813
	DD	0c094e66er			; -4.65313
	DD	0c093cbccr			; -4.61863
	DD	0c092b524r			; -4.58461
	DD	0c091a261r			; -4.55107
	DD	0c090936dr			; -4.518
	DD	0c08f8834r			; -4.48538
	DD	0c08e80a2r			; -4.4532
	DD	0c08d7ca3r			; -4.42146
	DD	0c08c7c26r			; -4.39015
	DD	0c08b7f16r			; -4.35926
	DD	0c08a8564r			; -4.32878
	DD	0c0898efcr			; -4.2987
	DD	0c0889bd0r			; -4.26902
	DD	0c087abcdr			; -4.23972
	DD	0c086bee4r			; -4.2108
	DD	0c085d506r			; -4.18225
	DD	0c084ee23r			; -4.15407
	DD	0c0840a2cr			; -4.12624
	DD	0c0832914r			; -4.09876
	DD	0c0824acbr			; -4.07163
	DD	0c0816f46r			; -4.04483
	DD	0c0809675r			; -4.01837
	DD	0c07f8098r			; -3.99222
	DD	0c07dd97er			; -3.9664
	DD	0c07c3781r			; -3.94089
	DD	0c07a9a8br			; -3.91568
	DD	0c0790282r			; -3.89078
	DD	0c0776f52r			; -3.86617
	DD	0c075e0e2r			; -3.84185
	DD	0c074571er			; -3.81782
	DD	0c072d1efr			; -3.79406
	DD	0c0715142r			; -3.77058
	DD	0c06fd501r			; -3.74738
	DD	0c06e5d19r			; -3.72443
	DD	0c06ce976r			; -3.70175
	DD	0c06b7a05r			; -3.67932
	DD	0c06a0eb5r			; -3.65715
	DD	0c068a772r			; -3.63522
	DD	0c067442br			; -3.61354
	DD	0c065e4cfr			; -3.59209
	DD	0c064894dr			; -3.57088
	DD	0c0633194r			; -3.5499
	DD	0c061dd94r			; -3.52915
	DD	0c0608d3er			; -3.50862
	DD	0c05f4081r			; -3.48831
	DD	0c05df74fr			; -3.46822
	DD	0c05cb199r			; -3.44834
	DD	0c05b6f51r			; -3.42867
	DD	0c05a3068r			; -3.4092
	DD	0c058f4d0r			; -3.38994
	DD	0c057bc7cr			; -3.37088
	DD	0c056875fr			; -3.35201
	DD	0c055556cr			; -3.33334
	DD	0c0542695r			; -3.31485
	DD	0c052facfr			; -3.29656
	DD	0c051d20dr			; -3.27845
	DD	0c050ac44r			; -3.26051
	DD	0c04f8967r			; -3.24276
	DD	0c04e696br			; -3.22518
	DD	0c04d4c45r			; -3.20778
	DD	0c04c31ear			; -3.19055
	DD	0c04b1a4fr			; -3.17348
	DD	0c04a056ar			; -3.15658
	DD	0c048f32fr			; -3.13984
	DD	0c047e396r			; -3.12327
	DD	0c046d694r			; -3.10685
	DD	0c045cc1fr			; -3.09058
	DD	0c044c42er			; -3.07447
	DD	0c043beb7r			; -3.05852
	DD	0c042bbb1r			; -3.04271
	DD	0c041bb13r			; -3.02704
	DD	0c040bcd5r			; -3.01153
	DD	0c03fc0edr			; -2.99615
	DD	0c03ec754r			; -2.98092
	DD	0c03dd000r			; -2.96582
	DD	0c03cdae9r			; -2.95086
	DD	0c03be808r			; -2.93604
	DD	0c03af755r			; -2.92135
	DD	0c03a08c7r			; -2.90679
	DD	0c0391c58r			; -2.89235
	DD	0c03831ffr			; -2.87805
	DD	0c03749b6r			; -2.86387
	DD	0c0366375r			; -2.84982
	DD	0c0357f34r			; -2.83589
	DD	0c0349cefr			; -2.82208
	DD	0c033bc9cr			; -2.80839
	DD	0c032de36r			; -2.79481
	DD	0c03201b7r			; -2.78135
	DD	0c0312717r			; -2.76801
	DD	0c0304e50r			; -2.75478
	DD	0c02f775cr			; -2.74166
	DD	0c02ea235r			; -2.72865
	DD	0c02dced5r			; -2.71575
	DD	0c02cfd36r			; -2.70295
	DD	0c02c2d52r			; -2.69027
	DD	0c02b5f24r			; -2.67768
	DD	0c02a92a6r			; -2.6652
	DD	0c029c7d1r			; -2.65282
	DD	0c028fea2r			; -2.64054
	DD	0c0283712r			; -2.62836
	DD	0c027711dr			; -2.61628
	DD	0c026acbcr			; -2.60429
	DD	0c025e9ecr			; -2.5924
	DD	0c02528a7r			; -2.58061
	DD	0c02468e8r			; -2.5689
	DD	0c023aaaar			; -2.55729
	DD	0c022ede9r			; -2.54577
	DD	0c02232a0r			; -2.53434
	DD	0c02178cbr			; -2.523
	DD	0c020c064r			; -2.51174
	DD	0c0200967r			; -2.50057
	DD	0c01f53d1r			; -2.48949
	DD	0c01e9f9cr			; -2.47849
	DD	0c01decc4r			; -2.46758
	DD	0c01d3b46r			; -2.45674
	DD	0c01c8b1dr			; -2.44599
	DD	0c01bdc46r			; -2.43532
	DD	0c01b2ebbr			; -2.42473
	DD	0c01a827ar			; -2.41421
	DD	0c019d77er			; -2.40378
	DD	0c0192dc3r			; -2.39342
	DD	0c0188547r			; -2.38313
	DD	0c017de05r			; -2.37293
	DD	0c01737f9r			; -2.36279
	DD	0c0169321r			; -2.35273
	DD	0c015ef78r			; -2.34274
	DD	0c0154cfbr			; -2.33282
	DD	0c014aba6r			; -2.32298
	DD	0c0140b77r			; -2.3132
	DD	0c0136c6ar			; -2.30349
	DD	0c012ce7cr			; -2.29385
	DD	0c01231a9r			; -2.28428
	DD	0c01195eer			; -2.27478
	DD	0c010fb49r			; -2.26534
	DD	0c01061b6r			; -2.25596
	DD	0c00fc932r			; -2.24665
	DD	0c00f31bbr			; -2.23741
	DD	0c00e9b4cr			; -2.22823
	DD	0c00e05e4r			; -2.21911
	DD	0c00d7180r			; -2.21005
	DD	0c00cde1cr			; -2.20106
	DD	0c00c4bb6r			; -2.19212
	DD	0c00bba4cr			; -2.18325
	DD	0c00b29d9r			; -2.17443
	DD	0c00a9a5dr			; -2.16567
	DD	0c00a0bd4r			; -2.15697
	DD	0c0097e3cr			; -2.14833
	DD	0c008f192r			; -2.13974
	DD	0c00865d3r			; -2.13121
	DD	0c007dafdr			; -2.12274
	DD	0c007510fr			; -2.11432
	DD	0c006c804r			; -2.10596
	DD	0c0063fdcr			; -2.09765
	DD	0c005b893r			; -2.08939
	DD	0c0053227r			; -2.08119
	DD	0c004ac97r			; -2.07303
	DD	0c00427dfr			; -2.06493
	DD	0c003a3fer			; -2.05688
	DD	0c00320f1r			; -2.04889
	DD	0c0029eb6r			; -2.04094
	DD	0c0021d4cr			; -2.03304
	DD	0c0019cafr			; -2.02519
	DD	0c0011cder			; -2.01739
	DD	0c0009dd8r			; -2.00963
	DD	0c0001f99r			; -2.00193
	DD	0bfff4440r			; -1.99427
	DD	0bffe4ad6r			; -1.98666
	DD	0bffd52f0r			; -1.97909
	DD	0bffc5c8ar			; -1.97157
	DD	0bffb67a0r			; -1.9641
	DD	0bffa7430r			; -1.95667
	DD	0bff98234r			; -1.94929
	DD	0bff891a9r			; -1.94195
	DD	0bff7a28cr			; -1.93465
	DD	0bff6b4dar			; -1.92739
	DD	0bff5c88er			; -1.92018
	DD	0bff4dda6r			; -1.91301
	DD	0bff3f41dr			; -1.90589
	DD	0bff30bf2r			; -1.8988
	DD	0bff2251fr			; -1.89176
	DD	0bff13fa2r			; -1.88475
	DD	0bff05b78r			; -1.87779
	DD	0bfef789er			; -1.87087
	DD	0bfee9710r			; -1.86399
	DD	0bfedb6cbr			; -1.85714
	DD	0bfecd7ccr			; -1.85034
	DD	0bfebfa11r			; -1.84357
	DD	0bfeb1d95r			; -1.83684
	DD	0bfea4257r			; -1.83015
	DD	0bfe96853r			; -1.8235
	DD	0bfe88f87r			; -1.81688
	DD	0bfe7b7efr			; -1.8103
	DD	0bfe6e188r			; -1.80376
	DD	0bfe60c51r			; -1.79725
	DD	0bfe53846r			; -1.79078
	DD	0bfe46564r			; -1.78434
	DD	0bfe393a9r			; -1.77794
	DD	0bfe2c312r			; -1.77158
	DD	0bfe1f39cr			; -1.76525
	DD	0bfe12545r			; -1.75895
	DD	0bfe0580br			; -1.75269
	DD	0bfdf8bear			; -1.74646
	DD	0bfdec0e0r			; -1.74026
	DD	0bfddf6ecr			; -1.7341
	DD	0bfdd2e09r			; -1.72797
	DD	0bfdc6637r			; -1.72187
	DD	0bfdb9f72r			; -1.7158
	DD	0bfdad9b8r			; -1.70977
	DD	0bfda1507r			; -1.70377
	DD	0bfd9515dr			; -1.6978
	DD	0bfd88eb6r			; -1.69186
	DD	0bfd7cd12r			; -1.68595
	DD	0bfd70c6er			; -1.68007
	DD	0bfd64cc7r			; -1.67422
	DD	0bfd58e1br			; -1.6684
	DD	0bfd4d069r			; -1.66261
	DD	0bfd413adr			; -1.65685
	DD	0bfd357e7r			; -1.65112
	DD	0bfd29d13r			; -1.64542
	DD	0bfd1e331r			; -1.63975
	DD	0bfd12a3dr			; -1.6341
	DD	0bfd07236r			; -1.62849
	DD	0bfcfbb19r			; -1.6229
	DD	0bfcf04e6r			; -1.61734
	DD	0bfce4f99r			; -1.6118
	DD	0bfcd9b32r			; -1.6063
	DD	0bfcce7adr			; -1.60082
	DD	0bfcc350ar			; -1.59537
	DD	0bfcb8345r			; -1.58994
	DD	0bfcad25fr			; -1.58455
	DD	0bfca2254r			; -1.57917
	DD	0bfc97322r			; -1.57383
	DD	0bfc8c4c9r			; -1.56851
	DD	0bfc81746r			; -1.56321
	DD	0bfc76a98r			; -1.55794
	DD	0bfc6bebcr			; -1.5527
	DD	0bfc613b1r			; -1.54748
	DD	0bfc56976r			; -1.54228
	DD	0bfc4c009r			; -1.53711
	DD	0bfc41767r			; -1.53196
	DD	0bfc36f90r			; -1.52684
	DD	0bfc2c882r			; -1.52174
	DD	0bfc2223br			; -1.51667
	DD	0bfc17cb9r			; -1.51162
	DD	0bfc0d7fcr			; -1.50659
	DD	0bfc03401r			; -1.50159
	DD	0bfbf90c7r			; -1.49661
	DD	0bfbeee4dr			; -1.49165
	DD	0bfbe4c90r			; -1.48671
	DD	0bfbdab90r			; -1.4818
	DD	0bfbd0b4ar			; -1.47691
	DD	0bfbc6bbfr			; -1.47204
	DD	0bfbbccebr			; -1.46719
	DD	0bfbb2ecer			; -1.46237
	DD	0bfba9166r			; -1.45756
	DD	0bfb9f4b2r			; -1.45278
	DD	0bfb958b0r			; -1.44802
	DD	0bfb8bd5fr			; -1.44328
	DD	0bfb822ber			; -1.43856
	DD	0bfb788ccr			; -1.43386
	DD	0bfb6ef86r			; -1.42918
	DD	0bfb656ecr			; -1.42453
	DD	0bfb5befcr			; -1.41989
	DD	0bfb527b6r			; -1.41527
	DD	0bfb49117r			; -1.41068
	DD	0bfb3fb1er			; -1.4061
	DD	0bfb365cbr			; -1.40154
	DD	0bfb2d11cr			; -1.39701
	DD	0bfb23d10r			; -1.39249
	DD	0bfb1a9a5r			; -1.38799
	DD	0bfb116dbr			; -1.38351
	DD	0bfb084b0r			; -1.37905
	DD	0bfaff323r			; -1.37461
	DD	0bfaf6232r			; -1.37018
	DD	0bfaed1der			; -1.36578
	DD	0bfae4224r			; -1.36139
	DD	0bfadb303r			; -1.35703
	DD	0bfad247ar			; -1.35268
	DD	0bfac9689r			; -1.34834
	DD	0bfac092dr			; -1.34403
	DD	0bfab7c66r			; -1.33973
	DD	0bfaaf034r			; -1.33546
	DD	0bfaa6494r			; -1.33119
	DD	0bfa9d985r			; -1.32695
	DD	0bfa94f08r			; -1.32272
	DD	0bfa8c519r			; -1.31851
	DD	0bfa83bbar			; -1.31432
	DD	0bfa7b2e8r			; -1.31015
	DD	0bfa72aa2r			; -1.30599
	DD	0bfa6a2e8r			; -1.30185
	DD	0bfa61bb9r			; -1.29772
	DD	0bfa59513r			; -1.29361
	DD	0bfa50ef5r			; -1.28952
	DD	0bfa4895fr			; -1.28544
	DD	0bfa40450r			; -1.28138
	DD	0bfa37fc6r			; -1.27734
	DD	0bfa2fbc1r			; -1.27331
	DD	0bfa27840r			; -1.26929
	DD	0bfa1f541r			; -1.2653
	DD	0bfa172c5r			; -1.26131
	DD	0bfa0f0car			; -1.25735
	DD	0bfa06f4er			; -1.2534
	DD	0bf9fee52r			; -1.24946
	DD	0bf9f6dd4r			; -1.24554
	DD	0bf9eedd4r			; -1.24163
	DD	0bf9e6e50r			; -1.23774
	DD	0bf9def48r			; -1.23386
	DD	0bf9d70bbr			; -1.23
	DD	0bf9cf2a8r			; -1.22616
	DD	0bf9c750er			; -1.22232
	DD	0bf9bf7ecr			; -1.2185
	DD	0bf9b7b42r			; -1.2147
	DD	0bf9aff0fr			; -1.21091
	DD	0bf9a8352r			; -1.20713
	DD	0bf9a0809r			; -1.20337
	DD	0bf998d35r			; -1.19962
	DD	0bf9912d5r			; -1.19589
	DD	0bf9898e7r			; -1.19217
	DD	0bf981f6br			; -1.18846
	DD	0bf97a660r			; -1.18476
	DD	0bf972dc6r			; -1.18108
	DD	0bf96b59cr			; -1.17742
	DD	0bf963de0r			; -1.17376
	DD	0bf95c693r			; -1.17012
	DD	0bf954fb3r			; -1.16649
	DD	0bf94d93fr			; -1.16288
	DD	0bf946338r			; -1.15928
	DD	0bf93ed9cr			; -1.15569
	DD	0bf93786ar			; -1.15211
	DD	0bf9303a3r			; -1.14855
	DD	0bf928f44r			; -1.145
	DD	0bf921b4er			; -1.14146
	DD	0bf91a7c0r			; -1.13793
	DD	0bf913499r			; -1.13442
	DD	0bf90c1d8r			; -1.13092
	DD	0bf904f7dr			; -1.12743
	DD	0bf8fdd88r			; -1.12395
	DD	0bf8f6bf6r			; -1.12048
	DD	0bf8efac8r			; -1.11703
	DD	0bf8e89fer			; -1.11359
	DD	0bf8e1996r			; -1.11016
	DD	0bf8da990r			; -1.10674
	DD	0bf8d39ebr			; -1.10333
	DD	0bf8ccaa6r			; -1.09993
	DD	0bf8c5bc2r			; -1.09655
	DD	0bf8bed3dr			; -1.09318
	DD	0bf8b7f16r			; -1.08982
	DD	0bf8b114er			; -1.08647
	DD	0bf8aa3e3r			; -1.08313
	DD	0bf8a36d5r			; -1.0798
	DD	0bf89ca24r			; -1.07648
	DD	0bf895dcer			; -1.07318
	DD	0bf88f1d4r			; -1.06988
	DD	0bf888634r			; -1.0666
	DD	0bf881aeer			; -1.06332
	DD	0bf87b001r			; -1.06006
	DD	0bf87456dr			; -1.05681
	DD	0bf86db32r			; -1.05356
	DD	0bf86714fr			; -1.05033
	DD	0bf8607c2r			; -1.04711
	DD	0bf859e8cr			; -1.0439
	DD	0bf8535adr			; -1.0407
	DD	0bf84cd23r			; -1.03751
	DD	0bf8464eer			; -1.03433
	DD	0bf83fd0dr			; -1.03116
	DD	0bf839581r			; -1.028
	DD	0bf832e48r			; -1.02485
	DD	0bf82c762r			; -1.02171
	DD	0bf8260cer			; -1.01858
	DD	0bf81fa8dr			; -1.01546
	DD	0bf81949dr			; -1.01235
	DD	0bf812efdr			; -1.00925
	DD	0bf80c9aer			; -1.00615
	DD	0bf8064afr			; -1.00307
	DD	0bf800000r			; -1
	DD	0bf7f373fr			; -0.996937
	DD	0bf7e6f1br			; -0.993883
	DD	0bf7da793r			; -0.990838
	DD	0bf7ce0a6r			; -0.987803
	DD	0bf7c1a53r			; -0.984777
	DD	0bf7b5499r			; -0.98176
	DD	0bf7a8f77r			; -0.978752
	DD	0bf79caedr			; -0.975753
	DD	0bf7906f9r			; -0.972763
	DD	0bf78439br			; -0.969782
	DD	0bf7780d1r			; -0.966809
	DD	0bf76be9br			; -0.963846
	DD	0bf75fcf7r			; -0.960891
	DD	0bf753be6r			; -0.957945
	DD	0bf747b66r			; -0.955008
	DD	0bf73bb75r			; -0.952079
	DD	0bf72fc15r			; -0.949159
	DD	0bf723d42r			; -0.946247
	DD	0bf717efdr			; -0.943344
	DD	0bf70c145r			; -0.940449
	DD	0bf700419r			; -0.937563
	DD	0bf6f4778r			; -0.934684
	DD	0bf6e8b62r			; -0.931814
	DD	0bf6dcfd4r			; -0.928952
	DD	0bf6d14d0r			; -0.926099
	DD	0bf6c5a53r			; -0.923253
	DD	0bf6ba05dr			; -0.920416
	DD	0bf6ae6eer			; -0.917586
	DD	0bf6a2e04r			; -0.914765
	DD	0bf69759er			; -0.911951
	DD	0bf68bdbdr			; -0.909145
	DD	0bf68065er			; -0.906347
	DD	0bf674f82r			; -0.903557
	DD	0bf669928r			; -0.900774
	DD	0bf65e34er			; -0.898
	DD	0bf652df5r			; -0.895232
	DD	0bf64791ar			; -0.892473
	DD	0bf63c4bfr			; -0.889721
	DD	0bf6310e1r			; -0.886976
	DD	0bf625d80r			; -0.884239
	DD	0bf61aa9cr			; -0.88151
	DD	0bf60f834r			; -0.878787
	DD	0bf604646r			; -0.876072
	DD	0bf5f94d3r			; -0.873365
	DD	0bf5ee3d9r			; -0.870664
	DD	0bf5e3358r			; -0.867971
	DD	0bf5d834fr			; -0.865285
	DD	0bf5cd3ber			; -0.862606
	DD	0bf5c24a4r			; -0.859934
	DD	0bf5b75ffr			; -0.857269
	DD	0bf5ac7d0r			; -0.854611
	DD	0bf5a1a16r			; -0.851961
	DD	0bf596cd0r			; -0.849317
	DD	0bf58bffdr			; -0.84668
	DD	0bf58139er			; -0.844049
	DD	0bf5767b0r			; -0.841426
	DD	0bf56bc34r			; -0.838809
	DD	0bf561128r			; -0.836199
	DD	0bf55668dr			; -0.833596
	DD	0bf54bc61r			; -0.830999
	DD	0bf5412a4r			; -0.828409
	DD	0bf536956r			; -0.825826
	DD	0bf52c075r			; -0.823249
	DD	0bf521801r			; -0.820679
	DD	0bf516ffar			; -0.818115
	DD	0bf50c85fr			; -0.815557
	DD	0bf50212er			; -0.813006
	DD	0bf4f7a69r			; -0.810462
	DD	0bf4ed40dr			; -0.807923
	DD	0bf4e2e1br			; -0.805391
	DD	0bf4d8892r			; -0.802865
	DD	0bf4ce370r			; -0.800345
	DD	0bf4c3eb7r			; -0.797832
	DD	0bf4b9a65r			; -0.795325
	DD	0bf4af679r			; -0.792823
	DD	0bf4a52f3r			; -0.790328
	DD	0bf49afd3r			; -0.787839
	DD	0bf490d17r			; -0.785356
	DD	0bf486ac0r			; -0.782879
	DD	0bf47c8ccr			; -0.780408
	DD	0bf47273br			; -0.777942
	DD	0bf46860dr			; -0.775483
	DD	0bf45e541r			; -0.773029
	DD	0bf4544d7r			; -0.770582
	DD	0bf44a4cer			; -0.76814
	DD	0bf440525r			; -0.765703
	DD	0bf4365dcr			; -0.763273
	DD	0bf42c6f2r			; -0.760848
	DD	0bf422867r			; -0.758429
	DD	0bf418a3ar			; -0.756015
	DD	0bf40ec6cr			; -0.753608
	DD	0bf404efar			; -0.751205
	DD	0bf3fb1e6r			; -0.748808
	DD	0bf3f152dr			; -0.746417
	DD	0bf3e78d1r			; -0.744031
	DD	0bf3ddccfr			; -0.741651
	DD	0bf3d4129r			; -0.739276
	DD	0bf3ca5ddr			; -0.736906
	DD	0bf3c0aear			; -0.734542
	DD	0bf3b7051r			; -0.732183
	DD	0bf3ad610r			; -0.729829
	DD	0bf3a3c28r			; -0.72748
	DD	0bf39a298r			; -0.725137
	DD	0bf39095fr			; -0.722799
	DD	0bf38707dr			; -0.720466
	DD	0bf37d7f2r			; -0.718139
	DD	0bf373fbcr			; -0.715816
	DD	0bf36a7dcr			; -0.713499
	DD	0bf361051r			; -0.711186
	DD	0bf35791ar			; -0.708879
	DD	0bf34e238r			; -0.706577
	DD	0bf344ba9r			; -0.704279
	DD	0bf33b56dr			; -0.701987
	DD	0bf331f84r			; -0.6997
	DD	0bf3289edr			; -0.697417
	DD	0bf31f4a9r			; -0.695139
	DD	0bf315fb5r			; -0.692867
	DD	0bf30cb13r			; -0.690599
	DD	0bf3036c1r			; -0.688335
	DD	0bf2fa2bfr			; -0.686077
	DD	0bf2f0f0dr			; -0.683823
	DD	0bf2e7baar			; -0.681574
	DD	0bf2de896r			; -0.67933
	DD	0bf2d55d0r			; -0.677091
	DD	0bf2cc359r			; -0.674856
	DD	0bf2c312fr			; -0.672625
	DD	0bf2b9f52r			; -0.6704
	DD	0bf2b0dc1r			; -0.668179
	DD	0bf2a7c7dr			; -0.665962
	DD	0bf29eb85r			; -0.66375
	DD	0bf295ad9r			; -0.661542
	DD	0bf28ca77r			; -0.659339
	DD	0bf283a60r			; -0.657141
	DD	0bf27aa94r			; -0.654947
	DD	0bf271b11r			; -0.652757
	DD	0bf268bd8r			; -0.650571
	DD	0bf25fce8r			; -0.64839
	DD	0bf256e41r			; -0.646214
	DD	0bf24dfe2r			; -0.644041
	DD	0bf2451cbr			; -0.641873
	DD	0bf23c3fcr			; -0.639709
	DD	0bf233673r			; -0.63755
	DD	0bf22a932r			; -0.635394
	DD	0bf221c37r			; -0.633243
	DD	0bf218f82r			; -0.631096
	DD	0bf210313r			; -0.628953
	DD	0bf2076e9r			; -0.626814
	DD	0bf1feb03r			; -0.62468
	DD	0bf1f5f63r			; -0.622549
	DD	0bf1ed407r			; -0.620423
	DD	0bf1e48eer			; -0.6183
	DD	0bf1dbe19r			; -0.616182
	DD	0bf1d3387r			; -0.614067
	DD	0bf1ca938r			; -0.611957
	DD	0bf1c1f2cr			; -0.609851
	DD	0bf1b9561r			; -0.607748
	DD	0bf1b0bd8r			; -0.605649
	DD	0bf1a8291r			; -0.603555
	DD	0bf19f98ar			; -0.601464
	DD	0bf1970c4r			; -0.599377
	DD	0bf18e83fr			; -0.597294
	DD	0bf185ff9r			; -0.595214
	DD	0bf17d7f3r			; -0.593139
	DD	0bf17502dr			; -0.591067
	DD	0bf16c8a5r			; -0.588999
	DD	0bf16415cr			; -0.586935
	DD	0bf15ba52r			; -0.584874
	DD	0bf153385r			; -0.582817
	DD	0bf14acf6r			; -0.580764
	DD	0bf1426a4r			; -0.578715
	DD	0bf13a08fr			; -0.576669
	DD	0bf131ab7r			; -0.574626
	DD	0bf12951cr			; -0.572588
	DD	0bf120fbcr			; -0.570553
	DD	0bf118a98r			; -0.568521
	DD	0bf1105afr			; -0.566493
	DD	0bf108102r			; -0.564469
	DD	0bf0ffc8fr			; -0.562447
	DD	0bf0f7857r			; -0.56043
	DD	0bf0ef459r			; -0.558416
	DD	0bf0e7095r			; -0.556405
	DD	0bf0ded0ar			; -0.554398
	DD	0bf0d69b9r			; -0.552394
	DD	0bf0ce6a0r			; -0.550394
	DD	0bf0c63c0r			; -0.548397
	DD	0bf0be118r			; -0.546403
	DD	0bf0b5ea9r			; -0.544413
	DD	0bf0adc71r			; -0.542426
	DD	0bf0a5a70r			; -0.540442
	DD	0bf09d8a7r			; -0.538462
	DD	0bf095715r			; -0.536485
	DD	0bf08d5b9r			; -0.534511
	DD	0bf085493r			; -0.532541
	DD	0bf07d3a3r			; -0.530573
	DD	0bf0752e9r			; -0.528609
	DD	0bf06d265r			; -0.526648
	DD	0bf065215r			; -0.52469
	DD	0bf05d1fbr			; -0.522735
	DD	0bf055215r			; -0.520784
	DD	0bf04d263r			; -0.518835
	DD	0bf0452e5r			; -0.51689
	DD	0bf03d39br			; -0.514948
	DD	0bf035484r			; -0.513008
	DD	0bf02d5a1r			; -0.511072
	DD	0bf0256f0r			; -0.509139
	DD	0bf01d872r			; -0.507209
	DD	0bf015a26r			; -0.505282
	DD	0bf00dc0dr			; -0.503358
	DD	0bf005e25r			; -0.501437
	DD	0beffc0der			; -0.499518
	DD	0befec5d4r			; -0.497603
	DD	0befdcb2cr			; -0.495691
	DD	0befcd0e6r			; -0.493781
	DD	0befbd701r			; -0.491875
	DD	0befadd7cr			; -0.489971
	DD	0bef9e457r			; -0.48807
	DD	0bef8eb91r			; -0.486172
	DD	0bef7f32br			; -0.484277
	DD	0bef6fb23r			; -0.482385
	DD	0bef60378r			; -0.480495
	DD	0bef50c2cr			; -0.478608
	DD	0bef4153cr			; -0.476725
	DD	0bef31ea8r			; -0.474843
	DD	0bef22870r			; -0.472965
	DD	0bef13294r			; -0.471089
	DD	0bef03d13r			; -0.469216
	DD	0beef47ecr			; -0.467346
	DD	0beee531fr			; -0.465478
	DD	0beed5eabr			; -0.463613
	DD	0beec6a90r			; -0.461751
	DD	0beeb76cer			; -0.459891
	DD	0beea8364r			; -0.458034
	DD	0bee99051r			; -0.456179
	DD	0bee89d96r			; -0.454327
	DD	0bee7ab31r			; -0.452478
	DD	0bee6b922r			; -0.450631
	DD	0bee5c768r			; -0.448787
	DD	0bee4d604r			; -0.446945
	DD	0bee3e4f4r			; -0.445106
	DD	0bee2f439r			; -0.44327
	DD	0bee203d1r			; -0.441435
	DD	0bee113bdr			; -0.439604
	DD	0bee023fbr			; -0.437775
	DD	0bedf348cr			; -0.435948
	DD	0bede456fr			; -0.434123
	DD	0bedd56a3r			; -0.432302
	DD	0bedc6828r			; -0.430482
	DD	0bedb79fer			; -0.428665
	DD	0beda8c24r			; -0.42685
	DD	0bed99e9ar			; -0.425038
	DD	0bed8b15fr			; -0.423228
	DD	0bed7c473r			; -0.421421
	DD	0bed6d7d5r			; -0.419615
	DD	0bed5eb85r			; -0.417812
	DD	0bed4ff82r			; -0.416012
	DD	0bed413cdr			; -0.414214
	DD	0bed32864r			; -0.412418
	DD	0bed23d47r			; -0.410624
	DD	0bed15277r			; -0.408832
	DD	0bed067f1r			; -0.407043
	DD	0becf7db7r			; -0.405256
	DD	0bece93c7r			; -0.403471
	DD	0becdaa21r			; -0.401689
	DD	0beccc0c4r			; -0.399908
	DD	0becbd7b1r			; -0.39813
	DD	0becaeee7r			; -0.396354
	DD	0beca0666r			; -0.39458
	DD	0bec91e2cr			; -0.392808
	DD	0bec8363ar			; -0.391039
	DD	0bec74e8fr			; -0.389271
	DD	0bec6672ar			; -0.387506
	DD	0bec5800dr			; -0.385743
	DD	0bec49935r			; -0.383981
	DD	0bec3b2a3r			; -0.382222
	DD	0bec2cc56r			; -0.380465
	DD	0bec1e64dr			; -0.37871
	DD	0bec10089r			; -0.376957
	DD	0bec01b0ar			; -0.375206
	DD	0bebf35cdr			; -0.373457
	DD	0bebe50d4r			; -0.37171
	DD	0bebd6c1er			; -0.369965
	DD	0bebc87aar			; -0.368223
	DD	0bebba378r			; -0.366482
	DD	0bebabf88r			; -0.364743
	DD	0beb9dbd9r			; -0.363005
	DD	0beb8f86br			; -0.36127
	DD	0beb8153dr			; -0.359537
	DD	0beb73250r			; -0.357806
	DD	0beb64fa2r			; -0.356076
	DD	0beb56d34r			; -0.354349
	DD	0beb48b04r			; -0.352623
	DD	0beb3a913r			; -0.350899
	DD	0beb2c761r			; -0.349177
	DD	0beb1e5ecr			; -0.347457
	DD	0beb104b5r			; -0.345739
	DD	0beb023bbr			; -0.344023
	DD	0beaf42fer			; -0.342308
	DD	0beae627dr			; -0.340595
	DD	0bead8238r			; -0.338884
	DD	0beaca22fr			; -0.337175
	DD	0beabc261r			; -0.335467
	DD	0beaae2cer			; -0.333762
	DD	0beaa0375r			; -0.332058
	DD	0bea92457r			; -0.330355
	DD	0bea84573r			; -0.328655
	DD	0bea766c8r			; -0.326956
	DD	0bea68856r			; -0.325259
	DD	0bea5aa1dr			; -0.323563
	DD	0bea4cc1dr			; -0.32187
	DD	0bea3ee54r			; -0.320178
	DD	0bea310c4r			; -0.318487
	DD	0bea2336br			; -0.316799
	DD	0bea15648r			; -0.315111
	DD	0bea0795dr			; -0.313426
	DD	0be9f9ca8r			; -0.311742
	DD	0be9ec029r			; -0.31006
	DD	0be9de3dfr			; -0.308379
	DD	0be9d07cbr			; -0.3067
	DD	0be9c2becr			; -0.305023
	DD	0be9b5042r			; -0.303347
	DD	0be9a74ccr			; -0.301672
	DD	0be999989r			; -0.3
	DD	0be98be7br			; -0.298328
	DD	0be97e3a0r			; -0.296659
	DD	0be9708f7r			; -0.29499
	DD	0be962e82r			; -0.293324
	DD	0be95543er			; -0.291658
	DD	0be947a2dr			; -0.289995
	DD	0be93a04dr			; -0.288332
	DD	0be92c69fr			; -0.286672
	DD	0be91ed21r			; -0.285012
	DD	0be9113d5r			; -0.283354
	DD	0be903ab8r			; -0.281698
	DD	0be8f61ccr			; -0.280043
	DD	0be8e890fr			; -0.278389
	DD	0be8db082r			; -0.276737
	DD	0be8cd824r			; -0.275087
	DD	0be8bfff4r			; -0.273437
	DD	0be8b27f3r			; -0.271789
	DD	0be8a5020r			; -0.270143
	DD	0be89787br			; -0.268497
	DD	0be88a103r			; -0.266853
	DD	0be87c9b8r			; -0.265211
	DD	0be86f29ar			; -0.26357
	DD	0be861ba9r			; -0.26193
	DD	0be8544e4r			; -0.260291
	DD	0be846e4ar			; -0.258654
	DD	0be8397ddr			; -0.257018
	DD	0be82c19ar			; -0.255383
	DD	0be81eb83r			; -0.25375
	DD	0be811596r			; -0.252118
	DD	0be803fd4r			; -0.250487
	DD	0be7ed477r			; -0.248857
	DD	0be7d2999r			; -0.247229
	DD	0be7b7f0fr			; -0.245602
	DD	0be79d4d6r			; -0.243976
	DD	0be782af0r			; -0.242351
	DD	0be76815ar			; -0.240728
	DD	0be74d815r			; -0.239106
	DD	0be732f20r			; -0.237484
	DD	0be718679r			; -0.235865
	DD	0be6fde22r			; -0.234246
	DD	0be6e3619r			; -0.232628
	DD	0be6c8e5dr			; -0.231012
	DD	0be6ae6edr			; -0.229397
	DD	0be693fcbr			; -0.227782
	DD	0be6798f3r			; -0.226169
	DD	0be65f267r			; -0.224558
	DD	0be644c26r			; -0.222947
	DD	0be62a62er			; -0.221337
	DD	0be610080r			; -0.219728
	DD	0be5f5b1ar			; -0.218121
	DD	0be5db5fdr			; -0.216515
	DD	0be5c1127r			; -0.214909
	DD	0be5a6c98r			; -0.213305
	DD	0be58c84fr			; -0.211702
	DD	0be57244dr			; -0.210099
	DD	0be558090r			; -0.208498
	DD	0be53dd17r			; -0.206898
	DD	0be5239e3r			; -0.205299
	DD	0be5096f2r			; -0.203701
	DD	0be4ef444r			; -0.202104
	DD	0be4d51d9r			; -0.200508
	DD	0be4bafafr			; -0.198912
	DD	0be4a0dc7r			; -0.197318
	DD	0be486c1fr			; -0.195725
	DD	0be46cab8r			; -0.194133
	DD	0be452990r			; -0.192541
	DD	0be4388a8r			; -0.190951
	DD	0be41e7fer			; -0.189362
	DD	0be404791r			; -0.187773
	DD	0be3ea763r			; -0.186185
	DD	0be3d0771r			; -0.184599
	DD	0be3b67bbr			; -0.183013
	DD	0be39c841r			; -0.181428
	DD	0be382902r			; -0.179844
	DD	0be3689fer			; -0.178261
	DD	0be34eb34r			; -0.176678
	DD	0be334ca4r			; -0.175097
	DD	0be31ae4dr			; -0.173516
	DD	0be30102er			; -0.171937
	DD	0be2e7246r			; -0.170358
	DD	0be2cd497r			; -0.16878
	DD	0be2b371er			; -0.167202
	DD	0be2999dbr			; -0.165626
	DD	0be27fccer			; -0.16405
	DD	0be265ff7r			; -0.162475
	DD	0be24c354r			; -0.160901
	DD	0be2326e5r			; -0.159328
	DD	0be218aaar			; -0.157756
	DD	0be1feea1r			; -0.156184
	DD	0be1e52ccr			; -0.154613
	DD	0be1cb728r			; -0.153042
	DD	0be1b1bb6r			; -0.151473
	DD	0be198074r			; -0.149904
	DD	0be17e564r			; -0.148336
	DD	0be164a83r			; -0.146769
	DD	0be14afd1r			; -0.145202
	DD	0be13154er			; -0.143636
	DD	0be117afar			; -0.142071
	DD	0be0fe0d3r			; -0.140506
	DD	0be0e46d9r			; -0.138942
	DD	0be0cad0dr			; -0.137379
	DD	0be0b136cr			; -0.135816
	DD	0be0979f7r			; -0.134254
	DD	0be07e0aer			; -0.132693
	DD	0be06478fr			; -0.131132
	DD	0be04ae9ar			; -0.129572
	DD	0be0315cer			; -0.128013
	DD	0be017d2cr			; -0.126454
	DD	0bdffc965r			; -0.124896
	DD	0bdfc98c2r			; -0.123338
	DD	0bdf9686er			; -0.121781
	DD	0bdf63868r			; -0.120225
	DD	0bdf308afr			; -0.118669
	DD	0bdefd942r			; -0.117114
	DD	0bdecaa20r			; -0.115559
	DD	0bde97b48r			; -0.114005
	DD	0bde64cb9r			; -0.112451
	DD	0bde31e72r			; -0.110898
	DD	0bddff072r			; -0.109345
	DD	0bddcc2b7r			; -0.107793
	DD	0bdd99542r			; -0.106242
	DD	0bdd66810r			; -0.104691
	DD	0bdd33b22r			; -0.10314
	DD	0bdd00e75r			; -0.10159
	DD	0bdcce209r			; -0.100041
	DD	0bdc9b5dcr			; -0.0984914
	DD	0bdc689efr			; -0.0969428
	DD	0bdc35e3fr			; -0.0953946
	DD	0bdc032cdr			; -0.0938469
	DD	0bdbd0796r			; -0.0922996
	DD	0bdb9dc99r			; -0.0907528
	DD	0bdb6b1d7r			; -0.0892064
	DD	0bdb3874dr			; -0.0876604
	DD	0bdb05cfcr			; -0.0861149
	DD	0bdad32e1r			; -0.0845697
	DD	0bdaa08fbr			; -0.0830249
	DD	0bda6df4br			; -0.0814806
	DD	0bda3b5cfr			; -0.0799366
	DD	0bda08c85r			; -0.078393
	DD	0bd9d636dr			; -0.0768498
	DD	0bd9a3a86r			; -0.0753069
	DD	0bd9711cer			; -0.0737644
	DD	0bd93e946r			; -0.0722223
	DD	0bd90c0ebr			; -0.0706805
	DD	0bd8d98ber			; -0.069139
	DD	0bd8a70bcr			; -0.0675978
	DD	0bd8748e5r			; -0.066057
	DD	0bd842138r			; -0.0645165
	DD	0bd80f9b4r			; -0.0629763
	DD	0bd7ba4afr			; -0.0614364
	DD	0bd755645r			; -0.0598967
	DD	0bd6f0826r			; -0.0583574
	DD	0bd68ba52r			; -0.0568183
	DD	0bd626cc5r			; -0.0552795
	DD	0bd5c1f7fr			; -0.053741
	DD	0bd55d27dr			; -0.0522027
	DD	0bd4f85bcr			; -0.0506646
	DD	0bd49393cr			; -0.0491268
	DD	0bd42ecfar			; -0.0475893
	DD	0bd3ca0f5r			; -0.0460519
	DD	0bd36552ar			; -0.0445148
	DD	0bd300997r			; -0.0429779
	DD	0bd29be3ar			; -0.0414412
	DD	0bd237312r			; -0.0399047
	DD	0bd1d281cr			; -0.0383683
	DD	0bd16dd57r			; -0.0368322
	DD	0bd1092c1r			; -0.0352962
	DD	0bd0a4857r			; -0.0337604
	DD	0bd03fe18r			; -0.0322247
	DD	0bcfb6803r			; -0.0306892
	DD	0bceed424r			; -0.0291539
	DD	0bce2408er			; -0.0276187
	DD	0bcd5ad3fr			; -0.0260836
	DD	0bcc91a31r			; -0.0245486
	DD	0bcbc8762r			; -0.0230138
	DD	0bcaff4ccr			; -0.021479
	DD	0bca3626dr			; -0.0199444
	DD	0bc96d040r			; -0.0184098
	DD	0bc8a3e42r			; -0.0168754
	DD	0bc7b58ddr			; -0.015341
	DD	0bc623584r			; -0.0138067
	DD	0bc491270r			; -0.0122725
	DD	0bc2fef9ar			; -0.0107383
	DD	0bc16ccfbr			; -0.00920414
	DD	0bbfb5514r			; -0.00767005
	DD	0bbc91080r			; -0.006136
	DD	0bb96cc2ar			; -0.00460197
	DD	0bb491004r			; -0.00306797
	DD	0bac90fe5r			; -0.00153398
	DD	0a50d3000r			; -1.22461e-16
	DD	03ac90fe5r			; 0.00153398
	DD	03b491004r			; 0.00306797
	DD	03b96cc2ar			; 0.00460197
	DD	03bc91080r			; 0.006136
	DD	03bfb5514r			; 0.00767005
	DD	03c16ccfbr			; 0.00920414
	DD	03c2fef9ar			; 0.0107383
	DD	03c491270r			; 0.0122725
	DD	03c623584r			; 0.0138067
	DD	03c7b58ddr			; 0.015341
	DD	03c8a3e42r			; 0.0168754
	DD	03c96d040r			; 0.0184098
	DD	03ca3626dr			; 0.0199444
	DD	03caff4ccr			; 0.021479
	DD	03cbc8762r			; 0.0230138
	DD	03cc91a31r			; 0.0245486
	DD	03cd5ad3fr			; 0.0260836
	DD	03ce2408er			; 0.0276187
	DD	03ceed424r			; 0.0291539
	DD	03cfb6803r			; 0.0306892
	DD	03d03fe18r			; 0.0322247
	DD	03d0a4857r			; 0.0337604
	DD	03d1092c1r			; 0.0352962
	DD	03d16dd57r			; 0.0368322
	DD	03d1d281cr			; 0.0383683
	DD	03d237312r			; 0.0399047
	DD	03d29be3ar			; 0.0414412
	DD	03d300997r			; 0.0429779
	DD	03d36552ar			; 0.0445148
	DD	03d3ca0f5r			; 0.0460519
	DD	03d42ecfar			; 0.0475893
	DD	03d49393cr			; 0.0491268
	DD	03d4f85bcr			; 0.0506646
	DD	03d55d27dr			; 0.0522027
	DD	03d5c1f7fr			; 0.053741
	DD	03d626cc5r			; 0.0552795
	DD	03d68ba52r			; 0.0568183
	DD	03d6f0826r			; 0.0583574
	DD	03d755645r			; 0.0598967
	DD	03d7ba4afr			; 0.0614364
	DD	03d80f9b4r			; 0.0629763
	DD	03d842138r			; 0.0645165
	DD	03d8748e5r			; 0.066057
	DD	03d8a70bcr			; 0.0675978
	DD	03d8d98ber			; 0.069139
	DD	03d90c0ebr			; 0.0706805
	DD	03d93e946r			; 0.0722223
	DD	03d9711cer			; 0.0737644
	DD	03d9a3a86r			; 0.0753069
	DD	03d9d636dr			; 0.0768498
	DD	03da08c85r			; 0.078393
	DD	03da3b5cfr			; 0.0799366
	DD	03da6df4br			; 0.0814806
	DD	03daa08fbr			; 0.0830249
	DD	03dad32e1r			; 0.0845697
	DD	03db05cfcr			; 0.0861149
	DD	03db3874dr			; 0.0876604
	DD	03db6b1d7r			; 0.0892064
	DD	03db9dc99r			; 0.0907528
	DD	03dbd0796r			; 0.0922996
	DD	03dc032cdr			; 0.0938469
	DD	03dc35e3fr			; 0.0953946
	DD	03dc689efr			; 0.0969428
	DD	03dc9b5dcr			; 0.0984914
	DD	03dcce209r			; 0.100041
	DD	03dd00e75r			; 0.10159
	DD	03dd33b22r			; 0.10314
	DD	03dd66810r			; 0.104691
	DD	03dd99542r			; 0.106242
	DD	03ddcc2b7r			; 0.107793
	DD	03ddff072r			; 0.109345
	DD	03de31e72r			; 0.110898
	DD	03de64cb9r			; 0.112451
	DD	03de97b48r			; 0.114005
	DD	03decaa20r			; 0.115559
	DD	03defd942r			; 0.117114
	DD	03df308afr			; 0.118669
	DD	03df63868r			; 0.120225
	DD	03df9686er			; 0.121781
	DD	03dfc98c2r			; 0.123338
	DD	03dffc965r			; 0.124896
	DD	03e017d2cr			; 0.126454
	DD	03e0315cer			; 0.128013
	DD	03e04ae9ar			; 0.129572
	DD	03e06478fr			; 0.131132
	DD	03e07e0aer			; 0.132693
	DD	03e0979f7r			; 0.134254
	DD	03e0b136cr			; 0.135816
	DD	03e0cad0dr			; 0.137379
	DD	03e0e46d9r			; 0.138942
	DD	03e0fe0d3r			; 0.140506
	DD	03e117afar			; 0.142071
	DD	03e13154er			; 0.143636
	DD	03e14afd1r			; 0.145202
	DD	03e164a83r			; 0.146769
	DD	03e17e564r			; 0.148336
	DD	03e198074r			; 0.149904
	DD	03e1b1bb6r			; 0.151473
	DD	03e1cb728r			; 0.153042
	DD	03e1e52ccr			; 0.154613
	DD	03e1feea1r			; 0.156184
	DD	03e218aaar			; 0.157756
	DD	03e2326e5r			; 0.159328
	DD	03e24c354r			; 0.160901
	DD	03e265ff7r			; 0.162475
	DD	03e27fccer			; 0.16405
	DD	03e2999dbr			; 0.165626
	DD	03e2b371er			; 0.167202
	DD	03e2cd497r			; 0.16878
	DD	03e2e7246r			; 0.170358
	DD	03e30102er			; 0.171937
	DD	03e31ae4dr			; 0.173516
	DD	03e334ca4r			; 0.175097
	DD	03e34eb34r			; 0.176678
	DD	03e3689fer			; 0.178261
	DD	03e382902r			; 0.179844
	DD	03e39c841r			; 0.181428
	DD	03e3b67bbr			; 0.183013
	DD	03e3d0771r			; 0.184599
	DD	03e3ea763r			; 0.186185
	DD	03e404791r			; 0.187773
	DD	03e41e7fer			; 0.189362
	DD	03e4388a8r			; 0.190951
	DD	03e452990r			; 0.192541
	DD	03e46cab8r			; 0.194133
	DD	03e486c1fr			; 0.195725
	DD	03e4a0dc7r			; 0.197318
	DD	03e4bafafr			; 0.198912
	DD	03e4d51d9r			; 0.200508
	DD	03e4ef444r			; 0.202104
	DD	03e5096f2r			; 0.203701
	DD	03e5239e3r			; 0.205299
	DD	03e53dd17r			; 0.206898
	DD	03e558090r			; 0.208498
	DD	03e57244dr			; 0.210099
	DD	03e58c84fr			; 0.211702
	DD	03e5a6c98r			; 0.213305
	DD	03e5c1127r			; 0.214909
	DD	03e5db5fdr			; 0.216515
	DD	03e5f5b1ar			; 0.218121
	DD	03e610080r			; 0.219728
	DD	03e62a62er			; 0.221337
	DD	03e644c26r			; 0.222947
	DD	03e65f267r			; 0.224558
	DD	03e6798f3r			; 0.226169
	DD	03e693fcbr			; 0.227782
	DD	03e6ae6edr			; 0.229397
	DD	03e6c8e5dr			; 0.231012
	DD	03e6e3619r			; 0.232628
	DD	03e6fde22r			; 0.234246
	DD	03e718679r			; 0.235865
	DD	03e732f20r			; 0.237484
	DD	03e74d815r			; 0.239106
	DD	03e76815ar			; 0.240728
	DD	03e782af0r			; 0.242351
	DD	03e79d4d6r			; 0.243976
	DD	03e7b7f0fr			; 0.245602
	DD	03e7d2999r			; 0.247229
	DD	03e7ed477r			; 0.248857
	DD	03e803fd4r			; 0.250487
	DD	03e811596r			; 0.252118
	DD	03e81eb83r			; 0.25375
	DD	03e82c19ar			; 0.255383
	DD	03e8397ddr			; 0.257018
	DD	03e846e4ar			; 0.258654
	DD	03e8544e4r			; 0.260291
	DD	03e861ba9r			; 0.26193
	DD	03e86f29ar			; 0.26357
	DD	03e87c9b8r			; 0.265211
	DD	03e88a103r			; 0.266853
	DD	03e89787br			; 0.268497
	DD	03e8a5020r			; 0.270143
	DD	03e8b27f3r			; 0.271789
	DD	03e8bfff4r			; 0.273437
	DD	03e8cd824r			; 0.275087
	DD	03e8db082r			; 0.276737
	DD	03e8e890fr			; 0.278389
	DD	03e8f61ccr			; 0.280043
	DD	03e903ab8r			; 0.281698
	DD	03e9113d5r			; 0.283354
	DD	03e91ed21r			; 0.285012
	DD	03e92c69fr			; 0.286672
	DD	03e93a04dr			; 0.288332
	DD	03e947a2dr			; 0.289995
	DD	03e95543er			; 0.291658
	DD	03e962e82r			; 0.293324
	DD	03e9708f7r			; 0.29499
	DD	03e97e3a0r			; 0.296659
	DD	03e98be7br			; 0.298328
	DD	03e999989r			; 0.3
	DD	03e9a74ccr			; 0.301672
	DD	03e9b5042r			; 0.303347
	DD	03e9c2becr			; 0.305023
	DD	03e9d07cbr			; 0.3067
	DD	03e9de3dfr			; 0.308379
	DD	03e9ec029r			; 0.31006
	DD	03e9f9ca8r			; 0.311742
	DD	03ea0795dr			; 0.313426
	DD	03ea15648r			; 0.315111
	DD	03ea2336br			; 0.316799
	DD	03ea310c4r			; 0.318487
	DD	03ea3ee54r			; 0.320178
	DD	03ea4cc1dr			; 0.32187
	DD	03ea5aa1dr			; 0.323563
	DD	03ea68856r			; 0.325259
	DD	03ea766c8r			; 0.326956
	DD	03ea84573r			; 0.328655
	DD	03ea92457r			; 0.330355
	DD	03eaa0375r			; 0.332058
	DD	03eaae2cer			; 0.333762
	DD	03eabc261r			; 0.335467
	DD	03eaca22fr			; 0.337175
	DD	03ead8238r			; 0.338884
	DD	03eae627dr			; 0.340595
	DD	03eaf42fer			; 0.342308
	DD	03eb023bbr			; 0.344023
	DD	03eb104b5r			; 0.345739
	DD	03eb1e5ecr			; 0.347457
	DD	03eb2c761r			; 0.349177
	DD	03eb3a913r			; 0.350899
	DD	03eb48b04r			; 0.352623
	DD	03eb56d34r			; 0.354349
	DD	03eb64fa2r			; 0.356076
	DD	03eb73250r			; 0.357806
	DD	03eb8153dr			; 0.359537
	DD	03eb8f86br			; 0.36127
	DD	03eb9dbd9r			; 0.363005
	DD	03ebabf88r			; 0.364743
	DD	03ebba378r			; 0.366482
	DD	03ebc87aar			; 0.368223
	DD	03ebd6c1er			; 0.369965
	DD	03ebe50d4r			; 0.37171
	DD	03ebf35cdr			; 0.373457
	DD	03ec01b0ar			; 0.375206
	DD	03ec10089r			; 0.376957
	DD	03ec1e64dr			; 0.37871
	DD	03ec2cc56r			; 0.380465
	DD	03ec3b2a3r			; 0.382222
	DD	03ec49935r			; 0.383981
	DD	03ec5800dr			; 0.385743
	DD	03ec6672ar			; 0.387506
	DD	03ec74e8fr			; 0.389271
	DD	03ec8363ar			; 0.391039
	DD	03ec91e2cr			; 0.392808
	DD	03eca0666r			; 0.39458
	DD	03ecaeee7r			; 0.396354
	DD	03ecbd7b1r			; 0.39813
	DD	03eccc0c4r			; 0.399908
	DD	03ecdaa21r			; 0.401689
	DD	03ece93c7r			; 0.403471
	DD	03ecf7db7r			; 0.405256
	DD	03ed067f1r			; 0.407043
	DD	03ed15277r			; 0.408832
	DD	03ed23d47r			; 0.410624
	DD	03ed32864r			; 0.412418
	DD	03ed413cdr			; 0.414214
	DD	03ed4ff82r			; 0.416012
	DD	03ed5eb85r			; 0.417812
	DD	03ed6d7d5r			; 0.419615
	DD	03ed7c473r			; 0.421421
	DD	03ed8b15fr			; 0.423228
	DD	03ed99e9ar			; 0.425038
	DD	03eda8c24r			; 0.42685
	DD	03edb79fer			; 0.428665
	DD	03edc6828r			; 0.430482
	DD	03edd56a3r			; 0.432302
	DD	03ede456fr			; 0.434123
	DD	03edf348cr			; 0.435948
	DD	03ee023fbr			; 0.437775
	DD	03ee113bdr			; 0.439604
	DD	03ee203d1r			; 0.441435
	DD	03ee2f439r			; 0.44327
	DD	03ee3e4f4r			; 0.445106
	DD	03ee4d604r			; 0.446945
	DD	03ee5c768r			; 0.448787
	DD	03ee6b922r			; 0.450631
	DD	03ee7ab31r			; 0.452478
	DD	03ee89d96r			; 0.454327
	DD	03ee99051r			; 0.456179
	DD	03eea8364r			; 0.458034
	DD	03eeb76cer			; 0.459891
	DD	03eec6a90r			; 0.461751
	DD	03eed5eabr			; 0.463613
	DD	03eee531fr			; 0.465478
	DD	03eef47ecr			; 0.467346
	DD	03ef03d13r			; 0.469216
	DD	03ef13294r			; 0.471089
	DD	03ef22870r			; 0.472965
	DD	03ef31ea8r			; 0.474843
	DD	03ef4153cr			; 0.476725
	DD	03ef50c2cr			; 0.478608
	DD	03ef60378r			; 0.480495
	DD	03ef6fb23r			; 0.482385
	DD	03ef7f32br			; 0.484277
	DD	03ef8eb91r			; 0.486172
	DD	03ef9e457r			; 0.48807
	DD	03efadd7cr			; 0.489971
	DD	03efbd701r			; 0.491875
	DD	03efcd0e6r			; 0.493781
	DD	03efdcb2cr			; 0.495691
	DD	03efec5d4r			; 0.497603
	DD	03effc0der			; 0.499518
	DD	03f005e25r			; 0.501437
	DD	03f00dc0dr			; 0.503358
	DD	03f015a26r			; 0.505282
	DD	03f01d872r			; 0.507209
	DD	03f0256f0r			; 0.509139
	DD	03f02d5a1r			; 0.511072
	DD	03f035484r			; 0.513008
	DD	03f03d39br			; 0.514948
	DD	03f0452e5r			; 0.51689
	DD	03f04d263r			; 0.518835
	DD	03f055215r			; 0.520784
	DD	03f05d1fbr			; 0.522735
	DD	03f065215r			; 0.52469
	DD	03f06d265r			; 0.526648
	DD	03f0752e9r			; 0.528609
	DD	03f07d3a3r			; 0.530573
	DD	03f085493r			; 0.532541
	DD	03f08d5b9r			; 0.534511
	DD	03f095715r			; 0.536485
	DD	03f09d8a7r			; 0.538462
	DD	03f0a5a70r			; 0.540442
	DD	03f0adc71r			; 0.542426
	DD	03f0b5ea9r			; 0.544413
	DD	03f0be118r			; 0.546403
	DD	03f0c63c0r			; 0.548397
	DD	03f0ce6a0r			; 0.550394
	DD	03f0d69b9r			; 0.552394
	DD	03f0ded0ar			; 0.554398
	DD	03f0e7095r			; 0.556405
	DD	03f0ef459r			; 0.558416
	DD	03f0f7857r			; 0.56043
	DD	03f0ffc8fr			; 0.562447
	DD	03f108102r			; 0.564469
	DD	03f1105afr			; 0.566493
	DD	03f118a98r			; 0.568521
	DD	03f120fbcr			; 0.570553
	DD	03f12951cr			; 0.572588
	DD	03f131ab7r			; 0.574626
	DD	03f13a08fr			; 0.576669
	DD	03f1426a4r			; 0.578715
	DD	03f14acf6r			; 0.580764
	DD	03f153385r			; 0.582817
	DD	03f15ba52r			; 0.584874
	DD	03f16415cr			; 0.586935
	DD	03f16c8a5r			; 0.588999
	DD	03f17502dr			; 0.591067
	DD	03f17d7f3r			; 0.593139
	DD	03f185ff9r			; 0.595214
	DD	03f18e83fr			; 0.597294
	DD	03f1970c4r			; 0.599377
	DD	03f19f98ar			; 0.601464
	DD	03f1a8291r			; 0.603555
	DD	03f1b0bd8r			; 0.605649
	DD	03f1b9561r			; 0.607748
	DD	03f1c1f2cr			; 0.609851
	DD	03f1ca938r			; 0.611957
	DD	03f1d3387r			; 0.614067
	DD	03f1dbe19r			; 0.616182
	DD	03f1e48eer			; 0.6183
	DD	03f1ed407r			; 0.620423
	DD	03f1f5f63r			; 0.622549
	DD	03f1feb03r			; 0.62468
	DD	03f2076e9r			; 0.626814
	DD	03f210313r			; 0.628953
	DD	03f218f82r			; 0.631096
	DD	03f221c37r			; 0.633243
	DD	03f22a932r			; 0.635394
	DD	03f233673r			; 0.63755
	DD	03f23c3fcr			; 0.639709
	DD	03f2451cbr			; 0.641873
	DD	03f24dfe2r			; 0.644041
	DD	03f256e41r			; 0.646214
	DD	03f25fce8r			; 0.64839
	DD	03f268bd8r			; 0.650571
	DD	03f271b11r			; 0.652757
	DD	03f27aa94r			; 0.654947
	DD	03f283a60r			; 0.657141
	DD	03f28ca77r			; 0.659339
	DD	03f295ad9r			; 0.661542
	DD	03f29eb85r			; 0.66375
	DD	03f2a7c7dr			; 0.665962
	DD	03f2b0dc1r			; 0.668179
	DD	03f2b9f52r			; 0.6704
	DD	03f2c312fr			; 0.672625
	DD	03f2cc359r			; 0.674856
	DD	03f2d55d0r			; 0.677091
	DD	03f2de896r			; 0.67933
	DD	03f2e7baar			; 0.681574
	DD	03f2f0f0dr			; 0.683823
	DD	03f2fa2bfr			; 0.686077
	DD	03f3036c1r			; 0.688335
	DD	03f30cb13r			; 0.690599
	DD	03f315fb5r			; 0.692867
	DD	03f31f4a9r			; 0.695139
	DD	03f3289edr			; 0.697417
	DD	03f331f84r			; 0.6997
	DD	03f33b56dr			; 0.701987
	DD	03f344ba9r			; 0.704279
	DD	03f34e238r			; 0.706577
	DD	03f35791ar			; 0.708879
	DD	03f361051r			; 0.711186
	DD	03f36a7dcr			; 0.713499
	DD	03f373fbcr			; 0.715816
	DD	03f37d7f2r			; 0.718139
	DD	03f38707dr			; 0.720466
	DD	03f39095fr			; 0.722799
	DD	03f39a298r			; 0.725137
	DD	03f3a3c28r			; 0.72748
	DD	03f3ad610r			; 0.729829
	DD	03f3b7051r			; 0.732183
	DD	03f3c0aear			; 0.734542
	DD	03f3ca5ddr			; 0.736906
	DD	03f3d4129r			; 0.739276
	DD	03f3ddccfr			; 0.741651
	DD	03f3e78d1r			; 0.744031
	DD	03f3f152dr			; 0.746417
	DD	03f3fb1e6r			; 0.748808
	DD	03f404efar			; 0.751205
	DD	03f40ec6cr			; 0.753608
	DD	03f418a3ar			; 0.756015
	DD	03f422867r			; 0.758429
	DD	03f42c6f2r			; 0.760848
	DD	03f4365dcr			; 0.763273
	DD	03f440525r			; 0.765703
	DD	03f44a4cer			; 0.76814
	DD	03f4544d7r			; 0.770582
	DD	03f45e541r			; 0.773029
	DD	03f46860dr			; 0.775483
	DD	03f47273br			; 0.777942
	DD	03f47c8ccr			; 0.780408
	DD	03f486ac0r			; 0.782879
	DD	03f490d17r			; 0.785356
	DD	03f49afd3r			; 0.787839
	DD	03f4a52f3r			; 0.790328
	DD	03f4af679r			; 0.792823
	DD	03f4b9a65r			; 0.795325
	DD	03f4c3eb7r			; 0.797832
	DD	03f4ce370r			; 0.800345
	DD	03f4d8892r			; 0.802865
	DD	03f4e2e1br			; 0.805391
	DD	03f4ed40dr			; 0.807923
	DD	03f4f7a69r			; 0.810462
	DD	03f50212er			; 0.813006
	DD	03f50c85fr			; 0.815557
	DD	03f516ffar			; 0.818115
	DD	03f521801r			; 0.820679
	DD	03f52c075r			; 0.823249
	DD	03f536956r			; 0.825826
	DD	03f5412a4r			; 0.828409
	DD	03f54bc61r			; 0.830999
	DD	03f55668dr			; 0.833596
	DD	03f561128r			; 0.836199
	DD	03f56bc34r			; 0.838809
	DD	03f5767b0r			; 0.841426
	DD	03f58139er			; 0.844049
	DD	03f58bffdr			; 0.84668
	DD	03f596cd0r			; 0.849317
	DD	03f5a1a16r			; 0.851961
	DD	03f5ac7d0r			; 0.854611
	DD	03f5b75ffr			; 0.857269
	DD	03f5c24a4r			; 0.859934
	DD	03f5cd3ber			; 0.862606
	DD	03f5d834fr			; 0.865285
	DD	03f5e3358r			; 0.867971
	DD	03f5ee3d9r			; 0.870664
	DD	03f5f94d3r			; 0.873365
	DD	03f604646r			; 0.876072
	DD	03f60f834r			; 0.878787
	DD	03f61aa9cr			; 0.88151
	DD	03f625d80r			; 0.884239
	DD	03f6310e1r			; 0.886976
	DD	03f63c4bfr			; 0.889721
	DD	03f64791ar			; 0.892473
	DD	03f652df5r			; 0.895232
	DD	03f65e34er			; 0.898
	DD	03f669928r			; 0.900774
	DD	03f674f82r			; 0.903557
	DD	03f68065er			; 0.906347
	DD	03f68bdbdr			; 0.909145
	DD	03f69759er			; 0.911951
	DD	03f6a2e04r			; 0.914765
	DD	03f6ae6eer			; 0.917586
	DD	03f6ba05dr			; 0.920416
	DD	03f6c5a53r			; 0.923253
	DD	03f6d14d0r			; 0.926099
	DD	03f6dcfd4r			; 0.928952
	DD	03f6e8b62r			; 0.931814
	DD	03f6f4778r			; 0.934684
	DD	03f700419r			; 0.937563
	DD	03f70c145r			; 0.940449
	DD	03f717efdr			; 0.943344
	DD	03f723d42r			; 0.946247
	DD	03f72fc15r			; 0.949159
	DD	03f73bb75r			; 0.952079
	DD	03f747b66r			; 0.955008
	DD	03f753be6r			; 0.957945
	DD	03f75fcf7r			; 0.960891
	DD	03f76be9br			; 0.963846
	DD	03f7780d1r			; 0.966809
	DD	03f78439br			; 0.969782
	DD	03f7906f9r			; 0.972763
	DD	03f79caedr			; 0.975753
	DD	03f7a8f77r			; 0.978752
	DD	03f7b5499r			; 0.98176
	DD	03f7c1a53r			; 0.984777
	DD	03f7ce0a6r			; 0.987803
	DD	03f7da793r			; 0.990838
	DD	03f7e6f1br			; 0.993883
	DD	03f7f373fr			; 0.996937
	DD	03f800000r			; 1
	DD	03f8064afr			; 1.00307
	DD	03f80c9aer			; 1.00615
	DD	03f812efdr			; 1.00925
	DD	03f81949dr			; 1.01235
	DD	03f81fa8dr			; 1.01546
	DD	03f8260cer			; 1.01858
	DD	03f82c762r			; 1.02171
	DD	03f832e48r			; 1.02485
	DD	03f839581r			; 1.028
	DD	03f83fd0dr			; 1.03116
	DD	03f8464eer			; 1.03433
	DD	03f84cd23r			; 1.03751
	DD	03f8535adr			; 1.0407
	DD	03f859e8cr			; 1.0439
	DD	03f8607c2r			; 1.04711
	DD	03f86714fr			; 1.05033
	DD	03f86db32r			; 1.05356
	DD	03f87456dr			; 1.05681
	DD	03f87b001r			; 1.06006
	DD	03f881aeer			; 1.06332
	DD	03f888634r			; 1.0666
	DD	03f88f1d4r			; 1.06988
	DD	03f895dcer			; 1.07318
	DD	03f89ca24r			; 1.07648
	DD	03f8a36d5r			; 1.0798
	DD	03f8aa3e3r			; 1.08313
	DD	03f8b114er			; 1.08647
	DD	03f8b7f16r			; 1.08982
	DD	03f8bed3dr			; 1.09318
	DD	03f8c5bc2r			; 1.09655
	DD	03f8ccaa6r			; 1.09993
	DD	03f8d39ebr			; 1.10333
	DD	03f8da990r			; 1.10674
	DD	03f8e1996r			; 1.11016
	DD	03f8e89fer			; 1.11359
	DD	03f8efac8r			; 1.11703
	DD	03f8f6bf6r			; 1.12048
	DD	03f8fdd88r			; 1.12395
	DD	03f904f7dr			; 1.12743
	DD	03f90c1d8r			; 1.13092
	DD	03f913499r			; 1.13442
	DD	03f91a7c0r			; 1.13793
	DD	03f921b4er			; 1.14146
	DD	03f928f44r			; 1.145
	DD	03f9303a3r			; 1.14855
	DD	03f93786ar			; 1.15211
	DD	03f93ed9cr			; 1.15569
	DD	03f946338r			; 1.15928
	DD	03f94d93fr			; 1.16288
	DD	03f954fb3r			; 1.16649
	DD	03f95c693r			; 1.17012
	DD	03f963de0r			; 1.17376
	DD	03f96b59cr			; 1.17742
	DD	03f972dc6r			; 1.18108
	DD	03f97a660r			; 1.18476
	DD	03f981f6br			; 1.18846
	DD	03f9898e7r			; 1.19217
	DD	03f9912d5r			; 1.19589
	DD	03f998d35r			; 1.19962
	DD	03f9a0809r			; 1.20337
	DD	03f9a8352r			; 1.20713
	DD	03f9aff0fr			; 1.21091
	DD	03f9b7b42r			; 1.2147
	DD	03f9bf7ecr			; 1.2185
	DD	03f9c750er			; 1.22232
	DD	03f9cf2a8r			; 1.22616
	DD	03f9d70bbr			; 1.23
	DD	03f9def48r			; 1.23386
	DD	03f9e6e50r			; 1.23774
	DD	03f9eedd4r			; 1.24163
	DD	03f9f6dd4r			; 1.24554
	DD	03f9fee52r			; 1.24946
	DD	03fa06f4er			; 1.2534
	DD	03fa0f0car			; 1.25735
	DD	03fa172c5r			; 1.26131
	DD	03fa1f541r			; 1.2653
	DD	03fa27840r			; 1.26929
	DD	03fa2fbc1r			; 1.27331
	DD	03fa37fc6r			; 1.27734
	DD	03fa40450r			; 1.28138
	DD	03fa4895fr			; 1.28544
	DD	03fa50ef5r			; 1.28952
	DD	03fa59513r			; 1.29361
	DD	03fa61bb9r			; 1.29772
	DD	03fa6a2e8r			; 1.30185
	DD	03fa72aa2r			; 1.30599
	DD	03fa7b2e8r			; 1.31015
	DD	03fa83bbar			; 1.31432
	DD	03fa8c519r			; 1.31851
	DD	03fa94f08r			; 1.32272
	DD	03fa9d985r			; 1.32695
	DD	03faa6494r			; 1.33119
	DD	03faaf034r			; 1.33546
	DD	03fab7c66r			; 1.33973
	DD	03fac092dr			; 1.34403
	DD	03fac9689r			; 1.34834
	DD	03fad247ar			; 1.35268
	DD	03fadb303r			; 1.35703
	DD	03fae4224r			; 1.36139
	DD	03faed1der			; 1.36578
	DD	03faf6232r			; 1.37018
	DD	03faff323r			; 1.37461
	DD	03fb084b0r			; 1.37905
	DD	03fb116dbr			; 1.38351
	DD	03fb1a9a5r			; 1.38799
	DD	03fb23d10r			; 1.39249
	DD	03fb2d11cr			; 1.39701
	DD	03fb365cbr			; 1.40154
	DD	03fb3fb1er			; 1.4061
	DD	03fb49117r			; 1.41068
	DD	03fb527b6r			; 1.41527
	DD	03fb5befcr			; 1.41989
	DD	03fb656ecr			; 1.42453
	DD	03fb6ef86r			; 1.42918
	DD	03fb788ccr			; 1.43386
	DD	03fb822ber			; 1.43856
	DD	03fb8bd5fr			; 1.44328
	DD	03fb958b0r			; 1.44802
	DD	03fb9f4b2r			; 1.45278
	DD	03fba9166r			; 1.45756
	DD	03fbb2ecer			; 1.46237
	DD	03fbbccebr			; 1.46719
	DD	03fbc6bbfr			; 1.47204
	DD	03fbd0b4ar			; 1.47691
	DD	03fbdab90r			; 1.4818
	DD	03fbe4c90r			; 1.48671
	DD	03fbeee4dr			; 1.49165
	DD	03fbf90c7r			; 1.49661
	DD	03fc03401r			; 1.50159
	DD	03fc0d7fcr			; 1.50659
	DD	03fc17cb9r			; 1.51162
	DD	03fc2223br			; 1.51667
	DD	03fc2c882r			; 1.52174
	DD	03fc36f90r			; 1.52684
	DD	03fc41767r			; 1.53196
	DD	03fc4c009r			; 1.53711
	DD	03fc56976r			; 1.54228
	DD	03fc613b1r			; 1.54748
	DD	03fc6bebcr			; 1.5527
	DD	03fc76a98r			; 1.55794
	DD	03fc81746r			; 1.56321
	DD	03fc8c4c9r			; 1.56851
	DD	03fc97322r			; 1.57383
	DD	03fca2254r			; 1.57917
	DD	03fcad25fr			; 1.58455
	DD	03fcb8345r			; 1.58994
	DD	03fcc350ar			; 1.59537
	DD	03fcce7adr			; 1.60082
	DD	03fcd9b32r			; 1.6063
	DD	03fce4f99r			; 1.6118
	DD	03fcf04e6r			; 1.61734
	DD	03fcfbb19r			; 1.6229
	DD	03fd07236r			; 1.62849
	DD	03fd12a3dr			; 1.6341
	DD	03fd1e331r			; 1.63975
	DD	03fd29d13r			; 1.64542
	DD	03fd357e7r			; 1.65112
	DD	03fd413adr			; 1.65685
	DD	03fd4d069r			; 1.66261
	DD	03fd58e1br			; 1.6684
	DD	03fd64cc7r			; 1.67422
	DD	03fd70c6er			; 1.68007
	DD	03fd7cd12r			; 1.68595
	DD	03fd88eb6r			; 1.69186
	DD	03fd9515dr			; 1.6978
	DD	03fda1507r			; 1.70377
	DD	03fdad9b8r			; 1.70977
	DD	03fdb9f72r			; 1.7158
	DD	03fdc6637r			; 1.72187
	DD	03fdd2e09r			; 1.72797
	DD	03fddf6ecr			; 1.7341
	DD	03fdec0e0r			; 1.74026
	DD	03fdf8bear			; 1.74646
	DD	03fe0580br			; 1.75269
	DD	03fe12545r			; 1.75895
	DD	03fe1f39cr			; 1.76525
	DD	03fe2c312r			; 1.77158
	DD	03fe393a9r			; 1.77794
	DD	03fe46564r			; 1.78434
	DD	03fe53846r			; 1.79078
	DD	03fe60c51r			; 1.79725
	DD	03fe6e188r			; 1.80376
	DD	03fe7b7efr			; 1.8103
	DD	03fe88f87r			; 1.81688
	DD	03fe96853r			; 1.8235
	DD	03fea4257r			; 1.83015
	DD	03feb1d95r			; 1.83684
	DD	03febfa11r			; 1.84357
	DD	03fecd7ccr			; 1.85034
	DD	03fedb6cbr			; 1.85714
	DD	03fee9710r			; 1.86399
	DD	03fef789er			; 1.87087
	DD	03ff05b78r			; 1.87779
	DD	03ff13fa2r			; 1.88475
	DD	03ff2251fr			; 1.89176
	DD	03ff30bf2r			; 1.8988
	DD	03ff3f41dr			; 1.90589
	DD	03ff4dda6r			; 1.91301
	DD	03ff5c88er			; 1.92018
	DD	03ff6b4dar			; 1.92739
	DD	03ff7a28cr			; 1.93465
	DD	03ff891a9r			; 1.94195
	DD	03ff98234r			; 1.94929
	DD	03ffa7430r			; 1.95667
	DD	03ffb67a0r			; 1.9641
	DD	03ffc5c8ar			; 1.97157
	DD	03ffd52f0r			; 1.97909
	DD	03ffe4ad6r			; 1.98666
	DD	03fff4440r			; 1.99427
	DD	040001f99r			; 2.00193
	DD	040009dd8r			; 2.00963
	DD	040011cder			; 2.01739
	DD	040019cafr			; 2.02519
	DD	040021d4cr			; 2.03304
	DD	040029eb6r			; 2.04094
	DD	0400320f1r			; 2.04889
	DD	04003a3fer			; 2.05688
	DD	0400427dfr			; 2.06493
	DD	04004ac97r			; 2.07303
	DD	040053227r			; 2.08119
	DD	04005b893r			; 2.08939
	DD	040063fdcr			; 2.09765
	DD	04006c804r			; 2.10596
	DD	04007510fr			; 2.11432
	DD	04007dafdr			; 2.12274
	DD	0400865d3r			; 2.13121
	DD	04008f192r			; 2.13974
	DD	040097e3cr			; 2.14833
	DD	0400a0bd4r			; 2.15697
	DD	0400a9a5dr			; 2.16567
	DD	0400b29d9r			; 2.17443
	DD	0400bba4cr			; 2.18325
	DD	0400c4bb6r			; 2.19212
	DD	0400cde1cr			; 2.20106
	DD	0400d7180r			; 2.21005
	DD	0400e05e4r			; 2.21911
	DD	0400e9b4cr			; 2.22823
	DD	0400f31bbr			; 2.23741
	DD	0400fc932r			; 2.24665
	DD	0401061b6r			; 2.25596
	DD	04010fb49r			; 2.26534
	DD	0401195eer			; 2.27478
	DD	0401231a9r			; 2.28428
	DD	04012ce7cr			; 2.29385
	DD	040136c6ar			; 2.30349
	DD	040140b77r			; 2.3132
	DD	04014aba6r			; 2.32298
	DD	040154cfbr			; 2.33282
	DD	04015ef78r			; 2.34274
	DD	040169321r			; 2.35273
	DD	0401737f9r			; 2.36279
	DD	04017de05r			; 2.37293
	DD	040188547r			; 2.38313
	DD	040192dc3r			; 2.39342
	DD	04019d77er			; 2.40378
	DD	0401a827ar			; 2.41421
	DD	0401b2ebbr			; 2.42473
	DD	0401bdc46r			; 2.43532
	DD	0401c8b1dr			; 2.44599
	DD	0401d3b46r			; 2.45674
	DD	0401decc4r			; 2.46758
	DD	0401e9f9cr			; 2.47849
	DD	0401f53d1r			; 2.48949
	DD	040200967r			; 2.50057
	DD	04020c064r			; 2.51174
	DD	0402178cbr			; 2.523
	DD	0402232a0r			; 2.53434
	DD	04022ede9r			; 2.54577
	DD	04023aaaar			; 2.55729
	DD	0402468e8r			; 2.5689
	DD	0402528a7r			; 2.58061
	DD	04025e9ecr			; 2.5924
	DD	04026acbcr			; 2.60429
	DD	04027711dr			; 2.61628
	DD	040283712r			; 2.62836
	DD	04028fea2r			; 2.64054
	DD	04029c7d1r			; 2.65282
	DD	0402a92a6r			; 2.6652
	DD	0402b5f24r			; 2.67768
	DD	0402c2d52r			; 2.69027
	DD	0402cfd36r			; 2.70295
	DD	0402dced5r			; 2.71575
	DD	0402ea235r			; 2.72865
	DD	0402f775cr			; 2.74166
	DD	040304e50r			; 2.75478
	DD	040312717r			; 2.76801
	DD	0403201b7r			; 2.78135
	DD	04032de36r			; 2.79481
	DD	04033bc9cr			; 2.80839
	DD	040349cefr			; 2.82208
	DD	040357f34r			; 2.83589
	DD	040366375r			; 2.84982
	DD	0403749b6r			; 2.86387
	DD	0403831ffr			; 2.87805
	DD	040391c58r			; 2.89235
	DD	0403a08c7r			; 2.90679
	DD	0403af755r			; 2.92135
	DD	0403be808r			; 2.93604
	DD	0403cdae9r			; 2.95086
	DD	0403dd000r			; 2.96582
	DD	0403ec754r			; 2.98092
	DD	0403fc0edr			; 2.99615
	DD	04040bcd5r			; 3.01153
	DD	04041bb13r			; 3.02704
	DD	04042bbb1r			; 3.04271
	DD	04043beb7r			; 3.05852
	DD	04044c42er			; 3.07447
	DD	04045cc1fr			; 3.09058
	DD	04046d694r			; 3.10685
	DD	04047e396r			; 3.12327
	DD	04048f32fr			; 3.13984
	DD	0404a056ar			; 3.15658
	DD	0404b1a4fr			; 3.17348
	DD	0404c31ear			; 3.19055
	DD	0404d4c45r			; 3.20778
	DD	0404e696br			; 3.22518
	DD	0404f8967r			; 3.24276
	DD	04050ac44r			; 3.26051
	DD	04051d20dr			; 3.27845
	DD	04052facfr			; 3.29656
	DD	040542695r			; 3.31485
	DD	04055556cr			; 3.33334
	DD	04056875fr			; 3.35201
	DD	04057bc7cr			; 3.37088
	DD	04058f4d0r			; 3.38994
	DD	0405a3068r			; 3.4092
	DD	0405b6f51r			; 3.42867
	DD	0405cb199r			; 3.44834
	DD	0405df74fr			; 3.46822
	DD	0405f4081r			; 3.48831
	DD	040608d3er			; 3.50862
	DD	04061dd94r			; 3.52915
	DD	040633194r			; 3.5499
	DD	04064894dr			; 3.57088
	DD	04065e4cfr			; 3.59209
	DD	04067442br			; 3.61354
	DD	04068a772r			; 3.63522
	DD	0406a0eb5r			; 3.65715
	DD	0406b7a05r			; 3.67932
	DD	0406ce976r			; 3.70175
	DD	0406e5d19r			; 3.72443
	DD	0406fd501r			; 3.74738
	DD	040715142r			; 3.77058
	DD	04072d1efr			; 3.79406
	DD	04074571er			; 3.81782
	DD	04075e0e2r			; 3.84185
	DD	040776f52r			; 3.86617
	DD	040790282r			; 3.89078
	DD	0407a9a8br			; 3.91568
	DD	0407c3781r			; 3.94089
	DD	0407dd97er			; 3.9664
	DD	0407f8098r			; 3.99222
	DD	040809675r			; 4.01837
	DD	040816f46r			; 4.04483
	DD	040824acbr			; 4.07163
	DD	040832914r			; 4.09876
	DD	040840a2cr			; 4.12624
	DD	04084ee23r			; 4.15407
	DD	04085d506r			; 4.18225
	DD	04086bee4r			; 4.2108
	DD	04087abcdr			; 4.23972
	DD	040889bd0r			; 4.26902
	DD	040898efcr			; 4.2987
	DD	0408a8564r			; 4.32878
	DD	0408b7f16r			; 4.35926
	DD	0408c7c26r			; 4.39015
	DD	0408d7ca3r			; 4.42146
	DD	0408e80a2r			; 4.4532
	DD	0408f8834r			; 4.48538
	DD	04090936dr			; 4.518
	DD	04091a261r			; 4.55107
	DD	04092b524r			; 4.58461
	DD	04093cbccr			; 4.61863
	DD	04094e66er			; 4.65313
	DD	04096051fr			; 4.68813
	DD	0409727f9r			; 4.72363
	DD	040984f11r			; 4.75965
	DD	040997a80r			; 4.7962
	DD	0409aaa60r			; 4.8333
	DD	0409bdecar			; 4.87095
	DD	0409d17d8r			; 4.90916
	DD	0409e55a7r			; 4.94796
	DD	0409f9852r			; 4.98734
	DD	040a0dff7r			; 5.02734
	DD	040a22cb4r			; 5.06796
	DD	040a37ea7r			; 5.10921
	DD	040a4d5f1r			; 5.15112
	DD	040a632b4r			; 5.19369
	DD	040a79510r			; 5.23695
	DD	040a8fd29r			; 5.2809
	DD	040aa6b25r			; 5.32558
	DD	040abdf27r			; 5.37099
	DD	040ad5958r			; 5.41716
	DD	040aed9e0r			; 5.4641
	DD	040b060e8r			; 5.51183
	DD	040b1ee9br			; 5.56038
	DD	040b38325r			; 5.60976
	DD	040b51eb6r			; 5.66
	DD	040b6c17cr			; 5.71112
	DD	040b86ba9r			; 5.76314
	DD	040ba1d70r			; 5.81609
	DD	040bbd707r			; 5.87
	DD	040bd98a4r			; 5.92488
	DD	040bf6280r			; 5.98077
	DD	040c134d7r			; 6.0377
	DD	040c30fe6r			; 6.09569
	DD	040c4f3edr			; 6.15478
	DD	040c6e12er			; 6.21499
	DD	040c8d7eer			; 6.27636
	DD	040cad874r			; 6.33892
	DD	040cce30br			; 6.40272
	DD	040cef800r			; 6.46777
	DD	040d117a3r			; 6.53414
	DD	040d34249r			; 6.60184
	DD	040d57848r			; 6.67093
	DD	040d7b9far			; 6.74145
	DD	040da07c0r			; 6.81345
	DD	040dc61fbr			; 6.88696
	DD	040dec912r			; 6.96204
	DD	040e13d71r			; 7.03875
	DD	040e3bf88r			; 7.11713
	DD	040e64fcbr			; 7.19724
	DD	040e8eeb5r			; 7.27914
	DD	040eb9cc7r			; 7.36289
	DD	040ee5a85r			; 7.44855
	DD	040f1287br			; 7.53619
	DD	040f4073dr			; 7.62588
	DD	040f6f764r			; 7.7177
	DD	040f9f991r			; 7.81171
	DD	040fd0e6cr			; 7.90801
	DD	041001b53r			; 8.00667
	DD	04101b97er			; 8.10779
	DD	041036216r			; 8.21145
	DD	041051585r			; 8.31775
	DD	04106d434r			; 8.42681
	DD	041089e96r			; 8.53872
	DD	0410a7524r			; 8.6536
	DD	0410c585ar			; 8.77157
	DD	0410e48bfr			; 8.89276
	DD	0411046dfr			; 9.0173
	DD	04112534er			; 9.14534
	DD	041146eaar			; 9.27702
	DD	041169998r			; 9.4125
	DD	04118d4c9r			; 9.55195
	DD	0411b20f6r			; 9.69555
	DD	0411d7ee7r			; 9.84348
	DD	0411fef6br			; 9.99595
	DD	041227363r			; 10.1532
	DD	041250bbbr			; 10.3154
	DD	04127b970r			; 10.4828
	DD	0412a7d8fr			; 10.6557
	DD	0412d5937r			; 10.8343
	DD	041304d99r			; 11.0189
	DD	041335bfer			; 11.21
	DD	0413685c4r			; 11.4077
	DD	04139cc63r			; 11.6124
	DD	0413d316cr			; 11.8246
	DD	04140b692r			; 12.0446
	DD	041445da5r			; 12.2729
	DD	04148289ar			; 12.5099
	DD	0414c198dr			; 12.7562
	DD	0415032c7r			; 13.0124
	DD	0415476ber			; 13.279
	DD	04158e81er			; 13.5567
	DD	0415d89cer			; 13.8461
	DD	041625ef3r			; 14.1482
	DD	041676afcr			; 14.4636
	DD	0416cb1a8r			; 14.7934
	DD	04172370dr			; 15.1384
	DD	04177ffa7r			; 15.4999
	DD	0417e105fr			; 15.879
	DD	041823750r			; 16.277
	DD	041859030r			; 16.6954
	DD	04189161ar			; 17.1358
	DD	0418cccb7r			; 17.6
	DD	04190b815r			; 18.0899
	DD	04194dcbar			; 18.6078
	DD	041993fb2r			; 19.1561
	DD	0419de6a9r			; 19.7376
	DD	041a2d7ffr			; 20.3555
	DD	041a81ae7r			; 21.0131
	DD	041adb787r			; 21.7146
	DD	041b3b729r			; 22.4644
	DD	041ba2468r			; 23.2678
	DD	041c10b71r			; 24.1306
	DD	041c87a53r			; 25.0597
	DD	041d0815br			; 26.0632
	DD	041d9338dr			; 27.1502
	DD	041e2a73cr			; 28.3317
	DD	041ecf6ccr			; 29.6205
	DD	041f841a6r			; 31.0321
	DD	0420256bdr			; 32.5847
	DD	0420933f5r			; 34.3007
	DD	04210d45dr			; 36.2074
	DD	042195a68r			; 38.3383
	DD	04222f123r			; 40.7355
	DD	0422dcf18r			; 43.4522
	DD	0423a3a66r			; 46.557
	DD	042488ebfr			; 50.1394
	DD	042594667r			; 54.3188
	DD	0426d0814r			; 59.2579
	DD	042825e98r			; 65.1848
	DD	04290db6fr			; 72.4286
	DD	042a2f76br			; 81.4832
	DD	042ba3fe6r			; 93.1248
	DD	042d94b1dr			; 108.647
	DD	04302608er			; 130.377
	DD	04322f8fdr			; 162.973
	DD	043594c4br			; 217.298
	DD	043a2f962r			; 325.948
	DD	04422f97br			; 651.898
	DD	0599ab9c7r			; 5.44393e+15
	DD	0c422f97br			; -651.898
	DD	0c3a2f962r			; -325.948
	DD	0c3594c4br			; -217.298
	DD	0c322f8fdr			; -162.973
	DD	0c302608er			; -130.377
	DD	0c2d94b1dr			; -108.647
	DD	0c2ba3fe6r			; -93.1248
	DD	0c2a2f76br			; -81.4832
	DD	0c290db6fr			; -72.4286
	DD	0c2825e98r			; -65.1848
	DD	0c26d0814r			; -59.2579
	DD	0c2594667r			; -54.3188
	DD	0c2488ebfr			; -50.1394
	DD	0c23a3a66r			; -46.557
	DD	0c22dcf18r			; -43.4522
	DD	0c222f123r			; -40.7355
	DD	0c2195a68r			; -38.3383
	DD	0c210d45dr			; -36.2074
	DD	0c20933f5r			; -34.3007
	DD	0c20256bdr			; -32.5847
	DD	0c1f841a6r			; -31.0321
	DD	0c1ecf6ccr			; -29.6205
	DD	0c1e2a73cr			; -28.3317
	DD	0c1d9338dr			; -27.1502
	DD	0c1d0815br			; -26.0632
	DD	0c1c87a53r			; -25.0597
	DD	0c1c10b71r			; -24.1306
	DD	0c1ba2468r			; -23.2678
	DD	0c1b3b729r			; -22.4644
	DD	0c1adb787r			; -21.7146
	DD	0c1a81ae7r			; -21.0131
	DD	0c1a2d7ffr			; -20.3555
	DD	0c19de6a9r			; -19.7376
	DD	0c1993fb2r			; -19.1561
	DD	0c194dcbar			; -18.6078
	DD	0c190b815r			; -18.0899
	DD	0c18cccb7r			; -17.6
	DD	0c189161ar			; -17.1358
	DD	0c1859030r			; -16.6954
	DD	0c1823750r			; -16.277
	DD	0c17e105fr			; -15.879
	DD	0c177ffa7r			; -15.4999
	DD	0c172370dr			; -15.1384
	DD	0c16cb1a8r			; -14.7934
	DD	0c1676afcr			; -14.4636
	DD	0c1625ef3r			; -14.1482
	DD	0c15d89cer			; -13.8461
	DD	0c158e81er			; -13.5567
	DD	0c15476ber			; -13.279
	DD	0c15032c7r			; -13.0124
	DD	0c14c198dr			; -12.7562
	DD	0c148289ar			; -12.5099
	DD	0c1445da5r			; -12.2729
	DD	0c140b692r			; -12.0446
	DD	0c13d316cr			; -11.8246
	DD	0c139cc63r			; -11.6124
	DD	0c13685c4r			; -11.4077
	DD	0c1335bfer			; -11.21
	DD	0c1304d99r			; -11.0189
	DD	0c12d5937r			; -10.8343
	DD	0c12a7d8fr			; -10.6557
	DD	0c127b970r			; -10.4828
	DD	0c1250bbbr			; -10.3154
	DD	0c1227363r			; -10.1532
	DD	0c11fef6br			; -9.99595
	DD	0c11d7ee7r			; -9.84348
	DD	0c11b20f6r			; -9.69555
	DD	0c118d4c9r			; -9.55195
	DD	0c1169998r			; -9.4125
	DD	0c1146eaar			; -9.27702
	DD	0c112534er			; -9.14534
	DD	0c11046dfr			; -9.0173
	DD	0c10e48bfr			; -8.89276
	DD	0c10c585ar			; -8.77157
	DD	0c10a7524r			; -8.6536
	DD	0c1089e96r			; -8.53872
	DD	0c106d434r			; -8.42681
	DD	0c1051585r			; -8.31775
	DD	0c1036216r			; -8.21145
	DD	0c101b97er			; -8.10779
	DD	0c1001b53r			; -8.00667
	DD	0c0fd0e6cr			; -7.90801
	DD	0c0f9f991r			; -7.81171
	DD	0c0f6f764r			; -7.7177
	DD	0c0f4073dr			; -7.62588
	DD	0c0f1287br			; -7.53619
	DD	0c0ee5a85r			; -7.44855
	DD	0c0eb9cc7r			; -7.36289
	DD	0c0e8eeb5r			; -7.27914
	DD	0c0e64fcbr			; -7.19724
	DD	0c0e3bf88r			; -7.11713
	DD	0c0e13d71r			; -7.03875
	DD	0c0dec912r			; -6.96204
	DD	0c0dc61fbr			; -6.88696
	DD	0c0da07c0r			; -6.81345
	DD	0c0d7b9far			; -6.74145
	DD	0c0d57848r			; -6.67093
	DD	0c0d34249r			; -6.60184
	DD	0c0d117a3r			; -6.53414
	DD	0c0cef800r			; -6.46777
	DD	0c0cce30br			; -6.40272
	DD	0c0cad874r			; -6.33892
	DD	0c0c8d7eer			; -6.27636
	DD	0c0c6e12er			; -6.21499
	DD	0c0c4f3edr			; -6.15478
	DD	0c0c30fe6r			; -6.09569
	DD	0c0c134d7r			; -6.0377
	DD	0c0bf6280r			; -5.98077
	DD	0c0bd98a4r			; -5.92488
	DD	0c0bbd707r			; -5.87
	DD	0c0ba1d70r			; -5.81609
	DD	0c0b86ba9r			; -5.76314
	DD	0c0b6c17cr			; -5.71112
	DD	0c0b51eb6r			; -5.66
	DD	0c0b38325r			; -5.60976
	DD	0c0b1ee9br			; -5.56038
	DD	0c0b060e8r			; -5.51183
	DD	0c0aed9e0r			; -5.4641
	DD	0c0ad5958r			; -5.41716
	DD	0c0abdf27r			; -5.37099
	DD	0c0aa6b25r			; -5.32558
	DD	0c0a8fd29r			; -5.2809
	DD	0c0a79510r			; -5.23695
	DD	0c0a632b4r			; -5.19369
	DD	0c0a4d5f1r			; -5.15112
	DD	0c0a37ea7r			; -5.10921
	DD	0c0a22cb4r			; -5.06796
	DD	0c0a0dff7r			; -5.02734
	DD	0c09f9852r			; -4.98734
	DD	0c09e55a7r			; -4.94796
	DD	0c09d17d8r			; -4.90916
	DD	0c09bdecar			; -4.87095
	DD	0c09aaa60r			; -4.8333
	DD	0c0997a80r			; -4.7962
	DD	0c0984f11r			; -4.75965
	DD	0c09727f9r			; -4.72363
	DD	0c096051fr			; -4.68813
	DD	0c094e66er			; -4.65313
	DD	0c093cbccr			; -4.61863
	DD	0c092b524r			; -4.58461
	DD	0c091a261r			; -4.55107
	DD	0c090936dr			; -4.518
	DD	0c08f8834r			; -4.48538
	DD	0c08e80a2r			; -4.4532
	DD	0c08d7ca3r			; -4.42146
	DD	0c08c7c26r			; -4.39015
	DD	0c08b7f16r			; -4.35926
	DD	0c08a8564r			; -4.32878
	DD	0c0898efcr			; -4.2987
	DD	0c0889bd0r			; -4.26902
	DD	0c087abcdr			; -4.23972
	DD	0c086bee4r			; -4.2108
	DD	0c085d506r			; -4.18225
	DD	0c084ee23r			; -4.15407
	DD	0c0840a2cr			; -4.12624
	DD	0c0832914r			; -4.09876
	DD	0c0824acbr			; -4.07163
	DD	0c0816f46r			; -4.04483
	DD	0c0809675r			; -4.01837
	DD	0c07f8098r			; -3.99222
	DD	0c07dd97er			; -3.9664
	DD	0c07c3781r			; -3.94089
	DD	0c07a9a8br			; -3.91568
	DD	0c0790282r			; -3.89078
	DD	0c0776f52r			; -3.86617
	DD	0c075e0e2r			; -3.84185
	DD	0c074571er			; -3.81782
	DD	0c072d1efr			; -3.79406
	DD	0c0715142r			; -3.77058
	DD	0c06fd501r			; -3.74738
	DD	0c06e5d19r			; -3.72443
	DD	0c06ce976r			; -3.70175
	DD	0c06b7a05r			; -3.67932
	DD	0c06a0eb5r			; -3.65715
	DD	0c068a772r			; -3.63522
	DD	0c067442br			; -3.61354
	DD	0c065e4cfr			; -3.59209
	DD	0c064894dr			; -3.57088
	DD	0c0633194r			; -3.5499
	DD	0c061dd94r			; -3.52915
	DD	0c0608d3er			; -3.50862
	DD	0c05f4081r			; -3.48831
	DD	0c05df74fr			; -3.46822
	DD	0c05cb199r			; -3.44834
	DD	0c05b6f51r			; -3.42867
	DD	0c05a3068r			; -3.4092
	DD	0c058f4d0r			; -3.38994
	DD	0c057bc7cr			; -3.37088
	DD	0c056875fr			; -3.35201
	DD	0c055556cr			; -3.33334
	DD	0c0542695r			; -3.31485
	DD	0c052facfr			; -3.29656
	DD	0c051d20dr			; -3.27845
	DD	0c050ac44r			; -3.26051
	DD	0c04f8967r			; -3.24276
	DD	0c04e696br			; -3.22518
	DD	0c04d4c45r			; -3.20778
	DD	0c04c31ear			; -3.19055
	DD	0c04b1a4fr			; -3.17348
	DD	0c04a056ar			; -3.15658
	DD	0c048f32fr			; -3.13984
	DD	0c047e396r			; -3.12327
	DD	0c046d694r			; -3.10685
	DD	0c045cc1fr			; -3.09058
	DD	0c044c42er			; -3.07447
	DD	0c043beb7r			; -3.05852
	DD	0c042bbb1r			; -3.04271
	DD	0c041bb13r			; -3.02704
	DD	0c040bcd5r			; -3.01153
	DD	0c03fc0edr			; -2.99615
	DD	0c03ec754r			; -2.98092
	DD	0c03dd000r			; -2.96582
	DD	0c03cdae9r			; -2.95086
	DD	0c03be808r			; -2.93604
	DD	0c03af755r			; -2.92135
	DD	0c03a08c7r			; -2.90679
	DD	0c0391c58r			; -2.89235
	DD	0c03831ffr			; -2.87805
	DD	0c03749b6r			; -2.86387
	DD	0c0366375r			; -2.84982
	DD	0c0357f34r			; -2.83589
	DD	0c0349cefr			; -2.82208
	DD	0c033bc9cr			; -2.80839
	DD	0c032de36r			; -2.79481
	DD	0c03201b7r			; -2.78135
	DD	0c0312717r			; -2.76801
	DD	0c0304e50r			; -2.75478
	DD	0c02f775cr			; -2.74166
	DD	0c02ea235r			; -2.72865
	DD	0c02dced5r			; -2.71575
	DD	0c02cfd36r			; -2.70295
	DD	0c02c2d52r			; -2.69027
	DD	0c02b5f24r			; -2.67768
	DD	0c02a92a6r			; -2.6652
	DD	0c029c7d1r			; -2.65282
	DD	0c028fea2r			; -2.64054
	DD	0c0283712r			; -2.62836
	DD	0c027711dr			; -2.61628
	DD	0c026acbcr			; -2.60429
	DD	0c025e9ecr			; -2.5924
	DD	0c02528a7r			; -2.58061
	DD	0c02468e8r			; -2.5689
	DD	0c023aaaar			; -2.55729
	DD	0c022ede9r			; -2.54577
	DD	0c02232a0r			; -2.53434
	DD	0c02178cbr			; -2.523
	DD	0c020c064r			; -2.51174
	DD	0c0200967r			; -2.50057
	DD	0c01f53d1r			; -2.48949
	DD	0c01e9f9cr			; -2.47849
	DD	0c01decc4r			; -2.46758
	DD	0c01d3b46r			; -2.45674
	DD	0c01c8b1dr			; -2.44599
	DD	0c01bdc46r			; -2.43532
	DD	0c01b2ebbr			; -2.42473
	DD	0c01a827ar			; -2.41421
	DD	0c019d77er			; -2.40378
	DD	0c0192dc3r			; -2.39342
	DD	0c0188547r			; -2.38313
	DD	0c017de05r			; -2.37293
	DD	0c01737f9r			; -2.36279
	DD	0c0169321r			; -2.35273
	DD	0c015ef78r			; -2.34274
	DD	0c0154cfbr			; -2.33282
	DD	0c014aba6r			; -2.32298
	DD	0c0140b77r			; -2.3132
	DD	0c0136c6ar			; -2.30349
	DD	0c012ce7cr			; -2.29385
	DD	0c01231a9r			; -2.28428
	DD	0c01195eer			; -2.27478
	DD	0c010fb49r			; -2.26534
	DD	0c01061b6r			; -2.25596
	DD	0c00fc932r			; -2.24665
	DD	0c00f31bbr			; -2.23741
	DD	0c00e9b4cr			; -2.22823
	DD	0c00e05e4r			; -2.21911
	DD	0c00d7180r			; -2.21005
	DD	0c00cde1cr			; -2.20106
	DD	0c00c4bb6r			; -2.19212
	DD	0c00bba4cr			; -2.18325
	DD	0c00b29d9r			; -2.17443
	DD	0c00a9a5dr			; -2.16567
	DD	0c00a0bd4r			; -2.15697
	DD	0c0097e3cr			; -2.14833
	DD	0c008f192r			; -2.13974
	DD	0c00865d3r			; -2.13121
	DD	0c007dafdr			; -2.12274
	DD	0c007510fr			; -2.11432
	DD	0c006c804r			; -2.10596
	DD	0c0063fdcr			; -2.09765
	DD	0c005b893r			; -2.08939
	DD	0c0053227r			; -2.08119
	DD	0c004ac97r			; -2.07303
	DD	0c00427dfr			; -2.06493
	DD	0c003a3fer			; -2.05688
	DD	0c00320f1r			; -2.04889
	DD	0c0029eb6r			; -2.04094
	DD	0c0021d4cr			; -2.03304
	DD	0c0019cafr			; -2.02519
	DD	0c0011cder			; -2.01739
	DD	0c0009dd8r			; -2.00963
	DD	0c0001f99r			; -2.00193
	DD	0bfff4440r			; -1.99427
	DD	0bffe4ad6r			; -1.98666
	DD	0bffd52f0r			; -1.97909
	DD	0bffc5c8ar			; -1.97157
	DD	0bffb67a0r			; -1.9641
	DD	0bffa7430r			; -1.95667
	DD	0bff98234r			; -1.94929
	DD	0bff891a9r			; -1.94195
	DD	0bff7a28cr			; -1.93465
	DD	0bff6b4dar			; -1.92739
	DD	0bff5c88er			; -1.92018
	DD	0bff4dda6r			; -1.91301
	DD	0bff3f41dr			; -1.90589
	DD	0bff30bf2r			; -1.8988
	DD	0bff2251fr			; -1.89176
	DD	0bff13fa2r			; -1.88475
	DD	0bff05b78r			; -1.87779
	DD	0bfef789er			; -1.87087
	DD	0bfee9710r			; -1.86399
	DD	0bfedb6cbr			; -1.85714
	DD	0bfecd7ccr			; -1.85034
	DD	0bfebfa11r			; -1.84357
	DD	0bfeb1d95r			; -1.83684
	DD	0bfea4257r			; -1.83015
	DD	0bfe96853r			; -1.8235
	DD	0bfe88f87r			; -1.81688
	DD	0bfe7b7efr			; -1.8103
	DD	0bfe6e188r			; -1.80376
	DD	0bfe60c51r			; -1.79725
	DD	0bfe53846r			; -1.79078
	DD	0bfe46564r			; -1.78434
	DD	0bfe393a9r			; -1.77794
	DD	0bfe2c312r			; -1.77158
	DD	0bfe1f39cr			; -1.76525
	DD	0bfe12545r			; -1.75895
	DD	0bfe0580br			; -1.75269
	DD	0bfdf8bear			; -1.74646
	DD	0bfdec0e0r			; -1.74026
	DD	0bfddf6ecr			; -1.7341
	DD	0bfdd2e09r			; -1.72797
	DD	0bfdc6637r			; -1.72187
	DD	0bfdb9f72r			; -1.7158
	DD	0bfdad9b8r			; -1.70977
	DD	0bfda1507r			; -1.70377
	DD	0bfd9515dr			; -1.6978
	DD	0bfd88eb6r			; -1.69186
	DD	0bfd7cd12r			; -1.68595
	DD	0bfd70c6er			; -1.68007
	DD	0bfd64cc7r			; -1.67422
	DD	0bfd58e1br			; -1.6684
	DD	0bfd4d069r			; -1.66261
	DD	0bfd413adr			; -1.65685
	DD	0bfd357e7r			; -1.65112
	DD	0bfd29d13r			; -1.64542
	DD	0bfd1e331r			; -1.63975
	DD	0bfd12a3dr			; -1.6341
	DD	0bfd07236r			; -1.62849
	DD	0bfcfbb19r			; -1.6229
	DD	0bfcf04e6r			; -1.61734
	DD	0bfce4f99r			; -1.6118
	DD	0bfcd9b32r			; -1.6063
	DD	0bfcce7adr			; -1.60082
	DD	0bfcc350ar			; -1.59537
	DD	0bfcb8345r			; -1.58994
	DD	0bfcad25fr			; -1.58455
	DD	0bfca2254r			; -1.57917
	DD	0bfc97322r			; -1.57383
	DD	0bfc8c4c9r			; -1.56851
	DD	0bfc81746r			; -1.56321
	DD	0bfc76a98r			; -1.55794
	DD	0bfc6bebcr			; -1.5527
	DD	0bfc613b1r			; -1.54748
	DD	0bfc56976r			; -1.54228
	DD	0bfc4c009r			; -1.53711
	DD	0bfc41767r			; -1.53196
	DD	0bfc36f90r			; -1.52684
	DD	0bfc2c882r			; -1.52174
	DD	0bfc2223br			; -1.51667
	DD	0bfc17cb9r			; -1.51162
	DD	0bfc0d7fcr			; -1.50659
	DD	0bfc03401r			; -1.50159
	DD	0bfbf90c7r			; -1.49661
	DD	0bfbeee4dr			; -1.49165
	DD	0bfbe4c90r			; -1.48671
	DD	0bfbdab90r			; -1.4818
	DD	0bfbd0b4ar			; -1.47691
	DD	0bfbc6bbfr			; -1.47204
	DD	0bfbbccebr			; -1.46719
	DD	0bfbb2ecer			; -1.46237
	DD	0bfba9166r			; -1.45756
	DD	0bfb9f4b2r			; -1.45278
	DD	0bfb958b0r			; -1.44802
	DD	0bfb8bd5fr			; -1.44328
	DD	0bfb822ber			; -1.43856
	DD	0bfb788ccr			; -1.43386
	DD	0bfb6ef86r			; -1.42918
	DD	0bfb656ecr			; -1.42453
	DD	0bfb5befcr			; -1.41989
	DD	0bfb527b6r			; -1.41527
	DD	0bfb49117r			; -1.41068
	DD	0bfb3fb1er			; -1.4061
	DD	0bfb365cbr			; -1.40154
	DD	0bfb2d11cr			; -1.39701
	DD	0bfb23d10r			; -1.39249
	DD	0bfb1a9a5r			; -1.38799
	DD	0bfb116dbr			; -1.38351
	DD	0bfb084b0r			; -1.37905
	DD	0bfaff323r			; -1.37461
	DD	0bfaf6232r			; -1.37018
	DD	0bfaed1der			; -1.36578
	DD	0bfae4224r			; -1.36139
	DD	0bfadb303r			; -1.35703
	DD	0bfad247ar			; -1.35268
	DD	0bfac9689r			; -1.34834
	DD	0bfac092dr			; -1.34403
	DD	0bfab7c66r			; -1.33973
	DD	0bfaaf034r			; -1.33546
	DD	0bfaa6494r			; -1.33119
	DD	0bfa9d985r			; -1.32695
	DD	0bfa94f08r			; -1.32272
	DD	0bfa8c519r			; -1.31851
	DD	0bfa83bbar			; -1.31432
	DD	0bfa7b2e8r			; -1.31015
	DD	0bfa72aa2r			; -1.30599
	DD	0bfa6a2e8r			; -1.30185
	DD	0bfa61bb9r			; -1.29772
	DD	0bfa59513r			; -1.29361
	DD	0bfa50ef5r			; -1.28952
	DD	0bfa4895fr			; -1.28544
	DD	0bfa40450r			; -1.28138
	DD	0bfa37fc6r			; -1.27734
	DD	0bfa2fbc1r			; -1.27331
	DD	0bfa27840r			; -1.26929
	DD	0bfa1f541r			; -1.2653
	DD	0bfa172c5r			; -1.26131
	DD	0bfa0f0car			; -1.25735
	DD	0bfa06f4er			; -1.2534
	DD	0bf9fee52r			; -1.24946
	DD	0bf9f6dd4r			; -1.24554
	DD	0bf9eedd4r			; -1.24163
	DD	0bf9e6e50r			; -1.23774
	DD	0bf9def48r			; -1.23386
	DD	0bf9d70bbr			; -1.23
	DD	0bf9cf2a8r			; -1.22616
	DD	0bf9c750er			; -1.22232
	DD	0bf9bf7ecr			; -1.2185
	DD	0bf9b7b42r			; -1.2147
	DD	0bf9aff0fr			; -1.21091
	DD	0bf9a8352r			; -1.20713
	DD	0bf9a0809r			; -1.20337
	DD	0bf998d35r			; -1.19962
	DD	0bf9912d5r			; -1.19589
	DD	0bf9898e7r			; -1.19217
	DD	0bf981f6br			; -1.18846
	DD	0bf97a660r			; -1.18476
	DD	0bf972dc6r			; -1.18108
	DD	0bf96b59cr			; -1.17742
	DD	0bf963de0r			; -1.17376
	DD	0bf95c693r			; -1.17012
	DD	0bf954fb3r			; -1.16649
	DD	0bf94d93fr			; -1.16288
	DD	0bf946338r			; -1.15928
	DD	0bf93ed9cr			; -1.15569
	DD	0bf93786ar			; -1.15211
	DD	0bf9303a3r			; -1.14855
	DD	0bf928f44r			; -1.145
	DD	0bf921b4er			; -1.14146
	DD	0bf91a7c0r			; -1.13793
	DD	0bf913499r			; -1.13442
	DD	0bf90c1d8r			; -1.13092
	DD	0bf904f7dr			; -1.12743
	DD	0bf8fdd88r			; -1.12395
	DD	0bf8f6bf6r			; -1.12048
	DD	0bf8efac8r			; -1.11703
	DD	0bf8e89fer			; -1.11359
	DD	0bf8e1996r			; -1.11016
	DD	0bf8da990r			; -1.10674
	DD	0bf8d39ebr			; -1.10333
	DD	0bf8ccaa6r			; -1.09993
	DD	0bf8c5bc2r			; -1.09655
	DD	0bf8bed3dr			; -1.09318
	DD	0bf8b7f16r			; -1.08982
	DD	0bf8b114er			; -1.08647
	DD	0bf8aa3e3r			; -1.08313
	DD	0bf8a36d5r			; -1.0798
	DD	0bf89ca24r			; -1.07648
	DD	0bf895dcer			; -1.07318
	DD	0bf88f1d4r			; -1.06988
	DD	0bf888634r			; -1.0666
	DD	0bf881aeer			; -1.06332
	DD	0bf87b001r			; -1.06006
	DD	0bf87456dr			; -1.05681
	DD	0bf86db32r			; -1.05356
	DD	0bf86714fr			; -1.05033
	DD	0bf8607c2r			; -1.04711
	DD	0bf859e8cr			; -1.0439
	DD	0bf8535adr			; -1.0407
	DD	0bf84cd23r			; -1.03751
	DD	0bf8464eer			; -1.03433
	DD	0bf83fd0dr			; -1.03116
	DD	0bf839581r			; -1.028
	DD	0bf832e48r			; -1.02485
	DD	0bf82c762r			; -1.02171
	DD	0bf8260cer			; -1.01858
	DD	0bf81fa8dr			; -1.01546
	DD	0bf81949dr			; -1.01235
	DD	0bf812efdr			; -1.00925
	DD	0bf80c9aer			; -1.00615
	DD	0bf8064afr			; -1.00307
	DD	0bf800000r			; -1
	DD	0bf7f373fr			; -0.996937
	DD	0bf7e6f1br			; -0.993883
	DD	0bf7da793r			; -0.990838
	DD	0bf7ce0a6r			; -0.987803
	DD	0bf7c1a53r			; -0.984777
	DD	0bf7b5499r			; -0.98176
	DD	0bf7a8f77r			; -0.978752
	DD	0bf79caedr			; -0.975753
	DD	0bf7906f9r			; -0.972763
	DD	0bf78439br			; -0.969782
	DD	0bf7780d1r			; -0.966809
	DD	0bf76be9br			; -0.963846
	DD	0bf75fcf7r			; -0.960891
	DD	0bf753be6r			; -0.957945
	DD	0bf747b66r			; -0.955008
	DD	0bf73bb75r			; -0.952079
	DD	0bf72fc15r			; -0.949159
	DD	0bf723d42r			; -0.946247
	DD	0bf717efdr			; -0.943344
	DD	0bf70c145r			; -0.940449
	DD	0bf700419r			; -0.937563
	DD	0bf6f4778r			; -0.934684
	DD	0bf6e8b62r			; -0.931814
	DD	0bf6dcfd4r			; -0.928952
	DD	0bf6d14d0r			; -0.926099
	DD	0bf6c5a53r			; -0.923253
	DD	0bf6ba05dr			; -0.920416
	DD	0bf6ae6eer			; -0.917586
	DD	0bf6a2e04r			; -0.914765
	DD	0bf69759er			; -0.911951
	DD	0bf68bdbdr			; -0.909145
	DD	0bf68065er			; -0.906347
	DD	0bf674f82r			; -0.903557
	DD	0bf669928r			; -0.900774
	DD	0bf65e34er			; -0.898
	DD	0bf652df5r			; -0.895232
	DD	0bf64791ar			; -0.892473
	DD	0bf63c4bfr			; -0.889721
	DD	0bf6310e1r			; -0.886976
	DD	0bf625d80r			; -0.884239
	DD	0bf61aa9cr			; -0.88151
	DD	0bf60f834r			; -0.878787
	DD	0bf604646r			; -0.876072
	DD	0bf5f94d3r			; -0.873365
	DD	0bf5ee3d9r			; -0.870664
	DD	0bf5e3358r			; -0.867971
	DD	0bf5d834fr			; -0.865285
	DD	0bf5cd3ber			; -0.862606
	DD	0bf5c24a4r			; -0.859934
	DD	0bf5b75ffr			; -0.857269
	DD	0bf5ac7d0r			; -0.854611
	DD	0bf5a1a16r			; -0.851961
	DD	0bf596cd0r			; -0.849317
	DD	0bf58bffdr			; -0.84668
	DD	0bf58139er			; -0.844049
	DD	0bf5767b0r			; -0.841426
	DD	0bf56bc34r			; -0.838809
	DD	0bf561128r			; -0.836199
	DD	0bf55668dr			; -0.833596
	DD	0bf54bc61r			; -0.830999
	DD	0bf5412a4r			; -0.828409
	DD	0bf536956r			; -0.825826
	DD	0bf52c075r			; -0.823249
	DD	0bf521801r			; -0.820679
	DD	0bf516ffar			; -0.818115
	DD	0bf50c85fr			; -0.815557
	DD	0bf50212er			; -0.813006
	DD	0bf4f7a69r			; -0.810462
	DD	0bf4ed40dr			; -0.807923
	DD	0bf4e2e1br			; -0.805391
	DD	0bf4d8892r			; -0.802865
	DD	0bf4ce370r			; -0.800345
	DD	0bf4c3eb7r			; -0.797832
	DD	0bf4b9a65r			; -0.795325
	DD	0bf4af679r			; -0.792823
	DD	0bf4a52f3r			; -0.790328
	DD	0bf49afd3r			; -0.787839
	DD	0bf490d17r			; -0.785356
	DD	0bf486ac0r			; -0.782879
	DD	0bf47c8ccr			; -0.780408
	DD	0bf47273br			; -0.777942
	DD	0bf46860dr			; -0.775483
	DD	0bf45e541r			; -0.773029
	DD	0bf4544d7r			; -0.770582
	DD	0bf44a4cer			; -0.76814
	DD	0bf440525r			; -0.765703
	DD	0bf4365dcr			; -0.763273
	DD	0bf42c6f2r			; -0.760848
	DD	0bf422867r			; -0.758429
	DD	0bf418a3ar			; -0.756015
	DD	0bf40ec6cr			; -0.753608
	DD	0bf404efar			; -0.751205
	DD	0bf3fb1e6r			; -0.748808
	DD	0bf3f152dr			; -0.746417
	DD	0bf3e78d1r			; -0.744031
	DD	0bf3ddccfr			; -0.741651
	DD	0bf3d4129r			; -0.739276
	DD	0bf3ca5ddr			; -0.736906
	DD	0bf3c0aear			; -0.734542
	DD	0bf3b7051r			; -0.732183
	DD	0bf3ad610r			; -0.729829
	DD	0bf3a3c28r			; -0.72748
	DD	0bf39a298r			; -0.725137
	DD	0bf39095fr			; -0.722799
	DD	0bf38707dr			; -0.720466
	DD	0bf37d7f2r			; -0.718139
	DD	0bf373fbcr			; -0.715816
	DD	0bf36a7dcr			; -0.713499
	DD	0bf361051r			; -0.711186
	DD	0bf35791ar			; -0.708879
	DD	0bf34e238r			; -0.706577
	DD	0bf344ba9r			; -0.704279
	DD	0bf33b56dr			; -0.701987
	DD	0bf331f84r			; -0.6997
	DD	0bf3289edr			; -0.697417
	DD	0bf31f4a9r			; -0.695139
	DD	0bf315fb5r			; -0.692867
	DD	0bf30cb13r			; -0.690599
	DD	0bf3036c1r			; -0.688335
	DD	0bf2fa2bfr			; -0.686077
	DD	0bf2f0f0dr			; -0.683823
	DD	0bf2e7baar			; -0.681574
	DD	0bf2de896r			; -0.67933
	DD	0bf2d55d0r			; -0.677091
	DD	0bf2cc359r			; -0.674856
	DD	0bf2c312fr			; -0.672625
	DD	0bf2b9f52r			; -0.6704
	DD	0bf2b0dc1r			; -0.668179
	DD	0bf2a7c7dr			; -0.665962
	DD	0bf29eb85r			; -0.66375
	DD	0bf295ad9r			; -0.661542
	DD	0bf28ca77r			; -0.659339
	DD	0bf283a60r			; -0.657141
	DD	0bf27aa94r			; -0.654947
	DD	0bf271b11r			; -0.652757
	DD	0bf268bd8r			; -0.650571
	DD	0bf25fce8r			; -0.64839
	DD	0bf256e41r			; -0.646214
	DD	0bf24dfe2r			; -0.644041
	DD	0bf2451cbr			; -0.641873
	DD	0bf23c3fcr			; -0.639709
	DD	0bf233673r			; -0.63755
	DD	0bf22a932r			; -0.635394
	DD	0bf221c37r			; -0.633243
	DD	0bf218f82r			; -0.631096
	DD	0bf210313r			; -0.628953
	DD	0bf2076e9r			; -0.626814
	DD	0bf1feb03r			; -0.62468
	DD	0bf1f5f63r			; -0.622549
	DD	0bf1ed407r			; -0.620423
	DD	0bf1e48eer			; -0.6183
	DD	0bf1dbe19r			; -0.616182
	DD	0bf1d3387r			; -0.614067
	DD	0bf1ca938r			; -0.611957
	DD	0bf1c1f2cr			; -0.609851
	DD	0bf1b9561r			; -0.607748
	DD	0bf1b0bd8r			; -0.605649
	DD	0bf1a8291r			; -0.603555
	DD	0bf19f98ar			; -0.601464
	DD	0bf1970c4r			; -0.599377
	DD	0bf18e83fr			; -0.597294
	DD	0bf185ff9r			; -0.595214
	DD	0bf17d7f3r			; -0.593139
	DD	0bf17502dr			; -0.591067
	DD	0bf16c8a5r			; -0.588999
	DD	0bf16415cr			; -0.586935
	DD	0bf15ba52r			; -0.584874
	DD	0bf153385r			; -0.582817
	DD	0bf14acf6r			; -0.580764
	DD	0bf1426a4r			; -0.578715
	DD	0bf13a08fr			; -0.576669
	DD	0bf131ab7r			; -0.574626
	DD	0bf12951cr			; -0.572588
	DD	0bf120fbcr			; -0.570553
	DD	0bf118a98r			; -0.568521
	DD	0bf1105afr			; -0.566493
	DD	0bf108102r			; -0.564469
	DD	0bf0ffc8fr			; -0.562447
	DD	0bf0f7857r			; -0.56043
	DD	0bf0ef459r			; -0.558416
	DD	0bf0e7095r			; -0.556405
	DD	0bf0ded0ar			; -0.554398
	DD	0bf0d69b9r			; -0.552394
	DD	0bf0ce6a0r			; -0.550394
	DD	0bf0c63c0r			; -0.548397
	DD	0bf0be118r			; -0.546403
	DD	0bf0b5ea9r			; -0.544413
	DD	0bf0adc71r			; -0.542426
	DD	0bf0a5a70r			; -0.540442
	DD	0bf09d8a7r			; -0.538462
	DD	0bf095715r			; -0.536485
	DD	0bf08d5b9r			; -0.534511
	DD	0bf085493r			; -0.532541
	DD	0bf07d3a3r			; -0.530573
	DD	0bf0752e9r			; -0.528609
	DD	0bf06d265r			; -0.526648
	DD	0bf065215r			; -0.52469
	DD	0bf05d1fbr			; -0.522735
	DD	0bf055215r			; -0.520784
	DD	0bf04d263r			; -0.518835
	DD	0bf0452e5r			; -0.51689
	DD	0bf03d39br			; -0.514948
	DD	0bf035484r			; -0.513008
	DD	0bf02d5a1r			; -0.511072
	DD	0bf0256f0r			; -0.509139
	DD	0bf01d872r			; -0.507209
	DD	0bf015a26r			; -0.505282
	DD	0bf00dc0dr			; -0.503358
	DD	0bf005e25r			; -0.501437
	DD	0beffc0der			; -0.499518
	DD	0befec5d4r			; -0.497603
	DD	0befdcb2cr			; -0.495691
	DD	0befcd0e6r			; -0.493781
	DD	0befbd701r			; -0.491875
	DD	0befadd7cr			; -0.489971
	DD	0bef9e457r			; -0.48807
	DD	0bef8eb91r			; -0.486172
	DD	0bef7f32br			; -0.484277
	DD	0bef6fb23r			; -0.482385
	DD	0bef60378r			; -0.480495
	DD	0bef50c2cr			; -0.478608
	DD	0bef4153cr			; -0.476725
	DD	0bef31ea8r			; -0.474843
	DD	0bef22870r			; -0.472965
	DD	0bef13294r			; -0.471089
	DD	0bef03d13r			; -0.469216
	DD	0beef47ecr			; -0.467346
	DD	0beee531fr			; -0.465478
	DD	0beed5eabr			; -0.463613
	DD	0beec6a90r			; -0.461751
	DD	0beeb76cer			; -0.459891
	DD	0beea8364r			; -0.458034
	DD	0bee99051r			; -0.456179
	DD	0bee89d96r			; -0.454327
	DD	0bee7ab31r			; -0.452478
	DD	0bee6b922r			; -0.450631
	DD	0bee5c768r			; -0.448787
	DD	0bee4d604r			; -0.446945
	DD	0bee3e4f4r			; -0.445106
	DD	0bee2f439r			; -0.44327
	DD	0bee203d1r			; -0.441435
	DD	0bee113bdr			; -0.439604
	DD	0bee023fbr			; -0.437775
	DD	0bedf348cr			; -0.435948
	DD	0bede456fr			; -0.434123
	DD	0bedd56a3r			; -0.432302
	DD	0bedc6828r			; -0.430482
	DD	0bedb79fer			; -0.428665
	DD	0beda8c24r			; -0.42685
	DD	0bed99e9ar			; -0.425038
	DD	0bed8b15fr			; -0.423228
	DD	0bed7c473r			; -0.421421
	DD	0bed6d7d5r			; -0.419615
	DD	0bed5eb85r			; -0.417812
	DD	0bed4ff82r			; -0.416012
	DD	0bed413cdr			; -0.414214
	DD	0bed32864r			; -0.412418
	DD	0bed23d47r			; -0.410624
	DD	0bed15277r			; -0.408832
	DD	0bed067f1r			; -0.407043
	DD	0becf7db7r			; -0.405256
	DD	0bece93c7r			; -0.403471
	DD	0becdaa21r			; -0.401689
	DD	0beccc0c4r			; -0.399908
	DD	0becbd7b1r			; -0.39813
	DD	0becaeee7r			; -0.396354
	DD	0beca0666r			; -0.39458
	DD	0bec91e2cr			; -0.392808
	DD	0bec8363ar			; -0.391039
	DD	0bec74e8fr			; -0.389271
	DD	0bec6672ar			; -0.387506
	DD	0bec5800dr			; -0.385743
	DD	0bec49935r			; -0.383981
	DD	0bec3b2a3r			; -0.382222
	DD	0bec2cc56r			; -0.380465
	DD	0bec1e64dr			; -0.37871
	DD	0bec10089r			; -0.376957
	DD	0bec01b0ar			; -0.375206
	DD	0bebf35cdr			; -0.373457
	DD	0bebe50d4r			; -0.37171
	DD	0bebd6c1er			; -0.369965
	DD	0bebc87aar			; -0.368223
	DD	0bebba378r			; -0.366482
	DD	0bebabf88r			; -0.364743
	DD	0beb9dbd9r			; -0.363005
	DD	0beb8f86br			; -0.36127
	DD	0beb8153dr			; -0.359537
	DD	0beb73250r			; -0.357806
	DD	0beb64fa2r			; -0.356076
	DD	0beb56d34r			; -0.354349
	DD	0beb48b04r			; -0.352623
	DD	0beb3a913r			; -0.350899
	DD	0beb2c761r			; -0.349177
	DD	0beb1e5ecr			; -0.347457
	DD	0beb104b5r			; -0.345739
	DD	0beb023bbr			; -0.344023
	DD	0beaf42fer			; -0.342308
	DD	0beae627dr			; -0.340595
	DD	0bead8238r			; -0.338884
	DD	0beaca22fr			; -0.337175
	DD	0beabc261r			; -0.335467
	DD	0beaae2cer			; -0.333762
	DD	0beaa0375r			; -0.332058
	DD	0bea92457r			; -0.330355
	DD	0bea84573r			; -0.328655
	DD	0bea766c8r			; -0.326956
	DD	0bea68856r			; -0.325259
	DD	0bea5aa1dr			; -0.323563
	DD	0bea4cc1dr			; -0.32187
	DD	0bea3ee54r			; -0.320178
	DD	0bea310c4r			; -0.318487
	DD	0bea2336br			; -0.316799
	DD	0bea15648r			; -0.315111
	DD	0bea0795dr			; -0.313426
	DD	0be9f9ca8r			; -0.311742
	DD	0be9ec029r			; -0.31006
	DD	0be9de3dfr			; -0.308379
	DD	0be9d07cbr			; -0.3067
	DD	0be9c2becr			; -0.305023
	DD	0be9b5042r			; -0.303347
	DD	0be9a74ccr			; -0.301672
	DD	0be999989r			; -0.3
	DD	0be98be7br			; -0.298328
	DD	0be97e3a0r			; -0.296659
	DD	0be9708f7r			; -0.29499
	DD	0be962e82r			; -0.293324
	DD	0be95543er			; -0.291658
	DD	0be947a2dr			; -0.289995
	DD	0be93a04dr			; -0.288332
	DD	0be92c69fr			; -0.286672
	DD	0be91ed21r			; -0.285012
	DD	0be9113d5r			; -0.283354
	DD	0be903ab8r			; -0.281698
	DD	0be8f61ccr			; -0.280043
	DD	0be8e890fr			; -0.278389
	DD	0be8db082r			; -0.276737
	DD	0be8cd824r			; -0.275087
	DD	0be8bfff4r			; -0.273437
	DD	0be8b27f3r			; -0.271789
	DD	0be8a5020r			; -0.270143
	DD	0be89787br			; -0.268497
	DD	0be88a103r			; -0.266853
	DD	0be87c9b8r			; -0.265211
	DD	0be86f29ar			; -0.26357
	DD	0be861ba9r			; -0.26193
	DD	0be8544e4r			; -0.260291
	DD	0be846e4ar			; -0.258654
	DD	0be8397ddr			; -0.257018
	DD	0be82c19ar			; -0.255383
	DD	0be81eb83r			; -0.25375
	DD	0be811596r			; -0.252118
	DD	0be803fd4r			; -0.250487
	DD	0be7ed477r			; -0.248857
	DD	0be7d2999r			; -0.247229
	DD	0be7b7f0fr			; -0.245602
	DD	0be79d4d6r			; -0.243976
	DD	0be782af0r			; -0.242351
	DD	0be76815ar			; -0.240728
	DD	0be74d815r			; -0.239106
	DD	0be732f20r			; -0.237484
	DD	0be718679r			; -0.235865
	DD	0be6fde22r			; -0.234246
	DD	0be6e3619r			; -0.232628
	DD	0be6c8e5dr			; -0.231012
	DD	0be6ae6edr			; -0.229397
	DD	0be693fcbr			; -0.227782
	DD	0be6798f3r			; -0.226169
	DD	0be65f267r			; -0.224558
	DD	0be644c26r			; -0.222947
	DD	0be62a62er			; -0.221337
	DD	0be610080r			; -0.219728
	DD	0be5f5b1ar			; -0.218121
	DD	0be5db5fdr			; -0.216515
	DD	0be5c1127r			; -0.214909
	DD	0be5a6c98r			; -0.213305
	DD	0be58c84fr			; -0.211702
	DD	0be57244dr			; -0.210099
	DD	0be558090r			; -0.208498
	DD	0be53dd17r			; -0.206898
	DD	0be5239e3r			; -0.205299
	DD	0be5096f2r			; -0.203701
	DD	0be4ef444r			; -0.202104
	DD	0be4d51d9r			; -0.200508
	DD	0be4bafafr			; -0.198912
	DD	0be4a0dc7r			; -0.197318
	DD	0be486c1fr			; -0.195725
	DD	0be46cab8r			; -0.194133
	DD	0be452990r			; -0.192541
	DD	0be4388a8r			; -0.190951
	DD	0be41e7fer			; -0.189362
	DD	0be404791r			; -0.187773
	DD	0be3ea763r			; -0.186185
	DD	0be3d0771r			; -0.184599
	DD	0be3b67bbr			; -0.183013
	DD	0be39c841r			; -0.181428
	DD	0be382902r			; -0.179844
	DD	0be3689fer			; -0.178261
	DD	0be34eb34r			; -0.176678
	DD	0be334ca4r			; -0.175097
	DD	0be31ae4dr			; -0.173516
	DD	0be30102er			; -0.171937
	DD	0be2e7246r			; -0.170358
	DD	0be2cd497r			; -0.16878
	DD	0be2b371er			; -0.167202
	DD	0be2999dbr			; -0.165626
	DD	0be27fccer			; -0.16405
	DD	0be265ff7r			; -0.162475
	DD	0be24c354r			; -0.160901
	DD	0be2326e5r			; -0.159328
	DD	0be218aaar			; -0.157756
	DD	0be1feea1r			; -0.156184
	DD	0be1e52ccr			; -0.154613
	DD	0be1cb728r			; -0.153042
	DD	0be1b1bb6r			; -0.151473
	DD	0be198074r			; -0.149904
	DD	0be17e564r			; -0.148336
	DD	0be164a83r			; -0.146769
	DD	0be14afd1r			; -0.145202
	DD	0be13154er			; -0.143636
	DD	0be117afar			; -0.142071
	DD	0be0fe0d3r			; -0.140506
	DD	0be0e46d9r			; -0.138942
	DD	0be0cad0dr			; -0.137379
	DD	0be0b136cr			; -0.135816
	DD	0be0979f7r			; -0.134254
	DD	0be07e0aer			; -0.132693
	DD	0be06478fr			; -0.131132
	DD	0be04ae9ar			; -0.129572
	DD	0be0315cer			; -0.128013
	DD	0be017d2cr			; -0.126454
	DD	0bdffc965r			; -0.124896
	DD	0bdfc98c2r			; -0.123338
	DD	0bdf9686er			; -0.121781
	DD	0bdf63868r			; -0.120225
	DD	0bdf308afr			; -0.118669
	DD	0bdefd942r			; -0.117114
	DD	0bdecaa20r			; -0.115559
	DD	0bde97b48r			; -0.114005
	DD	0bde64cb9r			; -0.112451
	DD	0bde31e72r			; -0.110898
	DD	0bddff072r			; -0.109345
	DD	0bddcc2b7r			; -0.107793
	DD	0bdd99542r			; -0.106242
	DD	0bdd66810r			; -0.104691
	DD	0bdd33b22r			; -0.10314
	DD	0bdd00e75r			; -0.10159
	DD	0bdcce209r			; -0.100041
	DD	0bdc9b5dcr			; -0.0984914
	DD	0bdc689efr			; -0.0969428
	DD	0bdc35e3fr			; -0.0953946
	DD	0bdc032cdr			; -0.0938469
	DD	0bdbd0796r			; -0.0922996
	DD	0bdb9dc99r			; -0.0907528
	DD	0bdb6b1d7r			; -0.0892064
	DD	0bdb3874dr			; -0.0876604
	DD	0bdb05cfcr			; -0.0861149
	DD	0bdad32e1r			; -0.0845697
	DD	0bdaa08fbr			; -0.0830249
	DD	0bda6df4br			; -0.0814806
	DD	0bda3b5cfr			; -0.0799366
	DD	0bda08c85r			; -0.078393
	DD	0bd9d636dr			; -0.0768498
	DD	0bd9a3a86r			; -0.0753069
	DD	0bd9711cer			; -0.0737644
	DD	0bd93e946r			; -0.0722223
	DD	0bd90c0ebr			; -0.0706805
	DD	0bd8d98ber			; -0.069139
	DD	0bd8a70bcr			; -0.0675978
	DD	0bd8748e5r			; -0.066057
	DD	0bd842138r			; -0.0645165
	DD	0bd80f9b4r			; -0.0629763
	DD	0bd7ba4afr			; -0.0614364
	DD	0bd755645r			; -0.0598967
	DD	0bd6f0826r			; -0.0583574
	DD	0bd68ba52r			; -0.0568183
	DD	0bd626cc5r			; -0.0552795
	DD	0bd5c1f7fr			; -0.053741
	DD	0bd55d27dr			; -0.0522027
	DD	0bd4f85bcr			; -0.0506646
	DD	0bd49393cr			; -0.0491268
	DD	0bd42ecfar			; -0.0475893
	DD	0bd3ca0f5r			; -0.0460519
	DD	0bd36552ar			; -0.0445148
	DD	0bd300997r			; -0.0429779
	DD	0bd29be3ar			; -0.0414412
	DD	0bd237312r			; -0.0399047
	DD	0bd1d281cr			; -0.0383683
	DD	0bd16dd57r			; -0.0368322
	DD	0bd1092c1r			; -0.0352962
	DD	0bd0a4857r			; -0.0337604
	DD	0bd03fe18r			; -0.0322247
	DD	0bcfb6803r			; -0.0306892
	DD	0bceed424r			; -0.0291539
	DD	0bce2408er			; -0.0276187
	DD	0bcd5ad3fr			; -0.0260836
	DD	0bcc91a31r			; -0.0245486
	DD	0bcbc8762r			; -0.0230138
	DD	0bcaff4ccr			; -0.021479
	DD	0bca3626dr			; -0.0199444
	DD	0bc96d040r			; -0.0184098
	DD	0bc8a3e42r			; -0.0168754
	DD	0bc7b58ddr			; -0.015341
	DD	0bc623584r			; -0.0138067
	DD	0bc491270r			; -0.0122725
	DD	0bc2fef9ar			; -0.0107383
	DD	0bc16ccfbr			; -0.00920414
	DD	0bbfb5514r			; -0.00767005
	DD	0bbc91080r			; -0.006136
	DD	0bb96cc2ar			; -0.00460197
	DD	0bb491004r			; -0.00306797
	DD	0bac90fe5r			; -0.00153398
CONST	ENDS
_DATA	SEGMENT
?m_fHorizontalFadeStartAngle@CSpeedTreeRT@@0MA DD 041f00000r ; 30 ; CSpeedTreeRT::m_fHorizontalFadeStartAngle
?m_fHorizontalFadeEndAngle@CSpeedTreeRT@@0MA DD 042700000r ; 60 ; CSpeedTreeRT::m_fHorizontalFadeEndAngle
?m_fHorizontalFadeValue@CSpeedTreeRT@@0MA DD 042a80000r ; 84 ; CSpeedTreeRT::m_fHorizontalFadeValue
_DATA	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__global_delete@@YAXPAX@Z			; __global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?__global_delete@@YAXPAXI@Z			; __global_delete
PUBLIC	?__global_array_delete@@YAXPAX@Z		; __global_array_delete
PUBLIC	?__global_array_delete@@YAXPAXI@Z		; __global_array_delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	_asinf
PUBLIC	_atan2f
PUBLIC	_fabsf
PUBLIC	_powf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	_vsprintf
PUBLIC	??0exception@std@@QAE@QBD@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_locked
PUBLIC	??0_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::_Iterator_base12
PUBLIC	??0_Iterator_base12@std@@QAE@ABU01@@Z		; std::_Iterator_base12::_Iterator_base12
PUBLIC	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z	; std::_Iterator_base12::operator=
PUBLIC	??1_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::~_Iterator_base12
PUBLIC	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_unlocked
PUBLIC	?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_locked
PUBLIC	?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked
PUBLIC	?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_locked
PUBLIC	?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
PUBLIC	?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_locked_v3
PUBLIC	??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
PUBLIC	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
PUBLIC	??0_Basic_container_proxy_ptr12@std@@IAE@XZ	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::move
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; IdvFileError::IdvFileError
PUBLIC	??1IdvFileError@@UAE@XZ				; IdvFileError::~IdvFileError
PUBLIC	??0IdvFileError@@QAE@ABV0@@Z			; IdvFileError::IdvFileError
PUBLIC	??_GIdvFileError@@UAEPAXI@Z			; IdvFileError::`scalar deleting destructor'
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0SGeometry@CSpeedTreeRT@@QAE@XZ		; CSpeedTreeRT::SGeometry::SGeometry
PUBLIC	??1SGeometry@CSpeedTreeRT@@QAE@XZ		; CSpeedTreeRT::SGeometry::~SGeometry
PUBLIC	??0SIndexed@SGeometry@CSpeedTreeRT@@QAE@XZ	; CSpeedTreeRT::SGeometry::SIndexed::SIndexed
PUBLIC	??1SIndexed@SGeometry@CSpeedTreeRT@@QAE@XZ	; CSpeedTreeRT::SGeometry::SIndexed::~SIndexed
PUBLIC	??4SIndexed@SGeometry@CSpeedTreeRT@@QAEAAU012@ABU012@@Z ; CSpeedTreeRT::SGeometry::SIndexed::operator=
PUBLIC	??0SLeaf@SGeometry@CSpeedTreeRT@@QAE@XZ		; CSpeedTreeRT::SGeometry::SLeaf::SLeaf
PUBLIC	??1SLeaf@SGeometry@CSpeedTreeRT@@QAE@XZ		; CSpeedTreeRT::SGeometry::SLeaf::~SLeaf
PUBLIC	??4SLeaf@SGeometry@CSpeedTreeRT@@QAEAAU012@ABU012@@Z ; CSpeedTreeRT::SGeometry::SLeaf::operator=
PUBLIC	??0SBillboard@SGeometry@CSpeedTreeRT@@QAE@XZ	; CSpeedTreeRT::SGeometry::SBillboard::SBillboard
PUBLIC	??1SBillboard@SGeometry@CSpeedTreeRT@@QAE@XZ	; CSpeedTreeRT::SGeometry::SBillboard::~SBillboard
PUBLIC	??4SBillboard@SGeometry@CSpeedTreeRT@@QAEAAU012@ABU012@@Z ; CSpeedTreeRT::SGeometry::SBillboard::operator=
PUBLIC	??4SGeometry@CSpeedTreeRT@@QAEAAU01@ABU01@@Z	; CSpeedTreeRT::SGeometry::operator=
PUBLIC	??0STextures@CSpeedTreeRT@@QAE@XZ		; CSpeedTreeRT::STextures::STextures
PUBLIC	??1STextures@CSpeedTreeRT@@QAE@XZ		; CSpeedTreeRT::STextures::~STextures
PUBLIC	??4STextures@CSpeedTreeRT@@QAEAAU01@ABU01@@Z	; CSpeedTreeRT::STextures::operator=
PUBLIC	??0CSpeedTreeRT@@QAE@XZ				; CSpeedTreeRT::CSpeedTreeRT
PUBLIC	??1CSpeedTreeRT@@QAE@XZ				; CSpeedTreeRT::~CSpeedTreeRT
PUBLIC	??2CSpeedTreeRT@@SAPAXI@Z			; CSpeedTreeRT::operator new
PUBLIC	??_UCSpeedTreeRT@@SAPAXI@Z			; CSpeedTreeRT::operator new[]
PUBLIC	??3CSpeedTreeRT@@SAXPAX@Z			; CSpeedTreeRT::operator delete
PUBLIC	??_VCSpeedTreeRT@@SAXPAX@Z			; CSpeedTreeRT::operator delete[]
PUBLIC	?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z		; CSpeedTreeRT::Compute
PUBLIC	?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z		; CSpeedTreeRT::Clone
PUBLIC	?InstanceOf@CSpeedTreeRT@@QBEPBV1@XZ		; CSpeedTreeRT::InstanceOf
PUBLIC	?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ		; CSpeedTreeRT::MakeInstance
PUBLIC	?DeleteTransientData@CSpeedTreeRT@@QAEXXZ	; CSpeedTreeRT::DeleteTransientData
PUBLIC	?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z		; CSpeedTreeRT::LoadTree
PUBLIC	?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z		; CSpeedTreeRT::LoadTree
PUBLIC	?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z		; CSpeedTreeRT::SaveTree
PUBLIC	?GetTreeSize@CSpeedTreeRT@@QBEXAAM0@Z		; CSpeedTreeRT::GetTreeSize
PUBLIC	?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z		; CSpeedTreeRT::SetTreeSize
PUBLIC	?GetSeed@CSpeedTreeRT@@QBEIXZ			; CSpeedTreeRT::GetSeed
PUBLIC	?GetTreePosition@CSpeedTreeRT@@QBEPBMXZ		; CSpeedTreeRT::GetTreePosition
PUBLIC	?SetTreePosition@CSpeedTreeRT@@QAEXMMM@Z	; CSpeedTreeRT::SetTreePosition
PUBLIC	?SetLeafTargetAlphaMask@CSpeedTreeRT@@QAEXE@Z	; CSpeedTreeRT::SetLeafTargetAlphaMask
PUBLIC	?GetBranchLightingMethod@CSpeedTreeRT@@QBE?AW4ELightingMethod@1@XZ ; CSpeedTreeRT::GetBranchLightingMethod
PUBLIC	?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z ; CSpeedTreeRT::SetBranchLightingMethod
PUBLIC	?GetLeafLightingMethod@CSpeedTreeRT@@QBE?AW4ELightingMethod@1@XZ ; CSpeedTreeRT::GetLeafLightingMethod
PUBLIC	?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z ; CSpeedTreeRT::SetLeafLightingMethod
PUBLIC	?GetFrondLightingMethod@CSpeedTreeRT@@QBE?AW4ELightingMethod@1@XZ ; CSpeedTreeRT::GetFrondLightingMethod
PUBLIC	?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z ; CSpeedTreeRT::SetFrondLightingMethod
PUBLIC	?GetStaticLightingStyle@CSpeedTreeRT@@QBE?AW4EStaticLightingStyle@1@XZ ; CSpeedTreeRT::GetStaticLightingStyle
PUBLIC	?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z ; CSpeedTreeRT::SetStaticLightingStyle
PUBLIC	?GetLeafLightingAdjustment@CSpeedTreeRT@@QBEMXZ	; CSpeedTreeRT::GetLeafLightingAdjustment
PUBLIC	?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z ; CSpeedTreeRT::SetLeafLightingAdjustment
PUBLIC	?GetLightState@CSpeedTreeRT@@SA_NI@Z		; CSpeedTreeRT::GetLightState
PUBLIC	?SetLightState@CSpeedTreeRT@@SAXI_N@Z		; CSpeedTreeRT::SetLightState
PUBLIC	?GetLightAttributes@CSpeedTreeRT@@SAPBMI@Z	; CSpeedTreeRT::GetLightAttributes
PUBLIC	?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z	; CSpeedTreeRT::SetLightAttributes
PUBLIC	?GetBranchMaterial@CSpeedTreeRT@@QBEPBMXZ	; CSpeedTreeRT::GetBranchMaterial
PUBLIC	?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z	; CSpeedTreeRT::SetBranchMaterial
PUBLIC	?GetLeafMaterial@CSpeedTreeRT@@QBEPBMXZ		; CSpeedTreeRT::GetLeafMaterial
PUBLIC	?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z	; CSpeedTreeRT::SetLeafMaterial
PUBLIC	?GetFrondMaterial@CSpeedTreeRT@@QBEPBMXZ	; CSpeedTreeRT::GetFrondMaterial
PUBLIC	?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z	; CSpeedTreeRT::SetFrondMaterial
PUBLIC	?GetCamera@CSpeedTreeRT@@SAXPAM0@Z		; CSpeedTreeRT::GetCamera
PUBLIC	?SetCamera@CSpeedTreeRT@@SAXPBM0@Z		; CSpeedTreeRT::SetCamera
PUBLIC	?SetTime@CSpeedTreeRT@@SAXM@Z			; CSpeedTreeRT::SetTime
PUBLIC	?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z	; CSpeedTreeRT::ComputeWindEffects
PUBLIC	?ResetLeafWindState@CSpeedTreeRT@@QAEXXZ	; CSpeedTreeRT::ResetLeafWindState
PUBLIC	?GetLeafRockingState@CSpeedTreeRT@@QBE_NXZ	; CSpeedTreeRT::GetLeafRockingState
PUBLIC	?SetLeafRockingState@CSpeedTreeRT@@QAEX_N@Z	; CSpeedTreeRT::SetLeafRockingState
PUBLIC	?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z	; CSpeedTreeRT::SetNumLeafRockingGroups
PUBLIC	?GetLeafWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ ; CSpeedTreeRT::GetLeafWindMethod
PUBLIC	?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z ; CSpeedTreeRT::SetLeafWindMethod
PUBLIC	?GetBranchWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ ; CSpeedTreeRT::GetBranchWindMethod
PUBLIC	?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z ; CSpeedTreeRT::SetBranchWindMethod
PUBLIC	?GetFrondWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ ; CSpeedTreeRT::GetFrondWindMethod
PUBLIC	?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z ; CSpeedTreeRT::SetFrondWindMethod
PUBLIC	?GetWindStrength@CSpeedTreeRT@@QBEMXZ		; CSpeedTreeRT::GetWindStrength
PUBLIC	?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z	; CSpeedTreeRT::SetWindStrength
PUBLIC	?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z ; CSpeedTreeRT::SetWindStrengthAndLeafAngles
PUBLIC	?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z	; CSpeedTreeRT::SetNumWindMatrices
PUBLIC	?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z		; CSpeedTreeRT::SetWindMatrix
PUBLIC	?GetLocalMatrices@CSpeedTreeRT@@QAEXAAI0@Z	; CSpeedTreeRT::GetLocalMatrices
PUBLIC	?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z	; CSpeedTreeRT::SetLocalMatrices
PUBLIC	?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ		; CSpeedTreeRT::ComputeLodLevel
PUBLIC	?GetLodLevel@CSpeedTreeRT@@QBEMXZ		; CSpeedTreeRT::GetLodLevel
PUBLIC	?SetLodLevel@CSpeedTreeRT@@QAEXM@Z		; CSpeedTreeRT::SetLodLevel
PUBLIC	?SetDropToBillboard@CSpeedTreeRT@@SAX_N@Z	; CSpeedTreeRT::SetDropToBillboard
PUBLIC	?GetLodLimits@CSpeedTreeRT@@QBEXAAM0@Z		; CSpeedTreeRT::GetLodLimits
PUBLIC	?SetLodLimits@CSpeedTreeRT@@QAEXMM@Z		; CSpeedTreeRT::SetLodLimits
PUBLIC	?GetDiscreteBranchLodLevel@CSpeedTreeRT@@QBEFM@Z ; CSpeedTreeRT::GetDiscreteBranchLodLevel
PUBLIC	?GetDiscreteLeafLodLevel@CSpeedTreeRT@@QBEGM@Z	; CSpeedTreeRT::GetDiscreteLeafLodLevel
PUBLIC	?GetDiscreteFrondLodLevel@CSpeedTreeRT@@QBEFM@Z	; CSpeedTreeRT::GetDiscreteFrondLodLevel
PUBLIC	?GetNumBranchLodLevels@CSpeedTreeRT@@QBEGXZ	; CSpeedTreeRT::GetNumBranchLodLevels
PUBLIC	?GetNumLeafLodLevels@CSpeedTreeRT@@QBEGXZ	; CSpeedTreeRT::GetNumLeafLodLevels
PUBLIC	?GetNumFrondLodLevels@CSpeedTreeRT@@QBEGXZ	; CSpeedTreeRT::GetNumFrondLodLevels
PUBLIC	?SetHorzBillboardFadeAngles@CSpeedTreeRT@@SAXMM@Z ; CSpeedTreeRT::SetHorzBillboardFadeAngles
PUBLIC	?GetHorzBillboardFadeAngles@CSpeedTreeRT@@SAXAAM0@Z ; CSpeedTreeRT::GetHorzBillboardFadeAngles
PUBLIC	?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ	; CSpeedTreeRT::DeleteBranchGeometry
PUBLIC	?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ	; CSpeedTreeRT::DeleteFrondGeometry
PUBLIC	?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z ; CSpeedTreeRT::GetFrondGeometryMapIndexes
PUBLIC	?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z ; CSpeedTreeRT::GetLeafBillboardTable
PUBLIC	?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ ; CSpeedTreeRT::GetLeafLodSizeAdjustments
PUBLIC	?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z ; CSpeedTreeRT::GetGeometry
PUBLIC	?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z ; CSpeedTreeRT::GetTextures
PUBLIC	?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z	; CSpeedTreeRT::SetLeafTextureCoords
PUBLIC	?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z	; CSpeedTreeRT::SetFrondTextureCoords
PUBLIC	?GetTextureFlip@CSpeedTreeRT@@SA_NXZ		; CSpeedTreeRT::GetTextureFlip
PUBLIC	?SetTextureFlip@CSpeedTreeRT@@SAX_N@Z		; CSpeedTreeRT::SetTextureFlip
PUBLIC	?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z ; CSpeedTreeRT::SetBranchTextureFilename
PUBLIC	?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z ; CSpeedTreeRT::SetLeafTextureFilename
PUBLIC	?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z ; CSpeedTreeRT::SetFrondTextureFilename
PUBLIC	?Authorize@CSpeedTreeRT@@SAXPBD@Z		; CSpeedTreeRT::Authorize
PUBLIC	?IsAuthorized@CSpeedTreeRT@@SA_NXZ		; CSpeedTreeRT::IsAuthorized
PUBLIC	?GetCurrentError@CSpeedTreeRT@@SAPBDXZ		; CSpeedTreeRT::GetCurrentError
PUBLIC	?ResetError@CSpeedTreeRT@@SAXXZ			; CSpeedTreeRT::ResetError
PUBLIC	?GetBoundingBox@CSpeedTreeRT@@QBEXPAM@Z		; CSpeedTreeRT::GetBoundingBox
PUBLIC	?GetLeafTriangleCount@CSpeedTreeRT@@QBEIM@Z	; CSpeedTreeRT::GetLeafTriangleCount
PUBLIC	?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z	; CSpeedTreeRT::GetBranchTriangleCount
PUBLIC	?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z	; CSpeedTreeRT::GetFrondTriangleCount
PUBLIC	?GetCollisionObjectCount@CSpeedTreeRT@@QAEIXZ	; CSpeedTreeRT::GetCollisionObjectCount
PUBLIC	?GetCollisionObject@CSpeedTreeRT@@QAEXIAAW4ECollisionObjectType@1@PAM1@Z ; CSpeedTreeRT::GetCollisionObject
PUBLIC	?GetUserData@CSpeedTreeRT@@QBEPBDXZ		; CSpeedTreeRT::GetUserData
PUBLIC	??0CSpeedTreeRT@@AAE@PBV0@@Z			; CSpeedTreeRT::CSpeedTreeRT
PUBLIC	?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ	; CSpeedTreeRT::ComputeLeafStaticLighting
PUBLIC	?ComputeSelfShadowTexCoords@CSpeedTreeRT@@AAEXXZ ; CSpeedTreeRT::ComputeSelfShadowTexCoords
PUBLIC	?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z	; CSpeedTreeRT::NotifyAllTreesOfEvent
PUBLIC	?SetError@CSpeedTreeRT@@CAXPBD@Z		; CSpeedTreeRT::SetError
PUBLIC	?ParseLodInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::ParseLodInfo
PUBLIC	?ParseWindInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::ParseWindInfo
PUBLIC	?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::ParseTextureCoordInfo
PUBLIC	?ParseCollisionObjects@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::ParseCollisionObjects
PUBLIC	?SaveTextureCoords@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::SaveTextureCoords
PUBLIC	?SaveCollisionObjects@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::SaveCollisionObjects
PUBLIC	?ParseShadowProjectionInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::ParseShadowProjectionInfo
PUBLIC	?SaveUserData@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::SaveUserData
PUBLIC	?ParseUserData@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::ParseUserData
PUBLIC	?SaveSupplementalTexCoordInfo@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::SaveSupplementalTexCoordInfo
PUBLIC	?ParseSupplementalTexCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::ParseSupplementalTexCoordInfo
PUBLIC	?CopyUserData@CSpeedTreeRT@@CAPADPBD@Z		; CSpeedTreeRT::CopyUserData
PUBLIC	?GetBranchGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@F@Z ; CSpeedTreeRT::GetBranchGeometry
PUBLIC	?GetFrondGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@F@Z ; CSpeedTreeRT::GetFrondGeometry
PUBLIC	?GetLeafGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@F@Z ; CSpeedTreeRT::GetLeafGeometry
PUBLIC	?Get360BillboardGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@K@Z ; CSpeedTreeRT::Get360BillboardGeometry
PUBLIC	?GetSimpleBillboardGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@@Z ; CSpeedTreeRT::GetSimpleBillboardGeometry
PUBLIC	?GetTransitionValues@CSpeedTreeRT@@CAXMGMMMMAAM0AAF1@Z ; CSpeedTreeRT::GetTransitionValues
PUBLIC	?SetupHorizontalBillboard@CSpeedTreeRT@@AAEXXZ	; CSpeedTreeRT::SetupHorizontalBillboard
PUBLIC	??4CSpeedTreeRT@@QAEAAV0@ABV0@@Z		; CSpeedTreeRT::operator=
PUBLIC	?_idv_sqrt1@@YAMM@Z				; _idv_sqrt1
PUBLIC	??0CVec3@@QAE@XZ				; CVec3::CVec3
PUBLIC	??0CVec3@@QAE@MMM@Z				; CVec3::CVec3
PUBLIC	?Distance@CVec3@@QBEMABV1@@Z			; CVec3::Distance
PUBLIC	?Set@CVec3@@QAEXMMM@Z				; CVec3::Set
PUBLIC	??BCVec3@@QAEPAMXZ				; CVec3::operator float *
PUBLIC	??ACVec3@@QAEAAMH@Z				; CVec3::operator[]
PUBLIC	??HCVec3@@QBE?AV0@ABV0@@Z			; CVec3::operator+
PUBLIC	??GCVec3@@QBE?AV0@XZ				; CVec3::operator-
PUBLIC	??DCVec3@@QBE?AV0@M@Z				; CVec3::operator*
PUBLIC	??9CVec3@@QBE_NABV0@@Z				; CVec3::operator!=
PUBLIC	??DCVec3@@QBE?AV0@ABVCTransform@@@Z		; CVec3::operator*
PUBLIC	??1CRegion@@QAE@XZ				; CRegion::~CRegion
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	?VecRad2Deg@@YAMM@Z				; VecRad2Deg
PUBLIC	?VecInterpolate@@YAMMMM@Z			; VecInterpolate
PUBLIC	?EnableManualLighting@CIndexedGeometry@@QAEX_N@Z ; CIndexedGeometry::EnableManualLighting
PUBLIC	?EnableVertexWeighting@CIndexedGeometry@@QAEX_N@Z ; CIndexedGeometry::EnableVertexWeighting
PUBLIC	?IsVertexWeightingEnabled@CIndexedGeometry@@QBE_NXZ ; CIndexedGeometry::IsVertexWeightingEnabled
PUBLIC	?SetWindMethod@CIndexedGeometry@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z ; CIndexedGeometry::SetWindMethod
PUBLIC	?GetNumLodLevels@CIndexedGeometry@@QAEGXZ	; CIndexedGeometry::GetNumLodLevels
PUBLIC	?GetNumStrips@CIndexedGeometry@@QBEGF@Z		; CIndexedGeometry::GetNumStrips
PUBLIC	?GetStripLengthsPointer@CIndexedGeometry@@QBEPBGG@Z ; CIndexedGeometry::GetStripLengthsPointer
PUBLIC	?GetVertexColors@CIndexedGeometry@@QBEPBKXZ	; CIndexedGeometry::GetVertexColors
PUBLIC	?GetVertexCoords@CIndexedGeometry@@QBEPBMXZ	; CIndexedGeometry::GetVertexCoords
PUBLIC	?GetVertexNormals@CIndexedGeometry@@QBEPBMXZ	; CIndexedGeometry::GetVertexNormals
PUBLIC	?GetVertexBinormals@CIndexedGeometry@@QBEPBMXZ	; CIndexedGeometry::GetVertexBinormals
PUBLIC	?GetVertexTangents@CIndexedGeometry@@QBEPBMXZ	; CIndexedGeometry::GetVertexTangents
PUBLIC	?GetVertexTexCoords0@CIndexedGeometry@@QBEPBMXZ	; CIndexedGeometry::GetVertexTexCoords0
PUBLIC	?GetVertexTexCoords1@CIndexedGeometry@@QBEPBMXZ	; CIndexedGeometry::GetVertexTexCoords1
PUBLIC	?GetVertexWindWeights@CIndexedGeometry@@QBEPBMXZ ; CIndexedGeometry::GetVertexWindWeights
PUBLIC	?GetVertexWindMatrixIndices@CIndexedGeometry@@QBEPBEXZ ; CIndexedGeometry::GetVertexWindMatrixIndices
PUBLIC	?GetVertexCount@CIndexedGeometry@@QBEGXZ	; CIndexedGeometry::GetVertexCount
PUBLIC	?GetVertexTexIndices@CIndexedGeometry@@QBEPBEXZ	; CIndexedGeometry::GetVertexTexIndices
PUBLIC	?Invalidate@CIndexedGeometry@@QAEXXZ		; CIndexedGeometry::Invalidate
PUBLIC	??A?$vector@V?$vector@GV?$allocator@G@std@@@std@@V?$allocator@V?$vector@GV?$allocator@G@std@@@std@@@2@@std@@QBEABV?$vector@GV?$allocator@G@std@@@1@I@Z ; std::vector<std::vector<unsigned short,std::allocator<unsigned short> >,std::allocator<std::vector<unsigned short,std::allocator<unsigned short> > > >::operator[]
PUBLIC	??A?$vector@V?$vector@PAGV?$allocator@PAG@std@@@std@@V?$allocator@V?$vector@PAGV?$allocator@PAG@std@@@std@@@2@@std@@QBEABV?$vector@PAGV?$allocator@PAG@std@@@1@I@Z ; std::vector<std::vector<unsigned short *,std::allocator<unsigned short *> >,std::allocator<std::vector<unsigned short *,std::allocator<unsigned short *> > > >::operator[]
PUBLIC	?empty@?$vector@KV?$allocator@K@std@@@std@@QBE_NXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::empty
PUBLIC	??A?$vector@KV?$allocator@K@std@@@std@@QBEABKI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::operator[]
PUBLIC	?empty@?$vector@MV?$allocator@M@std@@@std@@QBE_NXZ ; std::vector<float,std::allocator<float> >::empty
PUBLIC	?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::size
PUBLIC	??A?$vector@MV?$allocator@M@std@@@std@@QBEABMI@Z ; std::vector<float,std::allocator<float> >::operator[]
PUBLIC	??0?$allocator@E@std@@QAE@XZ			; std::allocator<unsigned char>::allocator<unsigned char>
PUBLIC	?deallocate@?$allocator@E@std@@QAEXQAEI@Z	; std::allocator<unsigned char>::deallocate
PUBLIC	?allocate@?$allocator@E@std@@QAEPAEI@Z		; std::allocator<unsigned char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back
PUBLIC	?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
PUBLIC	?empty@?$vector@EV?$allocator@E@std@@@std@@QBE_NXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::empty
PUBLIC	?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
PUBLIC	?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
PUBLIC	?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
PUBLIC	??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
PUBLIC	??A?$vector@EV?$allocator@E@std@@@std@@QBEABEI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
PUBLIC	?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
PUBLIC	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
PUBLIC	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
PUBLIC	?_Orphan_range_unlocked@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range_unlocked
PUBLIC	?_Orphan_range_locked@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range_locked
PUBLIC	?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
PUBLIC	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
PUBLIC	?_Getal@?$vector@EV?$allocator@E@std@@@std@@ABEABV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	??_GCIndexedGeometry@@QAEPAXI@Z			; CIndexedGeometry::`scalar deleting destructor'
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	?size@?$vector@PAGV?$allocator@PAG@std@@@std@@QBEIXZ ; std::vector<unsigned short *,std::allocator<unsigned short *> >::size
PUBLIC	?empty@?$vector@GV?$allocator@G@std@@@std@@QBE_NXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::empty
PUBLIC	??A?$vector@GV?$allocator@G@std@@@std@@QBEABGI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::operator[]
PUBLIC	??0STreeInstanceData@@QAE@XZ			; STreeInstanceData::STreeInstanceData
PUBLIC	??0?$allocator@PAVCSpeedTreeRT@@@std@@QAE@XZ	; std::allocator<CSpeedTreeRT *>::allocator<CSpeedTreeRT *>
PUBLIC	?deallocate@?$allocator@PAVCSpeedTreeRT@@@std@@QAEXQAPAVCSpeedTreeRT@@I@Z ; std::allocator<CSpeedTreeRT *>::deallocate
PUBLIC	?allocate@?$allocator@PAVCSpeedTreeRT@@@std@@QAEPAPAVCSpeedTreeRT@@I@Z ; std::allocator<CSpeedTreeRT *>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@SAIABV?$allocator@PAVCSpeedTreeRT@@@2@@Z ; std::_Default_allocator_traits<std::allocator<CSpeedTreeRT *> >::max_size
PUBLIC	??0?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >
PUBLIC	??1?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::~vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >
PUBLIC	?push_back@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAEX$$QAPAVCSpeedTreeRT@@@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::push_back
PUBLIC	?erase@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::erase
PUBLIC	?begin@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::begin
PUBLIC	?end@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::end
PUBLIC	?max_size@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QBEIXZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::max_size
PUBLIC	?capacity@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QBEIXZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::capacity
PUBLIC	?_Calculate_growth@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEII@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEXQAPAVCSpeedTreeRT@@II@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEXXZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@CAXXZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Xlength
PUBLIC	?_Orphan_range_unlocked@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Orphan_range_unlocked
PUBLIC	?_Orphan_range_locked@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Orphan_range_locked
PUBLIC	?_Orphan_range@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Orphan_range
PUBLIC	?_Getal@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAV?$allocator@PAVCSpeedTreeRT@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Getal
PUBLIC	?_Getal@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEABV?$allocator@PAVCSpeedTreeRT@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PAVCSpeedTreeRT@@@std@@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVCSpeedTreeRT@@@2@XZ ; std::_Compressed_pair<std::allocator<CSpeedTreeRT *>,std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PAVCSpeedTreeRT@@@std@@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@2@$00@std@@QBEABV?$allocator@PAVCSpeedTreeRT@@@2@XZ ; std::_Compressed_pair<std::allocator<CSpeedTreeRT *>,std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >,1>::_Get_first
PUBLIC	??0SInstanceList@@QAE@XZ			; SInstanceList::SInstanceList
PUBLIC	??1SInstanceList@@QAE@XZ			; SInstanceList::~SInstanceList
PUBLIC	??_GSInstanceList@@QAEPAXI@Z			; SInstanceList::`scalar deleting destructor'
PUBLIC	??0CIdvFilename@@QAE@PBD@Z			; CIdvFilename::CIdvFilename
PUBLIC	??0CIdvFilename@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CIdvFilename::CIdvFilename
PUBLIC	?NoPath@CIdvFilename@@QBE?AV1@XZ		; CIdvFilename::NoPath
PUBLIC	??1CIdvFilename@@QAE@XZ				; CIdvFilename::~CIdvFilename
PUBLIC	??4CIdvFilename@@QAEAAV0@$$QAV0@@Z		; CIdvFilename::operator=
PUBLIC	?size@?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@QBEIXZ ; std::vector<SIdvLeafTexture,std::allocator<SIdvLeafTexture> >::size
PUBLIC	??A?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@QBEABUSIdvLeafTexture@@I@Z ; std::vector<SIdvLeafTexture,std::allocator<SIdvLeafTexture> >::operator[]
PUBLIC	??0CTreeFileAccess@@QAE@XZ			; CTreeFileAccess::CTreeFileAccess
PUBLIC	??0CTreeFileAccess@@QAE@PBEH@Z			; CTreeFileAccess::CTreeFileAccess
PUBLIC	?ParseBool@CTreeFileAccess@@QAE_NXZ		; CTreeFileAccess::ParseBool
PUBLIC	?ParseToken@CTreeFileAccess@@QAE?AW4EFileToken@@XZ ; CTreeFileAccess::ParseToken
PUBLIC	?SaveBool@CTreeFileAccess@@QAEX_N@Z		; CTreeFileAccess::SaveBool
PUBLIC	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
PUBLIC	?EndOfFile@CTreeFileAccess@@QBE_NXZ		; CTreeFileAccess::EndOfFile
PUBLIC	??1CTreeFileAccess@@QAE@XZ			; CTreeFileAccess::~CTreeFileAccess
PUBLIC	?SetCamera@CIdvCamera@@SAXABVCVec3@@0@Z		; CIdvCamera::SetCamera
PUBLIC	?GetCamera@CIdvCamera@@SAXAAVCVec3@@0@Z		; CIdvCamera::GetCamera
PUBLIC	?GetPosition@CIdvCamera@@QBEABVCVec3@@XZ	; CIdvCamera::GetPosition
PUBLIC	?SetPosition@CIdvCamera@@QAEXABVCVec3@@@Z	; CIdvCamera::SetPosition
PUBLIC	?SetLightingEngine@CIdvBranch@@SAXPAVCLightingEngine@@@Z ; CIdvBranch::SetLightingEngine
PUBLIC	?SetFrondEngine@CIdvBranch@@SAXPAVCFrondEngine@@@Z ; CIdvBranch::SetFrondEngine
PUBLIC	?SetPropagateFlexibility@CIdvBranch@@SAX_N@Z	; CIdvBranch::SetPropagateFlexibility
PUBLIC	?GetPropagateFlexibility@CIdvBranch@@SA_NXZ	; CIdvBranch::GetPropagateFlexibility
PUBLIC	?TransientDataIntact@CTreeEngine@@QBE_NXZ	; CTreeEngine::TransientDataIntact
PUBLIC	?GetAllLeaves@CTreeEngine@@QBEPAV?$vector@PAVCBillboardLeaf@@V?$allocator@PAVCBillboardLeaf@@@std@@@std@@XZ ; CTreeEngine::GetAllLeaves
PUBLIC	?GetLeafInfo@CTreeEngine@@QBEABUSIdvLeafInfo@@XZ ; CTreeEngine::GetLeafInfo
PUBLIC	?GetLeafTextures@CTreeEngine@@QBEABV?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@XZ ; CTreeEngine::GetLeafTextures
PUBLIC	?InitTables@CTreeEngine@@QAEXXZ			; CTreeEngine::InitTables
PUBLIC	?SetNumLeafRockingGroups@CTreeEngine@@QAEXH@Z	; CTreeEngine::SetNumLeafRockingGroups
PUBLIC	?GetWindData@CTreeEngine@@QBEABUSIdvWindInfo@@XZ ; CTreeEngine::GetWindData
PUBLIC	?SetBranchLevelForWeighting@CTreeEngine@@QAEXH@Z ; CTreeEngine::SetBranchLevelForWeighting
PUBLIC	?GetBranchLevelForWeighting@CTreeEngine@@QAEHXZ	; CTreeEngine::GetBranchLevelForWeighting
PUBLIC	?GetBranchTextureFilename@CTreeEngine@@QBEABVCIdvFilename@@XZ ; CTreeEngine::GetBranchTextureFilename
PUBLIC	?GetSeed@CTreeEngine@@QBEHXZ			; CTreeEngine::GetSeed
PUBLIC	?SetLod@CTreeEngine@@QAEXM@Z			; CTreeEngine::SetLod
PUBLIC	?GetLod@CTreeEngine@@QBEMXZ			; CTreeEngine::GetLod
PUBLIC	?GetNumLeafLodLevels@CTreeEngine@@QBEHXZ	; CTreeEngine::GetNumLeafLodLevels
PUBLIC	?GetNumBranchLodLevels@CTreeEngine@@QBEIXZ	; CTreeEngine::GetNumBranchLodLevels
PUBLIC	?GetSize@CWindMatrices@@QBEGXZ			; CWindMatrices::GetSize
PUBLIC	?Resize@CWindMatrices@@QAEXG@Z			; CWindMatrices::Resize
PUBLIC	?SetMatrix@CWindMatrices@@QAEXGPBM@Z		; CWindMatrices::SetMatrix
PUBLIC	?GetWindStrength@CWindEngine@@QBEMXZ		; CWindEngine::GetWindStrength
PUBLIC	?SetTime@CWindEngine@@SAXM@Z			; CWindEngine::SetTime
PUBLIC	?GetFrequencyTimeShift@CWindEngine@@QBEMXZ	; CWindEngine::GetFrequencyTimeShift
PUBLIC	?GetBranchWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ ; CWindEngine::GetBranchWindMethod
PUBLIC	?SetBranchWindMethod@CWindEngine@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z ; CWindEngine::SetBranchWindMethod
PUBLIC	?GetFrondWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ ; CWindEngine::GetFrondWindMethod
PUBLIC	?SetFrondWindMethod@CWindEngine@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z ; CWindEngine::SetFrondWindMethod
PUBLIC	?GetLeafWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ ; CWindEngine::GetLeafWindMethod
PUBLIC	?SetLeafWindMethod@CWindEngine@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z ; CWindEngine::SetLeafWindMethod
PUBLIC	?GetLeafRockingState@CWindEngine@@QBE_NXZ	; CWindEngine::GetLeafRockingState
PUBLIC	?SetLeafRockingState@CWindEngine@@QAEX_N@Z	; CWindEngine::SetLeafRockingState
PUBLIC	?GetNumWindMatrices@CWindEngine@@SAIXZ		; CWindEngine::GetNumWindMatrices
PUBLIC	?SetNumWindMatrices@CWindEngine@@SAXG@Z		; CWindEngine::SetNumWindMatrices
PUBLIC	?SetWindMatrix@CWindEngine@@SAXGPBM@Z		; CWindEngine::SetWindMatrix
PUBLIC	?GetLocalMatrices@CWindEngine@@QAEXAAI0@Z	; CWindEngine::GetLocalMatrices
PUBLIC	?SetSpeedWindRockScalar@CWindEngine@@QAEXM@Z	; CWindEngine::SetSpeedWindRockScalar
PUBLIC	?GetSpeedWindRockScalar@CWindEngine@@QBEMXZ	; CWindEngine::GetSpeedWindRockScalar
PUBLIC	?SetSpeedWindRustleScalar@CWindEngine@@QAEXM@Z	; CWindEngine::SetSpeedWindRustleScalar
PUBLIC	?GetSpeedWindRustleScalar@CWindEngine@@QBEMXZ	; CWindEngine::GetSpeedWindRustleScalar
PUBLIC	?Assign3d@@YAXPAMPBM@Z				; Assign3d
PUBLIC	?ComputeAzimuth@@YAMPBM@Z			; ComputeAzimuth
PUBLIC	?GetBillboardCoords@CSimpleBillboard@@QAEPBMMM@Z ; CSimpleBillboard::GetBillboardCoords
PUBLIC	?Invalidate@CSimpleBillboard@@QAEXXZ		; CSimpleBillboard::Invalidate
PUBLIC	?IsValid@CSimpleBillboard@@QBE_NXZ		; CSimpleBillboard::IsValid
PUBLIC	?Validate@CSimpleBillboard@@QAEXXZ		; CSimpleBillboard::Validate
PUBLIC	?GetBranchLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ ; CLightingEngine::GetBranchLightingMethod
PUBLIC	?SetBranchLightingMethod@CLightingEngine@@QAEXW4ELightingMethod@CSpeedTreeRT@@@Z ; CLightingEngine::SetBranchLightingMethod
PUBLIC	?GetLeafLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ ; CLightingEngine::GetLeafLightingMethod
PUBLIC	?SetLeafLightingMethod@CLightingEngine@@QAEXW4ELightingMethod@CSpeedTreeRT@@@Z ; CLightingEngine::SetLeafLightingMethod
PUBLIC	?GetStaticLightingStyle@CLightingEngine@@QBE?AW4EStaticLightingStyle@CSpeedTreeRT@@XZ ; CLightingEngine::GetStaticLightingStyle
PUBLIC	?SetStaticLightingStyle@CLightingEngine@@QAEXW4EStaticLightingStyle@CSpeedTreeRT@@@Z ; CLightingEngine::SetStaticLightingStyle
PUBLIC	?GetFrondLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ ; CLightingEngine::GetFrondLightingMethod
PUBLIC	?SetFrondLightingMethod@CLightingEngine@@QAEXW4ELightingMethod@CSpeedTreeRT@@@Z ; CLightingEngine::SetFrondLightingMethod
PUBLIC	?SetLeafLightingAdjustment@CLightingEngine@@QAEXM@Z ; CLightingEngine::SetLeafLightingAdjustment
PUBLIC	?GetLeafLightingAdjustment@CLightingEngine@@QAEMXZ ; CLightingEngine::GetLeafLightingAdjustment
PUBLIC	?GetLightState@CLightingEngine@@SA_NI@Z		; CLightingEngine::GetLightState
PUBLIC	?SetLightState@CLightingEngine@@SAXI_N@Z	; CLightingEngine::SetLightState
PUBLIC	?GetLightAttributes@CLightingEngine@@SAPBMI@Z	; CLightingEngine::GetLightAttributes
PUBLIC	?GetBranchMaterial@CLightingEngine@@QBEPBMXZ	; CLightingEngine::GetBranchMaterial
PUBLIC	?SetBranchMaterial@CLightingEngine@@QAEXPBM@Z	; CLightingEngine::SetBranchMaterial
PUBLIC	?GetLeafMaterial@CLightingEngine@@QBEPBMXZ	; CLightingEngine::GetLeafMaterial
PUBLIC	?SetLeafMaterial@CLightingEngine@@QAEXPBM@Z	; CLightingEngine::SetLeafMaterial
PUBLIC	?GetFrondMaterial@CLightingEngine@@QBEPBMXZ	; CLightingEngine::GetFrondMaterial
PUBLIC	?SetFrondMaterial@CLightingEngine@@QAEXPBM@Z	; CLightingEngine::SetFrondMaterial
PUBLIC	?EnableManualLighting@CLeafGeometry@@QAEX_N@Z	; CLeafGeometry::EnableManualLighting
PUBLIC	?EnableVertexWeighting@CLeafGeometry@@QAEX_N@Z	; CLeafGeometry::EnableVertexWeighting
PUBLIC	?GetTriangleCount@CLeafGeometry@@QBEII@Z	; CLeafGeometry::GetTriangleCount
PUBLIC	?IsVertexWeightingEnabled@CLeafGeometry@@QBE_NXZ ; CLeafGeometry::IsVertexWeightingEnabled
PUBLIC	??_GCLeafGeometry@@QAEPAXI@Z			; CLeafGeometry::`scalar deleting destructor'
PUBLIC	?GetTextureCount@CFrondEngine@@QBEIXZ		; CFrondEngine::GetTextureCount
PUBLIC	?GetTextureFilename@CFrondEngine@@QBEPBDI@Z	; CFrondEngine::GetTextureFilename
PUBLIC	?SetTextureFilename@CFrondEngine@@QAEXIPBD@Z	; CFrondEngine::SetTextureFilename
PUBLIC	?size@?$vector@USFrondTexture@@V?$allocator@USFrondTexture@@@std@@@std@@QBEIXZ ; std::vector<SFrondTexture,std::allocator<SFrondTexture> >::size
PUBLIC	??A?$vector@USFrondTexture@@V?$allocator@USFrondTexture@@@std@@@std@@QAEAAUSFrondTexture@@I@Z ; std::vector<SFrondTexture,std::allocator<SFrondTexture> >::operator[]
PUBLIC	??A?$vector@USFrondTexture@@V?$allocator@USFrondTexture@@@std@@@std@@QBEABUSFrondTexture@@I@Z ; std::vector<SFrondTexture,std::allocator<SFrondTexture> >::operator[]
PUBLIC	??_GCFrondEngine@@QAEPAXI@Z			; CFrondEngine::`scalar deleting destructor'
PUBLIC	?GetSelfShadowFilename@CProjectedShadow@@QAEPBDXZ ; CProjectedShadow::GetSelfShadowFilename
PUBLIC	??1CProjectedShadow@@QAE@XZ			; CProjectedShadow::~CProjectedShadow
PUBLIC	??4CProjectedShadow@@QAEAAV0@ABV0@@Z		; CProjectedShadow::operator=
PUBLIC	??_GCProjectedShadow@@QAEPAXI@Z			; CProjectedShadow::`scalar deleting destructor'
PUBLIC	??0SEmbeddedTexCoords@@QAE@XZ			; SEmbeddedTexCoords::SEmbeddedTexCoords
PUBLIC	??1SEmbeddedTexCoords@@QAE@XZ			; SEmbeddedTexCoords::~SEmbeddedTexCoords
PUBLIC	??4SEmbeddedTexCoords@@QAEABU0@ABU0@@Z		; SEmbeddedTexCoords::operator=
PUBLIC	??_GSEmbeddedTexCoords@@QAEPAXI@Z		; SEmbeddedTexCoords::`scalar deleting destructor'
PUBLIC	??0SShape@@QAE@XZ				; SShape::SShape
PUBLIC	?TransformAll@SCollisionObjects@@QAEXAAVCTransform@@@Z ; SCollisionObjects::TransformAll
PUBLIC	??0?$allocator@USShape@@@std@@QAE@XZ		; std::allocator<SShape>::allocator<SShape>
PUBLIC	?deallocate@?$allocator@USShape@@@std@@QAEXQAUSShape@@I@Z ; std::allocator<SShape>::deallocate
PUBLIC	?allocate@?$allocator@USShape@@@std@@QAEPAUSShape@@I@Z ; std::allocator<SShape>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAIABV?$allocator@USShape@@@2@@Z ; std::_Default_allocator_traits<std::allocator<SShape> >::max_size
PUBLIC	??0?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE@XZ ; std::vector<SShape,std::allocator<SShape> >::vector<SShape,std::allocator<SShape> >
PUBLIC	??1?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE@XZ ; std::vector<SShape,std::allocator<SShape> >::~vector<SShape,std::allocator<SShape> >
PUBLIC	?push_back@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAEXABUSShape@@@Z ; std::vector<SShape,std::allocator<SShape> >::push_back
PUBLIC	??4?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<SShape,std::allocator<SShape> >::operator=
PUBLIC	?_Clear_and_reserve_geometric@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXI@Z ; std::vector<SShape,std::allocator<SShape> >::_Clear_and_reserve_geometric
PUBLIC	?begin@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@2@XZ ; std::vector<SShape,std::allocator<SShape> >::begin
PUBLIC	?end@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@2@XZ ; std::vector<SShape,std::allocator<SShape> >::end
PUBLIC	?size@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ ; std::vector<SShape,std::allocator<SShape> >::size
PUBLIC	?max_size@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ ; std::vector<SShape,std::allocator<SShape> >::max_size
PUBLIC	?capacity@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ ; std::vector<SShape,std::allocator<SShape> >::capacity
PUBLIC	??A?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAEAAUSShape@@I@Z ; std::vector<SShape,std::allocator<SShape> >::operator[]
PUBLIC	?_Calculate_growth@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEII@Z ; std::vector<SShape,std::allocator<SShape> >::_Calculate_growth
PUBLIC	?_Buy_raw@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXI@Z ; std::vector<SShape,std::allocator<SShape> >::_Buy_raw
PUBLIC	?_Change_array@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXQAUSShape@@II@Z ; std::vector<SShape,std::allocator<SShape> >::_Change_array
PUBLIC	?_Tidy@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXXZ ; std::vector<SShape,std::allocator<SShape> >::_Tidy
PUBLIC	?_Xlength@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@CAXXZ ; std::vector<SShape,std::allocator<SShape> >::_Xlength
PUBLIC	?_Orphan_range_unlocked@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z ; std::vector<SShape,std::allocator<SShape> >::_Orphan_range_unlocked
PUBLIC	?_Orphan_range_locked@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z ; std::vector<SShape,std::allocator<SShape> >::_Orphan_range_locked
PUBLIC	?_Orphan_range@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z ; std::vector<SShape,std::allocator<SShape> >::_Orphan_range
PUBLIC	?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAV?$allocator@USShape@@@2@XZ ; std::vector<SShape,std::allocator<SShape> >::_Getal
PUBLIC	?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEABV?$allocator@USShape@@@2@XZ ; std::vector<SShape,std::allocator<SShape> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<SShape> >::_Vector_val<std::_Simple_types<SShape> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@USShape@@@std@@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@2@$00@std@@QAEAAV?$allocator@USShape@@@2@XZ ; std::_Compressed_pair<std::allocator<SShape>,std::_Vector_val<std::_Simple_types<SShape> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@USShape@@@std@@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@2@$00@std@@QBEABV?$allocator@USShape@@@2@XZ ; std::_Compressed_pair<std::allocator<SShape>,std::_Vector_val<std::_Simple_types<SShape> >,1>::_Get_first
PUBLIC	??0SCollisionObjects@@QAE@XZ			; SCollisionObjects::SCollisionObjects
PUBLIC	??1SCollisionObjects@@QAE@XZ			; SCollisionObjects::~SCollisionObjects
PUBLIC	??4SCollisionObjects@@QAEAAU0@ABU0@@Z		; SCollisionObjects::operator=
PUBLIC	??_GSCollisionObjects@@QAEPAXI@Z		; SCollisionObjects::`scalar deleting destructor'
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@PAUSShape@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::_Compat
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >
PUBLIC	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator->
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator++
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@PAUSShape@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@PAPAVCSpeedTreeRT@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEABQAVCSpeedTreeRT@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Compat
PUBLIC	?_Verify_range@std@@YAXABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@1@0@Z ; std::_Verify_range
PUBLIC	?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAEXPBQAVCSpeedTreeRT@@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Seek_to
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@$$QAV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEAAPAVCSpeedTreeRT@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator++
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEPAPAVCSpeedTreeRT@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Unwrapped
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@$$QAV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@PAPAVCSpeedTreeRT@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAVCSpeedTreeRT@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@V10@V10@ABQAVCSpeedTreeRT@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >,CSpeedTreeRT *>
PUBLIC	?RoundToNearestInt@@YAHM@Z			; RoundToNearestInt
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@USShape@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<SShape> > >
PUBLIC	??$addressof@$$CBV?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@@std@@YAPBV?$vector@USShape@@V?$allocator@USShape@@@std@@@0@ABV10@@Z ; std::addressof<std::vector<SShape,std::allocator<SShape> > const >
PUBLIC	??$_Pocca@V?$allocator@USShape@@@std@@@std@@YAXAAV?$allocator@USShape@@@0@ABV10@@Z ; std::_Pocca<std::allocator<SShape> >
PUBLIC	??$_Assign_counted_range@PAUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXPAUSShape@@I@Z ; std::vector<SShape,std::allocator<SShape> >::_Assign_counted_range<SShape *>
PUBLIC	??$_Emplace_one_at_back@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAUSShape@@ABU2@@Z ; std::vector<SShape,std::allocator<SShape> >::_Emplace_one_at_back<SShape const &>
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$?0USShape@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@USShape@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><SShape>
PUBLIC	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@USShape@@@std@@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<SShape>,std::_Vector_val<std::_Simple_types<SShape> >,1>::_Compressed_pair<std::allocator<SShape>,std::_Vector_val<std::_Simple_types<SShape> >,1><>
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
PUBLIC	??$_Move_unchecked@PAPAVCSpeedTreeRT@@PAPAV1@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@00@Z ; std::_Move_unchecked<CSpeedTreeRT * *,CSpeedTreeRT * *>
PUBLIC	??$_Unfancy@PAVCSpeedTreeRT@@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@@Z ; std::_Unfancy<CSpeedTreeRT *>
PUBLIC	??$destroy@PAVCSpeedTreeRT@@@?$_Default_allocator_traits@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@SAXAAV?$allocator@PAVCSpeedTreeRT@@@1@QAPAVCSpeedTreeRT@@@Z ; std::_Default_allocator_traits<std::allocator<CSpeedTreeRT *> >::destroy<CSpeedTreeRT *>
PUBLIC	??$move@AAPAVCSpeedTreeRT@@@std@@YA$$QAPAVCSpeedTreeRT@@AAPAV1@@Z ; std::move<CSpeedTreeRT * &>
PUBLIC	??$_Emplace_one_at_back@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAPAVCSpeedTreeRT@@$$QAPAV2@@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Emplace_one_at_back<CSpeedTreeRT *>
PUBLIC	??$?0PAVCSpeedTreeRT@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVCSpeedTreeRT@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><CSpeedTreeRT *>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@PAVCSpeedTreeRT@@@std@@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<CSpeedTreeRT *>,std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >,1>::_Compressed_pair<std::allocator<CSpeedTreeRT *>,std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >,1><>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
PUBLIC	??$move@AAE@std@@YA$$QAEAAE@Z			; std::move<unsigned char &>
PUBLIC	??$_Emplace_one_at_back@E@?$vector@EV?$allocator@E@std@@@std@@AAEAAE$$QAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_one_at_back<unsigned char>
PUBLIC	??$?0E@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@E@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned char>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	??$_Convert_size@II@std@@YAII@Z			; std::_Convert_size<unsigned int,unsigned int>
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
PUBLIC	??$_Destroy_range@V?$allocator@USShape@@@std@@@std@@YAXPAUSShape@@QAU1@AAV?$allocator@USShape@@@0@@Z ; std::_Destroy_range<std::allocator<SShape> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAXPAPAVCSpeedTreeRT@@QAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z ; std::_Destroy_range<std::allocator<CSpeedTreeRT *> >
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
PUBLIC	??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$max@I@std@@YAABIABI0@Z			; std::max<unsigned int>
PUBLIC	??$_Deallocate@$07@std@@YAXPAXI@Z		; std::_Deallocate<8>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > > >
PUBLIC	??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > > &>
PUBLIC	??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > > const &>
PUBLIC	??$_Find_unchecked@PAPAVCSpeedTreeRT@@PAV1@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@QAPAV1@ABQAV1@@Z ; std::_Find_unchecked<CSpeedTreeRT * *,CSpeedTreeRT *>
PUBLIC	??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAPAVCSpeedTreeRT@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@$$QAPAPAVCSpeedTreeRT@@@Z ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >,CSpeedTreeRT * *>
PUBLIC	??$move@AAPAUSShape@@@std@@YA$$QAPAUSShape@@AAPAU1@@Z ; std::move<SShape * &>
PUBLIC	??$_Uninitialized_copy_n@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@PAU1@I0AAV?$allocator@USShape@@@0@@Z ; std::_Uninitialized_copy_n<SShape *,std::allocator<SShape> >
PUBLIC	??$_Copy_memmove_n@PAUSShape@@PAU1@@std@@YAPAUSShape@@PAU1@I0@Z ; std::_Copy_memmove_n<SShape *,SShape *>
PUBLIC	??$_Copy_n_unchecked4@PAUSShape@@IPAU1@@std@@YAPAUSShape@@PAU1@I0@Z ; std::_Copy_n_unchecked4<SShape *,unsigned int,SShape *>
PUBLIC	??$forward@ABUSShape@@@std@@YAABUSShape@@ABU1@@Z ; std::forward<SShape const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAUSShape@@ABU2@@Z ; std::vector<SShape,std::allocator<SShape> >::_Emplace_back_with_unused_capacity<SShape const &>
PUBLIC	??$_Emplace_reallocate@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEPAUSShape@@QAU2@ABU2@@Z ; std::vector<SShape,std::allocator<SShape> >::_Emplace_reallocate<SShape const &>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	??$_Copy_memmove@PAPAVCSpeedTreeRT@@PAPAV1@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@00@Z ; std::_Copy_memmove<CSpeedTreeRT * *,CSpeedTreeRT * *>
PUBLIC	??$forward@PAVCSpeedTreeRT@@@std@@YA$$QAPAVCSpeedTreeRT@@AAPAV1@@Z ; std::forward<CSpeedTreeRT *>
PUBLIC	??$_Emplace_back_with_unused_capacity@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAPAVCSpeedTreeRT@@$$QAPAV2@@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Emplace_back_with_unused_capacity<CSpeedTreeRT *>
PUBLIC	??$_Emplace_reallocate@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEPAPAVCSpeedTreeRT@@QAPAV2@$$QAPAV2@@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Emplace_reallocate<CSpeedTreeRT *>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
PUBLIC	??$forward@E@std@@YA$$QAEAAE@Z			; std::forward<unsigned char>
PUBLIC	??$_Emplace_back_with_unused_capacity@E@?$vector@EV?$allocator@E@std@@@std@@AAEAAE$$QAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_back_with_unused_capacity<unsigned char>
PUBLIC	??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEPAEQAE$$QAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
PUBLIC	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
PUBLIC	??$_Unfancy_maybe_null@PAVCSpeedTreeRT@@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@@Z ; std::_Unfancy_maybe_null<CSpeedTreeRT *>
PUBLIC	??$?0AAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@AAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> &>
PUBLIC	??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NABV?$allocator@D@0@0@Z ; std::_Allocators_equal<std::allocator<char> >
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@AAV?$allocator@USShape@@@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<SShape> >
PUBLIC	??$_Could_compare_equal_to_value_type@PAPAVCSpeedTreeRT@@PAV1@@std@@YA_NABQAVCSpeedTreeRT@@@Z ; std::_Could_compare_equal_to_value_type<CSpeedTreeRT * *,CSpeedTreeRT *>
PUBLIC	??$_To_address@PAPAVCSpeedTreeRT@@@std@@YA?A_PABQAPAVCSpeedTreeRT@@@Z ; std::_To_address<CSpeedTreeRT * *>
PUBLIC	??$__std_find_trivial@PAVCSpeedTreeRT@@PAV1@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0QAV1@@Z ; std::__std_find_trivial<CSpeedTreeRT *,CSpeedTreeRT *>
PUBLIC	??$forward@PAPAVCSpeedTreeRT@@@std@@YA$$QAPAPAVCSpeedTreeRT@@AAPAPAV1@@Z ; std::forward<CSpeedTreeRT * *>
PUBLIC	??$_Get_unwrapped@PAUSShape@@@std@@YA?A_T$$QAPAUSShape@@@Z ; std::_Get_unwrapped<SShape *>
PUBLIC	??$_Unfancy@USShape@@@std@@YAPAUSShape@@PAU1@@Z	; std::_Unfancy<SShape>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAE@PAUSShape@@AAV?$allocator@USShape@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<SShape> >::_Uninitialized_backout_al<std::allocator<SShape> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<SShape> >::~_Uninitialized_backout_al<std::allocator<SShape> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAEPAUSShape@@XZ ; std::_Uninitialized_backout_al<std::allocator<SShape> >::_Release
PUBLIC	??$_Emplace_back@AAUSShape@@@?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAEXAAUSShape@@@Z ; std::_Uninitialized_backout_al<std::allocator<SShape> >::_Emplace_back<SShape &>
PUBLIC	??$_Copy_memmove@PAUSShape@@PAU1@@std@@YAPAUSShape@@PAU1@00@Z ; std::_Copy_memmove<SShape *,SShape *>
PUBLIC	??$_Construct_in_place@USShape@@ABU1@@std@@YAXAAUSShape@@ABU1@@Z ; std::_Construct_in_place<SShape,SShape const &>
PUBLIC	??$construct@USShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAXAAV?$allocator@USShape@@@1@QAUSShape@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<SShape> >::construct<SShape,SShape const &>
PUBLIC	??$_Uninitialized_move@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@QAU1@0PAU1@AAV?$allocator@USShape@@@0@@Z ; std::_Uninitialized_move<SShape *,std::allocator<SShape> >
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
PUBLIC	??$_Construct_in_place@PAVCSpeedTreeRT@@PAV1@@std@@YAXAAPAVCSpeedTreeRT@@$$QAPAV1@@Z ; std::_Construct_in_place<CSpeedTreeRT *,CSpeedTreeRT *>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@AAV?$allocator@PAVCSpeedTreeRT@@@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<CSpeedTreeRT *> >
PUBLIC	??$construct@PAVCSpeedTreeRT@@PAV1@@?$_Default_allocator_traits@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@SAXAAV?$allocator@PAVCSpeedTreeRT@@@1@QAPAVCSpeedTreeRT@@$$QAPAV3@@Z ; std::_Default_allocator_traits<std::allocator<CSpeedTreeRT *> >::construct<CSpeedTreeRT *,CSpeedTreeRT *>
PUBLIC	??$_Uninitialized_move@PAPAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z ; std::_Uninitialized_move<CSpeedTreeRT * *,std::allocator<CSpeedTreeRT *> >
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPAEAAV?$allocator@E@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<unsigned char> >
PUBLIC	??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Unfancy@E@std@@YAPAEPAE@Z			; std::_Unfancy<unsigned char>
PUBLIC	??$_Zero_range@PAE@std@@YAPAEQAE0@Z		; std::_Zero_range<unsigned char *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAE@PAEAAV?$allocator@E@1@@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAEPAEXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<>
PUBLIC	??$_Construct_in_place@EE@std@@YAXAAE$$QAE@Z	; std::_Construct_in_place<unsigned char,unsigned char>
PUBLIC	??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@QAE$$QAE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$forward@AAV?$allocator@D@std@@@std@@YAAAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> &>
PUBLIC	??$_Refancy_maybe_null@PAPAVCSpeedTreeRT@@$0A@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@@Z ; std::_Refancy_maybe_null<CSpeedTreeRT * *,0>
PUBLIC	??$_Get_size_of_n@$0BM@@std@@YAII@Z		; std::_Get_size_of_n<28>
PUBLIC	??$__std_find_trivial@PAVCSpeedTreeRT@@I@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0I@Z ; std::__std_find_trivial<CSpeedTreeRT *,unsigned int>
PUBLIC	??$forward@AAUSShape@@@std@@YAAAUSShape@@AAU1@@Z ; std::forward<SShape &>
PUBLIC	??$construct@USShape@@AAU1@@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAXAAV?$allocator@USShape@@@1@QAUSShape@@AAU3@@Z ; std::_Default_allocator_traits<std::allocator<SShape> >::construct<SShape,SShape &>
PUBLIC	??$_To_address@PAUSShape@@@std@@YA?A_PABQAUSShape@@@Z ; std::_To_address<SShape *>
PUBLIC	??$addressof@USShape@@@std@@YAPAUSShape@@AAU1@@Z ; std::addressof<SShape>
PUBLIC	??$_Get_unwrapped@ABQAUSShape@@@std@@YA?A_TABQAUSShape@@@Z ; std::_Get_unwrapped<SShape * const &>
PUBLIC	??$move@AAUSShape@@@std@@YA$$QAUSShape@@AAU1@@Z	; std::move<SShape &>
PUBLIC	??$_Emplace_back@USShape@@@?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAEX$$QAUSShape@@@Z ; std::_Uninitialized_backout_al<std::allocator<SShape> >::_Emplace_back<SShape>
PUBLIC	??$addressof@PAVCSpeedTreeRT@@@std@@YAPAPAVCSpeedTreeRT@@AAPAV1@@Z ; std::addressof<CSpeedTreeRT *>
PUBLIC	??$_Get_unwrapped@ABQAPAVCSpeedTreeRT@@@std@@YA?A_TABQAPAVCSpeedTreeRT@@@Z ; std::_Get_unwrapped<CSpeedTreeRT * * const &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@PAPAVCSpeedTreeRT@@AAV?$allocator@PAVCSpeedTreeRT@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >::~_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAEPAPAVCSpeedTreeRT@@XZ ; std::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >::_Release
PUBLIC	??$_Emplace_back@PAVCSpeedTreeRT@@@?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAEX$$QAPAVCSpeedTreeRT@@@Z ; std::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >::_Emplace_back<CSpeedTreeRT *>
PUBLIC	??$_Get_unwrapped@ABQAE@std@@YA?A_TABQAE@Z	; std::_Get_unwrapped<unsigned char * const &>
PUBLIC	??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z	; std::_Copy_memmove<unsigned char *,unsigned char *>
PUBLIC	??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAEX$$QAE@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char>
PUBLIC	??$_To_address@PAE@std@@YA?A_PABQAE@Z		; std::_To_address<unsigned char *>
PUBLIC	??$construct@E$$V@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@QAE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char>
PUBLIC	??$addressof@E@std@@YAPAEAAE@Z			; std::addressof<unsigned char>
PUBLIC	??$_Get_size_of_n@$03@std@@YAII@Z		; std::_Get_size_of_n<4>
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	??$forward@USShape@@@std@@YA$$QAUSShape@@AAU1@@Z ; std::forward<SShape>
PUBLIC	??$construct@USShape@@U1@@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAXAAV?$allocator@USShape@@@1@QAUSShape@@$$QAU3@@Z ; std::_Default_allocator_traits<std::allocator<SShape> >::construct<SShape,SShape>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GC@GDGMGNBP@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1ME@KJJNLLPL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ ; `string'
PUBLIC	??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_7IdvFileError@@6B@				; IdvFileError::`vftable'
PUBLIC	??_C@_01LBDDMOBJ@?$FN@				; `string'
PUBLIC	??_C@_02GBLMOEJC@?5?$FL@			; `string'
PUBLIC	?__LINE__Var@?0??GetNumStrips@CIndexedGeometry@@QBEGF@Z@4JA ; `CIndexedGeometry::GetNumStrips'::`1'::__LINE__Var
PUBLIC	??_C@_0DJ@PPMMOPLM@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@ ; `string'
PUBLIC	??_C@_08KPJKAGGE@?0?5file?3?5@			; `string'
PUBLIC	??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@	; `string'
PUBLIC	?__LINE__Var@?0??GetStripLengthsPointer@CIndexedGeometry@@QBEPBGG@Z@4JA ; `CIndexedGeometry::GetStripLengthsPointer'::`1'::__LINE__Var
PUBLIC	?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A ; SInstanceList::m_vUniqueTrees
PUBLIC	??_C@_0DE@PACCNLEK@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@ ; `string'
PUBLIC	??_C@_0DI@KINJKJPN@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@ ; `string'
PUBLIC	??_C@_0DG@LPJNEMKC@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@ ; `string'
PUBLIC	??_C@_0BO@KEOEHMAH@CSpeedTreeRT?3?3CSpeedTreeRT?$CI?5?$CJ@ ; `string'
PUBLIC	??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@ ; `string'
PUBLIC	?__LINE__Var@?0???0CSpeedTreeRT@@AAE@PBV1@@Z@4JA ; `CSpeedTreeRT::CSpeedTreeRT'::`1'::__LINE__Var
PUBLIC	??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@ ; `string'
PUBLIC	??_C@_0CK@KICMMLEH@CSpeedTreeRT?3?3CSpeedTreeRT?$CICSpe@ ; `string'
PUBLIC	?__LINE__Var@?0???1CSpeedTreeRT@@QAE@XZ@4JA	; `CSpeedTreeRT::~CSpeedTreeRT'::`1'::__LINE__Var
PUBLIC	??_C@_0EA@FKCHCHCL@Compute?$CI?$CJ?5called?5more?5than?5once@ ; `string'
PUBLIC	??_C@_0BG@MNNNHHI@CSpeedTreeRT?3?3Compute@	; `string'
PUBLIC	?__LINE__Var@?0??Clone@CSpeedTreeRT@@QBEPAV2@MMMI@Z@4JA ; `CSpeedTreeRT::Clone'::`1'::__LINE__Var
PUBLIC	??_C@_0DD@OBNCDPAD@cannot?5Clone?$CI?$CJ?5after?5calling?5De@ ; `string'
PUBLIC	??_C@_0BE@EBKKKEGA@CSpeedTreeRT?3?3Clone@	; `string'
PUBLIC	??_C@_0DK@LEEALHFM@cannot?5MakeInstance?$CI?$CJ?5after?5cal@ ; `string'
PUBLIC	??_C@_0BL@PNFDFAFA@CSpeedTreeRT?3?3MakeInstance@ ; `string'
PUBLIC	??_C@_0DL@JAMEDGDD@DeleteTransientData?$CI?$CJ?5called?5wi@ ; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	__TI1?AVexception@std@@
PUBLIC	__CTA1?AVexception@std@@
PUBLIC	??_C@_0CA@IGGBMNBO@only?5read?5?$CFd?5of?5?$CFd?5from?5?$CFs?5?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0BO@LOAPLEHO@file?5seek?5failed?5on?5?8?$CFs?8?5?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0BO@MBMLMKLB@failed?5to?5load?5file?5?8?$CFs?8?5?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0BN@EBOIGFHO@CSpeedTreeRT?3?3Load?5Tree?5?9?5?$CFs@ ; `string'
PUBLIC	??_C@_0DL@NANINALL@CSpeedTreeRT?3?3LoadTree?5?9?5threw?5@ ; `string'
PUBLIC	??_C@_0BH@BPMMAHHL@CSpeedTreeRT?3?3LoadTree@	; `string'
PUBLIC	??_C@_0DE@NCFONFAJ@cannot?5Save?$CI?$CJ?5after?5DeleteTrans@ ; `string'
PUBLIC	??_C@_0BH@BABKOJAM@CSpeedTreeRT?3?3SaveTree@	; `string'
PUBLIC	??_C@_0DN@HHHECPHJ@SetTreeSize?$CI?$CJ?5is?5only?5valid?5for@ ; `string'
PUBLIC	??_C@_0EI@JLMDCMOK@SetTreeSize?$CI?$CJ?5has?5no?5effect?5aft@ ; `string'
PUBLIC	??_C@_0BK@ECGBHBNP@CSpeedTreeRT?3?3SetTreeSize@	; `string'
PUBLIC	??_C@_0EI@NEFFOLNG@SetBranchLightingMethod?$CI?$CJ?5has?5n@ ; `string'
PUBLIC	??_C@_0CG@JIPGNOHN@CSpeedTreeRT?3?3SetBranchLighting@ ; `string'
PUBLIC	??_C@_0EG@NJIHGNJJ@SetLeafLightingMethod?$CI?$CJ?5has?5no?5@ ; `string'
PUBLIC	??_C@_0CE@JEGOHDCD@CSpeedTreeRT?3?3SetLeafLightingMe@ ; `string'
PUBLIC	?__LINE__Var@?0??SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@2@@Z@4JA ; `CSpeedTreeRT::SetStaticLightingStyle'::`1'::__LINE__Var
PUBLIC	??_C@_0EH@NCCMENJN@SetStaticLightingStyle?$CI?$CJ?5has?5no@ ; `string'
PUBLIC	??_C@_0CF@BCLGOANH@CSpeedTreeRT?3?3SetStaticLighting@ ; `string'
PUBLIC	??_C@_0EK@FDHHEDFI@SetLeafLightingAdjustment?$CI?$CJ?5has@ ; `string'
PUBLIC	??_C@_0CI@EJKAJJHJ@CSpeedTreeRT?3?3SetLeafLightingAd@ ; `string'
PUBLIC	??_C@_0EH@NOGLOGJ@SetFrondLightingMethod?$CI?$CJ?5has?5no@ ; `string'
PUBLIC	??_C@_0CF@CLEAOJEL@CSpeedTreeRT?3?3SetFrondLightingM@ ; `string'
PUBLIC	??_C@_0CB@HONICPFE@CSpeedTreeRT?3?3SetLightAttribute@ ; `string'
PUBLIC	??_C@_0EC@FKMBDLKG@SetBranchMaterial?$CI?$CJ?5has?5no?5effe@ ; `string'
PUBLIC	??_C@_0CA@MCAEMOA@CSpeedTreeRT?3?3SetBranchMaterial@ ; `string'
PUBLIC	??_C@_0EA@MFLNIJGM@SetLeafMaterial?$CI?$CJ?5has?5no?5effect@ ; `string'
PUBLIC	??_C@_0BO@KAODBPCG@CSpeedTreeRT?3?3SetLeafMaterial@ ; `string'
PUBLIC	??_C@_0EB@FAJAKGFC@SetFrondMaterial?$CI?$CJ?5has?5no?5effec@ ; `string'
PUBLIC	??_C@_0BP@LFKENEJP@CSpeedTreeRT?3?3SetFrondMaterial@ ; `string'
PUBLIC	??_C@_0DM@INADBBLE@GetCamera?$CI?$CJ?5requires?5non?9NULL?5p@ ; `string'
PUBLIC	??_C@_0DM@LIMPHDB@SetCamera?$CI?$CJ?5requires?5non?9NULL?5p@ ; `string'
PUBLIC	??_C@_0BI@GJIKHFEL@CSpeedTreeRT?3?3SetCamera@	; `string'
PUBLIC	??_C@_0BG@MNLGBDFC@CSpeedTreeRT?3?3SetTime@	; `string'
PUBLIC	??_C@_0CB@JOANHIIK@CSpeedTreeRT?3?3ComputeWindEffect@ ; `string'
PUBLIC	??_C@_0EI@IEFOEBHE@SetNumLeafRockingGroups?$CI?$CJ?5has?5n@ ; `string'
PUBLIC	??_C@_0CC@KEPCIKJC@CSpeedTreeRT?3?3SetLeafRockingSta@ ; `string'
PUBLIC	??_C@_0EC@JAGFALME@SetLeafWindMethod?$CI?$CJ?5has?5no?5effe@ ; `string'
PUBLIC	??_C@_0CA@KIINICCD@CSpeedTreeRT?3?3SetLeafWindMethod@ ; `string'
PUBLIC	??_C@_0EE@IEBPHJNM@SetBranchWindMethod?$CI?$CJ?5has?5no?5ef@ ; `string'
PUBLIC	??_C@_0CC@MHEPFOGG@CSpeedTreeRT?3?3SetBranchWindMeth@ ; `string'
PUBLIC	??_C@_0ED@HKHBLIMN@SetFrondWindMethod?$CI?$CJ?5has?5no?5eff@ ; `string'
PUBLIC	??_C@_0CB@JBDMJJKN@CSpeedTreeRT?3?3SetFrondWindMetho@ ; `string'
PUBLIC	??_C@_0DD@IEKNEGPD@SetWindStrength?$CI?$CJ?5expects?5new?5w@ ; `string'
PUBLIC	??_C@_0BO@GJONFFJM@CSpeedTreeRT?3?3SetWindStrength@ ; `string'
PUBLIC	??_C@_0CB@LHALGCIH@CSpeedTreeRT?3?3SetNumWindMatrice@ ; `string'
PUBLIC	?__LINE__Var@?0??SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z@4JA ; `CSpeedTreeRT::SetWindMatrix'::`1'::__LINE__Var
PUBLIC	??_C@_0DD@CFNPDLCE@SetWindMatrix?$CI?$CJ?5requires?5a?5non?9@ ; `string'
PUBLIC	??_C@_0CM@FDEHPAEM@SetWindMatrix?$CI?$CJ?5?9?5matrix?5index?5@ ; `string'
PUBLIC	??_C@_0BM@CAFNOPKO@CSpeedTreeRT?3?3SetWindMatrix@ ; `string'
PUBLIC	??_C@_0DN@LOGCFILD@SetLocalMatrices?$CI?$CJ?5parameters?5e@ ; `string'
PUBLIC	??_C@_0EB@IGKHMMPL@SetLocalMatrices?$CI?$CJ?5has?5no?5effec@ ; `string'
PUBLIC	??_C@_0BP@LNJAODIF@CSpeedTreeRT?3?3SetLocalMatrices@ ; `string'
PUBLIC	??_C@_0BO@NEFNJPOG@CSpeedTreeRT?3?3ComputeLodLevel@ ; `string'
PUBLIC	??_C@_0DJ@ECEAEPMG@SetLodLevel?$CI?$CJ?5expects?5a?5value?5i@ ; `string'
PUBLIC	?__LINE__Var@?0??GetDiscreteBranchLodLevel@CSpeedTreeRT@@QBEFM@Z@4JA ; `CSpeedTreeRT::GetDiscreteBranchLodLevel'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??GetDiscreteFrondLodLevel@CSpeedTreeRT@@QBEFM@Z@4JA ; `CSpeedTreeRT::GetDiscreteFrondLodLevel'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??GetDiscreteLeafLodLevel@CSpeedTreeRT@@QBEGM@Z@4JA ; `CSpeedTreeRT::GetDiscreteLeafLodLevel'::`1'::__LINE__Var
PUBLIC	??_C@_0CD@MCKNGMH@CSpeedTreeRT?3?3DeleteBranchGeome@ ; `string'
PUBLIC	??_C@_0CE@IBNIGHFD@CSpeedTreeRT?3?3GetLeafBillboardT@ ; `string'
PUBLIC	??_C@_0CO@OEGBIMIE@GetBoundingBox?$CI?$CJ?5expects?5a?5non?9@ ; `string'
PUBLIC	??_C@_0CF@LDBPOABP@CSpeedTreeRT?3?3GetBranchTriangle@ ; `string'
PUBLIC	??_C@_0CE@JHCKAGHJ@CSpeedTreeRT?3?3GetFrondTriangleC@ ; `string'
PUBLIC	??_C@_0CI@BADCNPAN@CSpeedTreeRT?3?3ComputeLeafStatic@ ; `string'
PUBLIC	??_C@_0CE@LMHEPLMK@CSpeedTreeRT?3?3NotifyAllTreesOfE@ ; `string'
PUBLIC	__TI3?AVIdvFileError@@
PUBLIC	__CTA3?AVIdvFileError@@
PUBLIC	??_R0?AVIdvFileError@@@8			; IdvFileError `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVIdvFileError@@@8??0IdvFileError@@QAE@ABV0@@Z12
PUBLIC	??_C@_0BD@JMAANHEL@malformed?5lod?5info@	; `string'
PUBLIC	??_C@_0DD@JMFMAINC@premature?5end?5of?5file?5reached?5p@ ; `string'
PUBLIC	??_C@_0BI@IDEPHDPE@malformed?5new?5wind?5info@	; `string'
PUBLIC	??_C@_0DE@FHOGECHL@premature?5end?5of?5file?5reached?5p@ ; `string'
PUBLIC	??_C@_0BN@HDKMKOP@malformed?5texture?5coord?5info@ ; `string'
PUBLIC	??_C@_0DO@PNMFDPBL@premature?5end?5of?5file?5reached?5p@ ; `string'
PUBLIC	??_C@_0DH@IIFFBJOD@collision?5object?5index?5?$CI?$CFd?$CJ?5exc@ ; `string'
PUBLIC	??_C@_0CP@MJBCMBLO@no?5collision?5objects?5are?5stored@ ; `string'
PUBLIC	??_C@_0CA@BIAOOLMK@malformed?5collision?5object?5info@ ; `string'
PUBLIC	??_C@_0BO@GLFBFGPF@unknown?5collision?5object?5type@ ; `string'
PUBLIC	??_C@_0DM@NOGHELOF@premature?5end?5of?5file?5reached?5p@ ; `string'
PUBLIC	??_C@_0CC@JHFKHJHB@CSpeedTreeRT?3?3DeleteFrondGeomet@ ; `string'
PUBLIC	??_C@_0CM@DCKGMMJN@CSpeedTreeRT?3?3GetFrondGeometryM@ ; `string'
PUBLIC	?__LINE__Var@?0??GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@2@KFFF@Z@4JA ; `CSpeedTreeRT::GetGeometry'::`1'::__LINE__Var
PUBLIC	??_C@_0BK@ICBJPCHI@CSpeedTreeRT?3?3GetGeometry@	; `string'
PUBLIC	??_C@_0EH@MBPGMKE@no?5branch?5geometry?5exists?0?5poss@ ; `string'
PUBLIC	??_C@_0EF@KKLNJEEH@no?5frond?5geometry?5exists?0?5possi@ ; `string'
PUBLIC	?__LINE__Var@?0??GetLeafGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@2@F@Z@4JA ; `CSpeedTreeRT::GetLeafGeometry'::`1'::__LINE__Var
PUBLIC	??_C@_0CI@IJNCGOLC@CSpeedTreeRT?3?3GetLeafLodSizeAdj@ ; `string'
PUBLIC	??_C@_0BK@DHPJOIPO@CSpeedTreeRT?3?3GetTextures@	; `string'
PUBLIC	?__LINE__Var@?0??SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z@4JA ; `CSpeedTreeRT::SetLeafTextureCoords'::`1'::__LINE__Var
PUBLIC	??_C@_0CD@DILLEMNK@CSpeedTreeRT?3?3SetLeafTextureCoo@ ; `string'
PUBLIC	??_C@_0CE@MGEADCOJ@CSpeedTreeRT?3?3SetFrondTextureCo@ ; `string'
PUBLIC	?__LINE__Var@?0??SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z@4JA ; `CSpeedTreeRT::SetBranchTextureFilename'::`1'::__LINE__Var
PUBLIC	??_C@_0FF@PAIDPLB@SetBranchTextureFilename?$CI?$CJ?5has?5@ ; `string'
PUBLIC	??_C@_0CH@MDIENIJJ@CSpeedTreeRT?3?3SetBranchTextureF@ ; `string'
PUBLIC	?__LINE__Var@?0??SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z@4JA ; `CSpeedTreeRT::SetLeafTextureFilename'::`1'::__LINE__Var
PUBLIC	??_C@_0FD@LIMCGLOF@SetLeafTextureFilename?$CI?$CJ?5has?5no@ ; `string'
PUBLIC	??_C@_0CF@EPFLDMMH@CSpeedTreeRT?3?3SetLeafTextureFil@ ; `string'
PUBLIC	?__LINE__Var@?0??SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z@4JA ; `CSpeedTreeRT::SetFrondTextureFilename'::`1'::__LINE__Var
PUBLIC	??_C@_0CG@MINPLDH@CSpeedTreeRT?3?3SetFrondTextureFi@ ; `string'
PUBLIC	??_C@_0DE@CHADHGFF@can?8t?5dereference?5value?9initial@ ; `string'
PUBLIC	??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1GM@FNBFNBEL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_0CO@PGFNEDAH@can?8t?5dereference?5invalidated?5v@ ; `string'
PUBLIC	??_C@_1GA@CLCDIGKJ@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_0CP@MDHADBHN@can?8t?5dereference?5out?5of?5range?5@ ; `string'
PUBLIC	??_C@_1GC@JDCKOLAC@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@ ; `string'
PUBLIC	??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ ; `string'
PUBLIC	??_C@_0CE@EAMOGAIE@vector?5erase?5iterator?5outside?5r@ ; `string'
PUBLIC	??_C@_1EM@BEMPOGMM@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi@ ; `string'
PUBLIC	??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@ ; `string'
PUBLIC	??_C@_0GC@JKKBGBPG@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1ME@EHBBECCK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EA@OADAPGGK@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ ; `string'
PUBLIC	??_C@_0DC@KEKNBAEB@can?8t?5increment?5value?9initializ@ ; `string'
PUBLIC	??_C@_1GI@EDCILPL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn@ ; `string'
PUBLIC	??_C@_0CM@MNNBKIBC@can?8t?5increment?5invalidated?5vec@ ; `string'
PUBLIC	??_C@_1FM@ICPJNHLL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn@ ; `string'
PUBLIC	??_C@_0CJ@OAAAAGPM@can?8t?5increment?5vector?5iterator@ ; `string'
PUBLIC	??_C@_1FG@LDPPKMGP@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn@ ; `string'
PUBLIC	??_C@_0BO@CAOBBIOC@vector?5iterators?5incompatible@ ; `string'
PUBLIC	??_C@_1EA@DJDGNIII@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@ ; `string'
PUBLIC	??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ ; `string'
PUBLIC	??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ ; `string'
PUBLIC	??_C@_0BGJ@OHAFKLGF@You?5cannot?5concatenate?5the?5same@ ; `string'
PUBLIC	??_C@_1COI@GKKHJOON@?$AA?$CC?$AAY?$AAo?$AAu?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAc?$AAo?$AAn@ ; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_C@_0DI@PBEELKIF@vector?5iterators?5in?5range?5are?5f@ ; `string'
PUBLIC	??_C@_1HE@KBMFDAFB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@ ; `string'
PUBLIC	??_C@_0CB@LIAHLBAO@vector?5iterator?5range?5transpose@ ; `string'
PUBLIC	??_C@_1EG@ODKBEHFN@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4IdvFileError@@6B@				; IdvFileError::`RTTI Complete Object Locator'
PUBLIC	??_R3IdvFileError@@8				; IdvFileError::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IdvFileError@@8				; IdvFileError::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IdvFileError@@8			; IdvFileError::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3d8f5c29
PUBLIC	__real@3f000000
PUBLIC	__real@3f333333
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@42652ee1
PUBLIC	__real@42a80000
PUBLIC	__real@437f0000
PUBLIC	__real@43b40000
PUBLIC	__real@bf800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	_asin:PROC
EXTRN	_atan2:PROC
EXTRN	_fabs:PROC
EXTRN	_pow:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__abort:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fseek:PROC
EXTRN	__imp__ftell:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp__strerror:PROC
EXTRN	_strlen:PROC
EXTRN	___std_find_trivial_4@12:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	??_EIdvFileError@@UAEPAXI@Z:PROC		; IdvFileError::`vector deleting destructor'
EXTRN	??1CVec@@QAE@XZ:PROC				; CVec::~CVec
EXTRN	??0CTransform@@QAE@XZ:PROC			; CTransform::CTransform
EXTRN	?LoadIdentity@CTransform@@QAEXXZ:PROC		; CTransform::LoadIdentity
EXTRN	??0CRegion@@QAE@XZ:PROC				; CRegion::CRegion
EXTRN	??0CIndexedGeometry@@QAE@PAVCWindEngine@@_N@Z:PROC ; CIndexedGeometry::CIndexedGeometry
EXTRN	??1CIndexedGeometry@@QAE@XZ:PROC		; CIndexedGeometry::~CIndexedGeometry
EXTRN	?CombineStrips@CIndexedGeometry@@QAEX_N@Z:PROC	; CIndexedGeometry::CombineStrips
EXTRN	?ComputeExtents@CIndexedGeometry@@QBEXAAVCRegion@@@Z:PROC ; CIndexedGeometry::ComputeExtents
EXTRN	?Transform@CIndexedGeometry@@QAEXABVCTransform@@@Z:PROC ; CIndexedGeometry::Transform
EXTRN	?GetStripsPointer@CIndexedGeometry@@QBEPAPAGG@Z:PROC ; CIndexedGeometry::GetStripsPointer
EXTRN	?GetTriangleCount@CIndexedGeometry@@QBEIG@Z:PROC ; CIndexedGeometry::GetTriangleCount
EXTRN	?ComputeWindEffect@CIndexedGeometry@@QAE_NG@Z:PROC ; CIndexedGeometry::ComputeWindEffect
EXTRN	?ClearCache@CIdvBezierSpline@@SAXXZ:PROC	; CIdvBezierSpline::ClearCache
EXTRN	?InitTables@SIdvLeafInfo@@QAEXH@Z:PROC		; SIdvLeafInfo::InitTables
EXTRN	?ConvertMemoryToArray@CTreeFileAccess@@QAEPAEAAI@Z:PROC ; CTreeFileAccess::ConvertMemoryToArray
EXTRN	?ParseFloat@CTreeFileAccess@@QAEMXZ:PROC	; CTreeFileAccess::ParseFloat
EXTRN	?ParseInt@CTreeFileAccess@@QAEHXZ:PROC		; CTreeFileAccess::ParseInt
EXTRN	?ParseString@CTreeFileAccess@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:PROC ; CTreeFileAccess::ParseString
EXTRN	?SaveFloat@CTreeFileAccess@@QAEXM@Z:PROC	; CTreeFileAccess::SaveFloat
EXTRN	?SaveInt@CTreeFileAccess@@QAEXH@Z:PROC		; CTreeFileAccess::SaveInt
EXTRN	?SaveString@CTreeFileAccess@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CTreeFileAccess::SaveString
EXTRN	??0CTreeEngine@@QAE@PAVCIndexedGeometry@@@Z:PROC ; CTreeEngine::CTreeEngine
EXTRN	?Compute@CTreeEngine@@QAEXM@Z:PROC		; CTreeEngine::Compute
EXTRN	?Clone@CTreeEngine@@QBEXPAV1@ABVCVec3@@I@Z:PROC	; CTreeEngine::Clone
EXTRN	?Parse@CTreeEngine@@QAE_NAAVCTreeFileAccess@@@Z:PROC ; CTreeEngine::Parse
EXTRN	?Save@CTreeEngine@@QBEXAAVCTreeFileAccess@@_N@Z:PROC ; CTreeEngine::Save
EXTRN	?FreeTransientData@CTreeEngine@@QAEXXZ:PROC	; CTreeEngine::FreeTransientData
EXTRN	?GetSize@CTreeEngine@@QAEXAAM0@Z:PROC		; CTreeEngine::GetSize
EXTRN	?SetSize@CTreeEngine@@QAEXMM@Z:PROC		; CTreeEngine::SetSize
EXTRN	?SetBranchTextureFilename@CTreeEngine@@QAEXPBD@Z:PROC ; CTreeEngine::SetBranchTextureFilename
EXTRN	?SetLeafTextureFilename@CTreeEngine@@QAEXIPBD@Z:PROC ; CTreeEngine::SetLeafTextureFilename
EXTRN	?ComputeLod@CTreeEngine@@QAEMXZ:PROC		; CTreeEngine::ComputeLod
EXTRN	?GetLodLimits@CTreeEngine@@QBEXAAM0@Z:PROC	; CTreeEngine::GetLodLimits
EXTRN	?SetLodLimits@CTreeEngine@@QAEXMM@Z:PROC	; CTreeEngine::SetLodLimits
EXTRN	?SaveLodInfo@CTreeEngine@@QBEXAAVCTreeFileAccess@@@Z:PROC ; CTreeEngine::SaveLodInfo
EXTRN	?ParseLodInfo@CTreeEngine@@QAEXAAVCTreeFileAccess@@@Z:PROC ; CTreeEngine::ParseLodInfo
EXTRN	?SaveTextureControls@CTreeEngine@@QBEXAAVCTreeFileAccess@@@Z:PROC ; CTreeEngine::SaveTextureControls
EXTRN	?ParseTextureControls@CTreeEngine@@QAEXAAVCTreeFileAccess@@@Z:PROC ; CTreeEngine::ParseTextureControls
EXTRN	?SaveFlareInfo@CTreeEngine@@QBEXAAVCTreeFileAccess@@@Z:PROC ; CTreeEngine::SaveFlareInfo
EXTRN	?ParseFlareInfo@CTreeEngine@@QAEXAAVCTreeFileAccess@@@Z:PROC ; CTreeEngine::ParseFlareInfo
EXTRN	?SaveFlareSeed@CTreeEngine@@QBEXAAVCTreeFileAccess@@@Z:PROC ; CTreeEngine::SaveFlareSeed
EXTRN	?ParseFlareSeed@CTreeEngine@@QAEXAAVCTreeFileAccess@@@Z:PROC ; CTreeEngine::ParseFlareSeed
EXTRN	?SetSeed@CTreeEngine@@QAEXI@Z:PROC		; CTreeEngine::SetSeed
EXTRN	??0CWindEngine@@QAE@XZ:PROC			; CWindEngine::CWindEngine
EXTRN	?SetWindStrength@CWindEngine@@QAEMMMM@Z:PROC	; CWindEngine::SetWindStrength
EXTRN	?SetWindStrengthAndLeafAngles@CWindEngine@@QAEXMPBM0I@Z:PROC ; CWindEngine::SetWindStrengthAndLeafAngles
EXTRN	?Init@CWindEngine@@QAEXABUSIdvWindInfo@@@Z:PROC	; CWindEngine::Init
EXTRN	?SetLocalMatrices@CWindEngine@@QAEXII@Z:PROC	; CWindEngine::SetLocalMatrices
EXTRN	?ResetLeafWindState@CWindEngine@@QAEXXZ:PROC	; CWindEngine::ResetLeafWindState
EXTRN	??0CSimpleBillboard@@QAE@XZ:PROC		; CSimpleBillboard::CSimpleBillboard
EXTRN	?ComputeUnitBillboard@CSimpleBillboard@@SAXPBM@Z:PROC ; CSimpleBillboard::ComputeUnitBillboard
EXTRN	??0CLightingEngine@@QAE@XZ:PROC			; CLightingEngine::CLightingEngine
EXTRN	?ComputeLeafStaticLighting@CLightingEngine@@QAEXABVCVec3@@PAV?$vector@PAVCBillboardLeaf@@V?$allocator@PAVCBillboardLeaf@@@std@@@std@@H@Z:PROC ; CLightingEngine::ComputeLeafStaticLighting
EXTRN	?SetLightAttributes@CLightingEngine@@SAXIPBM@Z:PROC ; CLightingEngine::SetLightAttributes
EXTRN	?Save@CLightingEngine@@QAEXAAVCTreeFileAccess@@@Z:PROC ; CLightingEngine::Save
EXTRN	?Parse@CLightingEngine@@QAEXAAVCTreeFileAccess@@@Z:PROC ; CLightingEngine::Parse
EXTRN	??0CLeafGeometry@@QAE@PAVCWindEngine@@@Z:PROC	; CLeafGeometry::CLeafGeometry
EXTRN	??1CLeafGeometry@@QAE@XZ:PROC			; CLeafGeometry::~CLeafGeometry
EXTRN	?Invalidate@CLeafGeometry@@QAEXXZ:PROC		; CLeafGeometry::Invalidate
EXTRN	?GetLeafBillboardTable@CLeafGeometry@@QBEPBMAAI@Z:PROC ; CLeafGeometry::GetLeafBillboardTable
EXTRN	?ComputeExtents@CLeafGeometry@@QBEXAAVCRegion@@@Z:PROC ; CLeafGeometry::ComputeExtents
EXTRN	?Transform@CLeafGeometry@@QAEXABVCTransform@@@Z:PROC ; CLeafGeometry::Transform
EXTRN	?Init@CLeafGeometry@@QAEXGPBV?$vector@PAVCBillboardLeaf@@V?$allocator@PAVCBillboardLeaf@@@std@@@std@@ABUSIdvLeafInfo@@@Z:PROC ; CLeafGeometry::Init
EXTRN	?SetTextureCoords@CLeafGeometry@@QAEXIPBM@Z:PROC ; CLeafGeometry::SetTextureCoords
EXTRN	?Update@CLeafGeometry@@QAEXAAUSLeaf@SGeometry@CSpeedTreeRT@@GMMM@Z:PROC ; CLeafGeometry::Update
EXTRN	??0CFrondEngine@@QAE@XZ:PROC			; CFrondEngine::CFrondEngine
EXTRN	??1CFrondEngine@@QAE@XZ:PROC			; CFrondEngine::~CFrondEngine
EXTRN	?GetLevel@CFrondEngine@@QBEHXZ:PROC		; CFrondEngine::GetLevel
EXTRN	?Compute@CFrondEngine@@QAEXPAVCIndexedGeometry@@PAVCLightingEngine@@@Z:PROC ; CFrondEngine::Compute
EXTRN	?SetTextureCoords@CFrondEngine@@QAEXPAVCIndexedGeometry@@IPBM_N@Z:PROC ; CFrondEngine::SetTextureCoords
EXTRN	?Parse@CFrondEngine@@QAEXAAVCTreeFileAccess@@@Z:PROC ; CFrondEngine::Parse
EXTRN	?Save@CFrondEngine@@QBEXAAVCTreeFileAccess@@@Z:PROC ; CFrondEngine::Save
EXTRN	??4CFrondEngine@@QAEABV0@ABV0@@Z:PROC		; CFrondEngine::operator=
EXTRN	??0CProjectedShadow@@QAE@XZ:PROC		; CProjectedShadow::CProjectedShadow
EXTRN	?Save@CProjectedShadow@@QBEXAAVCTreeFileAccess@@@Z:PROC ; CProjectedShadow::Save
EXTRN	?Parse@CProjectedShadow@@QAEXAAVCTreeFileAccess@@@Z:PROC ; CProjectedShadow::Parse
EXTRN	?ComputeTexCoords@CProjectedShadow@@QBEXPAVCIndexedGeometry@@VCVec3@@MPAM@Z:PROC ; CProjectedShadow::ComputeTexCoords
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_UninitUse:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	?m_cCameraPos@CIdvCamera@@1VCVec3@@A:BYTE	; CIdvCamera::m_cCameraPos
EXTRN	?m_cCameraDir@CIdvCamera@@1VCVec3@@A:BYTE	; CIdvCamera::m_cCameraDir
EXTRN	?m_pLightingEngine@CIdvBranch@@0PAVCLightingEngine@@A:DWORD ; CIdvBranch::m_pLightingEngine
EXTRN	?m_pFrondEngine@CIdvBranch@@0PAVCFrondEngine@@A:DWORD ; CIdvBranch::m_pFrondEngine
EXTRN	?m_bPropagateFlexibility@CIdvBranch@@0_NA:BYTE	; CIdvBranch::m_bPropagateFlexibility
EXTRN	?m_fTime@CWindEngine@@0MA:DWORD			; CWindEngine::m_fTime
EXTRN	?m_cWindMatrices@CWindEngine@@0VCWindMatrices@@A:QWORD ; CWindEngine::m_cWindMatrices
EXTRN	?m_acUnitBillboard@CSimpleBillboard@@0PAVCVec3@@A:BYTE ; CSimpleBillboard::m_acUnitBillboard
EXTRN	?m_abLightEnabled@CLightingEngine@@0PA_NA:QWORD	; CLightingEngine::m_abLightEnabled
EXTRN	?m_afLightAttributes@CLightingEngine@@0PAY0BA@MA:BYTE ; CLightingEngine::m_afLightAttributes
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A DB 010H DUP (?) ; SInstanceList::m_vUniqueTrees
?g_strError@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 01cH DUP (?) ; g_strError
?g_strKey@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 01cH DUP (?) ; g_strKey
_BSS	ENDS
CRT$XCU	SEGMENT
??m_vUniqueTrees$initializer$@SInstanceList@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A@@YAXXZ ; ??m_vUniqueTrees$initializer$@SInstanceList@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42a80000
CONST	SEGMENT
__real@42a80000 DD 042a80000r			; 84
CONST	ENDS
;	COMDAT __real@42652ee1
CONST	SEGMENT
__real@42652ee1 DD 042652ee1r			; 57.2958
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3d8f5c29
CONST	SEGMENT
__real@3d8f5c29 DD 03d8f5c29r			; 0.07
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@IdvFileError@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IdvFileError@@8 DD FLAT:??_R0?AVIdvFileError@@@8 ; IdvFileError::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IdvFileError@@8
rdata$r	ENDS
;	COMDAT ??_R2IdvFileError@@8
rdata$r	SEGMENT
??_R2IdvFileError@@8 DD FLAT:??_R1A@?0A@EA@IdvFileError@@8 ; IdvFileError::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3IdvFileError@@8
rdata$r	SEGMENT
??_R3IdvFileError@@8 DD 00H				; IdvFileError::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2IdvFileError@@8
rdata$r	ENDS
;	COMDAT ??_R4IdvFileError@@6B@
rdata$r	SEGMENT
??_R4IdvFileError@@6B@ DD 00H				; IdvFileError::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIdvFileError@@@8
	DD	FLAT:??_R3IdvFileError@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_1EG@ODKBEHFN@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@
CONST	SEGMENT
??_C@_1EG@ODKBEHFN@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'n'
	DB	00H, 's', 00H, 'p', 00H, 'o', 00H, 's', 00H, 'e', 00H, 'd', 00H
	DB	'"', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LIAHLBAO@vector?5iterator?5range?5transpose@
CONST	SEGMENT
??_C@_0CB@LIAHLBAO@vector?5iterator?5range?5transpose@ DB 'vector iterato'
	DB	'r range transposed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1HE@KBMFDAFB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@
CONST	SEGMENT
??_C@_1HE@KBMFDAFB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, ' '
	DB	00H, 'a', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'r', 00H
	DB	'o', 00H, 'm', 00H, ' ', 00H, 'd', 00H, 'i', 00H, 'f', 00H, 'f'
	DB	00H, 'e', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H
	DB	'c', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n'
	DB	00H, 'e', 00H, 'r', 00H, 's', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@PBEELKIF@vector?5iterators?5in?5range?5are?5f@
CONST	SEGMENT
??_C@_0DI@PBEELKIF@vector?5iterators?5in?5range?5are?5f@ DB 'vector itera'
	DB	'tors in range are from different containers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1COI@GKKHJOON@?$AA?$CC?$AAY?$AAo?$AAu?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAc?$AAo?$AAn@
CONST	SEGMENT
??_C@_1COI@GKKHJOON@?$AA?$CC?$AAY?$AAo?$AAu?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAc?$AAo?$AAn@ DB '"'
	DB	00H, 'Y', 00H, 'o', 00H, 'u', 00H, ' ', 00H, 'c', 00H, 'a', 00H
	DB	'n', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'n', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e'
	DB	00H, ' ', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H
	DB	'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'i', 00H, 't', 00H, 's', 00H, 'e'
	DB	00H, 'l', 00H, 'f', 00H, '.', 00H, ' ', 00H, 'S', 00H, 'e', 00H
	DB	'e', 00H, ' ', 00H, 'N', 00H, '4', 00H, '9', 00H, '5', 00H, '0'
	DB	00H, ' ', 00H, '[', 00H, 'r', 00H, 'e', 00H, 's', 00H, '.', 00H
	DB	'o', 00H, 'n', 00H, '.', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u'
	DB	00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H, ']', 00H
	DB	'/', 00H, '1', 00H, '.', 00H, '3', 00H, ':', 00H, ' ', 00H, '"'
	DB	00H, ' ', 00H, '"', 00H, 'I', 00H, 'f', 00H, ' ', 00H, 'a', 00H
	DB	' ', 00H, 'f', 00H, 'u', 00H, 'n', 00H, 'c', 00H, 't', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'i'
	DB	00H, 's', 00H, ' ', 00H, 'b', 00H, 'o', 00H, 'u', 00H, 'n', 00H
	DB	'd', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, 'n'
	DB	00H, ' ', 00H, 'r', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H
	DB	'e', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 'p', 00H
	DB	'a', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 't', 00H, 'e'
	DB	00H, 'r', 00H, ',', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H
	DB	' ', 00H, 'i', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, 'a', 00H, 't', 00H, 'i', 00H
	DB	'o', 00H, 'n', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'y', 00H, ' '
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, 'u', 00H, 'm', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'h', 00H, 'a', 00H, 't', 00H, ' ', 00H, '"'
	DB	00H, ' ', 00H, '"', 00H, 't', 00H, 'h', 00H, 'i', 00H, 's', 00H
	DB	' ', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'i', 00H, 's', 00H
	DB	' ', 00H, 'a', 00H, ' ', 00H, 'u', 00H, 'n', 00H, 'i', 00H, 'q'
	DB	00H, 'u', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'f', 00H
	DB	'e', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'i', 00H
	DB	's', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, ',', 00H, ' ', 00H, 'e', 00H
	DB	'x', 00H, 'c', 00H, 'e', 00H, 'p', 00H, 't', 00H, ' ', 00H, 't'
	DB	00H, 'h', 00H, 'a', 00H, 't', 00H, ' ', 00H, 't', 00H, 'h', 00H
	DB	'e', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'p', 00H, 'a', 00H
	DB	's', 00H, 's', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'o'
	DB	00H, ' ', 00H, '"', 00H, ' ', 00H, '"', 00H, 'a', 00H, ' ', 00H
	DB	'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, '-', 00H, 'a', 00H, 's'
	DB	00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'm', 00H, 'e', 00H
	DB	'n', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'm', 00H
	DB	'a', 00H, 'y', 00H, ' ', 00H, 'b', 00H, 'e', 00H, ' ', 00H, 'a'
	DB	00H, ' ', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r', 00H
	DB	'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'o'
	DB	00H, ' ', 00H, '*', 00H, 't', 00H, 'h', 00H, 'i', 00H, 's', 00H
	DB	' ', 00H, '(', 00H, '[', 00H, 'l', 00H, 'i', 00H, 'b', 00H, '.'
	DB	00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '.', 00H
	DB	'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 'd', 00H, 'f', 00H, 'r'
	DB	00H, 'o', 00H, 'm', 00H, ']', 00H, ')', 00H, '.', 00H, '"', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BGJ@OHAFKLGF@You?5cannot?5concatenate?5the?5same@
CONST	SEGMENT
??_C@_0BGJ@OHAFKLGF@You?5cannot?5concatenate?5the?5same@ DB 'You cannot c'
	DB	'oncatenate the same moved string to itself. See N4950 [res.on'
	DB	'.arguments]/1.3: If a function argument is bound to an rvalue'
	DB	' reference parameter, the implementation may assume that this'
	DB	' parameter is a unique reference to this argument, except tha'
	DB	't the argument passed to a move-assignment operator may be a '
	DB	'reference to *this ([lib.types.movedfrom]).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
CONST	SEGMENT
??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ DB '"'
	DB	00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p', 00H
	DB	'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'p', 00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'b', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'o', 00H, 'f'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 'n', 00H, '-', 00H, 'z', 00H
	DB	'e', 00H, 'r', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
CONST	SEGMENT
??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ DB 'null pointe'
	DB	'r cannot point to a block of non-zero size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@DJDGNIII@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@
CONST	SEGMENT
??_C@_1EA@DJDGNIII@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 'i'
	DB	00H, 'b', 00H, 'l', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CAOBBIOC@vector?5iterators?5incompatible@
CONST	SEGMENT
??_C@_0BO@CAOBBIOC@vector?5iterators?5incompatible@ DB 'vector iterators '
	DB	'incompatible', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@LDPPKMGP@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn@
CONST	SEGMENT
??_C@_1FG@LDPPKMGP@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'm', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, ' ', 00H, 'v', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'i', 00H, 't', 00H, 'e'
	DB	00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'p', 00H, 'a', 00H, 's', 00H, 't', 00H, ' ', 00H, 'e', 00H, 'n'
	DB	00H, 'd', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OAAAAGPM@can?8t?5increment?5vector?5iterator@
CONST	SEGMENT
??_C@_0CJ@OAAAAGPM@can?8t?5increment?5vector?5iterator@ DB 'can''t increm'
	DB	'ent vector iterator past end', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1FM@ICPJNHLL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn@
CONST	SEGMENT
??_C@_1FM@ICPJNHLL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'm', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'v', 00H
	DB	'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MNNBKIBC@can?8t?5increment?5invalidated?5vec@
CONST	SEGMENT
??_C@_0CM@MNNBKIBC@can?8t?5increment?5invalidated?5vec@ DB 'can''t increm'
	DB	'ent invalidated vector iterator', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1GI@EDCILPL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn@
CONST	SEGMENT
??_C@_1GI@EDCILPL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'm', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, ' ', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'u', 00H, 'e', 00H, '-', 00H, 'i', 00H, 'n', 00H, 'i', 00H, 't'
	DB	00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@KEKNBAEB@can?8t?5increment?5value?9initializ@
CONST	SEGMENT
??_C@_0DC@KEKNBAEB@can?8t?5increment?5value?9initializ@ DB 'can''t increm'
	DB	'ent value-initialized vector iterator', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@OADAPGGK@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
CONST	SEGMENT
??_C@_1EA@OADAPGGK@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ DB '"'
	DB	00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	' ', 00H, 's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r'
	DB	00H, 'i', 00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H
	DB	't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a'
	DB	00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1ME@EHBBECCK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1ME@EHBBECCK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H
	DB	'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M'
	DB	00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H
	DB	'.', 00H, '4', 00H, '0', 00H, '.', 00H, '3', 00H, '3', 00H, '8'
	DB	00H, '0', 00H, '7', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@JKKBGBPG@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@JKKBGBPG@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'40.33807\include\xstring', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@
CONST	SEGMENT
??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@ DB 'string subscrip'
	DB	't out of range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EM@BEMPOGMM@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi@
CONST	SEGMENT
??_C@_1EM@BEMPOGMM@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 's', 00H, 'e', 00H, ' '
	DB	00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, 's'
	DB	00H, 'i', 00H, 'd', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EAMOGAIE@vector?5erase?5iterator?5outside?5r@
CONST	SEGMENT
??_C@_0CE@EAMOGAIE@vector?5erase?5iterator?5outside?5r@ DB 'vector erase '
	DB	'iterator outside range', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
CONST	SEGMENT
??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r'
	DB	00H, 'i', 00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H
	DB	't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a'
	DB	00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
CONST	SEGMENT
??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@ DB 'vector subscrip'
	DB	't out of range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1GC@JDCKOLAC@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1GC@JDCKOLAC@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 'o', 00H
	DB	'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r'
	DB	00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, ' ', 00H, 'v', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'i'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, '"', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@MDHADBHN@can?8t?5dereference?5out?5of?5range?5@
CONST	SEGMENT
??_C@_0CP@MDHADBHN@can?8t?5dereference?5out?5of?5range?5@ DB 'can''t dere'
	DB	'ference out of range vector iterator', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1GA@CLCDIGKJ@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1GA@CLCDIGKJ@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 'i', 00H
	DB	'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'"', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PGFNEDAH@can?8t?5dereference?5invalidated?5v@
CONST	SEGMENT
??_C@_0CO@PGFNEDAH@can?8t?5dereference?5invalidated?5v@ DB 'can''t derefe'
	DB	'rence invalidated vector iterator', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1GM@FNBFNBEL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1GM@FNBFNBEL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 'v', 00H
	DB	'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, '-', 00H, 'i', 00H, 'n'
	DB	00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'v', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H
	DB	'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M'
	DB	00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H
	DB	'.', 00H, '4', 00H, '0', 00H, '.', 00H, '3', 00H, '3', 00H, '8'
	DB	00H, '0', 00H, '7', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'v', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'40.33807\include\vector', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@CHADHGFF@can?8t?5dereference?5value?9initial@
CONST	SEGMENT
??_C@_0DE@CHADHGFF@can?8t?5dereference?5value?9initial@ DB 'can''t derefe'
	DB	'rence value-initialized vector iterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MINPLDH@CSpeedTreeRT?3?3SetFrondTextureFi@
CONST	SEGMENT
??_C@_0CG@MINPLDH@CSpeedTreeRT?3?3SetFrondTextureFi@ DB 'CSpeedTreeRT::Se'
	DB	'tFrondTextureFilename', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z@4JA DD 0dfeH ; `CSpeedTreeRT::SetFrondTextureFilename'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CF@EPFLDMMH@CSpeedTreeRT?3?3SetLeafTextureFil@
CONST	SEGMENT
??_C@_0CF@EPFLDMMH@CSpeedTreeRT?3?3SetLeafTextureFil@ DB 'CSpeedTreeRT::S'
	DB	'etLeafTextureFilename', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@LIMCGLOF@SetLeafTextureFilename?$CI?$CJ?5has?5no@
CONST	SEGMENT
??_C@_0FD@LIMCGLOF@SetLeafTextureFilename?$CI?$CJ?5has?5no@ DB 'SetLeafTe'
	DB	'xtureFilename() has no effect after DeleteTransientData() has'
	DB	' been called', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z@4JA DD 0deaH ; `CSpeedTreeRT::SetLeafTextureFilename'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CH@MDIENIJJ@CSpeedTreeRT?3?3SetBranchTextureF@
CONST	SEGMENT
??_C@_0CH@MDIENIJJ@CSpeedTreeRT?3?3SetBranchTextureF@ DB 'CSpeedTreeRT::S'
	DB	'etBranchTextureFilename', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@PAIDPLB@SetBranchTextureFilename?$CI?$CJ?5has?5@
CONST	SEGMENT
??_C@_0FF@PAIDPLB@SetBranchTextureFilename?$CI?$CJ?5has?5@ DB 'SetBranchT'
	DB	'extureFilename() has no effect after DeleteTransientData() ha'
	DB	's been called', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z@4JA DD 0dd6H ; `CSpeedTreeRT::SetBranchTextureFilename'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CE@MGEADCOJ@CSpeedTreeRT?3?3SetFrondTextureCo@
CONST	SEGMENT
??_C@_0CE@MGEADCOJ@CSpeedTreeRT?3?3SetFrondTextureCo@ DB 'CSpeedTreeRT::S'
	DB	'etFrondTextureCoords', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DILLEMNK@CSpeedTreeRT?3?3SetLeafTextureCoo@
CONST	SEGMENT
??_C@_0CD@DILLEMNK@CSpeedTreeRT?3?3SetLeafTextureCoo@ DB 'CSpeedTreeRT::S'
	DB	'etLeafTextureCoords', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z@4JA DD 0d3aH ; `CSpeedTreeRT::SetLeafTextureCoords'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BK@DHPJOIPO@CSpeedTreeRT?3?3GetTextures@
CONST	SEGMENT
??_C@_0BK@DHPJOIPO@CSpeedTreeRT?3?3GetTextures@ DB 'CSpeedTreeRT::GetText'
	DB	'ures', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@IJNCGOLC@CSpeedTreeRT?3?3GetLeafLodSizeAdj@
CONST	SEGMENT
??_C@_0CI@IJNCGOLC@CSpeedTreeRT?3?3GetLeafLodSizeAdj@ DB 'CSpeedTreeRT::G'
	DB	'etLeafLodSizeAdjustments', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GetLeafGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@2@F@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetLeafGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@2@F@Z@4JA DD 0ba7H ; `CSpeedTreeRT::GetLeafGeometry'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EF@KKLNJEEH@no?5frond?5geometry?5exists?0?5possi@
CONST	SEGMENT
??_C@_0EF@KKLNJEEH@no?5frond?5geometry?5exists?0?5possi@ DB 'no frond geo'
	DB	'metry exists, possible prior call to DeleteFrondGeometry', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@MBPGMKE@no?5branch?5geometry?5exists?0?5poss@
CONST	SEGMENT
??_C@_0EH@MBPGMKE@no?5branch?5geometry?5exists?0?5poss@ DB 'no branch geo'
	DB	'metry exists, possible prior call to DeleteBranchGeometry', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ICBJPCHI@CSpeedTreeRT?3?3GetGeometry@
CONST	SEGMENT
??_C@_0BK@ICBJPCHI@CSpeedTreeRT?3?3GetGeometry@ DB 'CSpeedTreeRT::GetGeom'
	DB	'etry', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@2@KFFF@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@2@KFFF@Z@4JA DD 0b16H ; `CSpeedTreeRT::GetGeometry'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CM@DCKGMMJN@CSpeedTreeRT?3?3GetFrondGeometryM@
CONST	SEGMENT
??_C@_0CM@DCKGMMJN@CSpeedTreeRT?3?3GetFrondGeometryM@ DB 'CSpeedTreeRT::G'
	DB	'etFrondGeometryMapIndexes( )', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JHFKHJHB@CSpeedTreeRT?3?3DeleteFrondGeomet@
CONST	SEGMENT
??_C@_0CC@JHFKHJHB@CSpeedTreeRT?3?3DeleteFrondGeomet@ DB 'CSpeedTreeRT::D'
	DB	'eleteFrondGeometry', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@NOGHELOF@premature?5end?5of?5file?5reached?5p@
CONST	SEGMENT
??_C@_0DM@NOGHELOF@premature?5end?5of?5file?5reached?5p@ DB 'premature en'
	DB	'd of file reached parsing collision object info', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GLFBFGPF@unknown?5collision?5object?5type@
CONST	SEGMENT
??_C@_0BO@GLFBFGPF@unknown?5collision?5object?5type@ DB 'unknown collisio'
	DB	'n object type', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BIAOOLMK@malformed?5collision?5object?5info@
CONST	SEGMENT
??_C@_0CA@BIAOOLMK@malformed?5collision?5object?5info@ DB 'malformed coll'
	DB	'ision object info', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@MJBCMBLO@no?5collision?5objects?5are?5stored@
CONST	SEGMENT
??_C@_0CP@MJBCMBLO@no?5collision?5objects?5are?5stored@ DB 'no collision '
	DB	'objects are stored with this tree', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@IIFFBJOD@collision?5object?5index?5?$CI?$CFd?$CJ?5exc@
CONST	SEGMENT
??_C@_0DH@IIFFBJOD@collision?5object?5index?5?$CI?$CFd?$CJ?5exc@ DB 'coll'
	DB	'ision object index (%d) exceeds maximum index (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@PNMFDPBL@premature?5end?5of?5file?5reached?5p@
CONST	SEGMENT
??_C@_0DO@PNMFDPBL@premature?5end?5of?5file?5reached?5p@ DB 'premature en'
	DB	'd of file reached parsing texture coordinate info', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HDKMKOP@malformed?5texture?5coord?5info@
CONST	SEGMENT
??_C@_0BN@HDKMKOP@malformed?5texture?5coord?5info@ DB 'malformed texture '
	DB	'coord info', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FHOGECHL@premature?5end?5of?5file?5reached?5p@
CONST	SEGMENT
??_C@_0DE@FHOGECHL@premature?5end?5of?5file?5reached?5p@ DB 'premature en'
	DB	'd of file reached parsing new wind info', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IDEPHDPE@malformed?5new?5wind?5info@
CONST	SEGMENT
??_C@_0BI@IDEPHDPE@malformed?5new?5wind?5info@ DB 'malformed new wind inf'
	DB	'o', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JMFMAINC@premature?5end?5of?5file?5reached?5p@
CONST	SEGMENT
??_C@_0DD@JMFMAINC@premature?5end?5of?5file?5reached?5p@ DB 'premature en'
	DB	'd of file reached parsing new lod info', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JMAANHEL@malformed?5lod?5info@
CONST	SEGMENT
??_C@_0BD@JMAANHEL@malformed?5lod?5info@ DB 'malformed lod info', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVIdvFileError@@@8??0IdvFileError@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVIdvFileError@@@8??0IdvFileError@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVIdvFileError@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0IdvFileError@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVIdvFileError@@@8
data$r	SEGMENT
??_R0?AVIdvFileError@@@8 DD FLAT:??_7type_info@@6B@	; IdvFileError `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIdvFileError@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVIdvFileError@@
xdata$x	SEGMENT
__CTA3?AVIdvFileError@@ DD 03H
	DD	FLAT:__CT??_R0?AVIdvFileError@@@8??0IdvFileError@@QAE@ABV0@@Z12
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVIdvFileError@@
xdata$x	SEGMENT
__TI3?AVIdvFileError@@ DD 00H
	DD	FLAT:??1IdvFileError@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVIdvFileError@@
xdata$x	ENDS
;	COMDAT ??_C@_0CE@LMHEPLMK@CSpeedTreeRT?3?3NotifyAllTreesOfE@
CONST	SEGMENT
??_C@_0CE@LMHEPLMK@CSpeedTreeRT?3?3NotifyAllTreesOfE@ DB 'CSpeedTreeRT::N'
	DB	'otifyAllTreesOfEvent', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BADCNPAN@CSpeedTreeRT?3?3ComputeLeafStatic@
CONST	SEGMENT
??_C@_0CI@BADCNPAN@CSpeedTreeRT?3?3ComputeLeafStatic@ DB 'CSpeedTreeRT::C'
	DB	'omputeLeafStaticLighting', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JHCKAGHJ@CSpeedTreeRT?3?3GetFrondTriangleC@
CONST	SEGMENT
??_C@_0CE@JHCKAGHJ@CSpeedTreeRT?3?3GetFrondTriangleC@ DB 'CSpeedTreeRT::G'
	DB	'etFrondTriangleCount', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LDBPOABP@CSpeedTreeRT?3?3GetBranchTriangle@
CONST	SEGMENT
??_C@_0CF@LDBPOABP@CSpeedTreeRT?3?3GetBranchTriangle@ DB 'CSpeedTreeRT::G'
	DB	'etBranchTriangleCount', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@OEGBIMIE@GetBoundingBox?$CI?$CJ?5expects?5a?5non?9@
CONST	SEGMENT
??_C@_0CO@OEGBIMIE@GetBoundingBox?$CI?$CJ?5expects?5a?5non?9@ DB 'GetBoun'
	DB	'dingBox() expects a non-NULL parameter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IBNIGHFD@CSpeedTreeRT?3?3GetLeafBillboardT@
CONST	SEGMENT
??_C@_0CE@IBNIGHFD@CSpeedTreeRT?3?3GetLeafBillboardT@ DB 'CSpeedTreeRT::G'
	DB	'etLeafBillboardTable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MCKNGMH@CSpeedTreeRT?3?3DeleteBranchGeome@
CONST	SEGMENT
??_C@_0CD@MCKNGMH@CSpeedTreeRT?3?3DeleteBranchGeome@ DB 'CSpeedTreeRT::De'
	DB	'leteBranchGeometry', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GetDiscreteLeafLodLevel@CSpeedTreeRT@@QBEGM@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetDiscreteLeafLodLevel@CSpeedTreeRT@@QBEGM@Z@4JA DD 0864H ; `CSpeedTreeRT::GetDiscreteLeafLodLevel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??GetDiscreteFrondLodLevel@CSpeedTreeRT@@QBEFM@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetDiscreteFrondLodLevel@CSpeedTreeRT@@QBEFM@Z@4JA DD 0850H ; `CSpeedTreeRT::GetDiscreteFrondLodLevel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??GetDiscreteBranchLodLevel@CSpeedTreeRT@@QBEFM@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetDiscreteBranchLodLevel@CSpeedTreeRT@@QBEFM@Z@4JA DD 083cH ; `CSpeedTreeRT::GetDiscreteBranchLodLevel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DJ@ECEAEPMG@SetLodLevel?$CI?$CJ?5expects?5a?5value?5i@
CONST	SEGMENT
??_C@_0DJ@ECEAEPMG@SetLodLevel?$CI?$CJ?5expects?5a?5value?5i@ DB 'SetLodL'
	DB	'evel() expects a value in the range of 0.0 to 1.0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NEFNJPOG@CSpeedTreeRT?3?3ComputeLodLevel@
CONST	SEGMENT
??_C@_0BO@NEFNJPOG@CSpeedTreeRT?3?3ComputeLodLevel@ DB 'CSpeedTreeRT::Com'
	DB	'puteLodLevel', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LNJAODIF@CSpeedTreeRT?3?3SetLocalMatrices@
CONST	SEGMENT
??_C@_0BP@LNJAODIF@CSpeedTreeRT?3?3SetLocalMatrices@ DB 'CSpeedTreeRT::Se'
	DB	'tLocalMatrices', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@IGKHMMPL@SetLocalMatrices?$CI?$CJ?5has?5no?5effec@
CONST	SEGMENT
??_C@_0EB@IGKHMMPL@SetLocalMatrices?$CI?$CJ?5has?5no?5effec@ DB 'SetLocal'
	DB	'Matrices() has no effect after Compute() has been called', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@LOGCFILD@SetLocalMatrices?$CI?$CJ?5parameters?5e@
CONST	SEGMENT
??_C@_0DN@LOGCFILD@SetLocalMatrices?$CI?$CJ?5parameters?5e@ DB 'SetLocalM'
	DB	'atrices() parameters exceed available wind matrices', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CAFNOPKO@CSpeedTreeRT?3?3SetWindMatrix@
CONST	SEGMENT
??_C@_0BM@CAFNOPKO@CSpeedTreeRT?3?3SetWindMatrix@ DB 'CSpeedTreeRT::SetWi'
	DB	'ndMatrix', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FDEHPAEM@SetWindMatrix?$CI?$CJ?5?9?5matrix?5index?5@
CONST	SEGMENT
??_C@_0CM@FDEHPAEM@SetWindMatrix?$CI?$CJ?5?9?5matrix?5index?5@ DB 'SetWin'
	DB	'dMatrix() - matrix index out of range', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@CFNPDLCE@SetWindMatrix?$CI?$CJ?5requires?5a?5non?9@
CONST	SEGMENT
??_C@_0DD@CFNPDLCE@SetWindMatrix?$CI?$CJ?5requires?5a?5non?9@ DB 'SetWind'
	DB	'Matrix() requires a non-NULL matrix pointer', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z@4JA DD 07a7H ; `CSpeedTreeRT::SetWindMatrix'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CB@LHALGCIH@CSpeedTreeRT?3?3SetNumWindMatrice@
CONST	SEGMENT
??_C@_0CB@LHALGCIH@CSpeedTreeRT?3?3SetNumWindMatrice@ DB 'CSpeedTreeRT::S'
	DB	'etNumWindMatrices', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GJONFFJM@CSpeedTreeRT?3?3SetWindStrength@
CONST	SEGMENT
??_C@_0BO@GJONFFJM@CSpeedTreeRT?3?3SetWindStrength@ DB 'CSpeedTreeRT::Set'
	DB	'WindStrength', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@IEKNEGPD@SetWindStrength?$CI?$CJ?5expects?5new?5w@
CONST	SEGMENT
??_C@_0DD@IEKNEGPD@SetWindStrength?$CI?$CJ?5expects?5new?5w@ DB 'SetWindS'
	DB	'trength() expects new wind strength >= 0.0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JBDMJJKN@CSpeedTreeRT?3?3SetFrondWindMetho@
CONST	SEGMENT
??_C@_0CB@JBDMJJKN@CSpeedTreeRT?3?3SetFrondWindMetho@ DB 'CSpeedTreeRT::S'
	DB	'etFrondWindMethod', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@HKHBLIMN@SetFrondWindMethod?$CI?$CJ?5has?5no?5eff@
CONST	SEGMENT
??_C@_0ED@HKHBLIMN@SetFrondWindMethod?$CI?$CJ?5has?5no?5eff@ DB 'SetFrond'
	DB	'WindMethod() has no effect after Compute() has been called', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MHEPFOGG@CSpeedTreeRT?3?3SetBranchWindMeth@
CONST	SEGMENT
??_C@_0CC@MHEPFOGG@CSpeedTreeRT?3?3SetBranchWindMeth@ DB 'CSpeedTreeRT::S'
	DB	'etBranchWindMethod', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@IEBPHJNM@SetBranchWindMethod?$CI?$CJ?5has?5no?5ef@
CONST	SEGMENT
??_C@_0EE@IEBPHJNM@SetBranchWindMethod?$CI?$CJ?5has?5no?5ef@ DB 'SetBranc'
	DB	'hWindMethod() has no effect after Compute() has been called', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KIINICCD@CSpeedTreeRT?3?3SetLeafWindMethod@
CONST	SEGMENT
??_C@_0CA@KIINICCD@CSpeedTreeRT?3?3SetLeafWindMethod@ DB 'CSpeedTreeRT::S'
	DB	'etLeafWindMethod', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@JAGFALME@SetLeafWindMethod?$CI?$CJ?5has?5no?5effe@
CONST	SEGMENT
??_C@_0EC@JAGFALME@SetLeafWindMethod?$CI?$CJ?5has?5no?5effe@ DB 'SetLeafW'
	DB	'indMethod() has no effect after Compute() has been called', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KEPCIKJC@CSpeedTreeRT?3?3SetLeafRockingSta@
CONST	SEGMENT
??_C@_0CC@KEPCIKJC@CSpeedTreeRT?3?3SetLeafRockingSta@ DB 'CSpeedTreeRT::S'
	DB	'etLeafRockingState', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@IEFOEBHE@SetNumLeafRockingGroups?$CI?$CJ?5has?5n@
CONST	SEGMENT
??_C@_0EI@IEFOEBHE@SetNumLeafRockingGroups?$CI?$CJ?5has?5n@ DB 'SetNumLea'
	DB	'fRockingGroups() has no effect after Compute() has been calle'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JOANHIIK@CSpeedTreeRT?3?3ComputeWindEffect@
CONST	SEGMENT
??_C@_0CB@JOANHIIK@CSpeedTreeRT?3?3ComputeWindEffect@ DB 'CSpeedTreeRT::C'
	DB	'omputeWindEffects', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MNLGBDFC@CSpeedTreeRT?3?3SetTime@
CONST	SEGMENT
??_C@_0BG@MNLGBDFC@CSpeedTreeRT?3?3SetTime@ DB 'CSpeedTreeRT::SetTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GJIKHFEL@CSpeedTreeRT?3?3SetCamera@
CONST	SEGMENT
??_C@_0BI@GJIKHFEL@CSpeedTreeRT?3?3SetCamera@ DB 'CSpeedTreeRT::SetCamera'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@LIMPHDB@SetCamera?$CI?$CJ?5requires?5non?9NULL?5p@
CONST	SEGMENT
??_C@_0DM@LIMPHDB@SetCamera?$CI?$CJ?5requires?5non?9NULL?5p@ DB 'SetCamer'
	DB	'a() requires non-NULL position and direction values', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@INADBBLE@GetCamera?$CI?$CJ?5requires?5non?9NULL?5p@
CONST	SEGMENT
??_C@_0DM@INADBBLE@GetCamera?$CI?$CJ?5requires?5non?9NULL?5p@ DB 'GetCame'
	DB	'ra() requires non-NULL position and direction values', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LFKENEJP@CSpeedTreeRT?3?3SetFrondMaterial@
CONST	SEGMENT
??_C@_0BP@LFKENEJP@CSpeedTreeRT?3?3SetFrondMaterial@ DB 'CSpeedTreeRT::Se'
	DB	'tFrondMaterial', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@FAJAKGFC@SetFrondMaterial?$CI?$CJ?5has?5no?5effec@
CONST	SEGMENT
??_C@_0EB@FAJAKGFC@SetFrondMaterial?$CI?$CJ?5has?5no?5effec@ DB 'SetFrond'
	DB	'Material() has no effect after Compute() has been called', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KAODBPCG@CSpeedTreeRT?3?3SetLeafMaterial@
CONST	SEGMENT
??_C@_0BO@KAODBPCG@CSpeedTreeRT?3?3SetLeafMaterial@ DB 'CSpeedTreeRT::Set'
	DB	'LeafMaterial', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@MFLNIJGM@SetLeafMaterial?$CI?$CJ?5has?5no?5effect@
CONST	SEGMENT
??_C@_0EA@MFLNIJGM@SetLeafMaterial?$CI?$CJ?5has?5no?5effect@ DB 'SetLeafM'
	DB	'aterial() has no effect after Compute() has been called', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MCAEMOA@CSpeedTreeRT?3?3SetBranchMaterial@
CONST	SEGMENT
??_C@_0CA@MCAEMOA@CSpeedTreeRT?3?3SetBranchMaterial@ DB 'CSpeedTreeRT::Se'
	DB	'tBranchMaterial', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@FKMBDLKG@SetBranchMaterial?$CI?$CJ?5has?5no?5effe@
CONST	SEGMENT
??_C@_0EC@FKMBDLKG@SetBranchMaterial?$CI?$CJ?5has?5no?5effe@ DB 'SetBranc'
	DB	'hMaterial() has no effect after Compute() has been called', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HONICPFE@CSpeedTreeRT?3?3SetLightAttribute@
CONST	SEGMENT
??_C@_0CB@HONICPFE@CSpeedTreeRT?3?3SetLightAttribute@ DB 'CSpeedTreeRT::S'
	DB	'etLightAttributes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CLEAOJEL@CSpeedTreeRT?3?3SetFrondLightingM@
CONST	SEGMENT
??_C@_0CF@CLEAOJEL@CSpeedTreeRT?3?3SetFrondLightingM@ DB 'CSpeedTreeRT::S'
	DB	'etFrondLightingMethod', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@NOGLOGJ@SetFrondLightingMethod?$CI?$CJ?5has?5no@
CONST	SEGMENT
??_C@_0EH@NOGLOGJ@SetFrondLightingMethod?$CI?$CJ?5has?5no@ DB 'SetFrondLi'
	DB	'ghtingMethod() has no effect after Compute() has been called', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EJKAJJHJ@CSpeedTreeRT?3?3SetLeafLightingAd@
CONST	SEGMENT
??_C@_0CI@EJKAJJHJ@CSpeedTreeRT?3?3SetLeafLightingAd@ DB 'CSpeedTreeRT::S'
	DB	'etLeafLightingAdjustment', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@FDHHEDFI@SetLeafLightingAdjustment?$CI?$CJ?5has@
CONST	SEGMENT
??_C@_0EK@FDHHEDFI@SetLeafLightingAdjustment?$CI?$CJ?5has@ DB 'SetLeafLig'
	DB	'htingAdjustment() has no effect after Compute() has been call'
	DB	'ed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BCLGOANH@CSpeedTreeRT?3?3SetStaticLighting@
CONST	SEGMENT
??_C@_0CF@BCLGOANH@CSpeedTreeRT?3?3SetStaticLighting@ DB 'CSpeedTreeRT::S'
	DB	'etStaticLightingStyle', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@NCCMENJN@SetStaticLightingStyle?$CI?$CJ?5has?5no@
CONST	SEGMENT
??_C@_0EH@NCCMENJN@SetStaticLightingStyle?$CI?$CJ?5has?5no@ DB 'SetStatic'
	DB	'LightingStyle() has no effect after Compute() has been called'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@2@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@2@@Z@4JA DD 0537H ; `CSpeedTreeRT::SetStaticLightingStyle'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CE@JEGOHDCD@CSpeedTreeRT?3?3SetLeafLightingMe@
CONST	SEGMENT
??_C@_0CE@JEGOHDCD@CSpeedTreeRT?3?3SetLeafLightingMe@ DB 'CSpeedTreeRT::S'
	DB	'etLeafLightingMethod', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@NJIHGNJJ@SetLeafLightingMethod?$CI?$CJ?5has?5no?5@
CONST	SEGMENT
??_C@_0EG@NJIHGNJJ@SetLeafLightingMethod?$CI?$CJ?5has?5no?5@ DB 'SetLeafL'
	DB	'ightingMethod() has no effect after Compute() has been called'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JIPGNOHN@CSpeedTreeRT?3?3SetBranchLighting@
CONST	SEGMENT
??_C@_0CG@JIPGNOHN@CSpeedTreeRT?3?3SetBranchLighting@ DB 'CSpeedTreeRT::S'
	DB	'etBranchLightingMethod', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@NEFFOLNG@SetBranchLightingMethod?$CI?$CJ?5has?5n@
CONST	SEGMENT
??_C@_0EI@NEFFOLNG@SetBranchLightingMethod?$CI?$CJ?5has?5n@ DB 'SetBranch'
	DB	'LightingMethod() has no effect after Compute() has been calle'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ECGBHBNP@CSpeedTreeRT?3?3SetTreeSize@
CONST	SEGMENT
??_C@_0BK@ECGBHBNP@CSpeedTreeRT?3?3SetTreeSize@ DB 'CSpeedTreeRT::SetTree'
	DB	'Size', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@JLMDCMOK@SetTreeSize?$CI?$CJ?5has?5no?5effect?5aft@
CONST	SEGMENT
??_C@_0EI@JLMDCMOK@SetTreeSize?$CI?$CJ?5has?5no?5effect?5aft@ DB 'SetTree'
	DB	'Size() has no effect after DeleteTransientData() has been cal'
	DB	'led', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@HHHECPHJ@SetTreeSize?$CI?$CJ?5is?5only?5valid?5for@
CONST	SEGMENT
??_C@_0DN@HHHECPHJ@SetTreeSize?$CI?$CJ?5is?5only?5valid?5for@ DB 'SetTree'
	DB	'Size() is only valid for size values greater than 0.0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BABKOJAM@CSpeedTreeRT?3?3SaveTree@
CONST	SEGMENT
??_C@_0BH@BABKOJAM@CSpeedTreeRT?3?3SaveTree@ DB 'CSpeedTreeRT::SaveTree', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@NCFONFAJ@cannot?5Save?$CI?$CJ?5after?5DeleteTrans@
CONST	SEGMENT
??_C@_0DE@NCFONFAJ@cannot?5Save?$CI?$CJ?5after?5DeleteTrans@ DB 'cannot S'
	DB	'ave() after DeleteTransientData() is called', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BPMMAHHL@CSpeedTreeRT?3?3LoadTree@
CONST	SEGMENT
??_C@_0BH@BPMMAHHL@CSpeedTreeRT?3?3LoadTree@ DB 'CSpeedTreeRT::LoadTree', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@NANINALL@CSpeedTreeRT?3?3LoadTree?5?9?5threw?5@
CONST	SEGMENT
??_C@_0DL@NANINALL@CSpeedTreeRT?3?3LoadTree?5?9?5threw?5@ DB 'CSpeedTreeR'
	DB	'T::LoadTree - threw an unknown system exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EBOIGFHO@CSpeedTreeRT?3?3Load?5Tree?5?9?5?$CFs@
CONST	SEGMENT
??_C@_0BN@EBOIGFHO@CSpeedTreeRT?3?3Load?5Tree?5?9?5?$CFs@ DB 'CSpeedTreeR'
	DB	'T::Load Tree - %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MBMLMKLB@failed?5to?5load?5file?5?8?$CFs?8?5?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0BO@MBMLMKLB@failed?5to?5load?5file?5?8?$CFs?8?5?$FL?$CFs?$FN@ DB 'f'
	DB	'ailed to load file ''%s'' [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LOAPLEHO@file?5seek?5failed?5on?5?8?$CFs?8?5?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0BO@LOAPLEHO@file?5seek?5failed?5on?5?8?$CFs?8?5?$FL?$CFs?$FN@ DB 'f'
	DB	'ile seek failed on ''%s'' [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IGGBMNBO@only?5read?5?$CFd?5of?5?$CFd?5from?5?$CFs?5?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0CA@IGGBMNBO@only?5read?5?$CFd?5of?5?$CFd?5from?5?$CFs?5?$FL?$CFs?$FN@ DB 'o'
	DB	'nly read %d of %d from %s [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT __CTA1?AVexception@std@@
xdata$x	SEGMENT
__CTA1?AVexception@std@@ DD 01H
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI1?AVexception@std@@
xdata$x	SEGMENT
__TI1?AVexception@std@@ DD 00H
	DD	FLAT:??1exception@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA1?AVexception@std@@
xdata$x	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@JAMEDGDD@DeleteTransientData?$CI?$CJ?5called?5wi@
CONST	SEGMENT
??_C@_0DL@JAMEDGDD@DeleteTransientData?$CI?$CJ?5called?5wi@ DB 'DeleteTra'
	DB	'nsientData() called with no intact transient data', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PNFDFAFA@CSpeedTreeRT?3?3MakeInstance@
CONST	SEGMENT
??_C@_0BL@PNFDFAFA@CSpeedTreeRT?3?3MakeInstance@ DB 'CSpeedTreeRT::MakeIn'
	DB	'stance', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@LEEALHFM@cannot?5MakeInstance?$CI?$CJ?5after?5cal@
CONST	SEGMENT
??_C@_0DK@LEEALHFM@cannot?5MakeInstance?$CI?$CJ?5after?5cal@ DB 'cannot M'
	DB	'akeInstance() after calling DeleteTransientData()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EBKKKEGA@CSpeedTreeRT?3?3Clone@
CONST	SEGMENT
??_C@_0BE@EBKKKEGA@CSpeedTreeRT?3?3Clone@ DB 'CSpeedTreeRT::Clone', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@OBNCDPAD@cannot?5Clone?$CI?$CJ?5after?5calling?5De@
CONST	SEGMENT
??_C@_0DD@OBNCDPAD@cannot?5Clone?$CI?$CJ?5after?5calling?5De@ DB 'cannot '
	DB	'Clone() after calling DeleteTransientData()', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Clone@CSpeedTreeRT@@QBEPAV2@MMMI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??Clone@CSpeedTreeRT@@QBEPAV2@MMMI@Z@4JA DD 0307H ; `CSpeedTreeRT::Clone'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BG@MNNNHHI@CSpeedTreeRT?3?3Compute@
CONST	SEGMENT
??_C@_0BG@MNNNHHI@CSpeedTreeRT?3?3Compute@ DB 'CSpeedTreeRT::Compute', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@FKCHCHCL@Compute?$CI?$CJ?5called?5more?5than?5once@
CONST	SEGMENT
??_C@_0EA@FKCHCHCL@Compute?$CI?$CJ?5called?5more?5than?5once@ DB 'Compute'
	DB	'() called more than once for single tree model (ignored)', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0???1CSpeedTreeRT@@QAE@XZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0???1CSpeedTreeRT@@QAE@XZ@4JA DD 0218H	; `CSpeedTreeRT::~CSpeedTreeRT'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CK@KICMMLEH@CSpeedTreeRT?3?3CSpeedTreeRT?$CICSpe@
CONST	SEGMENT
??_C@_0CK@KICMMLEH@CSpeedTreeRT?3?3CSpeedTreeRT?$CICSpe@ DB 'CSpeedTreeRT'
	DB	'::CSpeedTreeRT(CSpeedTreeRT*)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
CONST	SEGMENT
??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@ DB 'D:\pw152\Com'
	DB	'mon\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0???0CSpeedTreeRT@@AAE@PBV1@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0???0CSpeedTreeRT@@AAE@PBV1@@Z@4JA DD 01d3H ; `CSpeedTreeRT::CSpeedTreeRT'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
CONST	SEGMENT
??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@ DB '%s - th'
	DB	'rew an unknown system exception', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@ DB '%s - failed [%s]'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KEOEHMAH@CSpeedTreeRT?3?3CSpeedTreeRT?$CI?5?$CJ@
CONST	SEGMENT
??_C@_0BO@KEOEHMAH@CSpeedTreeRT?3?3CSpeedTreeRT?$CI?5?$CJ@ DB 'CSpeedTree'
	DB	'RT::CSpeedTreeRT( )', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@LPJNEMKC@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
CONST	SEGMENT
??_C@_0DG@LPJNEMKC@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@ DB 'D:\pw152\Com'
	DB	'mon\SpeedTreeRT\SourceCode\LeafGeometry.h', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@KINJKJPN@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
CONST	SEGMENT
??_C@_0DI@KINJKJPN@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@ DB 'D:\pw152\Com'
	DB	'mon\SpeedTreeRT\SourceCode\LightingEngine.h', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@PACCNLEK@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
CONST	SEGMENT
??_C@_0DE@PACCNLEK@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@ DB 'D:\pw152\Com'
	DB	'mon\SpeedTreeRT\SourceCode\WindEngine.h', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GetStripLengthsPointer@CIndexedGeometry@@QBEPBGG@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetStripLengthsPointer@CIndexedGeometry@@QBEPBGG@Z@4JA DD 0b4H ; `CIndexedGeometry::GetStripLengthsPointer'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
CONST	SEGMENT
??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@ DB 'Assertion failed', 0aH, 'L'
	DB	'ine ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_08KPJKAGGE@?0?5file?3?5@
CONST	SEGMENT
??_C@_08KPJKAGGE@?0?5file?3?5@ DB ', file: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@PPMMOPLM@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
CONST	SEGMENT
??_C@_0DJ@PPMMOPLM@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@ DB 'D:\pw152\Com'
	DB	'mon\SpeedTreeRT\SourceCode\IndexedGeometry.h', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GetNumStrips@CIndexedGeometry@@QBEGF@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetNumStrips@CIndexedGeometry@@QBEGF@Z@4JA DD 0aeH ; `CIndexedGeometry::GetNumStrips'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_02GBLMOEJC@?5?$FL@
CONST	SEGMENT
??_C@_02GBLMOEJC@?5?$FL@ DB ' [', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7IdvFileError@@6B@
CONST	SEGMENT
??_7IdvFileError@@6B@ DD FLAT:??_R4IdvFileError@@6B@	; IdvFileError::`vftable'
	DD	FLAT:??_EIdvFileError@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
CONST	SEGMENT
??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ DB '"'
	DB	00H, 'I', 00H, 'T', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H
	DB	'O', 00H, 'R', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'S', 00H, 'T'
	DB	00H, ' ', 00H, 'C', 00H, 'O', 00H, 'R', 00H, 'R', 00H, 'U', 00H
	DB	'P', 00H, 'T', 00H, 'E', 00H, 'D', 00H, '!', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
CONST	SEGMENT
??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ DB 'ITERATOR LIST CORRU'
	DB	'PTED!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1ME@KJJNLLPL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1ME@KJJNLLPL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H
	DB	'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M'
	DB	00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H
	DB	'.', 00H, '4', 00H, '0', 00H, '.', 00H, '3', 00H, '3', 00H, '8'
	DB	00H, '0', 00H, '7', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm'
	DB	00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@GDGMGNBP@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@GDGMGNBP@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'40.33807\include\xmemory', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA DD 0a9H ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z$0
__ehfuncinfo$??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_move@PAPAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move@PAPAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_move@PAPAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_move@PAPAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_move@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@QAU1@0PAU1@AAV?$allocator@USShape@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@QAU1@0PAU1@AAV?$allocator@USShape@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_move@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@QAU1@0PAU1@AAV?$allocator@USShape@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_move@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@QAU1@0PAU1@AAV?$allocator@USShape@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEPAEQAE$$QAE@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEPAEQAE$$QAE@Z$0
__unwindtable$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEPAEQAE$$QAE@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEPAEQAE$$QAE@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEPAEQAE$$QAE@Z$2
__ehfuncinfo$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEPAEQAE$$QAE@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEPAEQAE$$QAE@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEPAEQAE$$QAE@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z$0
__ehfuncinfo$??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$2
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEPAPAVCSpeedTreeRT@@QAPAV2@$$QAPAV2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEPAPAVCSpeedTreeRT@@QAPAV2@$$QAPAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEPAPAVCSpeedTreeRT@@QAPAV2@$$QAPAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEPAPAVCSpeedTreeRT@@QAPAV2@$$QAPAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEPAPAVCSpeedTreeRT@@QAPAV2@$$QAPAV2@@Z$2
__ehfuncinfo$??$_Emplace_reallocate@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEPAPAVCSpeedTreeRT@@QAPAV2@$$QAPAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEPAPAVCSpeedTreeRT@@QAPAV2@$$QAPAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEPAPAVCSpeedTreeRT@@QAPAV2@$$QAPAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEPAUSShape@@QAU2@ABU2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEPAUSShape@@QAU2@ABU2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEPAUSShape@@QAU2@ABU2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEPAUSShape@@QAU2@ABU2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEPAUSShape@@QAU2@ABU2@@Z$2
__ehfuncinfo$??$_Emplace_reallocate@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEPAUSShape@@QAU2@ABU2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEPAUSShape@@QAU2@ABU2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEPAUSShape@@QAU2@ABU2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy_n@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@PAU1@I0AAV?$allocator@USShape@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy_n@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@PAU1@I0AAV?$allocator@USShape@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy_n@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@PAU1@I0AAV?$allocator@USShape@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy_n@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@PAU1@I0AAV?$allocator@USShape@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z$0
__ehfuncinfo$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z$0
__ehfuncinfo$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAVCSpeedTreeRT@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@V10@V10@ABQAVCSpeedTreeRT@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAVCSpeedTreeRT@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@V10@V10@ABQAVCSpeedTreeRT@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAVCSpeedTreeRT@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@V10@V10@ABQAVCSpeedTreeRT@@@Z$1
__ehfuncinfo$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAVCSpeedTreeRT@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@V10@V10@ABQAVCSpeedTreeRT@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAVCSpeedTreeRT@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@V10@V10@ABQAVCSpeedTreeRT@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_range_locked@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range_locked@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z$0
__ehfuncinfo$?_Orphan_range_locked@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range_locked@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	0397H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?TransformAll@SCollisionObjects@@QAEXAAVCTransform@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TransformAll@SCollisionObjects@@QAEXAAVCTransform@@@Z$0
__ehfuncinfo$?TransformAll@SCollisionObjects@@QAEXAAVCTransform@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?TransformAll@SCollisionObjects@@QAEXAAVCTransform@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	065H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	024H
	DW	0307H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	022H
	DB	092H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Resize@CWindMatrices@@QAEXG@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Resize@CWindMatrices@@QAEXG@Z$0
__ehfuncinfo$?Resize@CWindMatrices@@QAEXG@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Resize@CWindMatrices@@QAEXG@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CTreeFileAccess@@QAE@PBEH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CTreeFileAccess@@QAE@PBEH@Z$0
__ehfuncinfo$??0CTreeFileAccess@@QAE@PBEH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CTreeFileAccess@@QAE@PBEH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	027H
	DW	01c0H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CIdvFilename@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CIdvFilename@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
__ehfuncinfo$??0CIdvFilename@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CIdvFilename@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_range_locked@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range_locked@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z$0
__ehfuncinfo$?_Orphan_range_locked@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range_locked@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?erase@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_range_locked@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range_locked@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z$0
__ehfuncinfo$?_Orphan_range_locked@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range_locked@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	027H
	DW	0205H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	027H
	DW	0431H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	027H
	DW	05b3H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02cH
	DB	039H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	035H
	DW	0245H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ParseSupplementalTexCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseSupplementalTexCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseSupplementalTexCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseSupplementalTexCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$4
__ehfuncinfo$?ParseSupplementalTexCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ParseSupplementalTexCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
	DB	026H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	032H
	DB	0dbH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ParseUserData@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseUserData@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$0
__ehfuncinfo$?ParseUserData@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ParseUserData@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ParseShadowProjectionInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseShadowProjectionInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$0
__ehfuncinfo$?ParseShadowProjectionInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ParseShadowProjectionInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02fH
	DB	03cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	035H
	DW	0324H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ParseCollisionObjects@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseCollisionObjects@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseCollisionObjects@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseCollisionObjects@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$2
__ehfuncinfo$?ParseCollisionObjects@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ParseCollisionObjects@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	041H
	DB	04eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	035H
	DW	04e4H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$5
__ehfuncinfo$?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	035H
	DW	0154H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ParseWindInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseWindInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseWindInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$1
__ehfuncinfo$?ParseWindInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ParseWindInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	035H
	DW	01afH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ParseLodInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseLodInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ParseLodInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$1
__ehfuncinfo$?ParseLodInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ParseLodInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02cH
	DB	039H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	034H
	DW	02b6H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z DD 00H
	DD	01H
	DD	04H
	DD	02H
	DD	FLAT:__catchsym$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z$7
__catchsym$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z$7 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd0H
	DD	FLAT:__catch$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z$1
__ehfuncinfo$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z$3
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z$5
	DD	02H
	DD	FLAT:__unwindfunclet$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z$6
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	024H
	DW	0253H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	022fH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ$5
__catchsym$?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffff98H
	DD	FLAT:__catch$?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ$1
__unwindtable$?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ$4
__ehfuncinfo$?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
	DB	043H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	05c2H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$??0CSpeedTreeRT@@AAE@PBV0@@Z DD 00H
	DD	01H
	DD	04H
	DD	02H
	DD	FLAT:__catchsym$??0CSpeedTreeRT@@AAE@PBV0@@Z$6
__catchsym$??0CSpeedTreeRT@@AAE@PBV0@@Z$6 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$??0CSpeedTreeRT@@AAE@PBV0@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0CSpeedTreeRT@@AAE@PBV0@@Z$1
__ehfuncinfo$??0CSpeedTreeRT@@AAE@PBV0@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0CSpeedTreeRT@@AAE@PBV0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0CSpeedTreeRT@@AAE@PBV0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CSpeedTreeRT@@AAE@PBV0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??0CSpeedTreeRT@@AAE@PBV0@@Z$3
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$??0CSpeedTreeRT@@AAE@PBV0@@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$??0CSpeedTreeRT@@AAE@PBV0@@Z$5
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
	DB	026H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	013aH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetCollisionObject@CSpeedTreeRT@@QAEXIAAW4ECollisionObjectType@1@PAM1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetCollisionObject@CSpeedTreeRT@@QAEXIAAW4ECollisionObjectType@1@PAM1@Z$0
__ehfuncinfo$?GetCollisionObject@CSpeedTreeRT@@QAEXIAAW4ECollisionObjectType@1@PAM1@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetCollisionObject@CSpeedTreeRT@@QAEXIAAW4ECollisionObjectType@1@PAM1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	01b4H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z$5
__catchsym$?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffc0H
	DD	FLAT:__catch$?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z$1
__unwindtable$?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z$4
__ehfuncinfo$?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z
	DD	01H
	DD	FLAT:__tryblocktable$?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	01b4H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z$5
__catchsym$?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffc0H
	DD	FLAT:__catch$?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z$1
__unwindtable$?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z$4
__ehfuncinfo$?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z
	DD	01H
	DD	FLAT:__tryblocktable$?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	01e3H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$5
__catchsym$?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$1
__unwindtable$?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$4
__ehfuncinfo$?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	020bH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$5
__catchsym$?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$1
__unwindtable$?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$4
__ehfuncinfo$?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	0207H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z$5
__catchsym$?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z$1
__unwindtable$?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z$4
__ehfuncinfo$?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	0187H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$5
__catchsym$?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$1
__unwindtable$?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$4
__ehfuncinfo$?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	040eH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$5
__catchsym$?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$1
__unwindtable$?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$4
__ehfuncinfo$?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	0332H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z$5
__catchsym$?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffb4H
	DD	FLAT:__catch$?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z$1
__unwindtable$?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z$4
__ehfuncinfo$?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	0257H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z$5
__catchsym$?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z$1
__unwindtable$?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z$4
__ehfuncinfo$?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z
	DD	01H
	DD	FLAT:__tryblocktable$?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	0224H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ$5
__catchsym$?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffc0H
	DD	FLAT:__catch$?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ$1
__unwindtable$?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ$4
__ehfuncinfo$?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ
	DD	01H
	DD	FLAT:__tryblocktable$?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	0180H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z$5
__catchsym$?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffccH
	DD	FLAT:__catch$?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z$1
__unwindtable$?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z$4
__ehfuncinfo$?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	0276H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z$5
__catchsym$?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffff90H
	DD	FLAT:__catch$?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z$1
__unwindtable$?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z$4
__ehfuncinfo$?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	01c7H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ$5
__catchsym$?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ$1
__unwindtable$?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ$4
__ehfuncinfo$?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	01beH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ$5
__catchsym$?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ$1
__unwindtable$?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ$4
__ehfuncinfo$?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	0215H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ$5
__catchsym$?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffb8H
	DD	FLAT:__catch$?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ$1
__unwindtable$?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ$4
__ehfuncinfo$?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	01afH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z$5
__catchsym$?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z$1
__unwindtable$?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z$4
__ehfuncinfo$?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	031H
	DW	029dH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z$5
__catchsym$?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffe4H
	DD	FLAT:__catch$?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z$1
__unwindtable$?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z$4
__ehfuncinfo$?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	031H
	DW	015dH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z$5
__catchsym$?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffe4H
	DD	FLAT:__catch$?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z$1
__unwindtable$?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z$4
__ehfuncinfo$?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	0230H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z$5
__catchsym$?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z$1
__unwindtable$?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z$4
__ehfuncinfo$?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	02baH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z$5
__catchsym$?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffccH
	DD	FLAT:__catch$?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z$1
__unwindtable$?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z$4
__ehfuncinfo$?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	01f7H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$5
__catchsym$?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$1
__unwindtable$?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$4
__ehfuncinfo$?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	01f7H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$5
__catchsym$?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$1
__unwindtable$?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$4
__ehfuncinfo$?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	01a9H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$5
__catchsym$?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$1
__unwindtable$?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$4
__ehfuncinfo$?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	018bH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z$5
__catchsym$?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z$1
__unwindtable$?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z$4
__ehfuncinfo$?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	034H
	DB	041H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	04a1H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z DD 00H
	DD	02H
	DD	05H
	DD	02H
	DD	FLAT:__catchsym$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z$9
__catchsym$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z$9 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffff8cH
	DD	FLAT:__catch$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z$1
__ehfuncinfo$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z
	DD	01H
	DD	FLAT:__tryblocktable$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z$5
	DD	0ffffffffH
	DD	00H
	DD	03H
	DD	FLAT:__unwindfunclet$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z$7
	DD	03H
	DD	FLAT:__unwindfunclet$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z$8
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	031H
	DW	016dH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetTime@CSpeedTreeRT@@SAXM@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetTime@CSpeedTreeRT@@SAXM@Z$5
__catchsym$?SetTime@CSpeedTreeRT@@SAXM@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffe4H
	DD	FLAT:__catch$?SetTime@CSpeedTreeRT@@SAXM@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetTime@CSpeedTreeRT@@SAXM@Z$1
__unwindtable$?SetTime@CSpeedTreeRT@@SAXM@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetTime@CSpeedTreeRT@@SAXM@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetTime@CSpeedTreeRT@@SAXM@Z$4
__ehfuncinfo$?SetTime@CSpeedTreeRT@@SAXM@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetTime@CSpeedTreeRT@@SAXM@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetTime@CSpeedTreeRT@@SAXM@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	034H
	DW	0417H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetCamera@CSpeedTreeRT@@SAXPBM0@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetCamera@CSpeedTreeRT@@SAXPBM0@Z$5
__catchsym$?SetCamera@CSpeedTreeRT@@SAXPBM0@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffff68H
	DD	FLAT:__catch$?SetCamera@CSpeedTreeRT@@SAXPBM0@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetCamera@CSpeedTreeRT@@SAXPBM0@Z$1
__unwindtable$?SetCamera@CSpeedTreeRT@@SAXPBM0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetCamera@CSpeedTreeRT@@SAXPBM0@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetCamera@CSpeedTreeRT@@SAXPBM0@Z$4
__ehfuncinfo$?SetCamera@CSpeedTreeRT@@SAXPBM0@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetCamera@CSpeedTreeRT@@SAXPBM0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetCamera@CSpeedTreeRT@@SAXPBM0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	022H
	DB	09aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	017fH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z$5
__catchsym$?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z$1
__unwindtable$?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z$4
__ehfuncinfo$?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	017fH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z$5
__catchsym$?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z$1
__unwindtable$?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z$4
__ehfuncinfo$?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	017fH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z$5
__catchsym$?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z$1
__unwindtable$?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z$4
__ehfuncinfo$?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	031H
	DW	0160H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z$5
__catchsym$?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffe4H
	DD	FLAT:__catch$?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z$1
__unwindtable$?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z$4
__ehfuncinfo$?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	0186H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z$5
__catchsym$?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z$1
__unwindtable$?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z$4
__ehfuncinfo$?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	0230H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z$5
__catchsym$?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z$1
__unwindtable$?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z$4
__ehfuncinfo$?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	01a9H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$5
__catchsym$?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$1
__unwindtable$?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$4
__ehfuncinfo$?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	01a9H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$5
__catchsym$?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$1
__unwindtable$?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$4
__ehfuncinfo$?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	01a9H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$5
__catchsym$?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$1
__unwindtable$?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$4
__ehfuncinfo$?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	0a0H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	01a5H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?GetSeed@CSpeedTreeRT@@QBEIXZ DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?GetSeed@CSpeedTreeRT@@QBEIXZ$5
__catchsym$?GetSeed@CSpeedTreeRT@@QBEIXZ$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffccH
	DD	FLAT:__catch$?GetSeed@CSpeedTreeRT@@QBEIXZ$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?GetSeed@CSpeedTreeRT@@QBEIXZ$1
__unwindtable$?GetSeed@CSpeedTreeRT@@QBEIXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?GetSeed@CSpeedTreeRT@@QBEIXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?GetSeed@CSpeedTreeRT@@QBEIXZ$4
__ehfuncinfo$?GetSeed@CSpeedTreeRT@@QBEIXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetSeed@CSpeedTreeRT@@QBEIXZ
	DD	01H
	DD	FLAT:__tryblocktable$?GetSeed@CSpeedTreeRT@@QBEIXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	01bdH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z DD 00H
	DD	00H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z$5
__catchsym$?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z$5 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z$1
__unwindtable$?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z$4
__ehfuncinfo$?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02cH
	DB	039H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	0450H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z DD 00H
	DD	01H
	DD	04H
	DD	02H
	DD	FLAT:__catchsym$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z$6
__catchsym$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z$6 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffb0H
	DD	FLAT:__catch$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z$1
__ehfuncinfo$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z$3
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z$5
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02cH
	DB	039H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	05d9H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z DD 00H
	DD	01H
	DD	04H
	DD	02H
	DD	FLAT:__catchsym$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z$6
__catchsym$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z$6 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffff98H
	DD	FLAT:__catch$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z$1
__ehfuncinfo$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z$3
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z$5
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	052H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	0463H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z DD 00H
	DD	03H
	DD	06H
	DD	02H
	DD	FLAT:__catchsym$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z$8
__catchsym$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z$8 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffff90H
	DD	FLAT:__catch$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z$1
__ehfuncinfo$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z$5
	DD	0ffffffffH
	DD	00H
	DD	04H
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z$7
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	032H
	DB	03fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	01feH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ DD 00H
	DD	01H
	DD	04H
	DD	02H
	DD	FLAT:__catchsym$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ$6
__catchsym$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ$6 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffccH
	DD	FLAT:__catch$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ$1
__ehfuncinfo$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ$3
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ$4
	DD	02H
	DD	FLAT:__unwindfunclet$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ$5
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	056H
	DB	063H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	0801H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z DD 00H
	DD	03H
	DD	06H
	DD	02H
	DD	FLAT:__catchsym$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z$8
__catchsym$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z$8 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffccH
	DD	FLAT:__catch$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z$1
__ehfuncinfo$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z$5
	DD	0ffffffffH
	DD	00H
	DD	04H
	DD	FLAT:__unwindfunclet$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z$7
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02fH
	DB	03cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	0874H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z DD 00H
	DD	01H
	DD	04H
	DD	02H
	DD	FLAT:__catchsym$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z$6
__catchsym$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z$6 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffff14H
	DD	FLAT:__catch$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z$1
__ehfuncinfo$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z$3
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z$5
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CSpeedTreeRT@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0c0H
	DB	0cdH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	07c0H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$??0CSpeedTreeRT@@QAE@XZ DD 00H
	DD	08H
	DD	0bH
	DD	02H
	DD	FLAT:__catchsym$??0CSpeedTreeRT@@QAE@XZ$13
__catchsym$??0CSpeedTreeRT@@QAE@XZ$13 DD 08H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffccH
	DD	FLAT:__catch$??0CSpeedTreeRT@@QAE@XZ$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0CSpeedTreeRT@@QAE@XZ$1
__ehfuncinfo$??0CSpeedTreeRT@@QAE@XZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$??0CSpeedTreeRT@@QAE@XZ
	DD	01H
	DD	FLAT:__tryblocktable$??0CSpeedTreeRT@@QAE@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CSpeedTreeRT@@QAE@XZ DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$6
	DD	00H
	DD	FLAT:__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$7
	DD	00H
	DD	FLAT:__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$8
	DD	00H
	DD	FLAT:__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$9
	DD	00H
	DD	FLAT:__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$10
	DD	0ffffffffH
	DD	00H
	DD	09H
	DD	FLAT:__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$11
	DD	09H
	DD	FLAT:__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$12
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	056H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0SGeometry@CSpeedTreeRT@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0SGeometry@CSpeedTreeRT@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0SGeometry@CSpeedTreeRT@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SGeometry@CSpeedTreeRT@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SGeometry@CSpeedTreeRT@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0SGeometry@CSpeedTreeRT@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0SGeometry@CSpeedTreeRT@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0SGeometry@CSpeedTreeRT@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0SGeometry@CSpeedTreeRT@@QAE@XZ$5
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	025H
	DB	084H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	073H
	DB	080H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	035H
	DW	0242H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$4
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	021H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z$1
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z$1
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
CRT$XCU	SEGMENT
?g_strError$initializer$@@3P6AXXZA DD FLAT:??__Eg_strError@@YAXXZ ; g_strError$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?g_strKey$initializer$@@3P6AXXZA DD FLAT:??__Eg_strKey@@YAXXZ ; g_strKey$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@USShape@@U1@@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAXAAV?$allocator@USShape@@@1@QAUSShape@@$$QAU3@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@USShape@@U1@@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAXAAV?$allocator@USShape@@@1@QAUSShape@@$$QAU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<SShape> >::construct<SShape,SShape>, COMDAT

; 696  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 697  : #if _HAS_CXX20
; 698  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 699  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 700  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	28					; 0000001cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@USShape@@@std@@YA$$QAUSShape@@AAU1@@Z ; std::forward<SShape>
	add	esp, 4
	mov	ecx, 7
	mov	esi, eax
	mov	edi, DWORD PTR $T1[ebp]
	rep movsd

; 701  : #endif // ^^^ !_HAS_CXX20 ^^^
; 702  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@USShape@@U1@@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAXAAV?$allocator@USShape@@@1@QAUSShape@@$$QAU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SShape> >::construct<SShape,SShape>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@USShape@@@std@@YA$$QAUSShape@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@USShape@@@std@@YA$$QAUSShape@@AAU1@@Z PROC	; std::forward<SShape>, COMDAT

; 1536 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1538 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@USShape@@@std@@YA$$QAUSShape@@AAU1@@Z ENDP	; std::forward<SShape>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Overflow_is_possible$ = -5				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 79   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi

; 80   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR __Overflow_is_possible$[ebp], 0

; 81   : 
; 82   :     if constexpr (_Overflow_is_possible) {
; 83   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 84   :         if (_Count > _Max_possible) {
; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[ebp]

; 90   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Get_size_of_n@$03@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
__Overflow_is_possible$ = -5				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$03@std@@YAII@Z PROC			; std::_Get_size_of_n<4>, COMDAT

; 79   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 80   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR __Overflow_is_possible$[ebp], 1

; 81   : 
; 82   :     if constexpr (_Overflow_is_possible) {
; 83   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	DWORD PTR __Max_possible$1[ebp], 1073741823 ; 3fffffffH

; 84   :         if (_Count > _Max_possible) {

	cmp	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH
	jbe	SHORT $LN2@Get_size_o

; 85   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
$LN1@Get_size_o:

; 90   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_size_of_n@$03@std@@YAII@Z ENDP			; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@E@std@@YAPAEAAE@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@E@std@@YAPAEAAE@Z PROC			; std::addressof<unsigned char>, COMDAT

; 1559 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1560 :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 1561 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@E@std@@YAPAEAAE@Z ENDP			; std::addressof<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@E$$V@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@QAE@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
$T2 = -200						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$construct@E$$V@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@QAE@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char>, COMDAT

; 696  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 697  : #if _HAS_CXX20
; 698  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 699  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 700  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR $T2[ebp], 1
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 701  : #endif // ^^^ !_HAS_CXX20 ^^^
; 702  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@E$$V@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@QAE@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_To_address@PAE@std@@YA?A_PABQAE@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PAE@std@@YA?A_PABQAE@Z PROC		; std::_To_address<unsigned char *>, COMDAT

; 4491 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 4492 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4493 :     return _Val;

	mov	eax, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [eax]

; 4494 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_To_address@PAE@std@@YA?A_PABQAE@Z ENDP		; std::_To_address<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAEX$$QAE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAEX$$QAE@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char>, COMDAT
; _this$ = ecx

; 1779 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1780 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR _<_Vals_0>$[ebp]
	push	eax
	call	??$forward@E@std@@YA$$QAEAAE@Z		; std::forward<unsigned char>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$_Unfancy@E@std@@YAPAEPAE@Z		; std::_Unfancy<unsigned char>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@QAE$$QAE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>
	add	esp, 12					; 0000000cH

; 1781 :         ++_Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1782 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAEX$$QAE@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT
__Count$ = -80						; size = 4
__Dest_ch$ = -68					; size = 4
__Last_ch$ = -56					; size = 4
__First_ch$ = -44					; size = 4
__DestPtr$ = -32					; size = 4
__LastPtr$ = -20					; size = 4
__FirstPtr$ = -8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z PROC		; std::_Copy_memmove<unsigned char *,unsigned char *>, COMDAT

; 4613 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 21					; 00000015H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4614 :     auto _FirstPtr              = _STD _To_address(_First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_To_address@PAE@std@@YA?A_PABQAE@Z	; std::_To_address<unsigned char *>
	add	esp, 4
	mov	DWORD PTR __FirstPtr$[ebp], eax

; 4615 :     auto _LastPtr               = _STD _To_address(_Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_To_address@PAE@std@@YA?A_PABQAE@Z	; std::_To_address<unsigned char *>
	add	esp, 4
	mov	DWORD PTR __LastPtr$[ebp], eax

; 4616 :     auto _DestPtr               = _STD _To_address(_Dest);

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_To_address@PAE@std@@YA?A_PABQAE@Z	; std::_To_address<unsigned char *>
	add	esp, 4
	mov	DWORD PTR __DestPtr$[ebp], eax

; 4617 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

	mov	eax, DWORD PTR __FirstPtr$[ebp]
	mov	DWORD PTR __First_ch$[ebp], eax

; 4618 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

	mov	eax, DWORD PTR __LastPtr$[ebp]
	mov	DWORD PTR __Last_ch$[ebp], eax

; 4619 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

	mov	eax, DWORD PTR __DestPtr$[ebp]
	mov	DWORD PTR __Dest_ch$[ebp], eax

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR __Last_ch$[ebp]
	sub	eax, DWORD PTR __First_ch$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First_ch$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest_ch$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 4622 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4623 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	mov	eax, DWORD PTR __Dest_ch$[ebp]
	add	eax, DWORD PTR __Count$[ebp]

; 4624 :     } else {
; 4625 :         return _Dest + (_LastPtr - _FirstPtr);
; 4626 :     }
; 4627 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ENDP		; std::_Copy_memmove<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAE@std@@YA?A_TABQAE@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAE@std@@YA?A_TABQAE@Z PROC		; std::_Get_unwrapped<unsigned char * const &>, COMDAT

; 1304 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1305 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1306 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1307 :         return _It + 0;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1308 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1309 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1310 :     } else {
; 1311 :         return static_cast<_Iter&&>(_It);
; 1312 :     }
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_unwrapped@ABQAE@std@@YA?A_TABQAE@Z ENDP		; std::_Get_unwrapped<unsigned char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Emplace_back@PAVCSpeedTreeRT@@@?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAEX$$QAPAVCSpeedTreeRT@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAVCSpeedTreeRT@@@?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAEX$$QAPAVCSpeedTreeRT@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >::_Emplace_back<CSpeedTreeRT *>, COMDAT
; _this$ = ecx

; 1779 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1780 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR _<_Vals_0>$[ebp]
	push	eax
	call	??$forward@PAVCSpeedTreeRT@@@std@@YA$$QAPAVCSpeedTreeRT@@AAPAV1@@Z ; std::forward<CSpeedTreeRT *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$_Unfancy@PAVCSpeedTreeRT@@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@@Z ; std::_Unfancy<CSpeedTreeRT *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	??$construct@PAVCSpeedTreeRT@@PAV1@@?$_Default_allocator_traits@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@SAXAAV?$allocator@PAVCSpeedTreeRT@@@1@QAPAVCSpeedTreeRT@@$$QAPAV3@@Z ; std::_Default_allocator_traits<std::allocator<CSpeedTreeRT *> >::construct<CSpeedTreeRT *,CSpeedTreeRT *>
	add	esp, 12					; 0000000cH

; 1781 :         ++_Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1782 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Emplace_back@PAVCSpeedTreeRT@@@?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAEX$$QAPAVCSpeedTreeRT@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >::_Emplace_back<CSpeedTreeRT *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAEPAPAVCSpeedTreeRT@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAEPAPAVCSpeedTreeRT@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >::_Release, COMDAT
; _this$ = ecx

; 1784 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1785 :         _First = _Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 1786 :         return _Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 1787 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAEPAPAVCSpeedTreeRT@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >::~_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >, COMDAT
; _this$ = ecx

; 1774 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1775 :         _STD _Destroy_range(_First, _Last, _Al);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAXPAPAVCSpeedTreeRT@@QAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z ; std::_Destroy_range<std::allocator<CSpeedTreeRT *> >
	add	esp, 12					; 0000000cH

; 1776 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >::~_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@PAPAVCSpeedTreeRT@@AAV?$allocator@PAVCSpeedTreeRT@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@PAPAVCSpeedTreeRT@@AAV?$allocator@PAVCSpeedTreeRT@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >, COMDAT
; _this$ = ecx

; 1769 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Al_$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@PAPAVCSpeedTreeRT@@AAV?$allocator@PAVCSpeedTreeRT@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAVCSpeedTreeRT@@@std@@YA?A_TABQAPAVCSpeedTreeRT@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAPAVCSpeedTreeRT@@@std@@YA?A_TABQAPAVCSpeedTreeRT@@@Z PROC ; std::_Get_unwrapped<CSpeedTreeRT * * const &>, COMDAT

; 1304 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1305 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1306 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1307 :         return _It + 0;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1308 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1309 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1310 :     } else {
; 1311 :         return static_cast<_Iter&&>(_It);
; 1312 :     }
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_unwrapped@ABQAPAVCSpeedTreeRT@@@std@@YA?A_TABQAPAVCSpeedTreeRT@@@Z ENDP ; std::_Get_unwrapped<CSpeedTreeRT * * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@PAVCSpeedTreeRT@@@std@@YAPAPAVCSpeedTreeRT@@AAPAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAVCSpeedTreeRT@@@std@@YAPAPAVCSpeedTreeRT@@AAPAV1@@Z PROC ; std::addressof<CSpeedTreeRT *>, COMDAT

; 1559 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1560 :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 1561 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@PAVCSpeedTreeRT@@@std@@YAPAPAVCSpeedTreeRT@@AAPAV1@@Z ENDP ; std::addressof<CSpeedTreeRT *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Emplace_back@USShape@@@?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAEX$$QAUSShape@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@USShape@@@?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAEX$$QAUSShape@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<SShape> >::_Emplace_back<SShape>, COMDAT
; _this$ = ecx

; 1779 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1780 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR _<_Vals_0>$[ebp]
	push	eax
	call	??$forward@USShape@@@std@@YA$$QAUSShape@@AAU1@@Z ; std::forward<SShape>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$_Unfancy@USShape@@@std@@YAPAUSShape@@PAU1@@Z ; std::_Unfancy<SShape>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	??$construct@USShape@@U1@@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAXAAV?$allocator@USShape@@@1@QAUSShape@@$$QAU3@@Z ; std::_Default_allocator_traits<std::allocator<SShape> >::construct<SShape,SShape>
	add	esp, 12					; 0000000cH

; 1781 :         ++_Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1782 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Emplace_back@USShape@@@?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAEX$$QAUSShape@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<SShape> >::_Emplace_back<SShape>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$move@AAUSShape@@@std@@YA$$QAUSShape@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUSShape@@@std@@YA$$QAUSShape@@AAU1@@Z PROC	; std::move<SShape &>, COMDAT

; 1547 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1548 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1549 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$move@AAUSShape@@@std@@YA$$QAUSShape@@AAU1@@Z ENDP	; std::move<SShape &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUSShape@@@std@@YA?A_TABQAUSShape@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAUSShape@@@std@@YA?A_TABQAUSShape@@@Z PROC ; std::_Get_unwrapped<SShape * const &>, COMDAT

; 1304 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1305 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1306 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1307 :         return _It + 0;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1308 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1309 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1310 :     } else {
; 1311 :         return static_cast<_Iter&&>(_It);
; 1312 :     }
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_unwrapped@ABQAUSShape@@@std@@YA?A_TABQAUSShape@@@Z ENDP ; std::_Get_unwrapped<SShape * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@USShape@@@std@@YAPAUSShape@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@USShape@@@std@@YAPAUSShape@@AAU1@@Z PROC	; std::addressof<SShape>, COMDAT

; 1559 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1560 :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 1561 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@USShape@@@std@@YAPAUSShape@@AAU1@@Z ENDP	; std::addressof<SShape>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_To_address@PAUSShape@@@std@@YA?A_PABQAUSShape@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PAUSShape@@@std@@YA?A_PABQAUSShape@@@Z PROC ; std::_To_address<SShape *>, COMDAT

; 4491 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 4492 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4493 :     return _Val;

	mov	eax, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [eax]

; 4494 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_To_address@PAUSShape@@@std@@YA?A_PABQAUSShape@@@Z ENDP ; std::_To_address<SShape *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@USShape@@AAU1@@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAXAAV?$allocator@USShape@@@1@QAUSShape@@AAU3@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@USShape@@AAU1@@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAXAAV?$allocator@USShape@@@1@QAUSShape@@AAU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<SShape> >::construct<SShape,SShape &>, COMDAT

; 696  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 697  : #if _HAS_CXX20
; 698  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 699  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 700  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	28					; 0000001cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAUSShape@@@std@@YAAAUSShape@@AAU1@@Z ; std::forward<SShape &>
	add	esp, 4
	mov	ecx, 7
	mov	esi, eax
	mov	edi, DWORD PTR $T1[ebp]
	rep movsd

; 701  : #endif // ^^^ !_HAS_CXX20 ^^^
; 702  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@USShape@@AAU1@@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAXAAV?$allocator@USShape@@@1@QAUSShape@@AAU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SShape> >::construct<SShape,SShape &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AAUSShape@@@std@@YAAAUSShape@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUSShape@@@std@@YAAAUSShape@@AAU1@@Z PROC	; std::forward<SShape &>, COMDAT

; 1536 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1538 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@AAUSShape@@@std@@YAAAUSShape@@AAU1@@Z ENDP	; std::forward<SShape &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$__std_find_trivial@PAVCSpeedTreeRT@@I@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0I@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$__std_find_trivial@PAVCSpeedTreeRT@@I@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0I@Z PROC ; std::__std_find_trivial<CSpeedTreeRT *,unsigned int>, COMDAT

; 153  : _Ty* __std_find_trivial(_Ty* const _First, _Ty* const _Last, const _TVal _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 154  :     if constexpr (is_pointer_v<_TVal> || is_null_pointer_v<_TVal>) {
; 155  :         return _STD __std_find_trivial(_First, _Last, reinterpret_cast<uintptr_t>(_Val));
; 156  :     } else if constexpr (sizeof(_Ty) == 1) {
; 157  :         return const_cast<_Ty*>(
; 158  :             static_cast<const _Ty*>(::__std_find_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
; 159  :     } else if constexpr (sizeof(_Ty) == 2) {
; 160  :         return const_cast<_Ty*>(
; 161  :             static_cast<const _Ty*>(::__std_find_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
; 162  :     } else if constexpr (sizeof(_Ty) == 4) {
; 163  :         return const_cast<_Ty*>(

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	___std_find_trivial_4@12

; 164  :             static_cast<const _Ty*>(::__std_find_trivial_4(_First, _Last, static_cast<uint32_t>(_Val))));
; 165  :     } else if constexpr (sizeof(_Ty) == 8) {
; 166  :         return const_cast<_Ty*>(
; 167  :             static_cast<const _Ty*>(::__std_find_trivial_8(_First, _Last, static_cast<uint64_t>(_Val))));
; 168  :     } else {
; 169  :         static_assert(_Always_false<_Ty>, "Unexpected size");
; 170  :     }
; 171  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$__std_find_trivial@PAVCSpeedTreeRT@@I@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0I@Z ENDP ; std::__std_find_trivial<CSpeedTreeRT *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BM@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
__Overflow_is_possible$ = -5				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0BM@@std@@YAII@Z PROC		; std::_Get_size_of_n<28>, COMDAT

; 79   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 80   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR __Overflow_is_possible$[ebp], 1

; 81   : 
; 82   :     if constexpr (_Overflow_is_possible) {
; 83   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	DWORD PTR __Max_possible$1[ebp], 153391689 ; 09249249H

; 84   :         if (_Count > _Max_possible) {

	cmp	DWORD PTR __Count$[ebp], 153391689	; 09249249H
	jbe	SHORT $LN2@Get_size_o

; 85   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	imul	eax, DWORD PTR __Count$[ebp], 28
$LN1@Get_size_o:

; 90   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_size_of_n@$0BM@@std@@YAII@Z ENDP		; std::_Get_size_of_n<28>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Refancy_maybe_null@PAPAVCSpeedTreeRT@@$0A@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy_maybe_null@PAPAVCSpeedTreeRT@@$0A@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@@Z PROC ; std::_Refancy_maybe_null<CSpeedTreeRT * *,0>, COMDAT

; 281  : _CONSTEXPR20 _Pointer _Refancy_maybe_null(_Pointer _Ptr) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 282  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]

; 283  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Refancy_maybe_null@PAPAVCSpeedTreeRT@@$0A@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@@Z ENDP ; std::_Refancy_maybe_null<CSpeedTreeRT * *,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AAV?$allocator@D@std@@@std@@YAAAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$allocator@D@std@@@std@@YAAAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> &>, COMDAT

; 1536 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1538 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@AAV?$allocator@D@std@@@std@@YAAAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -32						; size = 4
__Ptr_container$ = -20					; size = 4
__Block_size$ = -8					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 151  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 152  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	mov	eax, DWORD PTR __Bytes$[ebp]
	add	eax, 39					; 00000027H
	mov	DWORD PTR __Block_size$[ebp], eax

; 154  :     if (_Block_size <= _Bytes) {

	mov	eax, DWORD PTR __Block_size$[ebp]
	cmp	eax, DWORD PTR __Bytes$[ebp]
	ja	SHORT $LN8@Allocate_m

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN8@Allocate_m:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	eax, DWORD PTR __Block_size$[ebp]
	push	eax
	call	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
	add	esp, 4
	mov	DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	cmp	DWORD PTR __Ptr_container$[ebp], 0
	je	SHORT $LN9@Allocate_m
	jmp	SHORT $LN6@Allocate_m
$LN9@Allocate_m:
	mov	esi, esp
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	159					; 0000009fH
	push	OFFSET ??_C@_0GC@GDGMGNBP@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN12@Allocate_m
	int	3
$LN12@Allocate_m:
	mov	esi, esp
	push	0
	push	159					; 0000009fH
	push	OFFSET ??_C@_1ME@KJJNLLPL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN9@Allocate_m
$LN6@Allocate_m:
	xor	eax, eax
	jne	SHORT $LN4@Allocate_m

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	mov	eax, DWORD PTR __Ptr_container$[ebp]
	add	eax, 39					; 00000027H
	and	eax, -32				; ffffffe0H
	mov	DWORD PTR __Ptr$[ebp], eax

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	eax, 4
	imul	ecx, eax, -1
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 162  : 
; 163  : #ifdef _DEBUG
; 164  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

	mov	eax, 4
	imul	ecx, eax, -2
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+ecx], -84215046		; fafafafaH

; 165  : #endif // defined(_DEBUG)
; 166  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN1@Allocate_m:

; 167  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1536 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1538 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2177 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2178 : #if _HAS_CXX23
; 2179 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2180 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2181 :         _Count                  = _Allocated;
; 2182 :         return _Ptr;
; 2183 :     } else
; 2184 : #endif // _HAS_CXX23
; 2185 :     {
; 2186 :         return _Al.allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 2187 :     }
; 2188 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@QAE$$QAE@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@QAE$$QAE@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>, COMDAT

; 696  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 697  : #if _HAS_CXX20
; 698  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 699  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 700  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	1
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@E@std@@YA$$QAEAAE@Z		; std::forward<unsigned char>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	movzx	eax, BYTE PTR [eax]
	mov	BYTE PTR [edx], al

; 701  : #endif // ^^^ !_HAS_CXX20 ^^^
; 702  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@QAE$$QAE@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Construct_in_place@EE@std@@YAXAAE$$QAE@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@EE@std@@YAXAAE$$QAE@Z PROC	; std::_Construct_in_place<unsigned char,unsigned char>, COMDAT

; 381  :     is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 382  : #if _HAS_CXX20
; 383  :     if (_STD is_constant_evaluated()) {
; 384  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 385  :     } else
; 386  : #endif // _HAS_CXX20
; 387  :     {
; 388  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@E@std@@YAPAEAAE@Z		; std::addressof<unsigned char>
	add	esp, 4
	push	eax
	push	1
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@E@std@@YA$$QAEAAE@Z		; std::forward<unsigned char>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	movzx	eax, BYTE PTR [eax]
	mov	BYTE PTR [edx], al

; 389  :     }
; 390  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct_in_place@EE@std@@YAXAAE$$QAE@Z ENDP	; std::_Construct_in_place<unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 1779 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1780 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	??$_Unfancy@E@std@@YAPAEPAE@Z		; std::_Unfancy<unsigned char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	??$construct@E$$V@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@QAE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char>
	add	esp, 8

; 1781 :         ++_Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1782 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAEPAEXZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release, COMDAT
; _this$ = ecx

; 1784 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1785 :         _First = _Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 1786 :         return _Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 1787 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAEPAEXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 1774 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1775 :         _STD _Destroy_range(_First, _Last, _Al);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
	add	esp, 12					; 0000000cH

; 1776 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAE@PAEAAV?$allocator@E@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAE@PAEAAV?$allocator@E@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 1769 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Al_$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAE@PAEAAV?$allocator@E@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Zero_range@PAE@std@@YAPAEQAE0@Z
_TEXT	SEGMENT
__Last_ch$ = -20					; size = 4
__First_ch$ = -8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAE@std@@YAPAEQAE0@Z PROC		; std::_Zero_range<unsigned char *>, COMDAT

; 1995 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1996 :     char* const _First_ch = reinterpret_cast<char*>(_STD _To_address(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_To_address@PAE@std@@YA?A_PABQAE@Z	; std::_To_address<unsigned char *>
	add	esp, 4
	mov	DWORD PTR __First_ch$[ebp], eax

; 1997 :     char* const _Last_ch  = reinterpret_cast<char*>(_STD _To_address(_Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_To_address@PAE@std@@YA?A_PABQAE@Z	; std::_To_address<unsigned char *>
	add	esp, 4
	mov	DWORD PTR __Last_ch$[ebp], eax

; 1998 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	eax, DWORD PTR __Last_ch$[ebp]
	sub	eax, DWORD PTR __First_ch$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __First_ch$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1999 :     return _Last;

	mov	eax, DWORD PTR __Last$[ebp]

; 2000 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Zero_range@PAE@std@@YAPAEQAE0@Z ENDP		; std::_Zero_range<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Unfancy@E@std@@YAPAEPAE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@E@std@@YAPAEPAE@Z PROC			; std::_Unfancy<unsigned char>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 36   :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]

; 37   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unfancy@E@std@@YAPAEPAE@Z ENDP			; std::_Unfancy<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
$T2 = -256						; size = 4
__Backout$ = -52					; size = 12
__ULast$ = -32						; size = 4
__UFirst$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >, COMDAT

; 1905 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1906 :     // move [_First, _Last) to raw _Dest, using _Al
; 1907 :     // note: only called internally from elsewhere in the STL
; 1908 :     using _Ptrval     = typename _Alloc::value_type*;
; 1909 :     auto _UFirst      = _Get_unwrapped(_First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Get_unwrapped@ABQAE@std@@YA?A_TABQAE@Z ; std::_Get_unwrapped<unsigned char * const &>
	add	esp, 4
	mov	DWORD PTR __UFirst$[ebp], eax

; 1910 :     const auto _ULast = _Get_unwrapped(_Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Get_unwrapped@ABQAE@std@@YA?A_TABQAE@Z ; std::_Get_unwrapped<unsigned char * const &>
	add	esp, 4
	mov	DWORD PTR __ULast$[ebp], eax

; 1911 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1912 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1913 : #if _HAS_CXX20
; 1914 :         if (!_STD is_constant_evaluated())
; 1915 : #endif // _HAS_CXX20
; 1916 :         {
; 1917 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Unfancy@E@std@@YAPAEPAE@Z		; std::_Unfancy<unsigned char>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __ULast$[ebp]
	push	ecx
	mov	edx, DWORD PTR __UFirst$[ebp]
	push	edx
	call	??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ; std::_Copy_memmove<unsigned char *,unsigned char *>
	add	esp, 12					; 0000000cH

; 1918 :             return _Dest + (_ULast - _UFirst);

	mov	eax, DWORD PTR __ULast$[ebp]
	sub	eax, DWORD PTR __UFirst$[ebp]
	add	eax, DWORD PTR __Dest$[ebp]
	jmp	SHORT $LN1@Uninitiali

; 1919 :         }
; 1920 :     }
; 1921 : 
; 1922 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAE@PAEAAV?$allocator@E@1@@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1923 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	eax, DWORD PTR __UFirst$[ebp]
	add	eax, 1
	mov	DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
	mov	eax, DWORD PTR __UFirst$[ebp]
	cmp	eax, DWORD PTR __ULast$[ebp]
	je	SHORT $LN3@Uninitiali

; 1924 :         _Backout._Emplace_back(_STD move(*_UFirst));

	mov	eax, DWORD PTR __UFirst$[ebp]
	push	eax
	call	??$move@AAE@std@@YA$$QAEAAE@Z		; std::move<unsigned char &>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAEX$$QAE@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char>
	npad	1

; 1925 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1926 : 
; 1927 :     return _Backout._Release();

	lea	ecx, DWORD PTR __Backout$[ebp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAEPAEXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
	mov	eax, DWORD PTR $T2[ebp]
$LN1@Uninitiali:

; 1928 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Uninitiali
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 260				; 00000104H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN10@Uninitiali:
	DD	1
	DD	$LN9@Uninitiali
$LN9@Uninitiali:
	DD	-52					; ffffffccH
	DD	12					; 0000000cH
	DD	$LN7@Uninitiali
$LN7@Uninitiali:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z$0:
	lea	ecx, DWORD PTR __Backout$[ebp]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-264]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPAEAAV?$allocator@E@0@AAI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPAEAAV?$allocator@E@0@AAI@Z PROC ; std::_Allocate_at_least_helper<std::allocator<unsigned char> >, COMDAT

; 2177 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2178 : #if _HAS_CXX23
; 2179 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2180 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2181 :         _Count                  = _Allocated;
; 2182 :         return _Ptr;
; 2183 :     } else
; 2184 : #endif // _HAS_CXX23
; 2185 :     {
; 2186 :         return _Al.allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@E@std@@QAEPAEI@Z	; std::allocator<unsigned char>::allocate

; 2187 :     }
; 2188 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPAEAAV?$allocator@E@0@AAI@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z
_TEXT	SEGMENT
$T2 = -256						; size = 4
__Backout$ = -52					; size = 12
__ULast$ = -32						; size = 4
__UFirst$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z PROC ; std::_Uninitialized_move<CSpeedTreeRT * *,std::allocator<CSpeedTreeRT *> >, COMDAT

; 1905 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninitialized_move@PAPAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1906 :     // move [_First, _Last) to raw _Dest, using _Al
; 1907 :     // note: only called internally from elsewhere in the STL
; 1908 :     using _Ptrval     = typename _Alloc::value_type*;
; 1909 :     auto _UFirst      = _Get_unwrapped(_First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Get_unwrapped@ABQAPAVCSpeedTreeRT@@@std@@YA?A_TABQAPAVCSpeedTreeRT@@@Z ; std::_Get_unwrapped<CSpeedTreeRT * * const &>
	add	esp, 4
	mov	DWORD PTR __UFirst$[ebp], eax

; 1910 :     const auto _ULast = _Get_unwrapped(_Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Get_unwrapped@ABQAPAVCSpeedTreeRT@@@std@@YA?A_TABQAPAVCSpeedTreeRT@@@Z ; std::_Get_unwrapped<CSpeedTreeRT * * const &>
	add	esp, 4
	mov	DWORD PTR __ULast$[ebp], eax

; 1911 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1912 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1913 : #if _HAS_CXX20
; 1914 :         if (!_STD is_constant_evaluated())
; 1915 : #endif // _HAS_CXX20
; 1916 :         {
; 1917 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Unfancy@PAVCSpeedTreeRT@@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@@Z ; std::_Unfancy<CSpeedTreeRT *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __ULast$[ebp]
	push	ecx
	mov	edx, DWORD PTR __UFirst$[ebp]
	push	edx
	call	??$_Copy_memmove@PAPAVCSpeedTreeRT@@PAPAV1@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@00@Z ; std::_Copy_memmove<CSpeedTreeRT * *,CSpeedTreeRT * *>
	add	esp, 12					; 0000000cH

; 1918 :             return _Dest + (_ULast - _UFirst);

	mov	eax, DWORD PTR __ULast$[ebp]
	sub	eax, DWORD PTR __UFirst$[ebp]
	sar	eax, 2
	mov	ecx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN1@Uninitiali

; 1919 :         }
; 1920 :     }
; 1921 : 
; 1922 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@PAPAVCSpeedTreeRT@@AAV?$allocator@PAVCSpeedTreeRT@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1923 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	eax, DWORD PTR __UFirst$[ebp]
	add	eax, 4
	mov	DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
	mov	eax, DWORD PTR __UFirst$[ebp]
	cmp	eax, DWORD PTR __ULast$[ebp]
	je	SHORT $LN3@Uninitiali

; 1924 :         _Backout._Emplace_back(_STD move(*_UFirst));

	mov	eax, DWORD PTR __UFirst$[ebp]
	push	eax
	call	??$move@AAPAVCSpeedTreeRT@@@std@@YA$$QAPAVCSpeedTreeRT@@AAPAV1@@Z ; std::move<CSpeedTreeRT * &>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??$_Emplace_back@PAVCSpeedTreeRT@@@?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAEX$$QAPAVCSpeedTreeRT@@@Z ; std::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >::_Emplace_back<CSpeedTreeRT *>
	npad	1

; 1925 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1926 : 
; 1927 :     return _Backout._Release();

	lea	ecx, DWORD PTR __Backout$[ebp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAEPAPAVCSpeedTreeRT@@XZ ; std::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >::_Release
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >::~_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >
	mov	eax, DWORD PTR $T2[ebp]
$LN1@Uninitiali:

; 1928 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Uninitiali
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 260				; 00000104H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN10@Uninitiali:
	DD	1
	DD	$LN9@Uninitiali
$LN9@Uninitiali:
	DD	-52					; ffffffccH
	DD	12					; 0000000cH
	DD	$LN7@Uninitiali
$LN7@Uninitiali:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move@PAPAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z$0:
	lea	ecx, DWORD PTR __Backout$[ebp]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >::~_Uninitialized_backout_al<std::allocator<CSpeedTreeRT *> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Uninitialized_move@PAPAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-264]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninitialized_move@PAPAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move@PAPAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z ENDP ; std::_Uninitialized_move<CSpeedTreeRT * *,std::allocator<CSpeedTreeRT *> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@PAVCSpeedTreeRT@@PAV1@@?$_Default_allocator_traits@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@SAXAAV?$allocator@PAVCSpeedTreeRT@@@1@QAPAVCSpeedTreeRT@@$$QAPAV3@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCSpeedTreeRT@@PAV1@@?$_Default_allocator_traits@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@SAXAAV?$allocator@PAVCSpeedTreeRT@@@1@QAPAVCSpeedTreeRT@@$$QAPAV3@@Z PROC ; std::_Default_allocator_traits<std::allocator<CSpeedTreeRT *> >::construct<CSpeedTreeRT *,CSpeedTreeRT *>, COMDAT

; 696  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 697  : #if _HAS_CXX20
; 698  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 699  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 700  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@PAVCSpeedTreeRT@@@std@@YA$$QAPAVCSpeedTreeRT@@AAPAV1@@Z ; std::forward<CSpeedTreeRT *>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 701  : #endif // ^^^ !_HAS_CXX20 ^^^
; 702  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@PAVCSpeedTreeRT@@PAV1@@?$_Default_allocator_traits@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@SAXAAV?$allocator@PAVCSpeedTreeRT@@@1@QAPAVCSpeedTreeRT@@$$QAPAV3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<CSpeedTreeRT *> >::construct<CSpeedTreeRT *,CSpeedTreeRT *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@AAV?$allocator@PAVCSpeedTreeRT@@@0@AAI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Allocate_at_least_helper@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@AAV?$allocator@PAVCSpeedTreeRT@@@0@AAI@Z PROC ; std::_Allocate_at_least_helper<std::allocator<CSpeedTreeRT *> >, COMDAT

; 2177 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2178 : #if _HAS_CXX23
; 2179 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2180 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2181 :         _Count                  = _Allocated;
; 2182 :         return _Ptr;
; 2183 :     } else
; 2184 : #endif // _HAS_CXX23
; 2185 :     {
; 2186 :         return _Al.allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@PAVCSpeedTreeRT@@@std@@QAEPAPAVCSpeedTreeRT@@I@Z ; std::allocator<CSpeedTreeRT *>::allocate

; 2187 :     }
; 2188 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate_at_least_helper@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@AAV?$allocator@PAVCSpeedTreeRT@@@0@AAI@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<CSpeedTreeRT *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Construct_in_place@PAVCSpeedTreeRT@@PAV1@@std@@YAXAAPAVCSpeedTreeRT@@$$QAPAV1@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAVCSpeedTreeRT@@PAV1@@std@@YAXAAPAVCSpeedTreeRT@@$$QAPAV1@@Z PROC ; std::_Construct_in_place<CSpeedTreeRT *,CSpeedTreeRT *>, COMDAT

; 381  :     is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 382  : #if _HAS_CXX20
; 383  :     if (_STD is_constant_evaluated()) {
; 384  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 385  :     } else
; 386  : #endif // _HAS_CXX20
; 387  :     {
; 388  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@PAVCSpeedTreeRT@@@std@@YAPAPAVCSpeedTreeRT@@AAPAV1@@Z ; std::addressof<CSpeedTreeRT *>
	add	esp, 4
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@PAVCSpeedTreeRT@@@std@@YA$$QAPAVCSpeedTreeRT@@AAPAV1@@Z ; std::forward<CSpeedTreeRT *>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 389  :     }
; 390  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct_in_place@PAVCSpeedTreeRT@@PAV1@@std@@YAXAAPAVCSpeedTreeRT@@$$QAPAV1@@Z ENDP ; std::_Construct_in_place<CSpeedTreeRT *,CSpeedTreeRT *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z PROC ; std::forward<std::_Container_base12 *>, COMDAT

; 1536 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1538 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ENDP ; std::forward<std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 1559 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1560 :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 1561 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 682  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 683  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 684  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 685  :         if (_STD is_constant_evaluated()) {
; 686  :             _Al.deallocate(_Ptr, _Count);
; 687  :         } else
; 688  : #endif // _HAS_CXX20
; 689  :         {
; 690  :             (void) _Al;
; 691  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07@std@@YAXPAXI@Z	; std::_Deallocate<8>
	add	esp, 8

; 692  :         }
; 693  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@QAU1@0PAU1@AAV?$allocator@USShape@@@0@@Z
_TEXT	SEGMENT
$T2 = -256						; size = 4
__Backout$ = -52					; size = 12
__ULast$ = -32						; size = 4
__UFirst$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@QAU1@0PAU1@AAV?$allocator@USShape@@@0@@Z PROC ; std::_Uninitialized_move<SShape *,std::allocator<SShape> >, COMDAT

; 1905 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninitialized_move@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@QAU1@0PAU1@AAV?$allocator@USShape@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1906 :     // move [_First, _Last) to raw _Dest, using _Al
; 1907 :     // note: only called internally from elsewhere in the STL
; 1908 :     using _Ptrval     = typename _Alloc::value_type*;
; 1909 :     auto _UFirst      = _Get_unwrapped(_First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Get_unwrapped@ABQAUSShape@@@std@@YA?A_TABQAUSShape@@@Z ; std::_Get_unwrapped<SShape * const &>
	add	esp, 4
	mov	DWORD PTR __UFirst$[ebp], eax

; 1910 :     const auto _ULast = _Get_unwrapped(_Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Get_unwrapped@ABQAUSShape@@@std@@YA?A_TABQAUSShape@@@Z ; std::_Get_unwrapped<SShape * const &>
	add	esp, 4
	mov	DWORD PTR __ULast$[ebp], eax

; 1911 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1912 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1913 : #if _HAS_CXX20
; 1914 :         if (!_STD is_constant_evaluated())
; 1915 : #endif // _HAS_CXX20
; 1916 :         {
; 1917 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Unfancy@USShape@@@std@@YAPAUSShape@@PAU1@@Z ; std::_Unfancy<SShape>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __ULast$[ebp]
	push	ecx
	mov	edx, DWORD PTR __UFirst$[ebp]
	push	edx
	call	??$_Copy_memmove@PAUSShape@@PAU1@@std@@YAPAUSShape@@PAU1@00@Z ; std::_Copy_memmove<SShape *,SShape *>
	add	esp, 12					; 0000000cH

; 1918 :             return _Dest + (_ULast - _UFirst);

	mov	eax, DWORD PTR __ULast$[ebp]
	sub	eax, DWORD PTR __UFirst$[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	imul	eax, eax, 28
	add	eax, DWORD PTR __Dest$[ebp]
	jmp	SHORT $LN1@Uninitiali

; 1919 :         }
; 1920 :     }
; 1921 : 
; 1922 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAE@PAUSShape@@AAV?$allocator@USShape@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<SShape> >::_Uninitialized_backout_al<std::allocator<SShape> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1923 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	eax, DWORD PTR __UFirst$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
	mov	eax, DWORD PTR __UFirst$[ebp]
	cmp	eax, DWORD PTR __ULast$[ebp]
	je	SHORT $LN3@Uninitiali

; 1924 :         _Backout._Emplace_back(_STD move(*_UFirst));

	mov	eax, DWORD PTR __UFirst$[ebp]
	push	eax
	call	??$move@AAUSShape@@@std@@YA$$QAUSShape@@AAU1@@Z ; std::move<SShape &>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??$_Emplace_back@USShape@@@?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAEX$$QAUSShape@@@Z ; std::_Uninitialized_backout_al<std::allocator<SShape> >::_Emplace_back<SShape>
	npad	1

; 1925 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1926 : 
; 1927 :     return _Backout._Release();

	lea	ecx, DWORD PTR __Backout$[ebp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAEPAUSShape@@XZ ; std::_Uninitialized_backout_al<std::allocator<SShape> >::_Release
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<SShape> >::~_Uninitialized_backout_al<std::allocator<SShape> >
	mov	eax, DWORD PTR $T2[ebp]
$LN1@Uninitiali:

; 1928 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Uninitiali
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 260				; 00000104H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@Uninitiali:
	DD	1
	DD	$LN9@Uninitiali
$LN9@Uninitiali:
	DD	-52					; ffffffccH
	DD	12					; 0000000cH
	DD	$LN7@Uninitiali
$LN7@Uninitiali:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@QAU1@0PAU1@AAV?$allocator@USShape@@@0@@Z$0:
	lea	ecx, DWORD PTR __Backout$[ebp]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<SShape> >::~_Uninitialized_backout_al<std::allocator<SShape> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Uninitialized_move@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@QAU1@0PAU1@AAV?$allocator@USShape@@@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-264]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninitialized_move@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@QAU1@0PAU1@AAV?$allocator@USShape@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@QAU1@0PAU1@AAV?$allocator@USShape@@@0@@Z ENDP ; std::_Uninitialized_move<SShape *,std::allocator<SShape> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@USShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAXAAV?$allocator@USShape@@@1@QAUSShape@@ABU3@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@USShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAXAAV?$allocator@USShape@@@1@QAUSShape@@ABU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<SShape> >::construct<SShape,SShape const &>, COMDAT

; 696  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 697  : #if _HAS_CXX20
; 698  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 699  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 700  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	28					; 0000001cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@ABUSShape@@@std@@YAABUSShape@@ABU1@@Z ; std::forward<SShape const &>
	add	esp, 4
	mov	ecx, 7
	mov	esi, eax
	mov	edi, DWORD PTR $T1[ebp]
	rep movsd

; 701  : #endif // ^^^ !_HAS_CXX20 ^^^
; 702  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@USShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAXAAV?$allocator@USShape@@@1@QAUSShape@@ABU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SShape> >::construct<SShape,SShape const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Construct_in_place@USShape@@ABU1@@std@@YAXAAUSShape@@ABU1@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@USShape@@ABU1@@std@@YAXAAUSShape@@ABU1@@Z PROC ; std::_Construct_in_place<SShape,SShape const &>, COMDAT

; 381  :     is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 382  : #if _HAS_CXX20
; 383  :     if (_STD is_constant_evaluated()) {
; 384  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 385  :     } else
; 386  : #endif // _HAS_CXX20
; 387  :     {
; 388  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@USShape@@@std@@YAPAUSShape@@AAU1@@Z ; std::addressof<SShape>
	add	esp, 4
	push	eax
	push	28					; 0000001cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@ABUSShape@@@std@@YAABUSShape@@ABU1@@Z ; std::forward<SShape const &>
	add	esp, 4
	mov	ecx, 7
	mov	esi, eax
	mov	edi, DWORD PTR $T1[ebp]
	rep movsd

; 389  :     }
; 390  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct_in_place@USShape@@ABU1@@std@@YAXAAUSShape@@ABU1@@Z ENDP ; std::_Construct_in_place<SShape,SShape const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Copy_memmove@PAUSShape@@PAU1@@std@@YAPAUSShape@@PAU1@00@Z
_TEXT	SEGMENT
__Count$ = -80						; size = 4
__Dest_ch$ = -68					; size = 4
__Last_ch$ = -56					; size = 4
__First_ch$ = -44					; size = 4
__DestPtr$ = -32					; size = 4
__LastPtr$ = -20					; size = 4
__FirstPtr$ = -8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUSShape@@PAU1@@std@@YAPAUSShape@@PAU1@00@Z PROC ; std::_Copy_memmove<SShape *,SShape *>, COMDAT

; 4613 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 21					; 00000015H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4614 :     auto _FirstPtr              = _STD _To_address(_First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_To_address@PAUSShape@@@std@@YA?A_PABQAUSShape@@@Z ; std::_To_address<SShape *>
	add	esp, 4
	mov	DWORD PTR __FirstPtr$[ebp], eax

; 4615 :     auto _LastPtr               = _STD _To_address(_Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_To_address@PAUSShape@@@std@@YA?A_PABQAUSShape@@@Z ; std::_To_address<SShape *>
	add	esp, 4
	mov	DWORD PTR __LastPtr$[ebp], eax

; 4616 :     auto _DestPtr               = _STD _To_address(_Dest);

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_To_address@PAUSShape@@@std@@YA?A_PABQAUSShape@@@Z ; std::_To_address<SShape *>
	add	esp, 4
	mov	DWORD PTR __DestPtr$[ebp], eax

; 4617 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

	mov	eax, DWORD PTR __FirstPtr$[ebp]
	mov	DWORD PTR __First_ch$[ebp], eax

; 4618 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

	mov	eax, DWORD PTR __LastPtr$[ebp]
	mov	DWORD PTR __Last_ch$[ebp], eax

; 4619 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

	mov	eax, DWORD PTR __DestPtr$[ebp]
	mov	DWORD PTR __Dest_ch$[ebp], eax

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR __Last_ch$[ebp]
	sub	eax, DWORD PTR __First_ch$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First_ch$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest_ch$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 4622 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4623 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	mov	eax, DWORD PTR __Dest_ch$[ebp]
	add	eax, DWORD PTR __Count$[ebp]

; 4624 :     } else {
; 4625 :         return _Dest + (_LastPtr - _FirstPtr);
; 4626 :     }
; 4627 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_memmove@PAUSShape@@PAU1@@std@@YAPAUSShape@@PAU1@00@Z ENDP ; std::_Copy_memmove<SShape *,SShape *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Emplace_back@AAUSShape@@@?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAEXAAUSShape@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@AAUSShape@@@?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAEXAAUSShape@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<SShape> >::_Emplace_back<SShape &>, COMDAT
; _this$ = ecx

; 1779 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1780 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR _<_Vals_0>$[ebp]
	push	eax
	call	??$forward@AAUSShape@@@std@@YAAAUSShape@@AAU1@@Z ; std::forward<SShape &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$_Unfancy@USShape@@@std@@YAPAUSShape@@PAU1@@Z ; std::_Unfancy<SShape>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	??$construct@USShape@@AAU1@@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAXAAV?$allocator@USShape@@@1@QAUSShape@@AAU3@@Z ; std::_Default_allocator_traits<std::allocator<SShape> >::construct<SShape,SShape &>
	add	esp, 12					; 0000000cH

; 1781 :         ++_Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1782 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Emplace_back@AAUSShape@@@?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAEXAAUSShape@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<SShape> >::_Emplace_back<SShape &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAEPAUSShape@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Release@?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAEPAUSShape@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<SShape> >::_Release, COMDAT
; _this$ = ecx

; 1784 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1785 :         _First = _Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 1786 :         return _Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 1787 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAEPAUSShape@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<SShape> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<SShape> >::~_Uninitialized_backout_al<std::allocator<SShape> >, COMDAT
; _this$ = ecx

; 1774 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1775 :         _STD _Destroy_range(_First, _Last, _Al);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$_Destroy_range@V?$allocator@USShape@@@std@@@std@@YAXPAUSShape@@QAU1@AAV?$allocator@USShape@@@0@@Z ; std::_Destroy_range<std::allocator<SShape> >
	add	esp, 12					; 0000000cH

; 1776 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<SShape> >::~_Uninitialized_backout_al<std::allocator<SShape> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAE@PAUSShape@@AAV?$allocator@USShape@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAE@PAUSShape@@AAV?$allocator@USShape@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<SShape> >::_Uninitialized_backout_al<std::allocator<SShape> >, COMDAT
; _this$ = ecx

; 1769 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Al_$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAE@PAUSShape@@AAV?$allocator@USShape@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<SShape> >::_Uninitialized_backout_al<std::allocator<SShape> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Unfancy@USShape@@@std@@YAPAUSShape@@PAU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@USShape@@@std@@YAPAUSShape@@PAU1@@Z PROC	; std::_Unfancy<SShape>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 36   :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]

; 37   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unfancy@USShape@@@std@@YAPAUSShape@@PAU1@@Z ENDP	; std::_Unfancy<SShape>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Get_unwrapped@PAUSShape@@@std@@YA?A_T$$QAPAUSShape@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@PAUSShape@@@std@@YA?A_T$$QAPAUSShape@@@Z PROC ; std::_Get_unwrapped<SShape *>, COMDAT

; 1304 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1305 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1306 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1307 :         return _It + 0;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1308 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1309 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1310 :     } else {
; 1311 :         return static_cast<_Iter&&>(_It);
; 1312 :     }
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_unwrapped@PAUSShape@@@std@@YA?A_T$$QAPAUSShape@@@Z ENDP ; std::_Get_unwrapped<SShape *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@PAPAVCSpeedTreeRT@@@std@@YA$$QAPAPAVCSpeedTreeRT@@AAPAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAPAVCSpeedTreeRT@@@std@@YA$$QAPAPAVCSpeedTreeRT@@AAPAPAV1@@Z PROC ; std::forward<CSpeedTreeRT * *>, COMDAT

; 1536 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1538 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@PAPAVCSpeedTreeRT@@@std@@YA$$QAPAPAVCSpeedTreeRT@@AAPAPAV1@@Z ENDP ; std::forward<CSpeedTreeRT * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$__std_find_trivial@PAVCSpeedTreeRT@@PAV1@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0QAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$__std_find_trivial@PAVCSpeedTreeRT@@PAV1@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0QAV1@@Z PROC ; std::__std_find_trivial<CSpeedTreeRT *,CSpeedTreeRT *>, COMDAT

; 153  : _Ty* __std_find_trivial(_Ty* const _First, _Ty* const _Last, const _TVal _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 154  :     if constexpr (is_pointer_v<_TVal> || is_null_pointer_v<_TVal>) {
; 155  :         return _STD __std_find_trivial(_First, _Last, reinterpret_cast<uintptr_t>(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$__std_find_trivial@PAVCSpeedTreeRT@@I@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0I@Z ; std::__std_find_trivial<CSpeedTreeRT *,unsigned int>
	add	esp, 12					; 0000000cH

; 156  :     } else if constexpr (sizeof(_Ty) == 1) {
; 157  :         return const_cast<_Ty*>(
; 158  :             static_cast<const _Ty*>(::__std_find_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
; 159  :     } else if constexpr (sizeof(_Ty) == 2) {
; 160  :         return const_cast<_Ty*>(
; 161  :             static_cast<const _Ty*>(::__std_find_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
; 162  :     } else if constexpr (sizeof(_Ty) == 4) {
; 163  :         return const_cast<_Ty*>(
; 164  :             static_cast<const _Ty*>(::__std_find_trivial_4(_First, _Last, static_cast<uint32_t>(_Val))));
; 165  :     } else if constexpr (sizeof(_Ty) == 8) {
; 166  :         return const_cast<_Ty*>(
; 167  :             static_cast<const _Ty*>(::__std_find_trivial_8(_First, _Last, static_cast<uint64_t>(_Val))));
; 168  :     } else {
; 169  :         static_assert(_Always_false<_Ty>, "Unexpected size");
; 170  :     }
; 171  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$__std_find_trivial@PAVCSpeedTreeRT@@PAV1@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0QAV1@@Z ENDP ; std::__std_find_trivial<CSpeedTreeRT *,CSpeedTreeRT *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_To_address@PAPAVCSpeedTreeRT@@@std@@YA?A_PABQAPAVCSpeedTreeRT@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PAPAVCSpeedTreeRT@@@std@@YA?A_PABQAPAVCSpeedTreeRT@@@Z PROC ; std::_To_address<CSpeedTreeRT * *>, COMDAT

; 4491 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 4492 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4493 :     return _Val;

	mov	eax, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [eax]

; 4494 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_To_address@PAPAVCSpeedTreeRT@@@std@@YA?A_PABQAPAVCSpeedTreeRT@@@Z ENDP ; std::_To_address<CSpeedTreeRT * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Could_compare_equal_to_value_type@PAPAVCSpeedTreeRT@@PAV1@@std@@YA_NABQAVCSpeedTreeRT@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Could_compare_equal_to_value_type@PAPAVCSpeedTreeRT@@PAV1@@std@@YA_NABQAVCSpeedTreeRT@@@Z PROC ; std::_Could_compare_equal_to_value_type<CSpeedTreeRT * *,CSpeedTreeRT *>, COMDAT

; 5850 : _NODISCARD constexpr bool _Could_compare_equal_to_value_type(const _Ty& _Val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 5851 :     // check whether _Val is within the limits of _Elem
; 5852 :     _STL_INTERNAL_STATIC_ASSERT(_Vector_alg_in_find_is_safe<_InIt, _Ty>);
; 5853 : 
; 5854 :     if constexpr (disjunction_v<
; 5855 : #ifdef __cpp_lib_byte
; 5856 :                       is_same<_Ty, byte>,
; 5857 : #endif // defined(__cpp_lib_byte)
; 5858 :                       is_same<_Ty, bool>, is_pointer<_Ty>, is_same<_Ty, nullptr_t>>) {
; 5859 :         return true;

	mov	al, 1

; 5860 :     } else {
; 5861 :         using _Elem = _Iter_value_t<_InIt>;
; 5862 :         _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Elem> && is_integral_v<_Ty>);
; 5863 : 
; 5864 :         if constexpr (is_same_v<_Elem, bool>) {
; 5865 :             return _Val == true || _Val == false;
; 5866 :         } else if constexpr (is_signed_v<_Elem>) {
; 5867 :             // use instead of numeric_limits::min/max; avoid <limits> dependency
; 5868 :             constexpr _Elem _Min = static_cast<_Elem>(_Elem{1} << (sizeof(_Elem) * CHAR_BIT - 1));
; 5869 :             constexpr _Elem _Max = static_cast<_Elem>(~_Min);
; 5870 : 
; 5871 :             if constexpr (is_signed_v<_Ty>) {
; 5872 :                 // signed _Elem, signed _Ty
; 5873 :                 return _Min <= _Val && _Val <= _Max;
; 5874 :             } else {
; 5875 :                 // signed _Elem, unsigned _Ty
; 5876 :                 if constexpr (_Elem{-1} == static_cast<_Ty>(-1)) {
; 5877 :                     // negative values of _Elem can compare equal to values of _Ty
; 5878 :                     return _Val <= _Max || static_cast<_Ty>(_Min) <= _Val;
; 5879 :                 } else {
; 5880 :                     // negative values of _Elem cannot compare equal to values of _Ty
; 5881 :                     return _Val <= _Max;
; 5882 :                 }
; 5883 :             }
; 5884 :         } else {
; 5885 :             constexpr _Elem _Max = static_cast<_Elem>(~_Elem{0});
; 5886 : 
; 5887 :             if constexpr (is_unsigned_v<_Ty>) {
; 5888 :                 // unsigned _Elem, unsigned _Ty
; 5889 :                 return _Val <= _Max;
; 5890 :             } else {
; 5891 :                 // unsigned _Elem, signed _Ty
; 5892 :                 if constexpr (_Ty{-1} == static_cast<_Elem>(-1)) {
; 5893 :                     // negative values of _Ty can compare equal to values of _Elem
; 5894 :                     return _Val <= _Max;
; 5895 :                 } else {
; 5896 :                     // negative values of _Ty cannot compare equal to values of _Elem
; 5897 :                     return 0 <= _Val && _Val <= _Max;
; 5898 :                 }
; 5899 :             }
; 5900 :         }
; 5901 :     }
; 5902 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Could_compare_equal_to_value_type@PAPAVCSpeedTreeRT@@PAV1@@std@@YA_NABQAVCSpeedTreeRT@@@Z ENDP ; std::_Could_compare_equal_to_value_type<CSpeedTreeRT * *,CSpeedTreeRT *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@AAV?$allocator@USShape@@@0@AAI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Allocate_at_least_helper@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@AAV?$allocator@USShape@@@0@AAI@Z PROC ; std::_Allocate_at_least_helper<std::allocator<SShape> >, COMDAT

; 2177 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2178 : #if _HAS_CXX23
; 2179 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2180 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2181 :         _Count                  = _Allocated;
; 2182 :         return _Ptr;
; 2183 :     } else
; 2184 : #endif // _HAS_CXX23
; 2185 :     {
; 2186 :         return _Al.allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@USShape@@@std@@QAEPAUSShape@@I@Z ; std::allocator<SShape>::allocate

; 2187 :     }
; 2188 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate_at_least_helper@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@AAV?$allocator@USShape@@@0@AAI@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<SShape> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Lhs$ = 8						; size = 4
__Rhs$ = 12						; size = 4
??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NABV?$allocator@D@0@0@Z PROC ; std::_Allocators_equal<std::allocator<char> >, COMDAT

; 2152 : _NODISCARD constexpr bool _Allocators_equal(const _Alloc& _Lhs, const _Alloc& _Rhs) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 2153 :     if constexpr (allocator_traits<_Alloc>::is_always_equal::value) {
; 2154 :         return true;

	mov	al, 1

; 2155 :     } else {
; 2156 :         return _Lhs == _Rhs;
; 2157 :     }
; 2158 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NABV?$allocator@D@0@0@Z ENDP ; std::_Allocators_equal<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0AAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@AAV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0AAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@AAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> &>, COMDAT
; _this$ = ecx

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	call	??$forward@AAV?$allocator@D@std@@@std@@YAAAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> &>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0AAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@AAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Unfancy_maybe_null@PAVCSpeedTreeRT@@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy_maybe_null@PAVCSpeedTreeRT@@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@@Z PROC ; std::_Unfancy_maybe_null<CSpeedTreeRT *>, COMDAT

; 46   : constexpr _Ty* _Unfancy_maybe_null(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 47   :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]

; 48   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unfancy_maybe_null@PAVCSpeedTreeRT@@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@@Z ENDP ; std::_Unfancy_maybe_null<CSpeedTreeRT *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits>, COMDAT

; 194  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 195  :     // allocate _Bytes
; 196  :     if (_Bytes == 0) {

	cmp	DWORD PTR __Bytes$[ebp], 0
	jne	SHORT $LN2@Allocate

; 197  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN1@Allocate
$LN2@Allocate:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	DWORD PTR __Bytes$[ebp], 4096		; 00001000H
	jb	SHORT $LN3@Allocate

; 221  :             // boost the alignment of big allocations to help autovectorization
; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	call	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
	add	esp, 4
	jmp	SHORT $LN1@Allocate
$LN3@Allocate:

; 223  :         }
; 224  : #endif // defined(_M_IX86) || defined(_M_X64)
; 225  :         return _Traits::_Allocate(_Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	call	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
	add	esp, 4
$LN1@Allocate:

; 226  :     }
; 227  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
__Overflow_is_possible$ = -5				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 79   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 80   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR __Overflow_is_possible$[ebp], 1

; 81   : 
; 82   :     if constexpr (_Overflow_is_possible) {
; 83   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 84   :         if (_Count > _Max_possible) {

	cmp	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH
	jbe	SHORT $LN2@Get_size_o

; 85   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
$LN1@Get_size_o:

; 90   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z PROC ; std::addressof<std::_Container_base12>, COMDAT

; 1559 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1560 :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 1561 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ENDP ; std::addressof<std::_Container_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1536 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1538 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 1559 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1560 :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 1561 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 381  :     is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 382  : #if _HAS_CXX20
; 383  :     if (_STD is_constant_evaluated()) {
; 384  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 385  :     } else
; 386  : #endif // _HAS_CXX20
; 387  :     {
; 388  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@PAD@std@@YAPAPADAAPAD@Z	; std::addressof<char *>
	add	esp, 4
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@ABQAD@std@@YAABQADABQAD@Z	; std::forward<char * const &>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 389  :     }
; 390  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z
_TEXT	SEGMENT
__Fancy_ptr$ = -8					; size = 4
__Al$ = 8						; size = 4
__Capacity$ = 12					; size = 4
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 2614 :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2615 :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 2616 :         ++_Capacity; // Take null terminator into consideration

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR [edx], ecx

; 2617 : 
; 2618 :         pointer _Fancy_ptr;
; 2619 :         if constexpr (_Policy == _Allocation_policy::_At_least) {
; 2620 :             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
	add	esp, 8
	mov	DWORD PTR __Fancy_ptr$[ebp], eax

; 2621 :         } else {
; 2622 :             _STL_INTERNAL_STATIC_ASSERT(_Policy == _Allocation_policy::_Exactly);
; 2623 :             _Fancy_ptr = _Al.allocate(_Capacity);
; 2624 :         }
; 2625 : 
; 2626 : #if _HAS_CXX20
; 2627 :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 2628 :         // but likely more impactful to throughput.
; 2629 :         if (_STD is_constant_evaluated()) {
; 2630 :             _Elem* const _Ptr = _Unfancy(_Fancy_ptr);
; 2631 :             for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {
; 2632 :                 _STD construct_at(_Ptr + _Idx);
; 2633 :             }
; 2634 :         }
; 2635 : #endif // _HAS_CXX20
; 2636 :         --_Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR [edx], ecx

; 2637 :         return _Fancy_ptr;

	mov	eax, DWORD PTR __Fancy_ptr$[ebp]

; 2638 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1536 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1538 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1460 :     _CONSTEXPR20 ~_Container_proxy_ptr12() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1461 :         if (_Ptr) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Container_

; 1462 :             _Delete_plain_internal(_Al, _Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8
$LN2@Container_:

; 1463 :         }
; 1464 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Al_$ = 8						; size = 4
__Mycont$ = 12						; size = 4
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1446 :     _CONSTEXPR20 _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Basic_container_proxy_ptr12@std@@IAE@XZ ; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Al_$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1447 :         // create a new _Container_proxy pointing at _Mycont
; 1448 :         _Ptr = _Unfancy(_Al_.allocate(1));

	push	1
	mov	ecx, DWORD PTR __Al_$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	push	eax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 1449 :         _Construct_in_place(*_Ptr, _STD addressof(_Mycont));

	mov	eax, DWORD PTR __Mycont$[ebp]
	push	eax
	call	??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
	add	esp, 8

; 1450 :         _Mycont._Myproxy = _Ptr;

	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1451 :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEPAEQAE$$QAE@Z
_TEXT	SEGMENT
__Constructed_first$ = -156				; size = 4
__Constructed_last$ = -144				; size = 4
__Newvec$ = -132					; size = 4
__Newcapacity$ = -120					; size = 4
__Newsize$ = -108					; size = 4
__Oldsize$ = -96					; size = 4
__Whereoff$ = -84					; size = 4
__Mylast$ = -72						; size = 4
__Myfirst$ = -60					; size = 4
__My_data$ = -48					; size = 4
__Al$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEPAEQAE$$QAE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>, COMDAT
; _this$ = ecx

; 806  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEPAEQAE$$QAE@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-160]
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 807  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 808  :         _Alty& _Al        = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 809  :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 810  :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 811  :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 812  : 
; 813  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 814  : 
; 815  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR __Whereptr$[ebp]
	sub	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Whereoff$[ebp], ecx

; 816  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Oldsize$[ebp], edx

; 817  : 
; 818  :         if (_Oldsize == max_size()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
	cmp	DWORD PTR __Oldsize$[ebp], eax
	jne	SHORT $LN2@Emplace_re

; 819  :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	npad	1
$LN2@Emplace_re:

; 820  :         }
; 821  : 
; 822  :         const size_type _Newsize = _Oldsize + 1;

	mov	eax, DWORD PTR __Oldsize$[ebp]
	add	eax, 1
	mov	DWORD PTR __Newsize$[ebp], eax

; 823  :         size_type _Newcapacity   = _Calculate_growth(_Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
	mov	DWORD PTR __Newcapacity$[ebp], eax

; 824  : 
; 825  :         const pointer _Newvec           = _Allocate_at_least_helper(_Al, _Newcapacity);

	lea	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPAEAAV?$allocator@E@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<unsigned char> >
	add	esp, 8
	mov	DWORD PTR __Newvec$[ebp], eax

; 826  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	mov	eax, DWORD PTR __Whereoff$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR __Constructed_last$[ebp], edx

; 827  :         pointer _Constructed_first      = _Constructed_last;

	mov	eax, DWORD PTR __Constructed_last$[ebp]
	mov	DWORD PTR __Constructed_first$[ebp], eax

; 828  : 
; 829  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 830  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	call	??$forward@E@std@@YA$$QAEAAE@Z		; std::forward<unsigned char>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Newvec$[ebp]
	add	ecx, DWORD PTR __Whereoff$[ebp]
	push	ecx
	call	??$_Unfancy@E@std@@YAPAEPAE@Z		; std::_Unfancy<unsigned char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	call	??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@QAE$$QAE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>
	add	esp, 12					; 0000000cH

; 831  :         _Constructed_first = _Newvec + _Whereoff;

	mov	eax, DWORD PTR __Newvec$[ebp]
	add	eax, DWORD PTR __Whereoff$[ebp]
	mov	DWORD PTR __Constructed_first$[ebp], eax

; 832  : 
; 833  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __Whereptr$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN4@Emplace_re

; 834  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 835  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mylast$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
	add	esp, 16					; 00000010H

; 836  :             } else {
; 837  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 838  :             }
; 839  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 840  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Whereptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
	add	esp, 16					; 00000010H

; 841  :             _Constructed_first = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR __Constructed_first$[ebp], eax

; 842  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Whereoff$[ebp]
	mov	edx, DWORD PTR __Newvec$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Whereptr$[ebp]
	push	eax
	call	??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
	add	esp, 16					; 00000010H
$LN5@Emplace_re:
	jmp	SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEPAEQAE$$QAE@Z$0:

; 843  :         }
; 844  :         _CATCH_ALL
; 845  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Constructed_last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Constructed_first$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
	add	esp, 12					; 0000000cH

; 846  :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@E@std@@QAEXQAEI@Z ; std::allocator<unsigned char>::deallocate
	npad	1

; 847  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	npad	1

; 848  :         _CATCH_END

	mov	eax, $LN10@Emplace_re
	ret	0
$LN7@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN9@Emplace_re
$LN10@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Emplace_re:

; 849  : 
; 850  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newvec$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
	npad	1

; 851  :         return _Newvec + _Whereoff;

	mov	eax, DWORD PTR __Newvec$[ebp]
	add	eax, DWORD PTR __Whereoff$[ebp]
$LN1@Emplace_re:

; 852  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@Emplace_re
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 352				; 00000160H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN14@Emplace_re:
	DD	1
	DD	$LN13@Emplace_re
$LN13@Emplace_re:
	DD	-120					; ffffff88H
	DD	4
	DD	$LN11@Emplace_re
$LN11@Emplace_re:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEPAEQAE$$QAE@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-356]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEPAEQAE$$QAE@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEPAEQAE$$QAE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@E@?$vector@EV?$allocator@E@std@@@std@@AAEAAE$$QAE@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
__Mylast$ = -32						; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@E@?$vector@EV?$allocator@E@std@@@std@@AAEAAE$$QAE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_back_with_unused_capacity<unsigned char>, COMDAT
; _this$ = ecx

; 783  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 784  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 785  :         auto& _My_data   = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 786  :         pointer& _Mylast = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 787  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 788  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 789  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 790  :             _ASAN_VECTOR_MODIFY(1);
; 791  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	call	??$forward@E@std@@YA$$QAEAAE@Z		; std::forward<unsigned char>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$_Construct_in_place@EE@std@@YAXAAE$$QAE@Z ; std::_Construct_in_place<unsigned char,unsigned char>
	add	esp, 8

; 792  :         } else {
; 793  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 794  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 795  :             _ASAN_VECTOR_RELEASE_GUARD;
; 796  :         }
; 797  : 
; 798  :         _Orphan_range(_Mylast, _Mylast);

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Mylast$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
	npad	1

; 799  :         _Ty& _Result = *_Mylast;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Result$[ebp], ecx

; 800  :         ++_Mylast;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [edx], ecx

; 801  : 
; 802  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 803  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Emplace_back_with_unused_capacity@E@?$vector@EV?$allocator@E@std@@@std@@AAEAAE$$QAE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_back_with_unused_capacity<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@E@std@@YA$$QAEAAE@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@E@std@@YA$$QAEAAE@Z PROC			; std::forward<unsigned char>, COMDAT

; 1536 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1538 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@E@std@@YA$$QAEAAE@Z ENDP			; std::forward<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
$T2 = -244						; size = 4
__Backout$ = -40					; size = 12
__PFirst$3 = -20					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >, COMDAT

; 2004 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2005 :     // value-initialize _Count objects to raw _First, using _Al
; 2006 :     using _Ptrty = typename _Alloc::value_type*;
; 2007 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2008 : #if _HAS_CXX20
; 2009 :         if (!_STD is_constant_evaluated())
; 2010 : #endif // _HAS_CXX20
; 2011 :         {
; 2012 :             auto _PFirst = _Unfancy(_First);

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unfancy@E@std@@YAPAEPAE@Z		; std::_Unfancy<unsigned char>
	add	esp, 4
	mov	DWORD PTR __PFirst$3[ebp], eax

; 2013 :             _Zero_range(_PFirst, _PFirst + _Count);

	mov	eax, DWORD PTR __PFirst$3[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __PFirst$3[ebp]
	push	ecx
	call	??$_Zero_range@PAE@std@@YAPAEQAE0@Z	; std::_Zero_range<unsigned char *>
	add	esp, 8

; 2014 :             return _First + _Count;

	mov	eax, DWORD PTR __First$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	jmp	SHORT $LN1@Uninitiali

; 2015 :         }
; 2016 :     }
; 2017 : 
; 2018 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAE@PAEAAV?$allocator@E@1@@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2019 :     for (; 0 < _Count; --_Count) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN4@Uninitiali:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@Uninitiali

; 2020 :         _Backout._Emplace_back();

	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<>
	npad	1

; 2021 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 2022 : 
; 2023 :     return _Backout._Release();

	lea	ecx, DWORD PTR __Backout$[ebp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAEPAEXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
	mov	eax, DWORD PTR $T2[ebp]
$LN1@Uninitiali:

; 2024 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Uninitiali
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@Uninitiali:
	DD	1
	DD	$LN9@Uninitiali
$LN9@Uninitiali:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN7@Uninitiali
$LN7@Uninitiali:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z$0:
	lea	ecx, DWORD PTR __Backout$[ebp]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
tv135 = -332						; size = 4
__Appended_last$ = -132					; size = 4
__Appended_first$ = -120				; size = 4
__Newvec$ = -108					; size = 4
__Newcapacity$ = -96					; size = 4
__Oldsize$ = -84					; size = 4
__Mylast$ = -72						; size = 4
__Myfirst$ = -60					; size = 4
__My_data$ = -48					; size = 4
__Al$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1505 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-140]
	mov	ecx, 31					; 0000001fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1506 :         if (_Newsize > max_size()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jbe	SHORT $LN2@Resize_rea

; 1507 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	npad	1
$LN2@Resize_rea:

; 1508 :         }
; 1509 : 
; 1510 :         auto& _Al         = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 1511 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1512 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 1513 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 1514 : 
; 1515 :         const auto _Oldsize    = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Oldsize$[ebp], edx

; 1516 :         size_type _Newcapacity = _Calculate_growth(_Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
	mov	DWORD PTR __Newcapacity$[ebp], eax

; 1517 : 
; 1518 :         const pointer _Newvec         = _Allocate_at_least_helper(_Al, _Newcapacity);

	lea	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPAEAAV?$allocator@E@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<unsigned char> >
	add	esp, 8
	mov	DWORD PTR __Newvec$[ebp], eax

; 1519 :         const pointer _Appended_first = _Newvec + _Oldsize;

	mov	eax, DWORD PTR __Newvec$[ebp]
	add	eax, DWORD PTR __Oldsize$[ebp]
	mov	DWORD PTR __Appended_first$[ebp], eax

; 1520 :         pointer _Appended_last        = _Appended_first;

	mov	eax, DWORD PTR __Appended_first$[ebp]
	mov	DWORD PTR __Appended_last$[ebp], eax

; 1521 : 
; 1522 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1523 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1524 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1525 :         } else {
; 1526 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1527 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, DWORD PTR __Oldsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Appended_first$[ebp]
	push	edx
	call	??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv135[ebp], eax
	mov	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR __Appended_last$[ebp], eax

; 1528 :         }
; 1529 : 
; 1530 :         if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 1531 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mylast$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
	add	esp, 16					; 00000010H
	jmp	SHORT $LN5@Resize_rea
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1532 :         } else {
; 1533 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1534 :         }
; 1535 :         _CATCH_ALL
; 1536 :         _Destroy_range(_Appended_first, _Appended_last, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Appended_last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Appended_first$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
	add	esp, 12					; 0000000cH

; 1537 :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@E@std@@QAEXQAEI@Z ; std::allocator<unsigned char>::deallocate
	npad	1

; 1538 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	npad	1

; 1539 :         _CATCH_END

	mov	eax, $LN8@Resize_rea
	ret	0
$LN5@Resize_rea:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN7@Resize_rea
$LN8@Resize_rea:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN7@Resize_rea:

; 1540 : 
; 1541 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newvec$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
	npad	1
$LN1@Resize_rea:

; 1542 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@Resize_rea
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 332				; 0000014cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN12@Resize_rea:
	DD	1
	DD	$LN11@Resize_rea
$LN11@Resize_rea:
	DD	-96					; ffffffa0H
	DD	4
	DD	$LN9@Resize_rea
$LN9@Resize_rea:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-336]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Emplace_reallocate@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEPAPAVCSpeedTreeRT@@QAPAV2@$$QAPAV2@@Z
_TEXT	SEGMENT
__Constructed_first$ = -156				; size = 4
__Constructed_last$ = -144				; size = 4
__Newvec$ = -132					; size = 4
__Newcapacity$ = -120					; size = 4
__Newsize$ = -108					; size = 4
__Oldsize$ = -96					; size = 4
__Whereoff$ = -84					; size = 4
__Mylast$ = -72						; size = 4
__Myfirst$ = -60					; size = 4
__My_data$ = -48					; size = 4
__Al$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEPAPAVCSpeedTreeRT@@QAPAV2@$$QAPAV2@@Z PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Emplace_reallocate<CSpeedTreeRT *>, COMDAT
; _this$ = ecx

; 806  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEPAPAVCSpeedTreeRT@@QAPAV2@$$QAPAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-160]
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 807  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 808  :         _Alty& _Al        = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAV?$allocator@PAVCSpeedTreeRT@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 809  :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 810  :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 811  :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 812  : 
; 813  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 814  : 
; 815  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR __Whereptr$[ebp]
	sub	ecx, DWORD PTR [eax]
	sar	ecx, 2
	mov	DWORD PTR __Whereoff$[ebp], ecx

; 816  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	sar	edx, 2
	mov	DWORD PTR __Oldsize$[ebp], edx

; 817  : 
; 818  :         if (_Oldsize == max_size()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QBEIXZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::max_size
	cmp	DWORD PTR __Oldsize$[ebp], eax
	jne	SHORT $LN2@Emplace_re

; 819  :             _Xlength();

	call	?_Xlength@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@CAXXZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Xlength
	npad	1
$LN2@Emplace_re:

; 820  :         }
; 821  : 
; 822  :         const size_type _Newsize = _Oldsize + 1;

	mov	eax, DWORD PTR __Oldsize$[ebp]
	add	eax, 1
	mov	DWORD PTR __Newsize$[ebp], eax

; 823  :         size_type _Newcapacity   = _Calculate_growth(_Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEII@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Calculate_growth
	mov	DWORD PTR __Newcapacity$[ebp], eax

; 824  : 
; 825  :         const pointer _Newvec           = _Allocate_at_least_helper(_Al, _Newcapacity);

	lea	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Allocate_at_least_helper@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@AAV?$allocator@PAVCSpeedTreeRT@@@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<CSpeedTreeRT *> >
	add	esp, 8
	mov	DWORD PTR __Newvec$[ebp], eax

; 826  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	mov	eax, DWORD PTR __Whereoff$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+4]
	mov	DWORD PTR __Constructed_last$[ebp], edx

; 827  :         pointer _Constructed_first      = _Constructed_last;

	mov	eax, DWORD PTR __Constructed_last$[ebp]
	mov	DWORD PTR __Constructed_first$[ebp], eax

; 828  : 
; 829  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 830  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	call	??$forward@PAVCSpeedTreeRT@@@std@@YA$$QAPAVCSpeedTreeRT@@AAPAV1@@Z ; std::forward<CSpeedTreeRT *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Whereoff$[ebp]
	mov	edx, DWORD PTR __Newvec$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	??$_Unfancy@PAVCSpeedTreeRT@@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@@Z ; std::_Unfancy<CSpeedTreeRT *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$construct@PAVCSpeedTreeRT@@PAV1@@?$_Default_allocator_traits@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@SAXAAV?$allocator@PAVCSpeedTreeRT@@@1@QAPAVCSpeedTreeRT@@$$QAPAV3@@Z ; std::_Default_allocator_traits<std::allocator<CSpeedTreeRT *> >::construct<CSpeedTreeRT *,CSpeedTreeRT *>
	add	esp, 12					; 0000000cH

; 831  :         _Constructed_first = _Newvec + _Whereoff;

	mov	eax, DWORD PTR __Whereoff$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Constructed_first$[ebp], edx

; 832  : 
; 833  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __Whereptr$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN4@Emplace_re

; 834  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 835  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mylast$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$_Uninitialized_move@PAPAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z ; std::_Uninitialized_move<CSpeedTreeRT * *,std::allocator<CSpeedTreeRT *> >
	add	esp, 16					; 00000010H

; 836  :             } else {
; 837  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 838  :             }
; 839  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 840  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Whereptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Uninitialized_move@PAPAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z ; std::_Uninitialized_move<CSpeedTreeRT * *,std::allocator<CSpeedTreeRT *> >
	add	esp, 16					; 00000010H

; 841  :             _Constructed_first = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR __Constructed_first$[ebp], eax

; 842  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Whereoff$[ebp]
	mov	edx, DWORD PTR __Newvec$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+4]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Whereptr$[ebp]
	push	eax
	call	??$_Uninitialized_move@PAPAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z ; std::_Uninitialized_move<CSpeedTreeRT * *,std::allocator<CSpeedTreeRT *> >
	add	esp, 16					; 00000010H
$LN5@Emplace_re:
	jmp	SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEPAPAVCSpeedTreeRT@@QAPAV2@$$QAPAV2@@Z$0:

; 843  :         }
; 844  :         _CATCH_ALL
; 845  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Constructed_last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Constructed_first$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAXPAPAVCSpeedTreeRT@@QAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z ; std::_Destroy_range<std::allocator<CSpeedTreeRT *> >
	add	esp, 12					; 0000000cH

; 846  :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@PAVCSpeedTreeRT@@@std@@QAEXQAPAVCSpeedTreeRT@@I@Z ; std::allocator<CSpeedTreeRT *>::deallocate
	npad	1

; 847  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	npad	1

; 848  :         _CATCH_END

	mov	eax, $LN10@Emplace_re
	ret	0
$LN7@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN9@Emplace_re
$LN10@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Emplace_re:

; 849  : 
; 850  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newvec$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Change_array@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEXQAPAVCSpeedTreeRT@@II@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Change_array
	npad	1

; 851  :         return _Newvec + _Whereoff;

	mov	eax, DWORD PTR __Whereoff$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
$LN1@Emplace_re:

; 852  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@Emplace_re
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 352				; 00000160H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN14@Emplace_re:
	DD	1
	DD	$LN13@Emplace_re
$LN13@Emplace_re:
	DD	-120					; ffffff88H
	DD	4
	DD	$LN11@Emplace_re
$LN11@Emplace_re:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEPAPAVCSpeedTreeRT@@QAPAV2@$$QAPAV2@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-356]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEPAPAVCSpeedTreeRT@@QAPAV2@$$QAPAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEPAPAVCSpeedTreeRT@@QAPAV2@$$QAPAV2@@Z ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Emplace_reallocate<CSpeedTreeRT *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAPAVCSpeedTreeRT@@$$QAPAV2@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
__Mylast$ = -32						; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAPAVCSpeedTreeRT@@$$QAPAV2@@Z PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Emplace_back_with_unused_capacity<CSpeedTreeRT *>, COMDAT
; _this$ = ecx

; 783  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 784  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 785  :         auto& _My_data   = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 786  :         pointer& _Mylast = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 787  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 788  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 789  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 790  :             _ASAN_VECTOR_MODIFY(1);
; 791  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	call	??$forward@PAVCSpeedTreeRT@@@std@@YA$$QAPAVCSpeedTreeRT@@AAPAV1@@Z ; std::forward<CSpeedTreeRT *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$_Construct_in_place@PAVCSpeedTreeRT@@PAV1@@std@@YAXAAPAVCSpeedTreeRT@@$$QAPAV1@@Z ; std::_Construct_in_place<CSpeedTreeRT *,CSpeedTreeRT *>
	add	esp, 8

; 792  :         } else {
; 793  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 794  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 795  :             _ASAN_VECTOR_RELEASE_GUARD;
; 796  :         }
; 797  : 
; 798  :         _Orphan_range(_Mylast, _Mylast);

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Mylast$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Orphan_range
	npad	1

; 799  :         _Ty& _Result = *_Mylast;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Result$[ebp], ecx

; 800  :         ++_Mylast;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	edx, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [edx], ecx

; 801  : 
; 802  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 803  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Emplace_back_with_unused_capacity@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAPAVCSpeedTreeRT@@$$QAPAV2@@Z ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Emplace_back_with_unused_capacity<CSpeedTreeRT *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@PAVCSpeedTreeRT@@@std@@YA$$QAPAVCSpeedTreeRT@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAVCSpeedTreeRT@@@std@@YA$$QAPAVCSpeedTreeRT@@AAPAV1@@Z PROC ; std::forward<CSpeedTreeRT *>, COMDAT

; 1536 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1538 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@PAVCSpeedTreeRT@@@std@@YA$$QAPAVCSpeedTreeRT@@AAPAV1@@Z ENDP ; std::forward<CSpeedTreeRT *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCSpeedTreeRT@@PAPAV1@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@00@Z
_TEXT	SEGMENT
__Count$ = -80						; size = 4
__Dest_ch$ = -68					; size = 4
__Last_ch$ = -56					; size = 4
__First_ch$ = -44					; size = 4
__DestPtr$ = -32					; size = 4
__LastPtr$ = -20					; size = 4
__FirstPtr$ = -8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCSpeedTreeRT@@PAPAV1@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CSpeedTreeRT * *,CSpeedTreeRT * *>, COMDAT

; 4613 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 21					; 00000015H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4614 :     auto _FirstPtr              = _STD _To_address(_First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_To_address@PAPAVCSpeedTreeRT@@@std@@YA?A_PABQAPAVCSpeedTreeRT@@@Z ; std::_To_address<CSpeedTreeRT * *>
	add	esp, 4
	mov	DWORD PTR __FirstPtr$[ebp], eax

; 4615 :     auto _LastPtr               = _STD _To_address(_Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_To_address@PAPAVCSpeedTreeRT@@@std@@YA?A_PABQAPAVCSpeedTreeRT@@@Z ; std::_To_address<CSpeedTreeRT * *>
	add	esp, 4
	mov	DWORD PTR __LastPtr$[ebp], eax

; 4616 :     auto _DestPtr               = _STD _To_address(_Dest);

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_To_address@PAPAVCSpeedTreeRT@@@std@@YA?A_PABQAPAVCSpeedTreeRT@@@Z ; std::_To_address<CSpeedTreeRT * *>
	add	esp, 4
	mov	DWORD PTR __DestPtr$[ebp], eax

; 4617 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

	mov	eax, DWORD PTR __FirstPtr$[ebp]
	mov	DWORD PTR __First_ch$[ebp], eax

; 4618 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

	mov	eax, DWORD PTR __LastPtr$[ebp]
	mov	DWORD PTR __Last_ch$[ebp], eax

; 4619 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

	mov	eax, DWORD PTR __DestPtr$[ebp]
	mov	DWORD PTR __Dest_ch$[ebp], eax

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR __Last_ch$[ebp]
	sub	eax, DWORD PTR __First_ch$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First_ch$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest_ch$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 4622 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4623 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	mov	eax, DWORD PTR __Dest_ch$[ebp]
	add	eax, DWORD PTR __Count$[ebp]

; 4624 :     } else {
; 4625 :         return _Dest + (_LastPtr - _FirstPtr);
; 4626 :     }
; 4627 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_memmove@PAPAVCSpeedTreeRT@@PAPAV1@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CSpeedTreeRT * *,CSpeedTreeRT * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 381  :     is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 382  : #if _HAS_CXX20
; 383  :     if (_STD is_constant_evaluated()) {
; 384  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 385  :     } else
; 386  : #endif // _HAS_CXX20
; 387  :     {
; 388  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
	add	esp, 4
	push	eax
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
	npad	1

; 389  :     }
; 390  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 36   :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]

; 37   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 1100 : _CONSTEXPR20 void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1101 :     // deallocate a plain pointer using an allocator
; 1102 :     using _Alloc_traits = allocator_traits<_Alloc>;
; 1103 :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 1104 :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

	push	1
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
	add	esp, 12					; 0000000cH

; 1105 :     } else {
; 1106 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1107 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1108 :     }
; 1109 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEPAUSShape@@QAU2@ABU2@@Z
_TEXT	SEGMENT
__Constructed_first$ = -156				; size = 4
__Constructed_last$ = -144				; size = 4
__Newvec$ = -132					; size = 4
__Newcapacity$ = -120					; size = 4
__Newsize$ = -108					; size = 4
__Oldsize$ = -96					; size = 4
__Whereoff$ = -84					; size = 4
__Mylast$ = -72						; size = 4
__Myfirst$ = -60					; size = 4
__My_data$ = -48					; size = 4
__Al$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEPAUSShape@@QAU2@ABU2@@Z PROC ; std::vector<SShape,std::allocator<SShape> >::_Emplace_reallocate<SShape const &>, COMDAT
; _this$ = ecx

; 806  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEPAUSShape@@QAU2@ABU2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-160]
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 807  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 808  :         _Alty& _Al        = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAV?$allocator@USShape@@@2@XZ ; std::vector<SShape,std::allocator<SShape> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 809  :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 810  :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 811  :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 812  : 
; 813  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 814  : 
; 815  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR __Whereptr$[ebp]
	sub	ecx, DWORD PTR [eax]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR __Whereoff$[ebp], eax

; 816  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR __Oldsize$[ebp], eax

; 817  : 
; 818  :         if (_Oldsize == max_size()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ ; std::vector<SShape,std::allocator<SShape> >::max_size
	cmp	DWORD PTR __Oldsize$[ebp], eax
	jne	SHORT $LN2@Emplace_re

; 819  :             _Xlength();

	call	?_Xlength@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@CAXXZ ; std::vector<SShape,std::allocator<SShape> >::_Xlength
	npad	1
$LN2@Emplace_re:

; 820  :         }
; 821  : 
; 822  :         const size_type _Newsize = _Oldsize + 1;

	mov	eax, DWORD PTR __Oldsize$[ebp]
	add	eax, 1
	mov	DWORD PTR __Newsize$[ebp], eax

; 823  :         size_type _Newcapacity   = _Calculate_growth(_Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEII@Z ; std::vector<SShape,std::allocator<SShape> >::_Calculate_growth
	mov	DWORD PTR __Newcapacity$[ebp], eax

; 824  : 
; 825  :         const pointer _Newvec           = _Allocate_at_least_helper(_Al, _Newcapacity);

	lea	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Allocate_at_least_helper@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@AAV?$allocator@USShape@@@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<SShape> >
	add	esp, 8
	mov	DWORD PTR __Newvec$[ebp], eax

; 826  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	imul	eax, DWORD PTR __Whereoff$[ebp], 28
	mov	ecx, DWORD PTR __Newvec$[ebp]
	lea	edx, DWORD PTR [ecx+eax+28]
	mov	DWORD PTR __Constructed_last$[ebp], edx

; 827  :         pointer _Constructed_first      = _Constructed_last;

	mov	eax, DWORD PTR __Constructed_last$[ebp]
	mov	DWORD PTR __Constructed_first$[ebp], eax

; 828  : 
; 829  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 830  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	call	??$forward@ABUSShape@@@std@@YAABUSShape@@ABU1@@Z ; std::forward<SShape const &>
	add	esp, 4
	push	eax
	imul	ecx, DWORD PTR __Whereoff$[ebp], 28
	add	ecx, DWORD PTR __Newvec$[ebp]
	push	ecx
	call	??$_Unfancy@USShape@@@std@@YAPAUSShape@@PAU1@@Z ; std::_Unfancy<SShape>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	call	??$construct@USShape@@ABU1@@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAXAAV?$allocator@USShape@@@1@QAUSShape@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<SShape> >::construct<SShape,SShape const &>
	add	esp, 12					; 0000000cH

; 831  :         _Constructed_first = _Newvec + _Whereoff;

	imul	eax, DWORD PTR __Whereoff$[ebp], 28
	add	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR __Constructed_first$[ebp], eax

; 832  : 
; 833  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __Whereptr$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN4@Emplace_re

; 834  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 835  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mylast$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$_Uninitialized_move@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@QAU1@0PAU1@AAV?$allocator@USShape@@@0@@Z ; std::_Uninitialized_move<SShape *,std::allocator<SShape> >
	add	esp, 16					; 00000010H

; 836  :             } else {
; 837  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 838  :             }
; 839  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 840  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Whereptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Uninitialized_move@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@QAU1@0PAU1@AAV?$allocator@USShape@@@0@@Z ; std::_Uninitialized_move<SShape *,std::allocator<SShape> >
	add	esp, 16					; 00000010H

; 841  :             _Constructed_first = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR __Constructed_first$[ebp], eax

; 842  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	imul	ecx, DWORD PTR __Whereoff$[ebp], 28
	mov	edx, DWORD PTR __Newvec$[ebp]
	lea	eax, DWORD PTR [edx+ecx+28]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Whereptr$[ebp]
	push	eax
	call	??$_Uninitialized_move@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@QAU1@0PAU1@AAV?$allocator@USShape@@@0@@Z ; std::_Uninitialized_move<SShape *,std::allocator<SShape> >
	add	esp, 16					; 00000010H
$LN5@Emplace_re:
	jmp	SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEPAUSShape@@QAU2@ABU2@@Z$0:

; 843  :         }
; 844  :         _CATCH_ALL
; 845  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Constructed_last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Constructed_first$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@USShape@@@std@@@std@@YAXPAUSShape@@QAU1@AAV?$allocator@USShape@@@0@@Z ; std::_Destroy_range<std::allocator<SShape> >
	add	esp, 12					; 0000000cH

; 846  :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@USShape@@@std@@QAEXQAUSShape@@I@Z ; std::allocator<SShape>::deallocate
	npad	1

; 847  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	npad	1

; 848  :         _CATCH_END

	mov	eax, $LN10@Emplace_re
	ret	0
$LN7@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN9@Emplace_re
$LN10@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Emplace_re:

; 849  : 
; 850  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newvec$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Change_array@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXQAUSShape@@II@Z ; std::vector<SShape,std::allocator<SShape> >::_Change_array
	npad	1

; 851  :         return _Newvec + _Whereoff;

	imul	eax, DWORD PTR __Whereoff$[ebp], 28
	add	eax, DWORD PTR __Newvec$[ebp]
$LN1@Emplace_re:

; 852  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@Emplace_re
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 352				; 00000160H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN14@Emplace_re:
	DD	1
	DD	$LN13@Emplace_re
$LN13@Emplace_re:
	DD	-120					; ffffff88H
	DD	4
	DD	$LN11@Emplace_re
$LN11@Emplace_re:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEPAUSShape@@QAU2@ABU2@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-356]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEPAUSShape@@QAU2@ABU2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEPAUSShape@@QAU2@ABU2@@Z ENDP ; std::vector<SShape,std::allocator<SShape> >::_Emplace_reallocate<SShape const &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAUSShape@@ABU2@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
__Mylast$ = -32						; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAUSShape@@ABU2@@Z PROC ; std::vector<SShape,std::allocator<SShape> >::_Emplace_back_with_unused_capacity<SShape const &>, COMDAT
; _this$ = ecx

; 783  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 784  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 785  :         auto& _My_data   = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 786  :         pointer& _Mylast = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 787  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 788  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 789  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 790  :             _ASAN_VECTOR_MODIFY(1);
; 791  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	call	??$forward@ABUSShape@@@std@@YAABUSShape@@ABU1@@Z ; std::forward<SShape const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$_Construct_in_place@USShape@@ABU1@@std@@YAXAAUSShape@@ABU1@@Z ; std::_Construct_in_place<SShape,SShape const &>
	add	esp, 8

; 792  :         } else {
; 793  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 794  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 795  :             _ASAN_VECTOR_RELEASE_GUARD;
; 796  :         }
; 797  : 
; 798  :         _Orphan_range(_Mylast, _Mylast);

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Mylast$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z ; std::vector<SShape,std::allocator<SShape> >::_Orphan_range
	npad	1

; 799  :         _Ty& _Result = *_Mylast;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Result$[ebp], ecx

; 800  :         ++_Mylast;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [edx], ecx

; 801  : 
; 802  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 803  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Emplace_back_with_unused_capacity@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAUSShape@@ABU2@@Z ENDP ; std::vector<SShape,std::allocator<SShape> >::_Emplace_back_with_unused_capacity<SShape const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@ABUSShape@@@std@@YAABUSShape@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUSShape@@@std@@YAABUSShape@@ABU1@@Z PROC	; std::forward<SShape const &>, COMDAT

; 1536 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1538 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@ABUSShape@@@std@@YAABUSShape@@ABU1@@Z ENDP	; std::forward<SShape const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PAUSShape@@IPAU1@@std@@YAPAUSShape@@PAU1@I0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_n_unchecked4@PAUSShape@@IPAU1@@std@@YAPAUSShape@@PAU1@I0@Z PROC ; std::_Copy_n_unchecked4<SShape *,unsigned int,SShape *>, COMDAT

; 4655 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4656 :     // copy _First + [0, _Count) to _Dest + [0, _Count), returning _Dest + _Count
; 4657 :     // note: has callers outside the copy family
; 4658 : #if _HAS_CXX20
; 4659 :     _STL_INTERNAL_STATIC_ASSERT(_Integer_like<_SizeTy>);
; 4660 : #endif // _HAS_CXX20
; 4661 : 
; 4662 :     if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4663 : #if _HAS_CXX20
; 4664 :         if (!_STD is_constant_evaluated())
; 4665 : #endif // _HAS_CXX20
; 4666 :         {
; 4667 :             return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_memmove_n@PAUSShape@@PAU1@@std@@YAPAUSShape@@PAU1@I0@Z ; std::_Copy_memmove_n<SShape *,SShape *>
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@Copy_n_unc

; 4668 :         }
; 4669 :     }
; 4670 : 
; 4671 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	jmp	SHORT $LN4@Copy_n_unc
$LN2@Copy_n_unc:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR __First$[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Count$[ebp], edx
$LN4@Copy_n_unc:
	cmp	DWORD PTR __Count$[ebp], 0
	je	SHORT $LN3@Copy_n_unc

; 4672 :         *_Dest = *_First;

	mov	ecx, 7
	mov	esi, DWORD PTR __First$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	rep movsd

; 4673 :     }

	jmp	SHORT $LN2@Copy_n_unc
$LN3@Copy_n_unc:

; 4674 : 
; 4675 :     return _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
$LN1@Copy_n_unc:

; 4676 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_n_unchecked4@PAUSShape@@IPAU1@@std@@YAPAUSShape@@PAU1@I0@Z ENDP ; std::_Copy_n_unchecked4<SShape *,unsigned int,SShape *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Copy_memmove_n@PAUSShape@@PAU1@@std@@YAPAUSShape@@PAU1@I0@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove_n@PAUSShape@@PAU1@@std@@YAPAUSShape@@PAU1@I0@Z PROC ; std::_Copy_memmove_n<SShape *,SShape *>, COMDAT

; 4630 : _OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Count, _OutCtgIt _Dest) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4631 :     const auto _Result = _STD _Copy_memmove(_First, _First + _Count, _Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	imul	ecx, DWORD PTR __Count$[ebp], 28
	add	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_memmove@PAUSShape@@PAU1@@std@@YAPAUSShape@@PAU1@00@Z ; std::_Copy_memmove<SShape *,SShape *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Result$[ebp], eax

; 4632 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4633 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 4634 :     } else { // _Result is unused so the compiler can optimize it away
; 4635 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Count);
; 4636 :     }
; 4637 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_memmove_n@PAUSShape@@PAU1@@std@@YAPAUSShape@@PAU1@I0@Z ENDP ; std::_Copy_memmove_n<SShape *,SShape *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@PAU1@I0AAV?$allocator@USShape@@@0@@Z
_TEXT	SEGMENT
$T2 = -256						; size = 4
__Backout$ = -52					; size = 12
__Can_memmove$ = -29					; size = 1
__UFirst$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy_n@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@PAU1@I0AAV?$allocator@USShape@@@0@@Z PROC ; std::_Uninitialized_copy_n<SShape *,std::allocator<SShape> >, COMDAT

; 1842 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninitialized_copy_n@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@PAU1@I0AAV?$allocator@USShape@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1843 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1844 :     // note: only called internally from elsewhere in the STL
; 1845 :     using _Ptrval = typename _Alloc::value_type*;
; 1846 : 
; 1847 :     auto _UFirst = _STD _Get_unwrapped(_STD move(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$move@AAPAUSShape@@@std@@YA$$QAPAUSShape@@AAPAU1@@Z ; std::move<SShape * &>
	add	esp, 4
	push	eax
	call	??$_Get_unwrapped@PAUSShape@@@std@@YA?A_T$$QAPAUSShape@@@Z ; std::_Get_unwrapped<SShape *>
	add	esp, 4
	mov	DWORD PTR __UFirst$[ebp], eax

; 1848 : 
; 1849 :     constexpr bool _Can_memmove =

	mov	BYTE PTR __Can_memmove$[ebp], 1

; 1850 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1851 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1852 : 
; 1853 :     if constexpr (_Can_memmove) {
; 1854 : #if _HAS_CXX20
; 1855 :         if (!_STD is_constant_evaluated())
; 1856 : #endif // _HAS_CXX20
; 1857 :         {
; 1858 :             _STD _Copy_memmove_n(_UFirst, _Count, _STD _Unfancy(_Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Unfancy@USShape@@@std@@YAPAUSShape@@PAU1@@Z ; std::_Unfancy<SShape>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __UFirst$[ebp]
	push	edx
	call	??$_Copy_memmove_n@PAUSShape@@PAU1@@std@@YAPAUSShape@@PAU1@I0@Z ; std::_Copy_memmove_n<SShape *,SShape *>
	add	esp, 12					; 0000000cH

; 1859 :             _Dest += _Count;

	imul	eax, DWORD PTR __Count$[ebp], 28
	add	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Dest$[ebp], eax

; 1860 :             return _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	jmp	SHORT $LN1@Uninitiali

; 1861 :         }
; 1862 :     }
; 1863 : 
; 1864 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAE@PAUSShape@@AAV?$allocator@USShape@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<SShape> >::_Uninitialized_backout_al<std::allocator<SShape> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1865 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	eax, DWORD PTR __UFirst$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR __UFirst$[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
$LN4@Uninitiali:
	cmp	DWORD PTR __Count$[ebp], 0
	je	SHORT $LN3@Uninitiali

; 1866 :         _Backout._Emplace_back(*_UFirst);

	mov	eax, DWORD PTR __UFirst$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??$_Emplace_back@AAUSShape@@@?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAEXAAUSShape@@@Z ; std::_Uninitialized_backout_al<std::allocator<SShape> >::_Emplace_back<SShape &>
	npad	1

; 1867 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1868 : 
; 1869 :     return _Backout._Release();

	lea	ecx, DWORD PTR __Backout$[ebp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAEPAUSShape@@XZ ; std::_Uninitialized_backout_al<std::allocator<SShape> >::_Release
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<SShape> >::~_Uninitialized_backout_al<std::allocator<SShape> >
	mov	eax, DWORD PTR $T2[ebp]
$LN1@Uninitiali:

; 1870 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Uninitiali
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 260				; 00000104H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN10@Uninitiali:
	DD	1
	DD	$LN9@Uninitiali
$LN9@Uninitiali:
	DD	-52					; ffffffccH
	DD	12					; 0000000cH
	DD	$LN7@Uninitiali
$LN7@Uninitiali:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy_n@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@PAU1@I0AAV?$allocator@USShape@@@0@@Z$0:
	lea	ecx, DWORD PTR __Backout$[ebp]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@USShape@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<SShape> >::~_Uninitialized_backout_al<std::allocator<SShape> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Uninitialized_copy_n@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@PAU1@I0AAV?$allocator@USShape@@@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-264]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy_n@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@PAU1@I0AAV?$allocator@USShape@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy_n@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@PAU1@I0AAV?$allocator@USShape@@@0@@Z ENDP ; std::_Uninitialized_copy_n<SShape *,std::allocator<SShape> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$move@AAPAUSShape@@@std@@YA$$QAPAUSShape@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAUSShape@@@std@@YA$$QAPAUSShape@@AAPAU1@@Z PROC ; std::move<SShape * &>, COMDAT

; 1547 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1548 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1549 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$move@AAPAUSShape@@@std@@YA$$QAPAUSShape@@AAPAU1@@Z ENDP ; std::move<SShape * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAPAVCSpeedTreeRT@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@$$QAPAPAVCSpeedTreeRT@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
__UIt$ = 12						; size = 4
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAPAVCSpeedTreeRT@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@$$QAPAPAVCSpeedTreeRT@@@Z PROC ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >,CSpeedTreeRT * *>, COMDAT

; 1404 : constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1405 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1406 :         _It._Seek_to(_STD forward<_UIter>(_UIt));

	mov	eax, DWORD PTR __UIt$[ebp]
	push	eax
	call	??$forward@PAPAVCSpeedTreeRT@@@std@@YA$$QAPAPAVCSpeedTreeRT@@AAPAPAV1@@Z ; std::forward<CSpeedTreeRT * *>
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAEXPBQAVCSpeedTreeRT@@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Seek_to
	npad	1

; 1407 :     } else {
; 1408 :         _It = _STD forward<_UIter>(_UIt);
; 1409 :     }
; 1410 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAPAVCSpeedTreeRT@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@$$QAPAPAVCSpeedTreeRT@@@Z ENDP ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >,CSpeedTreeRT * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Find_unchecked@PAPAVCSpeedTreeRT@@PAV1@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@QAPAV1@ABQAV1@@Z
_TEXT	SEGMENT
__Result$1 = -20					; size = 4
__First_ptr$2 = -8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Find_unchecked@PAPAVCSpeedTreeRT@@PAV1@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@QAPAV1@ABQAV1@@Z PROC ; std::_Find_unchecked<CSpeedTreeRT * *,CSpeedTreeRT *>, COMDAT

; 5905 : _NODISCARD _CONSTEXPR20 _InIt _Find_unchecked(_InIt _First, const _InIt _Last, const _Ty& _Val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5906 :     // find first matching _Val; choose optimization
; 5907 :     // activate optimization for contiguous iterators to most scalar types (possibly const-qualified)
; 5908 :     if constexpr (_Vector_alg_in_find_is_safe<_InIt, _Ty>) {
; 5909 : #if _HAS_CXX20
; 5910 :         if (!_STD is_constant_evaluated())
; 5911 : #endif // _HAS_CXX20
; 5912 :         {
; 5913 :             if (!_STD _Could_compare_equal_to_value_type<_InIt>(_Val)) {

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$_Could_compare_equal_to_value_type@PAPAVCSpeedTreeRT@@PAV1@@std@@YA_NABQAVCSpeedTreeRT@@@Z ; std::_Could_compare_equal_to_value_type<CSpeedTreeRT * *,CSpeedTreeRT *>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@Find_unche

; 5914 :                 return _Last;

	mov	eax, DWORD PTR __Last$[ebp]
	jmp	SHORT $LN1@Find_unche
$LN5@Find_unche:

; 5915 :             }
; 5916 : #if _USE_STD_VECTOR_ALGORITHMS
; 5917 :             const auto _First_ptr = _STD _To_address(_First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_To_address@PAPAVCSpeedTreeRT@@@std@@YA?A_PABQAPAVCSpeedTreeRT@@@Z ; std::_To_address<CSpeedTreeRT * *>
	add	esp, 4
	mov	DWORD PTR __First_ptr$2[ebp], eax

; 5918 :             const auto _Result    = _STD __std_find_trivial(_First_ptr, _STD _To_address(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_To_address@PAPAVCSpeedTreeRT@@@std@@YA?A_PABQAPAVCSpeedTreeRT@@@Z ; std::_To_address<CSpeedTreeRT * *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __First_ptr$2[ebp]
	push	eax
	call	??$__std_find_trivial@PAVCSpeedTreeRT@@PAV1@@std@@YAPAPAVCSpeedTreeRT@@QAPAV1@0QAV1@@Z ; std::__std_find_trivial<CSpeedTreeRT *,CSpeedTreeRT *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Result$1[ebp], eax

; 5919 :             if constexpr (is_pointer_v<_InIt>) {
; 5920 :                 return _Result;

	mov	eax, DWORD PTR __Result$1[ebp]
	jmp	SHORT $LN1@Find_unche

; 5921 :             } else {
; 5922 :                 return _First + (_Result - _First_ptr);
; 5923 :             }
; 5924 : #else // ^^^ _USE_STD_VECTOR_ALGORITHMS / !_USE_STD_VECTOR_ALGORITHMS vvv
; 5925 :             if constexpr (sizeof(_Iter_value_t<_InIt>) == 1) {
; 5926 :                 const auto _First_ptr = _STD _To_address(_First);
; 5927 :                 const auto _Result    = static_cast<remove_reference_t<_Iter_ref_t<_InIt>>*>(
; 5928 :                     _CSTD memchr(_First_ptr, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First)));
; 5929 :                 if constexpr (is_pointer_v<_InIt>) {
; 5930 :                     return _Result ? _Result : _Last;
; 5931 :                 } else {
; 5932 :                     return _Result ? _First + (_Result - _First_ptr) : _Last;
; 5933 :                 }
; 5934 :             }
; 5935 :             // TRANSITION, DevCom-1614562: not trying wmemchr
; 5936 : #endif // ^^^ !_USE_STD_VECTOR_ALGORITHMS ^^^
; 5937 :         }
; 5938 :     }
; 5939 : 
; 5940 :     for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@Find_unche
$LN2@Find_unche:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN4@Find_unche:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@Find_unche

; 5941 :         if (*_First == _Val) {

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN6@Find_unche

; 5942 :             break;

	jmp	SHORT $LN3@Find_unche
$LN6@Find_unche:

; 5943 :         }
; 5944 :     }

	jmp	SHORT $LN2@Find_unche
$LN3@Find_unche:

; 5945 : 
; 5946 :     return _First;

	mov	eax, DWORD PTR __First$[ebp]
$LN1@Find_unche:

; 5947 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Find_unchecked@PAPAVCSpeedTreeRT@@PAV1@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@QAPAV1@ABQAV1@@Z ENDP ; std::_Find_unchecked<CSpeedTreeRT * *,CSpeedTreeRT *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > > const &>, COMDAT

; 1304 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1305 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1306 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1307 :         return _It + 0;
; 1308 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1309 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEPAPAVCSpeedTreeRT@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Unwrapped

; 1310 :     } else {
; 1311 :         return static_cast<_Iter&&>(_It);
; 1312 :     }
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > > &>, COMDAT

; 1304 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1305 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1306 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1307 :         return _It + 0;
; 1308 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1309 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEPAPAVCSpeedTreeRT@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Unwrapped

; 1310 :     } else {
; 1311 :         return static_cast<_Iter&&>(_It);
; 1312 :     }
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > > >, COMDAT

; 1277 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1278 :     // check that [_First, _Last) forms an iterator range
; 1279 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1280 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1281 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1282 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1283 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1284 :         _Verify_range(_First, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	?_Verify_range@std@@YAXABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@1@0@Z ; std::_Verify_range
	add	esp, 8

; 1285 :     }
; 1286 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 289  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 290  :     if constexpr (is_array_v<_Ty>) {
; 291  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 292  :     } else {
; 293  :         _Obj.~_Ty();
; 294  :     }
; 295  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Deallocate@$07@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07@std@@YAXPAXI@Z PROC			; std::_Deallocate<8>, COMDAT

; 230  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Deallocate@$07@std@@YAXPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 231  :     // deallocate storage allocated by _Allocate
; 232  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 233  :     if (_STD is_constant_evaluated()) {
; 234  :         ::operator delete(_Ptr);
; 235  :         return;
; 236  :     }
; 237  : #endif // _HAS_CXX20
; 238  : 
; 239  : #ifdef __cpp_aligned_new
; 240  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 241  :         size_t _Passed_align = _Align;
; 242  : #if defined(_M_IX86) || defined(_M_X64)
; 243  :         if (_Bytes >= _Big_allocation_threshold) {
; 244  :             // boost the alignment of big allocations to help autovectorization
; 245  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 246  :         }
; 247  : #endif // defined(_M_IX86) || defined(_M_X64)
; 248  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 249  :     } else
; 250  : #endif // defined(__cpp_aligned_new)
; 251  :     {
; 252  : #if defined(_M_IX86) || defined(_M_X64)
; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	DWORD PTR __Bytes$[ebp], 4096		; 00001000H
	jb	SHORT $LN2@Deallocate

; 254  :             // boost the alignment of big allocations to help autovectorization
; 255  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
	add	esp, 8
$LN2@Deallocate:

; 256  :         }
; 257  : #endif // defined(_M_IX86) || defined(_M_X64)
; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 259  :     }
; 260  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07@std@@YAXPAXI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Deallocate@$07@std@@YAXPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07@std@@YAXPAXI@Z ENDP			; std::_Deallocate<8>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$max@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
$T1 = -200						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@I@std@@YAABIABI0@Z PROC				; std::max<unsigned int>, COMDAT

; 72   :     (max) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi

; 73   :     // return larger of _Left and _Right
; 74   :     return _Left < _Right ? _Right : _Left;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN3@max
	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max
$LN3@max:
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	DWORD PTR tv65[ebp], ecx
$LN4@max:
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]

; 75   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$max@I@std@@YAABIABI0@Z ENDP				; std::max<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 36   :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]

; 37   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z PROC	; std::_Construct_in_place<char *,char * &>, COMDAT

; 381  :     is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 382  : #if _HAS_CXX20
; 383  :     if (_STD is_constant_evaluated()) {
; 384  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 385  :     } else
; 386  : #endif // _HAS_CXX20
; 387  :     {
; 388  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@PAD@std@@YAPAPADAAPAD@Z	; std::addressof<char *>
	add	esp, 4
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 389  :     }
; 390  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z ENDP	; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1559 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1560 :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 1561 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
__Old_ptr$1 = -116					; size = 4
__Raw_new$ = -104					; size = 4
__New_ptr$ = -92					; size = 4
__Al$ = -80						; size = 4
__New_capacity$ = -68					; size = 4
__Old_capacity$ = -56					; size = 4
__New_size$ = -44					; size = 4
__Old_size$ = -32					; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 4809 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-120]
	mov	ecx, 30					; 0000001eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4810 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4811 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4812 :         auto& _My_data            = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 4813 :         const size_type _Old_size = _My_data._Mysize;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Old_size$[ebp], ecx

; 4814 :         if (max_size() - _Old_size < _Size_increase) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, DWORD PTR __Old_size$[ebp]
	cmp	eax, DWORD PTR __Size_increase$[ebp]
	jae	SHORT $LN2@Reallocate

; 4815 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Reallocate:

; 4816 :         }
; 4817 : 
; 4818 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	eax, DWORD PTR __Old_size$[ebp]
	add	eax, DWORD PTR __Size_increase$[ebp]
	mov	DWORD PTR __New_size$[ebp], eax

; 4819 :         const size_type _Old_capacity = _My_data._Myres;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Old_capacity$[ebp], ecx

; 4820 :         size_type _New_capacity       = _Calculate_growth(_New_size);

	mov	eax, DWORD PTR __New_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	DWORD PTR __New_capacity$[ebp], eax

; 4821 :         auto& _Al                     = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 4822 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	eax, DWORD PTR __New_capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	add	esp, 8
	mov	DWORD PTR __New_ptr$[ebp], eax

; 4823 : 
; 4824 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 4825 :         _ASAN_STRING_REMOVE(*this);
; 4826 :         _My_data._Mysize      = _New_size;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 4827 :         _My_data._Myres       = _New_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 4828 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	eax, DWORD PTR __New_ptr$[ebp]
	push	eax
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Raw_new$[ebp], eax

; 4829 :         if (_Old_capacity > _Small_string_capacity) {

	cmp	DWORD PTR __Old_capacity$[ebp], 15	; 0000000fH
	jbe	SHORT $LN3@Reallocate

; 4830 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Old_ptr$1[ebp], ecx

; 4831 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	push	eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	mov	eax, DWORD PTR __Old_ptr$1[ebp]
	push	eax
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Raw_new$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
	npad	1

; 4832 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

	mov	eax, DWORD PTR __Old_capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
	add	esp, 12					; 0000000cH

; 4833 :             _My_data._Bx._Ptr = _New_ptr;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 4834 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4835 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	push	eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Raw_new$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
	npad	1

; 4836 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	lea	eax, DWORD PTR __New_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
	add	esp, 8
$LN4@Reallocate:

; 4837 :         }
; 4838 : 
; 4839 :         _ASAN_STRING_CREATE(*this);
; 4840 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 4841 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@Reallocate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 312				; 00000138H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	1
$LN9@Reallocate:
	DD	2
	DD	$LN8@Reallocate
$LN8@Reallocate:
	DD	-68					; ffffffbcH
	DD	4
	DD	$LN6@Reallocate
	DD	-92					; ffffffa4H
	DD	4
	DD	$LN7@Reallocate
$LN7@Reallocate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN6@Reallocate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Count$ = 24						; size = 4
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z PROC ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator(), COMDAT
; _this$ = ecx

; 3326 :             },

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3323 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

	mov	eax, DWORD PTR __Old_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 3324 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	add	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 3325 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	add	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 3326 :             },

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ENDP ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__New_ptr$ = -56					; size = 4
__Al$ = -44						; size = 4
__New_capacity$ = -32					; size = 4
__Old_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4780 :     _CONSTEXPR20 basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4781 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4782 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4783 :         if (_New_size > max_size()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	DWORD PTR __New_size$[ebp], eax
	jbe	SHORT $LN2@Reallocate

; 4784 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Reallocate:

; 4785 :         }
; 4786 : 
; 4787 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Old_capacity$[ebp], ecx

; 4788 :         size_type _New_capacity       = _Calculate_growth(_New_size);

	mov	eax, DWORD PTR __New_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	DWORD PTR __New_capacity$[ebp], eax

; 4789 :         auto& _Al                     = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 4790 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	eax, DWORD PTR __New_capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	add	esp, 8
	mov	DWORD PTR __New_ptr$[ebp], eax

; 4791 : 
; 4792 :         _Mypair._Myval2._Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 4793 :         _ASAN_STRING_REMOVE(*this);
; 4794 :         _Mypair._Myval2._Mysize = _New_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 4795 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 4796 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR __New_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
	npad	1

; 4797 :         if (_Old_capacity > _Small_string_capacity) {

	cmp	DWORD PTR __Old_capacity$[ebp], 15	; 0000000fH
	jbe	SHORT $LN3@Reallocate

; 4798 :             _Deallocate_for_capacity(_Al, _Mypair._Myval2._Bx._Ptr, _Old_capacity);

	mov	eax, DWORD PTR __Old_capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
	add	esp, 12					; 0000000cH

; 4799 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 4800 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4801 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

	lea	eax, DWORD PTR __New_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
	add	esp, 8
$LN4@Reallocate:

; 4802 :         }
; 4803 : 
; 4804 :         _ASAN_STRING_CREATE(*this);
; 4805 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 4806 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@Reallocate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN9@Reallocate:
	DD	2
	DD	$LN8@Reallocate
$LN8@Reallocate:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN6@Reallocate
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN7@Reallocate
$LN7@Reallocate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN6@Reallocate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z PROC ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator(), COMDAT
; _this$ = ecx

; 3430 :             },

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3428 :                 _Traits::copy(_New_ptr, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 3429 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 3430 :             },

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z ENDP ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char> >, COMDAT

; 1063 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1064 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1065 :     using _Ty = typename _Alloc::value_type;
; 1066 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1067 :         for (; _First != _Last; ++_First) {
; 1068 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1069 :         }
; 1070 :     }
; 1071 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAXPAPAVCSpeedTreeRT@@QAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAXPAPAVCSpeedTreeRT@@QAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CSpeedTreeRT *> >, COMDAT

; 1063 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1064 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1065 :     using _Ty = typename _Alloc::value_type;
; 1066 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1067 :         for (; _First != _Last; ++_First) {
; 1068 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1069 :         }
; 1070 :     }
; 1071 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAXPAPAVCSpeedTreeRT@@QAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CSpeedTreeRT *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USShape@@@std@@@std@@YAXPAUSShape@@QAU1@AAV?$allocator@USShape@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USShape@@@std@@@std@@YAXPAUSShape@@QAU1@AAV?$allocator@USShape@@@0@@Z PROC ; std::_Destroy_range<std::allocator<SShape> >, COMDAT

; 1063 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1064 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1065 :     using _Ty = typename _Alloc::value_type;
; 1066 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1067 :         for (; _First != _Last; ++_First) {
; 1068 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1069 :         }
; 1070 :     }
; 1071 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@USShape@@@std@@@std@@YAXPAUSShape@@QAU1@AAV?$allocator@USShape@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<SShape> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
_TEXT	SEGMENT
__New_ptr$ = -108					; size = 4
__New_capacity$ = -96					; size = 4
__Proxy$ = -84						; size = 8
_$S15$ = -65						; size = 1
__Alproxy$ = -56					; size = 4
__Al$ = -44						; size = 4
__My_data$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>, COMDAT
; _this$ = ecx

; 2662 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 292				; 00000124H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-112]
	mov	ecx, 25					; 00000019H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2663 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2664 :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 2665 : 
; 2666 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2667 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2668 :         } else {
; 2669 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2670 :         }
; 2671 : 
; 2672 :         if (_Count > max_size()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	DWORD PTR __Count$[ebp], eax
	jbe	SHORT $LN2@Construct

; 2673 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 2674 :         }
; 2675 : 
; 2676 :         auto& _Al       = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 2677 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	lea	ecx, DWORD PTR _$S15$[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	lea	ecx, DWORD PTR _$S15$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], ecx

; 2678 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Alproxy$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2679 : 
; 2680 :         if (_Count <= _Small_string_capacity) {

	cmp	DWORD PTR __Count$[ebp], 15		; 0000000fH
	ja	SHORT $LN3@Construct

; 2681 :             _My_data._Mysize = _Count;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2682 :             _My_data._Myres  = _Small_string_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 2683 : 
; 2684 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2685 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2686 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2687 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2688 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2689 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2690 :             } else { // _Strat == _Construct_strategy::_From_string
; 2691 : #ifdef _INSERT_STRING_ANNOTATION
; 2692 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2693 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2694 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);

	push	16					; 00000010H
	mov	eax, DWORD PTR __Arg$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 2695 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2696 :             }
; 2697 : 
; 2698 :             _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
	npad	1

; 2699 :             return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
	jmp	$LN1@Construct
$LN3@Construct:

; 2700 :         }
; 2701 : 
; 2702 :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	push	eax
	push	15					; 0000000fH
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __New_capacity$[ebp], eax

; 2703 :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	eax, DWORD PTR __New_capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	add	esp, 8
	mov	DWORD PTR __New_ptr$[ebp], eax

; 2704 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	lea	eax, DWORD PTR __New_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
	add	esp, 8

; 2705 : 
; 2706 :         _My_data._Mysize = _Count;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2707 :         _My_data._Myres  = _New_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 2708 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2709 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2710 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2711 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2712 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2713 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2714 :         } else { // _Strat == _Construct_strategy::_From_string
; 2715 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Arg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 2716 :         }
; 2717 : 
; 2718 :         _ASAN_STRING_CREATE(*this);
; 2719 :         _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
	npad	1

; 2720 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
$LN1@Construct:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@Construct
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN12@Construct:
	DD	4
	DD	$LN11@Construct
$LN11@Construct:
	DD	-65					; ffffffbfH
	DD	1
	DD	$LN6@Construct
	DD	-84					; ffffffacH
	DD	8
	DD	$LN7@Construct
	DD	-96					; ffffffa0H
	DD	4
	DD	$LN8@Construct
	DD	-108					; ffffff94H
	DD	4
	DD	$LN9@Construct
$LN9@Construct:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN8@Construct:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
$LN7@Construct:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
$LN6@Construct:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	49					; 00000031H
	DB	53					; 00000035H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z$0:
	lea	ecx, DWORD PTR __Proxy$[ebp]
	jmp	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-308]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
_TEXT	SEGMENT
$T2 = -321						; size = 1
$T3 = -309						; size = 1
__New_ptr$ = -108					; size = 4
__New_capacity$ = -96					; size = 4
__Proxy$ = -84						; size = 8
_$S14$ = -65						; size = 1
__Alproxy$ = -56					; size = 4
__Al$ = -44						; size = 4
__My_data$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT
; _this$ = ecx

; 2662 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-136]
	mov	ecx, 31					; 0000001fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2663 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2664 :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 2665 : 
; 2666 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2667 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2668 :         } else {
; 2669 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2670 :         }
; 2671 : 
; 2672 :         if (_Count > max_size()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	DWORD PTR __Count$[ebp], eax
	jbe	SHORT $LN2@Construct

; 2673 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 2674 :         }
; 2675 : 
; 2676 :         auto& _Al       = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 2677 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	lea	ecx, DWORD PTR _$S14$[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	lea	ecx, DWORD PTR _$S14$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], ecx

; 2678 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Alproxy$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2679 : 
; 2680 :         if (_Count <= _Small_string_capacity) {

	cmp	DWORD PTR __Count$[ebp], 15		; 0000000fH
	ja	SHORT $LN3@Construct

; 2681 :             _My_data._Mysize = _Count;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2682 :             _My_data._Myres  = _Small_string_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 2683 : 
; 2684 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2685 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2686 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2687 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2688 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Arg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __My_data$[ebp]
	add	edx, 4
	push	edx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 2689 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T3[ebp], 0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __My_data$[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	push	eax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 2690 :             } else { // _Strat == _Construct_strategy::_From_string
; 2691 : #ifdef _INSERT_STRING_ANNOTATION
; 2692 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2693 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2694 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2695 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2696 :             }
; 2697 : 
; 2698 :             _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
	npad	1

; 2699 :             return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
	jmp	$LN1@Construct
$LN3@Construct:

; 2700 :         }
; 2701 : 
; 2702 :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	push	eax
	push	15					; 0000000fH
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __New_capacity$[ebp], eax

; 2703 :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	eax, DWORD PTR __New_capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	add	esp, 8
	mov	DWORD PTR __New_ptr$[ebp], eax

; 2704 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	lea	eax, DWORD PTR __New_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
	add	esp, 8

; 2705 : 
; 2706 :         _My_data._Mysize = _Count;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2707 :         _My_data._Myres  = _New_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 2708 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2709 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2710 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2711 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2712 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Arg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 2713 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 2714 :         } else { // _Strat == _Construct_strategy::_From_string
; 2715 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2716 :         }
; 2717 : 
; 2718 :         _ASAN_STRING_CREATE(*this);
; 2719 :         _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
	npad	1

; 2720 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
$LN1@Construct:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@Construct
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 328				; 00000148H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN12@Construct:
	DD	4
	DD	$LN11@Construct
$LN11@Construct:
	DD	-65					; ffffffbfH
	DD	1
	DD	$LN6@Construct
	DD	-84					; ffffffacH
	DD	8
	DD	$LN7@Construct
	DD	-96					; ffffffa0H
	DD	4
	DD	$LN8@Construct
	DD	-108					; ffffff94H
	DD	4
	DD	$LN9@Construct
$LN9@Construct:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN8@Construct:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
$LN7@Construct:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
$LN6@Construct:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	49					; 00000031H
	DB	52					; 00000034H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z$0:
	lea	ecx, DWORD PTR __Proxy$[ebp]
	jmp	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-332]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 1496 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	npad	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	call	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1547 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1548 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1549 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1047 : _CONSTEXPR20 void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { // (maybe) propagate on container move assignment

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1048 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 1049 :         _Left = _STD move(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
	add	esp, 4

; 1050 :     }
; 1051 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1559 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1560 :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 1561 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT
; _this$ = ecx

; 943  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 1040 : _CONSTEXPR20 void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1041 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1042 :         _Left = _Right;
; 1043 :     }
; 1044 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 1559 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1560 :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 1561 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Convert_size@II@std@@YAII@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
??$_Convert_size@II@std@@YAII@Z PROC			; std::_Convert_size<unsigned int,unsigned int>, COMDAT

; 1085 :     sizeof(_Unsigned_type) <= sizeof(_Size_type)) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1086 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1087 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1088 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1089 : 
; 1090 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1091 :         if (_Len > (numeric_limits<_Size_type>::max)()) {
; 1092 :             _Xlength_error("size is too long for _Size_type");
; 1093 :         }
; 1094 :     }
; 1095 : 
; 1096 :     return static_cast<_Size_type>(_Len);

	mov	eax, DWORD PTR __Len$[ebp]

; 1097 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Convert_size@II@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
$T1 = -200						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 95   :     (min) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi

; 96   :     // return smaller of _Left and _Right
; 97   :     return _Right < _Left ? _Right : _Left;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN3@min
	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@min
$LN3@min:
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	DWORD PTR tv65[ebp], ecx
$LN4@min:
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]

; 98   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1547 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1548 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1549 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 128  :         explicit __CLR_OR_THIS_CALL operator bool() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 129  :             return _Ok;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+4]

; 130  :         }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -217						; size = 1
__Zero_uncaught_exceptions$ = -17			; size = 1
_this$ = -8						; size = 4
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 113  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-28]
	mov	ecx, 7
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : #if !_HAS_EXCEPTIONS
; 115  :             const bool _Zero_uncaught_exceptions = true;
; 116  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@sentry
	mov	BYTE PTR tv72[ebp], 1
	jmp	SHORT $LN5@sentry
$LN4@sentry:
	mov	BYTE PTR tv72[ebp], 0
$LN5@sentry:
	mov	cl, BYTE PTR tv72[ebp]
	mov	BYTE PTR __Zero_uncaught_exceptions$[ebp], cl

; 118  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 119  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 120  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 121  : 
; 122  :             if (_Zero_uncaught_exceptions) {

	movzx	eax, BYTE PTR __Zero_uncaught_exceptions$[ebp]
	test	eax, eax
	je	SHORT $LN2@sentry

; 123  :                 this->_Myostr._Osfx();

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@sentry:

; 124  :             }
; 125  :         }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Tied$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 96   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 97   :             if (!_Ostr.good()) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@sentry

; 98   :                 _Ok = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 0

; 99   :                 return;

	jmp	SHORT $LN1@sentry
$LN2@sentry:

; 100  :             }
; 101  : 
; 102  :             const auto _Tied = _Ostr.tie();

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Tied$[ebp], eax

; 103  :             if (!_Tied || _Tied == &_Ostr) {

	cmp	DWORD PTR __Tied$[ebp], 0
	je	SHORT $LN4@sentry
	mov	eax, DWORD PTR __Tied$[ebp]
	cmp	eax, DWORD PTR __Ostr$[ebp]
	jne	SHORT $LN3@sentry
$LN4@sentry:

; 104  :                 _Ok = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 1

; 105  :                 return;

	jmp	SHORT $LN1@sentry
$LN3@sentry:

; 106  :             }
; 107  : 
; 108  :             _Tied->flush();

	mov	esi, esp
	mov	ecx, DWORD PTR __Tied$[ebp]
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1

; 109  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], al
$LN1@sentry:

; 110  :         }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -232						; size = 4
__Rdbuf$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 82   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 7
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 83   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR tv72[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv72[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Rdbuf$[ebp], eax

; 84   :             if (_Rdbuf) {

	cmp	DWORD PTR __Rdbuf$[ebp], 0
	je	SHORT $LN2@Sentry_bas

; 85   :                 _Rdbuf->_Unlock();

	mov	eax, DWORD PTR __Rdbuf$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR __Rdbuf$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@Sentry_bas:

; 86   :             }
; 87   :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv73 = -220						; size = 4
__Rdbuf$ = -20						; size = 4
_this$ = -8						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 75   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-28]
	mov	ecx, 7
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [eax], ecx

; 76   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR tv73[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv73[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Rdbuf$[ebp], eax

; 77   :             if (_Rdbuf) {

	cmp	DWORD PTR __Rdbuf$[ebp], 0
	je	SHORT $LN2@Sentry_bas

; 78   :                 _Rdbuf->_Lock();

	mov	eax, DWORD PTR __Rdbuf$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR __Rdbuf$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@Sentry_bas:

; 79   :             }
; 80   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>, COMDAT
; _this$ = ecx

; 1496 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@E@std@@QAE@XZ		; std::allocator<unsigned char>::allocator<unsigned char>
	npad	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0E@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@E@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0E@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@E@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned char>, COMDAT
; _this$ = ecx

; 943  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0E@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@E@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Emplace_one_at_back@E@?$vector@EV?$allocator@E@std@@@std@@AAEAAE$$QAE@Z
_TEXT	SEGMENT
__Mylast$ = -32						; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_one_at_back@E@?$vector@EV?$allocator@E@std@@@std@@AAEAAE$$QAE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_one_at_back<unsigned char>, COMDAT
; _this$ = ecx

; 770  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 771  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 772  :         auto& _My_data   = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 773  :         pointer& _Mylast = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 774  : 
; 775  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	je	SHORT $LN2@Emplace_on

; 776  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	call	??$forward@E@std@@YA$$QAEAAE@Z		; std::forward<unsigned char>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Emplace_back_with_unused_capacity@E@?$vector@EV?$allocator@E@std@@@std@@AAEAAE$$QAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_back_with_unused_capacity<unsigned char>
	jmp	SHORT $LN1@Emplace_on
$LN2@Emplace_on:

; 777  :         }
; 778  : 
; 779  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	call	??$forward@E@std@@YA$$QAEAAE@Z		; std::forward<unsigned char>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AAEPAEQAE$$QAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
$LN1@Emplace_on:

; 780  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Emplace_one_at_back@E@?$vector@EV?$allocator@E@std@@@std@@AAEAAE$$QAE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_one_at_back<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$move@AAE@std@@YA$$QAEAAE@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAE@std@@YA$$QAEAAE@Z PROC			; std::move<unsigned char &>, COMDAT

; 1547 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1548 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1549 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$move@AAE@std@@YA$$QAEAAE@Z ENDP			; std::move<unsigned char &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldlast$1 = -104					; size = 4
__Oldcapacity$2 = -92					; size = 4
__Newlast$3 = -80					; size = 4
__Oldsize$ = -68					; size = 4
__Mylast$ = -56						; size = 4
__Myfirst$ = -44					; size = 4
__My_data$ = -32					; size = 4
__Al$ = -20						; size = 4
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1545 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-108]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1546 :         // trim or append elements, provide strong guarantee
; 1547 :         auto& _Al           = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 1548 :         auto& _My_data      = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1549 :         pointer& _Myfirst   = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 1550 :         pointer& _Mylast    = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 1551 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Oldsize$[ebp], edx

; 1552 :         if (_Newsize < _Oldsize) { // trim

	mov	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, DWORD PTR __Oldsize$[ebp]
	jae	SHORT $LN2@Resize

; 1553 :             const pointer _Newlast = _Myfirst + _Newsize;

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newlast$3[ebp], ecx

; 1554 :             _Orphan_range(_Newlast, _Mylast);

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Newlast$3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
	npad	1

; 1555 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Newlast$3[ebp]
	push	eax
	call	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
	add	esp, 12					; 0000000cH

; 1556 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1557 :             _Mylast = _Newlast;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __Newlast$3[ebp]
	mov	DWORD PTR [eax], ecx

; 1558 :             return;

	jmp	SHORT $LN1@Resize
$LN2@Resize:

; 1559 :         }
; 1560 : 
; 1561 :         if (_Newsize > _Oldsize) { // append

	mov	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, DWORD PTR __Oldsize$[ebp]
	jbe	SHORT $LN3@Resize

; 1562 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Oldcapacity$2[ebp], edx

; 1563 :             if (_Newsize > _Oldcapacity) { // reallocate

	mov	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, DWORD PTR __Oldcapacity$2[ebp]
	jbe	SHORT $LN4@Resize

; 1564 :                 _Resize_reallocate(_Newsize, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
	npad	1

; 1565 :                 return;

	jmp	SHORT $LN1@Resize
$LN4@Resize:

; 1566 :             }
; 1567 : 
; 1568 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1569 :             const pointer _Oldlast = _Mylast;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Oldlast$1[ebp], ecx

; 1570 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1571 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1572 :             } else {
; 1573 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1574 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, DWORD PTR __Oldsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldlast$1[ebp]
	push	edx
	call	??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [ecx], eax

; 1575 :             }
; 1576 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1577 :             _Orphan_range(_Oldlast, _Oldlast);

	mov	eax, DWORD PTR __Oldlast$1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Oldlast$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
	npad	1
$LN3@Resize:
$LN1@Resize:

; 1578 :         }
; 1579 : 
; 1580 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1581 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@PAVCSpeedTreeRT@@@std@@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@PAVCSpeedTreeRT@@@std@@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<CSpeedTreeRT *>,std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >,1>::_Compressed_pair<std::allocator<CSpeedTreeRT *>,std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >,1><>, COMDAT
; _this$ = ecx

; 1496 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@PAVCSpeedTreeRT@@@std@@QAE@XZ ; std::allocator<CSpeedTreeRT *>::allocator<CSpeedTreeRT *>
	npad	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@PAVCSpeedTreeRT@@@std@@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<CSpeedTreeRT *>,std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >,1>::_Compressed_pair<std::allocator<CSpeedTreeRT *>,std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0PAVCSpeedTreeRT@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVCSpeedTreeRT@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0PAVCSpeedTreeRT@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVCSpeedTreeRT@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><CSpeedTreeRT *>, COMDAT
; _this$ = ecx

; 943  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVCSpeedTreeRT@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVCSpeedTreeRT@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><CSpeedTreeRT *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Emplace_one_at_back@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAPAVCSpeedTreeRT@@$$QAPAV2@@Z
_TEXT	SEGMENT
__Mylast$ = -32						; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_one_at_back@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAPAVCSpeedTreeRT@@$$QAPAV2@@Z PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Emplace_one_at_back<CSpeedTreeRT *>, COMDAT
; _this$ = ecx

; 770  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 771  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 772  :         auto& _My_data   = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 773  :         pointer& _Mylast = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 774  : 
; 775  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	je	SHORT $LN2@Emplace_on

; 776  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	call	??$forward@PAVCSpeedTreeRT@@@std@@YA$$QAPAVCSpeedTreeRT@@AAPAV1@@Z ; std::forward<CSpeedTreeRT *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Emplace_back_with_unused_capacity@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAPAVCSpeedTreeRT@@$$QAPAV2@@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Emplace_back_with_unused_capacity<CSpeedTreeRT *>
	jmp	SHORT $LN1@Emplace_on
$LN2@Emplace_on:

; 777  :         }
; 778  : 
; 779  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	call	??$forward@PAVCSpeedTreeRT@@@std@@YA$$QAPAVCSpeedTreeRT@@AAPAV1@@Z ; std::forward<CSpeedTreeRT *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Emplace_reallocate@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEPAPAVCSpeedTreeRT@@QAPAV2@$$QAPAV2@@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Emplace_reallocate<CSpeedTreeRT *>
$LN1@Emplace_on:

; 780  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Emplace_one_at_back@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAPAVCSpeedTreeRT@@$$QAPAV2@@Z ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Emplace_one_at_back<CSpeedTreeRT *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$move@AAPAVCSpeedTreeRT@@@std@@YA$$QAPAVCSpeedTreeRT@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAVCSpeedTreeRT@@@std@@YA$$QAPAVCSpeedTreeRT@@AAPAV1@@Z PROC ; std::move<CSpeedTreeRT * &>, COMDAT

; 1547 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1548 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1549 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$move@AAPAVCSpeedTreeRT@@@std@@YA$$QAPAVCSpeedTreeRT@@AAPAV1@@Z ENDP ; std::move<CSpeedTreeRT * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$destroy@PAVCSpeedTreeRT@@@?$_Default_allocator_traits@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@SAXAAV?$allocator@PAVCSpeedTreeRT@@@1@QAPAVCSpeedTreeRT@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAVCSpeedTreeRT@@@?$_Default_allocator_traits@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@SAXAAV?$allocator@PAVCSpeedTreeRT@@@1@QAPAVCSpeedTreeRT@@@Z PROC ; std::_Default_allocator_traits<std::allocator<CSpeedTreeRT *> >::destroy<CSpeedTreeRT *>, COMDAT

; 705  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 706  : #if _HAS_CXX20
; 707  :         _STD destroy_at(_Ptr);
; 708  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 709  :         _Ptr->~_Uty();
; 710  : #endif // ^^^ !_HAS_CXX20 ^^^
; 711  :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$destroy@PAVCSpeedTreeRT@@@?$_Default_allocator_traits@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@SAXAAV?$allocator@PAVCSpeedTreeRT@@@1@QAPAVCSpeedTreeRT@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<CSpeedTreeRT *> >::destroy<CSpeedTreeRT *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Unfancy@PAVCSpeedTreeRT@@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@PAVCSpeedTreeRT@@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@@Z PROC ; std::_Unfancy<CSpeedTreeRT *>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 36   :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]

; 37   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unfancy@PAVCSpeedTreeRT@@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@@Z ENDP ; std::_Unfancy<CSpeedTreeRT *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Move_unchecked@PAPAVCSpeedTreeRT@@PAPAV1@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_unchecked@PAPAVCSpeedTreeRT@@PAPAV1@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@00@Z PROC ; std::_Move_unchecked<CSpeedTreeRT * *,CSpeedTreeRT * *>, COMDAT

; 4990 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4991 :     // move [_First, _Last) to [_Dest, ...)
; 4992 :     // note: _Move_unchecked has callers other than the move family
; 4993 :     if constexpr (_Is_vb_iterator<_InIt> && _Is_vb_iterator<_OutIt, true>) {
; 4994 :         return _STD _Copy_vbool(_First, _Last, _Dest);
; 4995 :     } else {
; 4996 :         if constexpr (_Iter_move_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4997 : #if _HAS_CXX20
; 4998 :             if (!_STD is_constant_evaluated())
; 4999 : #endif // _HAS_CXX20
; 5000 :             {
; 5001 :                 return _STD _Copy_memmove(_First, _Last, _Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_memmove@PAPAVCSpeedTreeRT@@PAPAV1@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@00@Z ; std::_Copy_memmove<CSpeedTreeRT * *,CSpeedTreeRT * *>
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@Move_unche

; 5002 :             }
; 5003 :         }
; 5004 : 
; 5005 :         for (; _First != _Last; ++_Dest, (void) ++_First) {

	jmp	SHORT $LN4@Move_unche
$LN2@Move_unche:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 4
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN4@Move_unche:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@Move_unche

; 5006 :             *_Dest = _STD move(*_First);

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$move@AAPAVCSpeedTreeRT@@@std@@YA$$QAPAVCSpeedTreeRT@@AAPAV1@@Z ; std::move<CSpeedTreeRT * &>
	add	esp, 4
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 5007 :         }

	jmp	SHORT $LN2@Move_unche
$LN3@Move_unche:

; 5008 : 
; 5009 :         return _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
$LN1@Move_unche:

; 5010 :     }
; 5011 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_unchecked@PAPAVCSpeedTreeRT@@PAPAV1@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@00@Z ENDP ; std::_Move_unchecked<CSpeedTreeRT * *,CSpeedTreeRT * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >, COMDAT

; 1559 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1560 :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 1561 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
__New_proxy$ = -20					; size = 4
_this$ = -8						; size = 4
__Al$ = 8						; size = 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1184 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1185 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));

	push	1
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	push	eax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	add	esp, 4
	mov	DWORD PTR __New_proxy$[ebp], eax

; 1186 :         _Construct_in_place(*_New_proxy, this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_proxy$[ebp]
	push	edx
	call	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
	add	esp, 8

; 1187 :         _Myproxy            = _New_proxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __New_proxy$[ebp]
	mov	DWORD PTR [eax], ecx

; 1188 :         _New_proxy->_Mycont = this;

	mov	eax, DWORD PTR __New_proxy$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx

; 1189 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@USShape@@@std@@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@USShape@@@std@@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<SShape>,std::_Vector_val<std::_Simple_types<SShape> >,1>::_Compressed_pair<std::allocator<SShape>,std::_Vector_val<std::_Simple_types<SShape> >,1><>, COMDAT
; _this$ = ecx

; 1496 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@USShape@@@std@@QAE@XZ	; std::allocator<SShape>::allocator<SShape>
	npad	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<SShape> >::_Vector_val<std::_Simple_types<SShape> >
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@USShape@@@std@@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<SShape>,std::_Vector_val<std::_Simple_types<SShape> >,1>::_Compressed_pair<std::allocator<SShape>,std::_Vector_val<std::_Simple_types<SShape> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1112 : _CONSTEXPR20 void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1113 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1114 :     using _Ty = typename _Alloc::value_type;
; 1115 :     _Ptr->~_Ty();
; 1116 :     _STD _Deallocate_plain(_Al, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 1117 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -8						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Container_proxy *,std::nullptr_t>, COMDAT

; 754  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi

; 755  :     // assign _New_val to _Val, return previous _Val
; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Old_val$[ebp], ecx

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR __New_val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 758  :     return _Old_val;

	mov	eax, DWORD PTR __Old_val$[ebp]

; 759  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Container_proxy *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0USShape@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@USShape@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0USShape@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@USShape@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><SShape>, COMDAT
; _this$ = ecx

; 943  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0USShape@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@USShape@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><SShape>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 953  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$07@std@@YAII@Z	; std::_Get_size_of_n<8>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
	add	esp, 4

; 956  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Emplace_one_at_back@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAUSShape@@ABU2@@Z
_TEXT	SEGMENT
__Mylast$ = -32						; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_one_at_back@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAUSShape@@ABU2@@Z PROC ; std::vector<SShape,std::allocator<SShape> >::_Emplace_one_at_back<SShape const &>, COMDAT
; _this$ = ecx

; 770  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 771  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 772  :         auto& _My_data   = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 773  :         pointer& _Mylast = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 774  : 
; 775  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	je	SHORT $LN2@Emplace_on

; 776  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	call	??$forward@ABUSShape@@@std@@YAABUSShape@@ABU1@@Z ; std::forward<SShape const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Emplace_back_with_unused_capacity@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAUSShape@@ABU2@@Z ; std::vector<SShape,std::allocator<SShape> >::_Emplace_back_with_unused_capacity<SShape const &>
	jmp	SHORT $LN1@Emplace_on
$LN2@Emplace_on:

; 777  :         }
; 778  : 
; 779  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	call	??$forward@ABUSShape@@@std@@YAABUSShape@@ABU1@@Z ; std::forward<SShape const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Emplace_reallocate@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEPAUSShape@@QAU2@ABU2@@Z ; std::vector<SShape,std::allocator<SShape> >::_Emplace_reallocate<SShape const &>
$LN1@Emplace_on:

; 780  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Emplace_one_at_back@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAUSShape@@ABU2@@Z ENDP ; std::vector<SShape,std::allocator<SShape> >::_Emplace_one_at_back<SShape const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Assign_counted_range@PAUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXPAUSShape@@I@Z
_TEXT	SEGMENT
__Newlast$1 = -140					; size = 4
__Mid$2 = -128						; size = 4
__Copied$3 = -113					; size = 1
__Oldsize$ = -104					; size = 4
__Oldcapacity$ = -92					; size = 4
__Nothrow_construct$ = -77				; size = 1
__Myend$ = -68						; size = 4
__Mylast$ = -56						; size = 4
__Myfirst$ = -44					; size = 4
__My_data$ = -32					; size = 4
__Al$ = -20						; size = 4
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Newsize$ = 12						; size = 4
??$_Assign_counted_range@PAUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXPAUSShape@@I@Z PROC ; std::vector<SShape,std::allocator<SShape> >::_Assign_counted_range<SShape *>, COMDAT
; _this$ = ecx

; 1375 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-144]
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1376 :         // assign elements from counted range _First + [0, _Newsize)
; 1377 :         auto& _Al         = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAV?$allocator@USShape@@@2@XZ ; std::vector<SShape,std::allocator<SShape> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 1378 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1379 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 1380 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 1381 :         pointer& _Myend   = _My_data._Myend;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Myend$[ebp], eax

; 1382 : 
; 1383 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,

	mov	BYTE PTR __Nothrow_construct$[ebp], 1

; 1384 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1385 : 
; 1386 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 1387 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR __Oldcapacity$[ebp], eax

; 1388 :         if (_Newsize > _Oldcapacity) {

	mov	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, DWORD PTR __Oldcapacity$[ebp]
	jbe	SHORT $LN5@Assign_cou

; 1389 :             _Clear_and_reserve_geometric(_Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Clear_and_reserve_geometric@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXI@Z ; std::vector<SShape,std::allocator<SShape> >::_Clear_and_reserve_geometric
	npad	1

; 1390 :             if constexpr (_Nothrow_construct) {
; 1391 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$move@AAPAUSShape@@@std@@YA$$QAPAUSShape@@AAPAU1@@Z ; std::move<SShape * &>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	??$_Uninitialized_copy_n@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@PAU1@I0AAV?$allocator@USShape@@@0@@Z ; std::_Uninitialized_copy_n<SShape *,std::allocator<SShape> >
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [ecx], eax

; 1392 :                 _ASAN_VECTOR_CREATE;
; 1393 :             } else {
; 1394 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1395 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1396 :             }
; 1397 :             return;

	jmp	$LN1@Assign_cou
$LN5@Assign_cou:

; 1398 :         }
; 1399 : 
; 1400 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR __Oldsize$[ebp], eax

; 1401 :         if (_Newsize > _Oldsize) {

	mov	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, DWORD PTR __Oldsize$[ebp]
	jbe	$LN6@Assign_cou

; 1402 :             bool _Copied = false;

	mov	BYTE PTR __Copied$3[ebp], 0

; 1403 :             if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {
; 1404 : #if _HAS_CXX20
; 1405 :                 if (!_STD is_constant_evaluated())
; 1406 : #endif // _HAS_CXX20
; 1407 :                 {
; 1408 :                     _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Oldsize$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_memmove_n@PAUSShape@@PAU1@@std@@YAPAUSShape@@PAU1@I0@Z ; std::_Copy_memmove_n<SShape *,SShape *>
	add	esp, 12					; 0000000cH

; 1409 :                     _First += _Oldsize;

	imul	eax, DWORD PTR __Oldsize$[ebp], 28
	add	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1410 :                     _Copied = true;

	mov	BYTE PTR __Copied$3[ebp], 1

; 1411 :                 }
; 1412 :             }
; 1413 : 
; 1414 :             if (!_Copied) {

	movzx	eax, BYTE PTR __Copied$3[ebp]
	test	eax, eax
	jne	SHORT $LN3@Assign_cou

; 1415 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Mid$2[ebp], ecx
	jmp	SHORT $LN4@Assign_cou
$LN2@Assign_cou:
	mov	eax, DWORD PTR __Mid$2[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR __Mid$2[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR __First$[ebp], ecx
$LN4@Assign_cou:
	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __Mid$2[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN3@Assign_cou

; 1416 :                     *_Mid = *_First;

	mov	ecx, 7
	mov	esi, DWORD PTR __First$[ebp]
	mov	edi, DWORD PTR __Mid$2[ebp]
	rep movsd

; 1417 :                 }

	jmp	SHORT $LN2@Assign_cou
$LN3@Assign_cou:

; 1418 :             }
; 1419 : 
; 1420 :             if constexpr (_Nothrow_construct) {
; 1421 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1422 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Newsize$[ebp]
	sub	eax, DWORD PTR __Oldsize$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$move@AAPAUSShape@@@std@@YA$$QAPAUSShape@@AAPAU1@@Z ; std::move<SShape * &>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	??$_Uninitialized_copy_n@PAUSShape@@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@PAU1@I0AAV?$allocator@USShape@@@0@@Z ; std::_Uninitialized_copy_n<SShape *,std::allocator<SShape> >
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [ecx], eax

; 1423 :             } else {
; 1424 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1425 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1426 :                 _ASAN_VECTOR_RELEASE_GUARD;
; 1427 :             }
; 1428 :         } else {

	jmp	SHORT $LN7@Assign_cou
$LN6@Assign_cou:

; 1429 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	eax, DWORD PTR __Newsize$[ebp], 28
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR __Newlast$1[ebp], eax

; 1430 :             _STD _Copy_n_unchecked4(_STD move(_First), _Newsize, _Myfirst);

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$move@AAPAUSShape@@@std@@YA$$QAPAUSShape@@AAPAU1@@Z ; std::move<SShape * &>
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Copy_n_unchecked4@PAUSShape@@IPAU1@@std@@YAPAUSShape@@PAU1@I0@Z ; std::_Copy_n_unchecked4<SShape *,unsigned int,SShape *>
	add	esp, 12					; 0000000cH

; 1431 :             _STD _Destroy_range(_Newlast, _Mylast, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Newlast$1[ebp]
	push	eax
	call	??$_Destroy_range@V?$allocator@USShape@@@std@@@std@@YAXPAUSShape@@QAU1@AAV?$allocator@USShape@@@0@@Z ; std::_Destroy_range<std::allocator<SShape> >
	add	esp, 12					; 0000000cH

; 1432 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1433 :             _Mylast = _Newlast;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __Newlast$1[ebp]
	mov	DWORD PTR [eax], ecx
$LN7@Assign_cou:
$LN1@Assign_cou:

; 1434 :         }
; 1435 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 336				; 00000150H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$_Assign_counted_range@PAUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXPAUSShape@@I@Z ENDP ; std::vector<SShape,std::allocator<SShape> >::_Assign_counted_range<SShape *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@USShape@@@std@@@std@@YAXAAV?$allocator@USShape@@@0@ABV10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@USShape@@@std@@@std@@YAXAAV?$allocator@USShape@@@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<SShape> >, COMDAT

; 1040 : _CONSTEXPR20 void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1041 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1042 :         _Left = _Right;
; 1043 :     }
; 1044 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pocca@V?$allocator@USShape@@@std@@@std@@YAXAAV?$allocator@USShape@@@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<SShape> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@$$CBV?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@@std@@YAPBV?$vector@USShape@@V?$allocator@USShape@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@@std@@YAPBV?$vector@USShape@@V?$allocator@USShape@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::vector<SShape,std::allocator<SShape> > const >, COMDAT

; 1559 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1560 :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 1561 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@$$CBV?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@@std@@YAPBV?$vector@USShape@@V?$allocator@USShape@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::vector<SShape,std::allocator<SShape> > const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@USShape@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@USShape@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<SShape> > >, COMDAT

; 1559 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1560 :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 1561 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@USShape@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<SShape> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?RoundToNearestInt@@YAHM@Z
_TEXT	SEGMENT
_fDiff$ = -20						; size = 4
_nIntValue$ = -8					; size = 4
_fValue$ = 8						; size = 4
?RoundToNearestInt@@YAHM@Z PROC				; RoundToNearestInt, COMDAT

; 2230 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi

; 2231 :     int nIntValue = int(fValue);

	cvttss2si eax, DWORD PTR _fValue$[ebp]
	mov	DWORD PTR _nIntValue$[ebp], eax

; 2232 :     float fDiff = fValue - nIntValue;

	cvtsi2ss xmm0, DWORD PTR _nIntValue$[ebp]
	movss	xmm1, DWORD PTR _fValue$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _fDiff$[ebp], xmm1

; 2233 :     if (fDiff >= 0.5f)

	movss	xmm0, DWORD PTR _fDiff$[ebp]
	comiss	xmm0, DWORD PTR __real@3f000000
	jb	SHORT $LN2@RoundToNea

; 2234 :         ++nIntValue;

	mov	eax, DWORD PTR _nIntValue$[ebp]
	add	eax, 1
	mov	DWORD PTR _nIntValue$[ebp], eax
$LN2@RoundToNea:

; 2235 : 
; 2236 :     return nIntValue;

	mov	eax, DWORD PTR _nIntValue$[ebp]

; 2237 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RoundToNearestInt@@YAHM@Z ENDP				; RoundToNearestInt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAVCSpeedTreeRT@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@V10@V10@ABQAVCSpeedTreeRT@@@Z
_TEXT	SEGMENT
$T2 = -224						; size = 4
$T3 = -212						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Val$ = 36						; size = 4
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAVCSpeedTreeRT@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@V10@V10@ABQAVCSpeedTreeRT@@@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >,CSpeedTreeRT *>, COMDAT

; 5950 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAVCSpeedTreeRT@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@V10@V10@ABQAVCSpeedTreeRT@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 5951 :     _STD _Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > > >
	add	esp, 8

; 5952 :     if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
; 5953 :         return _STD _Find_vbool(_First, _Last, _Val);
; 5954 :     } else {
; 5955 :         _STD _Seek_wrapped(_First, _STD _Find_unchecked(_STD _Get_unwrapped(_First), _STD _Get_unwrapped(_Last), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > > const &>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > > &>
	add	esp, 4
	push	eax
	call	??$_Find_unchecked@PAPAVCSpeedTreeRT@@PAV1@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@QAPAV1@ABQAV1@@Z ; std::_Find_unchecked<CSpeedTreeRT * *,CSpeedTreeRT *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T3[ebp], eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAPAVCSpeedTreeRT@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@$$QAPAPAVCSpeedTreeRT@@@Z ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >,CSpeedTreeRT * *>
	add	esp, 8

; 5956 :         return _First;

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@$$QAV01@@Z
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	npad	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN1@find

; 5957 :     }
; 5958 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	npad	1
$LN1@find:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAVCSpeedTreeRT@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@V10@V10@ABQAVCSpeedTreeRT@@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAVCSpeedTreeRT@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@V10@V10@ABQAVCSpeedTreeRT@@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAVCSpeedTreeRT@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@V10@V10@ABQAVCSpeedTreeRT@@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAVCSpeedTreeRT@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@V10@V10@ABQAVCSpeedTreeRT@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAVCSpeedTreeRT@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@V10@V10@ABQAVCSpeedTreeRT@@@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >,CSpeedTreeRT *>
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@PAPAVCSpeedTreeRT@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@PAPAVCSpeedTreeRT@@PBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___param1$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___param0$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@PAPAVCSpeedTreeRT@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@PAPAVCSpeedTreeRT@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@$$QAV01@@Z
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEPAPAVCSpeedTreeRT@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEPAPAVCSpeedTreeRT@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Unwrapped, COMDAT
; _this$ = ecx

; 344  :     _NODISCARD _CONSTEXPR20 value_type* _Unwrapped() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 345  :         return _STD _Unfancy_maybe_null(this->_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	??$_Unfancy_maybe_null@PAVCSpeedTreeRT@@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@@Z ; std::_Unfancy_maybe_null<CSpeedTreeRT *>
	add	esp, 4

; 346  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEPAPAVCSpeedTreeRT@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator++, COMDAT
; _this$ = ecx

; 286  :     _CONSTEXPR20 _Vector_iterator& operator++() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 287  :         _Mybase::operator++();

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator++
	npad	1

; 288  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 289  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEAAPAVCSpeedTreeRT@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEAAPAVCSpeedTreeRT@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator*, COMDAT
; _this$ = ecx

; 270  :     _NODISCARD _CONSTEXPR20 reference operator*() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 271  :         return const_cast<reference>(_Mybase::operator*());

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEABQAVCSpeedTreeRT@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator*

; 272  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEAAPAVCSpeedTreeRT@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@ABU01@@Z	; std::_Iterator_base12::_Iterator_base12
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@ABU01@@Z	; std::_Iterator_base12::_Iterator_base12
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAEXPBQAVCSpeedTreeRT@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__It$ = 8						; size = 4
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAEXPBQAVCSpeedTreeRT@@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Seek_to, COMDAT
; _this$ = ecx

; 220  :     _CONSTEXPR20 void _Seek_to(const value_type* _It) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 221  :         _Ptr = _STD _Refancy_maybe_null<_Tptr>(const_cast<value_type*>(_It));

	mov	eax, DWORD PTR __It$[ebp]
	push	eax
	call	??$_Refancy_maybe_null@PAPAVCSpeedTreeRT@@$0A@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@@Z ; std::_Refancy_maybe_null<CSpeedTreeRT * *,0>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 222  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAEXPBQAVCSpeedTreeRT@@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Verify_range@std@@YAXABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Verify_range@std@@YAXABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@1@0@Z PROC ; std::_Verify_range, COMDAT

; 208  :         const _Vector_const_iterator& _First, const _Vector_const_iterator& _Last) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN4@Verify_ran:

; 209  :         _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "vector iterators in range are from different containers");

	mov	ecx, DWORD PTR __First$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	esi, eax
	mov	ecx, DWORD PTR __Last$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	esi, eax
	jne	SHORT $LN14@Verify_ran
	jmp	SHORT $LN6@Verify_ran
$LN14@Verify_ran:
	mov	esi, esp
	push	OFFSET ??_C@_0DI@PBEELKIF@vector?5iterators?5in?5range?5are?5f@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	209					; 000000d1H
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN19@Verify_ran
	int	3
$LN19@Verify_ran:
	mov	esi, esp
	push	0
	push	209					; 000000d1H
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1HE@KBMFDAFB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN14@Verify_ran
$LN6@Verify_ran:
	xor	eax, eax
	jne	SHORT $LN4@Verify_ran
$LN3@Verify_ran:

; 210  :         _STL_VERIFY(_First._Ptr <= _Last._Ptr, "vector iterator range transposed");

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN16@Verify_ran
	jmp	SHORT $LN12@Verify_ran
$LN16@Verify_ran:
	mov	esi, esp
	push	OFFSET ??_C@_0CB@LIAHLBAO@vector?5iterator?5range?5transpose@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	210					; 000000d2H
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN20@Verify_ran
	int	3
$LN20@Verify_ran:
	mov	esi, esp
	push	0
	push	210					; 000000d2H
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1EG@ODKBEHFN@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN16@Verify_ran
$LN12@Verify_ran:
	xor	eax, eax
	jne	SHORT $LN3@Verify_ran

; 211  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Verify_range@std@@YAXABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@1@0@Z ENDP ; std::_Verify_range
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Compat, COMDAT
; _this$ = ecx

; 197  :     _CONSTEXPR20 void _Compat(const _Vector_const_iterator& _Right) const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN4@Compat:

; 198  :         // test for compatible iterator pair
; 199  : #if _ITERATOR_DEBUG_LEVEL == 0
; 200  :         (void) _Right;
; 201  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL != 0 vvv
; 202  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	esi, eax
	jne	SHORT $LN8@Compat
	jmp	SHORT $LN6@Compat
$LN8@Compat:
	mov	esi, esp
	push	OFFSET ??_C@_0BO@CAOBBIOC@vector?5iterators?5incompatible@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	202					; 000000caH
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@Compat
	int	3
$LN11@Compat:
	mov	esi, esp
	push	0
	push	202					; 000000caH
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1EA@DJDGNIII@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@Compat
$LN6@Compat:
	xor	eax, eax
	jne	SHORT $LN4@Compat

; 203  : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 0 ^^^
; 204  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator!=, COMDAT
; _this$ = ecx

; 175  :     _NODISCARD bool operator!=(const _Vector_const_iterator& _Right) const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 176  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[ebp]

; 177  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator==, COMDAT
; _this$ = ecx

; 164  :     _NODISCARD _CONSTEXPR20 bool operator==(const _Vector_const_iterator& _Right) const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 165  :         _Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Compat
	npad	1

; 166  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[ebp]

; 167  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator++, COMDAT
; _this$ = ecx

; 74   :     _CONSTEXPR20 _Vector_const_iterator& operator++() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 75   : #if _ITERATOR_DEBUG_LEVEL != 0
; 76   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax
$LN4@operator:

; 77   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN20@operator
	jmp	SHORT $LN6@operator
$LN20@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0DC@KEKNBAEB@can?8t?5increment?5value?9initializ@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	77					; 0000004dH
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN27@operator
	int	3
$LN27@operator:
	mov	esi, esp
	push	0
	push	77					; 0000004dH
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1GI@EDCILPL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN20@operator
$LN6@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator
$LN3@operator:

; 78   :         _STL_VERIFY(_Mycont, "can't increment invalidated vector iterator");

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN22@operator
	jmp	SHORT $LN12@operator
$LN22@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0CM@MNNBKIBC@can?8t?5increment?5invalidated?5vec@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	78					; 0000004eH
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN28@operator
	int	3
$LN28@operator:
	mov	esi, esp
	push	0
	push	78					; 0000004eH
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1FM@ICPJNHLL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN22@operator
$LN12@operator:
	xor	eax, eax
	jne	SHORT $LN3@operator
$LN9@operator:

; 79   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mycont$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN24@operator
	jmp	SHORT $LN18@operator
$LN24@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0CJ@OAAAAGPM@can?8t?5increment?5vector?5iterator@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	79					; 0000004fH
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN29@operator
	int	3
$LN29@operator:
	mov	esi, esp
	push	0
	push	79					; 0000004fH
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1FG@LDPPKMGP@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN24@operator
$LN18@operator:
	xor	eax, eax
	jne	SHORT $LN9@operator

; 80   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 81   : 
; 82   :         ++_Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 83   :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 84   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEABQAVCSpeedTreeRT@@XZ
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEABQAVCSpeedTreeRT@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator*, COMDAT
; _this$ = ecx

; 50   :     _NODISCARD _CONSTEXPR20 reference operator*() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : #if _ITERATOR_DEBUG_LEVEL != 0
; 52   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax
$LN4@operator:

; 53   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN20@operator
	jmp	SHORT $LN6@operator
$LN20@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0DE@CHADHGFF@can?8t?5dereference?5value?9initial@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	53					; 00000035H
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN27@operator
	int	3
$LN27@operator:
	mov	esi, esp
	push	0
	push	53					; 00000035H
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1GM@FNBFNBEL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN20@operator
$LN6@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator
$LN3@operator:

; 54   :         _STL_VERIFY(_Mycont, "can't dereference invalidated vector iterator");

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN22@operator
	jmp	SHORT $LN12@operator
$LN22@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0CO@PGFNEDAH@can?8t?5dereference?5invalidated?5v@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	54					; 00000036H
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN28@operator
	int	3
$LN28@operator:
	mov	esi, esp
	push	0
	push	54					; 00000036H
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1GA@CLCDIGKJ@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN22@operator
$LN12@operator:
	xor	eax, eax
	jne	SHORT $LN3@operator
$LN9@operator:

; 55   :         _STL_VERIFY(

	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN24@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mycont$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN24@operator
	jmp	SHORT $LN18@operator
$LN24@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0CP@MDHADBHN@can?8t?5dereference?5out?5of?5range?5@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	56					; 00000038H
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN29@operator
	int	3
$LN29@operator:
	mov	esi, esp
	push	0
	push	56					; 00000038H
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1GC@JDCKOLAC@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN24@operator
$LN18@operator:
	xor	eax, eax
	jne	SHORT $LN9@operator

; 56   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 57   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 58   : 
; 59   :         return *_Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 60   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEABQAVCSpeedTreeRT@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@PAPAVCSpeedTreeRT@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@PAPAVCSpeedTreeRT@@PBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >, COMDAT
; _this$ = ecx

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::_Iterator_base12
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 47   :         this->_Adopt(_Pvector);

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
	npad	1

; 48   :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@PAPAVCSpeedTreeRT@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@PAUSShape@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@PAUSShape@@PBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___param1$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___param0$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@PAUSShape@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@PAUSShape@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@XZ
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator++, COMDAT
; _this$ = ecx

; 286  :     _CONSTEXPR20 _Vector_iterator& operator++() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 287  :         _Mybase::operator++();

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator++
	npad	1

; 288  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 289  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator->, COMDAT
; _this$ = ecx

; 274  :     _NODISCARD _CONSTEXPR20 pointer operator->() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 275  : #if _ITERATOR_DEBUG_LEVEL != 0
; 276  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax
$LN4@operator:

; 277  :         _STL_VERIFY(this->_Ptr, "can't dereference value-initialized vector iterator");

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN20@operator
	jmp	SHORT $LN6@operator
$LN20@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0DE@CHADHGFF@can?8t?5dereference?5value?9initial@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	277					; 00000115H
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN27@operator
	int	3
$LN27@operator:
	mov	esi, esp
	push	0
	push	277					; 00000115H
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1GM@FNBFNBEL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN20@operator
$LN6@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator
$LN3@operator:

; 278  :         _STL_VERIFY(_Mycont, "can't dereference invalidated vector iterator");

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN22@operator
	jmp	SHORT $LN12@operator
$LN22@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0CO@PGFNEDAH@can?8t?5dereference?5invalidated?5v@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	278					; 00000116H
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN28@operator
	int	3
$LN28@operator:
	mov	esi, esp
	push	0
	push	278					; 00000116H
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1GA@CLCDIGKJ@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN22@operator
$LN12@operator:
	xor	eax, eax
	jne	SHORT $LN3@operator
$LN9@operator:

; 279  :         _STL_VERIFY(_Mycont->_Myfirst <= this->_Ptr && this->_Ptr < _Mycont->_Mylast,

	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN24@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mycont$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN24@operator
	jmp	SHORT $LN18@operator
$LN24@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0CP@MDHADBHN@can?8t?5dereference?5out?5of?5range?5@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	280					; 00000118H
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN29@operator
	int	3
$LN29@operator:
	mov	esi, esp
	push	0
	push	280					; 00000118H
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1GC@JDCKOLAC@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN24@operator
$LN18@operator:
	xor	eax, eax
	jne	SHORT $LN9@operator

; 280  :             "can't dereference out of range vector iterator");
; 281  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 282  : 
; 283  :         return this->_Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 284  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::_Compat, COMDAT
; _this$ = ecx

; 197  :     _CONSTEXPR20 void _Compat(const _Vector_const_iterator& _Right) const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN4@Compat:

; 198  :         // test for compatible iterator pair
; 199  : #if _ITERATOR_DEBUG_LEVEL == 0
; 200  :         (void) _Right;
; 201  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL != 0 vvv
; 202  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	esi, eax
	jne	SHORT $LN8@Compat
	jmp	SHORT $LN6@Compat
$LN8@Compat:
	mov	esi, esp
	push	OFFSET ??_C@_0BO@CAOBBIOC@vector?5iterators?5incompatible@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	202					; 000000caH
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@Compat
	int	3
$LN11@Compat:
	mov	esi, esp
	push	0
	push	202					; 000000caH
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1EA@DJDGNIII@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@Compat
$LN6@Compat:
	xor	eax, eax
	jne	SHORT $LN4@Compat

; 203  : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 0 ^^^
; 204  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator!=, COMDAT
; _this$ = ecx

; 175  :     _NODISCARD bool operator!=(const _Vector_const_iterator& _Right) const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 176  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[ebp]

; 177  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator==, COMDAT
; _this$ = ecx

; 164  :     _NODISCARD _CONSTEXPR20 bool operator==(const _Vector_const_iterator& _Right) const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 165  :         _Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::_Compat
	npad	1

; 166  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[ebp]

; 167  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator++, COMDAT
; _this$ = ecx

; 74   :     _CONSTEXPR20 _Vector_const_iterator& operator++() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 75   : #if _ITERATOR_DEBUG_LEVEL != 0
; 76   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax
$LN4@operator:

; 77   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN20@operator
	jmp	SHORT $LN6@operator
$LN20@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0DC@KEKNBAEB@can?8t?5increment?5value?9initializ@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	77					; 0000004dH
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN27@operator
	int	3
$LN27@operator:
	mov	esi, esp
	push	0
	push	77					; 0000004dH
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1GI@EDCILPL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN20@operator
$LN6@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator
$LN3@operator:

; 78   :         _STL_VERIFY(_Mycont, "can't increment invalidated vector iterator");

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN22@operator
	jmp	SHORT $LN12@operator
$LN22@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0CM@MNNBKIBC@can?8t?5increment?5invalidated?5vec@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	78					; 0000004eH
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN28@operator
	int	3
$LN28@operator:
	mov	esi, esp
	push	0
	push	78					; 0000004eH
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1FM@ICPJNHLL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN22@operator
$LN12@operator:
	xor	eax, eax
	jne	SHORT $LN3@operator
$LN9@operator:

; 79   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mycont$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN24@operator
	jmp	SHORT $LN18@operator
$LN24@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0CJ@OAAAAGPM@can?8t?5increment?5vector?5iterator@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	79					; 0000004fH
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN29@operator
	int	3
$LN29@operator:
	mov	esi, esp
	push	0
	push	79					; 0000004fH
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1FG@LDPPKMGP@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN24@operator
$LN18@operator:
	xor	eax, eax
	jne	SHORT $LN9@operator

; 80   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 81   : 
; 82   :         ++_Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 83   :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 84   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@PAUSShape@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@PAUSShape@@PBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >, COMDAT
; _this$ = ecx

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::_Iterator_base12
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 47   :         this->_Adopt(_Pvector);

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
	npad	1

; 48   :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@PAUSShape@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GSCollisionObjects@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GSCollisionObjects@@QAEPAXI@Z PROC			; SCollisionObjects::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SCollisionObjects@@QAE@XZ
	npad	1
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSCollisionObjects@@QAEPAXI@Z ENDP			; SCollisionObjects::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??4SCollisionObjects@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4SCollisionObjects@@QAEAAU0@ABU0@@Z PROC		; SCollisionObjects::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<SShape,std::allocator<SShape> >::operator=
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4SCollisionObjects@@QAEAAU0@ABU0@@Z ENDP		; SCollisionObjects::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1SCollisionObjects@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1SCollisionObjects@@QAE@XZ PROC			; SCollisionObjects::~SCollisionObjects, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE@XZ ; std::vector<SShape,std::allocator<SShape> >::~vector<SShape,std::allocator<SShape> >
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1SCollisionObjects@@QAE@XZ ENDP			; SCollisionObjects::~SCollisionObjects
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0SCollisionObjects@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0SCollisionObjects@@QAE@XZ PROC			; SCollisionObjects::SCollisionObjects, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE@XZ ; std::vector<SShape,std::allocator<SShape> >::vector<SShape,std::allocator<SShape> >
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0SCollisionObjects@@QAE@XZ ENDP			; SCollisionObjects::SCollisionObjects
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@USShape@@@std@@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@2@$00@std@@QBEABV?$allocator@USShape@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@USShape@@@std@@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@2@$00@std@@QBEABV?$allocator@USShape@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<SShape>,std::_Vector_val<std::_Simple_types<SShape> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1507 :     constexpr const _Ty1& _Get_first() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1508 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1509 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@USShape@@@std@@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@2@$00@std@@QBEABV?$allocator@USShape@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<SShape>,std::_Vector_val<std::_Simple_types<SShape> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@USShape@@@std@@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@2@$00@std@@QAEAAV?$allocator@USShape@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@USShape@@@std@@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@2@$00@std@@QAEAAV?$allocator@USShape@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<SShape>,std::_Vector_val<std::_Simple_types<SShape> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1503 :     constexpr _Ty1& _Get_first() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1504 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1505 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@USShape@@@std@@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@2@$00@std@@QAEAAV?$allocator@USShape@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<SShape>,std::_Vector_val<std::_Simple_types<SShape> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<SShape> >::_Vector_val<std::_Simple_types<SShape> >, COMDAT
; _this$ = ecx

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<SShape> >::_Vector_val<std::_Simple_types<SShape> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEABV?$allocator@USShape@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEABV?$allocator@USShape@@@2@XZ PROC ; std::vector<SShape,std::allocator<SShape> >::_Getal, COMDAT
; _this$ = ecx

; 2188 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2189 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@USShape@@@std@@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@2@$00@std@@QBEABV?$allocator@USShape@@@2@XZ ; std::_Compressed_pair<std::allocator<SShape>,std::_Vector_val<std::_Simple_types<SShape> >,1>::_Get_first

; 2190 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEABV?$allocator@USShape@@@2@XZ ENDP ; std::vector<SShape,std::allocator<SShape> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAV?$allocator@USShape@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAV?$allocator@USShape@@@2@XZ PROC ; std::vector<SShape,std::allocator<SShape> >::_Getal, COMDAT
; _this$ = ecx

; 2184 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2185 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@USShape@@@std@@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@2@$00@std@@QAEAAV?$allocator@USShape@@@2@XZ ; std::_Compressed_pair<std::allocator<SShape>,std::_Vector_val<std::_Simple_types<SShape> >,1>::_Get_first

; 2186 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAV?$allocator@USShape@@@2@XZ ENDP ; std::vector<SShape,std::allocator<SShape> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Orphan_range@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z PROC ; std::vector<SShape,std::allocator<SShape> >::_Orphan_range, COMDAT
; _this$ = ecx

; 2169 :     _CONSTEXPR20 void _Orphan_range(pointer _First, pointer _Last) const {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2170 :         // orphan iterators within specified (inclusive) range
; 2171 : #if _HAS_CXX20
; 2172 :         if (_STD is_constant_evaluated()) {
; 2173 :             _Orphan_range_unlocked(_First, _Last);
; 2174 :         } else
; 2175 : #endif // _HAS_CXX20
; 2176 :         {
; 2177 :             _Orphan_range_locked(_First, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range_locked@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z ; std::vector<SShape,std::allocator<SShape> >::_Orphan_range_locked
	npad	1

; 2178 :         }
; 2179 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Orphan_range@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z ENDP ; std::vector<SShape,std::allocator<SShape> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Orphan_range_locked@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z
_TEXT	SEGMENT
__Lock$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range_locked@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z PROC ; std::vector<SShape,std::allocator<SShape> >::_Orphan_range_locked, COMDAT
; _this$ = ecx

; 2164 :     void _Orphan_range_locked(pointer _First, pointer _Last) const {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_range_locked@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2165 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2166 :         _Orphan_range_unlocked(_First, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range_unlocked@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z ; std::vector<SShape,std::allocator<SShape> >::_Orphan_range_unlocked
	npad	1

; 2167 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@Orphan_ran
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN7@Orphan_ran:
	DD	1
	DD	$LN6@Orphan_ran
$LN6@Orphan_ran:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN4@Orphan_ran
$LN4@Orphan_ran:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range_locked@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?_Orphan_range_locked@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_range_locked@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_range_locked@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z ENDP ; std::vector<SShape,std::allocator<SShape> >::_Orphan_range_locked
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Orphan_range_unlocked@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z
_TEXT	SEGMENT
__Temp$1 = -44						; size = 4
__Pnextptr$2 = -32					; size = 4
__Pnext$ = -20						; size = 4
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range_unlocked@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z PROC ; std::vector<SShape,std::allocator<SShape> >::_Orphan_range_unlocked, COMDAT
; _this$ = ecx

; 2150 :     _CONSTEXPR20 void _Orphan_range_unlocked(pointer _First, pointer _Last) const {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2151 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$[ebp], ecx
$LN2@Orphan_ran:

; 2152 :         while (*_Pnext) {

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Orphan_ran

; 2153 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Pnextptr$2[ebp], edx

; 2154 :             const auto _Temp     = *_Pnext;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Temp$1[ebp], ecx

; 2155 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator

	mov	eax, DWORD PTR __Pnextptr$2[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jb	SHORT $LN6@Orphan_ran
	mov	eax, DWORD PTR __Last$[ebp]
	cmp	eax, DWORD PTR __Pnextptr$2[ebp]
	jae	SHORT $LN4@Orphan_ran
$LN6@Orphan_ran:

; 2156 :                 _Pnext = &_Temp->_Mynextiter;

	mov	eax, DWORD PTR __Temp$1[ebp]
	add	eax, 4
	mov	DWORD PTR __Pnext$[ebp], eax

; 2157 :             } else { // orphan the iterator

	jmp	SHORT $LN5@Orphan_ran
$LN4@Orphan_ran:

; 2158 :                 _Temp->_Myproxy = nullptr;

	mov	eax, DWORD PTR __Temp$1[ebp]
	mov	DWORD PTR [eax], 0

; 2159 :                 *_Pnext         = _Temp->_Mynextiter;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR __Temp$1[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
$LN5@Orphan_ran:

; 2160 :             }
; 2161 :         }

	jmp	SHORT $LN2@Orphan_ran
$LN3@Orphan_ran:

; 2162 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?_Orphan_range_unlocked@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEXPAUSShape@@0@Z ENDP ; std::vector<SShape,std::allocator<SShape> >::_Orphan_range_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Xlength@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@CAXXZ PROC ; std::vector<SShape,std::allocator<SShape> >::_Xlength, COMDAT

; 2141 :     [[noreturn]] static void _Xlength() {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2142 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
	npad	1
$LN1@Xlength:

; 2143 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlength@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@CAXXZ ENDP ; std::vector<SShape,std::allocator<SShape> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Tidy@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Myend$ = -80						; size = 4
__Mylast$ = -68						; size = 4
__Myfirst$ = -56					; size = 4
__My_data$ = -44					; size = 4
__Al$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXXZ PROC ; std::vector<SShape,std::allocator<SShape> >::_Tidy, COMDAT
; _this$ = ecx

; 2039 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Tidy@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2040 :         auto& _Al         = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAV?$allocator@USShape@@@2@XZ ; std::vector<SShape,std::allocator<SShape> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 2041 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2042 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 2043 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 2044 :         pointer& _Myend   = _My_data._Myend;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Myend$[ebp], eax

; 2045 : 
; 2046 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 2047 : 
; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR __Myfirst$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Tidy

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Destroy_range@V?$allocator@USShape@@@std@@@std@@YAXPAUSShape@@QAU1@AAV?$allocator@USShape@@@0@@Z ; std::_Destroy_range<std::allocator<SShape> >
	add	esp, 12					; 0000000cH

; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@USShape@@@std@@QAEXQAUSShape@@I@Z ; std::allocator<SShape>::deallocate
	npad	1

; 2052 : 
; 2053 :             _Myfirst = nullptr;

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	DWORD PTR [eax], 0

; 2054 :             _Mylast  = nullptr;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [eax], 0

; 2055 :             _Myend   = nullptr;

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@Tidy:

; 2056 :         }
; 2057 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXXZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXXZ ENDP ; std::vector<SShape,std::allocator<SShape> >::_Tidy
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Change_array@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXQAUSShape@@II@Z
_TEXT	SEGMENT
__Myend$ = -68						; size = 4
__Mylast$ = -56						; size = 4
__Myfirst$ = -44					; size = 4
__My_data$ = -32					; size = 4
__Al$ = -20						; size = 4
_this$ = -8						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXQAUSShape@@II@Z PROC ; std::vector<SShape,std::allocator<SShape> >::_Change_array, COMDAT
; _this$ = ecx

; 2017 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2018 :         // orphan all iterators, discard old array, acquire new array
; 2019 :         auto& _Al         = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAV?$allocator@USShape@@@2@XZ ; std::vector<SShape,std::allocator<SShape> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 2020 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2021 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 2022 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 2023 :         pointer& _Myend   = _My_data._Myend;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Myend$[ebp], eax

; 2024 : 
; 2025 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 2026 : 
; 2027 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR __Myfirst$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Change_arr

; 2028 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Destroy_range@V?$allocator@USShape@@@std@@@std@@YAXPAUSShape@@QAU1@AAV?$allocator@USShape@@@0@@Z ; std::_Destroy_range<std::allocator<SShape> >
	add	esp, 12					; 0000000cH

; 2029 :             _ASAN_VECTOR_REMOVE;
; 2030 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@USShape@@@std@@QAEXQAUSShape@@I@Z ; std::allocator<SShape>::deallocate
	npad	1
$LN2@Change_arr:

; 2031 :         }
; 2032 : 
; 2033 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [eax], ecx

; 2034 :         _Mylast  = _Newvec + _Newsize;

	imul	eax, DWORD PTR __Newsize$[ebp], 28
	add	eax, DWORD PTR __Newvec$[ebp]
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [ecx], eax

; 2035 :         _Myend   = _Newvec + _Newcapacity;

	imul	eax, DWORD PTR __Newcapacity$[ebp], 28
	add	eax, DWORD PTR __Newvec$[ebp]
	mov	ecx, DWORD PTR __Myend$[ebp]
	mov	DWORD PTR [ecx], eax

; 2036 :         _ASAN_VECTOR_CREATE;
; 2037 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Change_array@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXQAUSShape@@II@Z ENDP ; std::vector<SShape,std::allocator<SShape> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Buy_raw@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newvec$ = -68						; size = 4
__Myend$ = -56						; size = 4
__Mylast$ = -44						; size = 4
__Myfirst$ = -32					; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXI@Z PROC ; std::vector<SShape,std::allocator<SShape> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1983 :     _CONSTEXPR20 void _Buy_raw(size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1984 :         // allocate array with _Newcapacity elements
; 1985 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1986 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 1987 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 1988 :         pointer& _Myend   = _My_data._Myend;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Myend$[ebp], eax

; 1989 : 
; 1990 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1991 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1992 : 
; 1993 :         const pointer _Newvec = _STD _Allocate_at_least_helper(_Getal(), _Newcapacity);

	lea	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAV?$allocator@USShape@@@2@XZ ; std::vector<SShape,std::allocator<SShape> >::_Getal
	push	eax
	call	??$_Allocate_at_least_helper@V?$allocator@USShape@@@std@@@std@@YAPAUSShape@@AAV?$allocator@USShape@@@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<SShape> >
	add	esp, 8
	mov	DWORD PTR __Newvec$[ebp], eax

; 1994 :         _Myfirst              = _Newvec;

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [eax], ecx

; 1995 :         _Mylast               = _Newvec;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [eax], ecx

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	imul	eax, DWORD PTR __Newcapacity$[ebp], 28
	add	eax, DWORD PTR __Newvec$[ebp]
	mov	ecx, DWORD PTR __Myend$[ebp]
	mov	DWORD PTR [ecx], eax

; 1997 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy_raw@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXI@Z ENDP ; std::vector<SShape,std::allocator<SShape> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Calculate_growth@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Geometric$ = -44					; size = 4
__Max$ = -32						; size = 4
__Oldcapacity$ = -20					; size = 4
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEII@Z PROC ; std::vector<SShape,std::allocator<SShape> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1965 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1966 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1967 :         const size_type _Oldcapacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ ; std::vector<SShape,std::allocator<SShape> >::capacity
	mov	DWORD PTR __Oldcapacity$[ebp], eax

; 1968 :         const auto _Max              = max_size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ ; std::vector<SShape,std::allocator<SShape> >::max_size
	mov	DWORD PTR __Max$[ebp], eax

; 1969 : 
; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	eax, DWORD PTR __Oldcapacity$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR __Max$[ebp]
	sub	ecx, eax
	cmp	DWORD PTR __Oldcapacity$[ebp], ecx
	jbe	SHORT $LN2@Calculate_

; 1971 :             return _Max; // geometric growth would overflow

	mov	eax, DWORD PTR __Max$[ebp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1972 :         }
; 1973 : 
; 1974 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	mov	eax, DWORD PTR __Oldcapacity$[ebp]
	shr	eax, 1
	add	eax, DWORD PTR __Oldcapacity$[ebp]
	mov	DWORD PTR __Geometric$[ebp], eax

; 1975 : 
; 1976 :         if (_Geometric < _Newsize) {

	mov	eax, DWORD PTR __Geometric$[ebp]
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@Calculate_

; 1977 :             return _Newsize; // geometric growth would be insufficient

	mov	eax, DWORD PTR __Newsize$[ebp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1978 :         }
; 1979 : 
; 1980 :         return _Geometric; // geometric growth is sufficient

	mov	eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1981 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Calculate_growth@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEII@Z ENDP ; std::vector<SShape,std::allocator<SShape> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??A?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAEAAUSShape@@I@Z
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAEAAUSShape@@I@Z PROC ; std::vector<SShape,std::allocator<SShape> >::operator[], COMDAT
; _this$ = ecx

; 1886 :     _NODISCARD _CONSTEXPR20 _Ty& operator[](const size_type _Pos) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1887 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax
$LN4@operator:

; 1888 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1889 :         _STL_VERIFY(

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	DWORD PTR __Pos$[ebp], eax
	jae	SHORT $LN8@operator
	jmp	SHORT $LN6@operator
$LN8@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1890					; 00000762H
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	mov	esi, esp
	push	0
	push	1890					; 00000762H
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@operator
$LN6@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator

; 1890 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1891 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1892 : 
; 1893 :         return _My_data._Myfirst[_Pos];

	imul	eax, DWORD PTR __Pos$[ebp], 28
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	eax, DWORD PTR [ecx+4]

; 1894 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAEAAUSShape@@I@Z ENDP ; std::vector<SShape,std::allocator<SShape> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?capacity@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?capacity@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ PROC ; std::vector<SShape,std::allocator<SShape> >::capacity, COMDAT
; _this$ = ecx

; 1881 :     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1882 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1883 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx

; 1884 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ ENDP ; std::vector<SShape,std::allocator<SShape> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?max_size@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
$T2 = -212						; size = 4
_this$ = -8						; size = 4
?max_size@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ PROC ; std::vector<SShape,std::allocator<SShape> >::max_size, COMDAT
; _this$ = ecx

; 1876 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1877 :         return (_STD min)(

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEABV?$allocator@USShape@@@2@XZ ; std::vector<SShape,std::allocator<SShape> >::_Getal
	push	eax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAIABV?$allocator@USShape@@@2@@Z ; std::_Default_allocator_traits<std::allocator<SShape> >::max_size
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	call	?max@?$numeric_limits@H@std@@SAHXZ	; std::numeric_limits<int>::max
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$min@I@std@@YAABIABI0@Z		; std::min<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 1878 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1879 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ ENDP ; std::vector<SShape,std::allocator<SShape> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?size@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?size@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ PROC ; std::vector<SShape,std::allocator<SShape> >::size, COMDAT
; _this$ = ecx

; 1871 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1872 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1873 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx

; 1874 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ ENDP ; std::vector<SShape,std::allocator<SShape> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?end@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@2@XZ PROC ; std::vector<SShape,std::allocator<SShape> >::end, COMDAT
; _this$ = ecx

; 1808 :     _NODISCARD _CONSTEXPR20 iterator end() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1809 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1810 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@USShape@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<SShape> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@PAUSShape@@PBU_Container_base12@1@@Z
	npad	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1811 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@2@XZ ENDP ; std::vector<SShape,std::allocator<SShape> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?begin@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@2@XZ PROC ; std::vector<SShape,std::allocator<SShape> >::begin, COMDAT
; _this$ = ecx

; 1798 :     _NODISCARD _CONSTEXPR20 iterator begin() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1799 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1800 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@USShape@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<SShape> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@PAUSShape@@PBU_Container_base12@1@@Z
	npad	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1801 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@2@XZ ENDP ; std::vector<SShape,std::allocator<SShape> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = -80					; size = 4
__Myend$ = -68						; size = 4
__Mylast$ = -56						; size = 4
__Myfirst$ = -44					; size = 4
__My_data$ = -32					; size = 4
__Al$ = -20						; size = 4
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?_Clear_and_reserve_geometric@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXI@Z PROC ; std::vector<SShape,std::allocator<SShape> >::_Clear_and_reserve_geometric, COMDAT
; _this$ = ecx

; 1649 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 21					; 00000015H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1650 :         auto& _Al         = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAV?$allocator@USShape@@@2@XZ ; std::vector<SShape,std::allocator<SShape> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 1651 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1652 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 1653 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 1654 :         pointer& _Myend   = _My_data._Myend;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Myend$[ebp], eax

; 1655 : 
; 1656 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1657 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1658 :         _Check_all_orphaned();
; 1659 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1660 : 
; 1661 :         if (_Newsize > max_size()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ ; std::vector<SShape,std::allocator<SShape> >::max_size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jbe	SHORT $LN2@Clear_and_

; 1662 :             _Xlength();

	call	?_Xlength@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@CAXXZ ; std::vector<SShape,std::allocator<SShape> >::_Xlength
	npad	1
$LN2@Clear_and_:

; 1663 :         }
; 1664 : 
; 1665 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEII@Z ; std::vector<SShape,std::allocator<SShape> >::_Calculate_growth
	mov	DWORD PTR __Newcapacity$[ebp], eax

; 1666 : 
; 1667 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR __Myfirst$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Clear_and_

; 1668 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Destroy_range@V?$allocator@USShape@@@std@@@std@@YAXPAUSShape@@QAU1@AAV?$allocator@USShape@@@0@@Z ; std::_Destroy_range<std::allocator<SShape> >
	add	esp, 12					; 0000000cH

; 1669 :             _ASAN_VECTOR_REMOVE;
; 1670 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@USShape@@@std@@QAEXQAUSShape@@I@Z ; std::allocator<SShape>::deallocate
	npad	1

; 1671 : 
; 1672 :             _Myfirst = nullptr;

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	DWORD PTR [eax], 0

; 1673 :             _Mylast  = nullptr;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [eax], 0

; 1674 :             _Myend   = nullptr;

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	DWORD PTR [eax], 0
$LN3@Clear_and_:

; 1675 :         }
; 1676 : 
; 1677 :         _Buy_raw(_Newcapacity);

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy_raw@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXI@Z ; std::vector<SShape,std::allocator<SShape> >::_Buy_raw
	npad	1
$LN1@Clear_and_:

; 1678 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Clear_and_reserve_geometric@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXI@Z ENDP ; std::vector<SShape,std::allocator<SShape> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??4?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right_data$ = -44					; size = 4
__Right_al$ = -32					; size = 4
__Al$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??4?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<SShape,std::allocator<SShape> >::operator=, COMDAT
; _this$ = ecx

; 1476 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1477 :         if (this == _STD addressof(_Right)) {

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$addressof@$$CBV?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@@std@@YAPBV?$vector@USShape@@V?$allocator@USShape@@@std@@@0@ABV10@@Z ; std::addressof<std::vector<SShape,std::allocator<SShape> > const >
	add	esp, 4
	cmp	DWORD PTR _this$[ebp], eax
	jne	SHORT $LN2@operator

; 1478 :             return *this;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@operator
$LN2@operator:

; 1479 :         }
; 1480 : 
; 1481 :         auto& _Al       = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAV?$allocator@USShape@@@2@XZ ; std::vector<SShape,std::allocator<SShape> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 1482 :         auto& _Right_al = _Right._Getal();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@ABEABV?$allocator@USShape@@@2@XZ ; std::vector<SShape,std::allocator<SShape> >::_Getal
	mov	DWORD PTR __Right_al$[ebp], eax

; 1483 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1484 :             if (_Al != _Right_al) {
; 1485 :                 _Tidy();
; 1486 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1487 :             }
; 1488 :         }
; 1489 : 
; 1490 :         _Pocca(_Al, _Right_al);

	mov	eax, DWORD PTR __Right_al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Pocca@V?$allocator@USShape@@@std@@@std@@YAXAAV?$allocator@USShape@@@0@ABV10@@Z ; std::_Pocca<std::allocator<SShape> >
	add	esp, 8

; 1491 :         auto& _Right_data = _Right._Mypair._Myval2;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR __Right_data$[ebp], eax

; 1492 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	eax, DWORD PTR __Right_data$[ebp]
	mov	ecx, DWORD PTR __Right_data$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR __Right_data$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Assign_counted_range@PAUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXPAUSShape@@I@Z ; std::vector<SShape,std::allocator<SShape> >::_Assign_counted_range<SShape *>
	npad	1

; 1493 : 
; 1494 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]
$LN1@operator:

; 1495 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<SShape,std::allocator<SShape> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?push_back@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAEXABUSShape@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAEXABUSShape@@@Z PROC ; std::vector<SShape,std::allocator<SShape> >::push_back, COMDAT
; _this$ = ecx

; 866  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 867  :         _Emplace_one_at_back(_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Emplace_one_at_back@ABUSShape@@@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAUSShape@@ABU2@@Z ; std::vector<SShape,std::allocator<SShape> >::_Emplace_one_at_back<SShape const &>
	npad	1

; 868  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAEXABUSShape@@@Z ENDP ; std::vector<SShape,std::allocator<SShape> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??1?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -236						; size = 4
_$S1$ = -29						; size = 1
__Alproxy$ = -20					; size = 4
_this$ = -8						; size = 4
??1?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE@XZ PROC ; std::vector<SShape,std::allocator<SShape> >::~vector<SShape,std::allocator<SShape> >, COMDAT
; _this$ = ecx

; 760  :     _CONSTEXPR20 ~vector() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 761  :         _Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEXXZ ; std::vector<SShape,std::allocator<SShape> >::_Tidy
	npad	1

; 762  : #if _ITERATOR_DEBUG_LEVEL != 0
; 763  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAV?$allocator@USShape@@@2@XZ ; std::vector<SShape,std::allocator<SShape> >::_Getal
	push	eax
	lea	ecx, DWORD PTR _$S1$[ebp]
	call	??$?0USShape@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@USShape@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><SShape>
	lea	eax, DWORD PTR _$S1$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 764  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

	mov	DWORD PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR __Alproxy$[ebp]
	push	edx
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 765  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 766  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@vector
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@vector:
	DD	1
	DD	$LN5@vector
$LN5@vector:
	DD	-29					; ffffffe3H
	DD	1
	DD	$LN4@vector
$LN4@vector:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	49					; 00000031H
	DB	0
??1?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE@XZ ENDP ; std::vector<SShape,std::allocator<SShape> >::~vector<SShape,std::allocator<SShape> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -233						; size = 1
$T3 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE@XZ PROC ; std::vector<SShape,std::allocator<SShape> >::vector<SShape,std::allocator<SShape> >, COMDAT
; _this$ = ecx

; 601  :     _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@USShape@@@std@@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<SShape>,std::_Vector_val<std::_Simple_types<SShape> >,1>::_Compressed_pair<std::allocator<SShape>,std::_Vector_val<std::_Simple_types<SShape> >,1><>
	npad	1

; 602  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@AAEAAV?$allocator@USShape@@@2@XZ ; std::vector<SShape,std::allocator<SShape> >::_Getal
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0USShape@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@USShape@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><SShape>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
	npad	1

; 603  :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE@XZ ENDP ; std::vector<SShape,std::allocator<SShape> >::vector<SShape,std::allocator<SShape> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAIABV?$allocator@USShape@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAIABV?$allocator@USShape@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<SShape> >::max_size, COMDAT

; 713  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 714  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	eax, 153391689				; 09249249H

; 715  :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@USShape@@@std@@@std@@SAIABV?$allocator@USShape@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SShape> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?allocate@?$allocator@USShape@@@std@@QAEPAUSShape@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@USShape@@@std@@QAEPAUSShape@@I@Z PROC ; std::allocator<SShape>::allocate, COMDAT
; _this$ = ecx

; 953  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$0BM@@std@@YAII@Z	; std::_Get_size_of_n<28>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
	add	esp, 4

; 956  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@USShape@@@std@@QAEPAUSShape@@I@Z ENDP ; std::allocator<SShape>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?deallocate@?$allocator@USShape@@@std@@QAEXQAUSShape@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@USShape@@@std@@QAEXQAUSShape@@I@Z PROC ; std::allocator<SShape>::deallocate, COMDAT
; _this$ = ecx

; 947  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN4@deallocate:

; 948  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN10@deallocate
	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN8@deallocate
$LN10@deallocate:
	jmp	SHORT $LN6@deallocate
$LN8@deallocate:
	mov	esi, esp
	push	OFFSET ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	948					; 000003b4H
	push	OFFSET ??_C@_0GC@GDGMGNBP@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN12@deallocate
	int	3
$LN12@deallocate:
	mov	esi, esp
	push	0
	push	948					; 000003b4H
	push	OFFSET ??_C@_1ME@KJJNLLPL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@deallocate
$LN6@deallocate:
	xor	eax, eax
	jne	SHORT $LN4@deallocate

; 949  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	eax, DWORD PTR __Count$[ebp], 28
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07@std@@YAXPAXI@Z	; std::_Deallocate<8>
	add	esp, 8

; 951  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@USShape@@@std@@QAEXQAUSShape@@I@Z ENDP ; std::allocator<SShape>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$allocator@USShape@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@USShape@@@std@@QAE@XZ PROC		; std::allocator<SShape>::allocator<SShape>, COMDAT
; _this$ = ecx

; 939  :     constexpr allocator() noexcept {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@USShape@@@std@@QAE@XZ ENDP		; std::allocator<SShape>::allocator<SShape>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?TransformAll@SCollisionObjects@@QAEXAAVCTransform@@@Z
_TEXT	SEGMENT
tv255 = -316						; size = 4
tv251 = -316						; size = 4
tv239 = -316						; size = 4
tv227 = -316						; size = 4
tv211 = -316						; size = 4
tv199 = -316						; size = 4
tv183 = -316						; size = 4
$T2 = -308						; size = 12
$T3 = -288						; size = 12
$T4 = -265						; size = 1
_cPos$5 = -64						; size = 12
_i$6 = -44						; size = 12
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_cTransform$ = 8					; size = 4
?TransformAll@SCollisionObjects@@QAEXAAVCTransform@@@Z PROC ; SCollisionObjects::TransformAll, COMDAT
; _this$ = ecx

; 188  :         {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?TransformAll@SCollisionObjects@@QAEXAAVCTransform@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 304				; 00000130H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 189  :             for (vector<SShape>::iterator i = m_vObjects.begin( ); i != m_vObjects.end( ); ++i)

	lea	eax, DWORD PTR _i$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@2@XZ ; std::vector<SShape,std::allocator<SShape> >::begin
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	jmp	SHORT $LN4@TransformA
$LN2@TransformA:
	lea	ecx, DWORD PTR _i$6[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator++
	npad	1
$LN4@TransformA:
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@2@XZ ; std::vector<SShape,std::allocator<SShape> >::end
	mov	DWORD PTR tv255[ebp], eax
	mov	ecx, DWORD PTR tv255[ebp]
	push	ecx
	lea	ecx, DWORD PTR _i$6[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator!=
	mov	BYTE PTR $T4[ebp], al
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@XZ
	movzx	edx, BYTE PTR $T4[ebp]
	test	edx, edx
	je	$LN3@TransformA

; 190  :             {
; 191  :                 // transform base point
; 192  :                 CVec3 cPos(i->m_afPosition[0], i->m_afPosition[1], i->m_afPosition[2]);

	lea	ecx, DWORD PTR _i$6[ebp]
	call	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator->
	mov	ecx, 4
	shl	ecx, 1
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx+4]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _i$6[ebp]
	call	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator->
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx+4]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _i$6[ebp]
	call	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator->
	mov	ecx, 4
	imul	edx, ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx+4]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _cPos$5[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	npad	1

; 193  :                 cPos = cPos * cTransform;

	mov	eax, DWORD PTR _cTransform$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _cPos$5[ebp]
	call	??DCVec3@@QBE?AV0@ABVCTransform@@@Z	; CVec3::operator*
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _cPos$5[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _cPos$5[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _cPos$5[ebp+8], edx

; 194  :                 i->m_afPosition[0] = cPos[0];

	push	0
	lea	ecx, DWORD PTR _cPos$5[ebp]
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	mov	esi, eax
	lea	ecx, DWORD PTR _i$6[ebp]
	call	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator->
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax+edx+4], ecx

; 195  :                 i->m_afPosition[1] = cPos[1];

	push	1
	lea	ecx, DWORD PTR _cPos$5[ebp]
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	mov	esi, eax
	lea	ecx, DWORD PTR _i$6[ebp]
	call	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator->
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax+ecx+4], edx

; 196  :                 i->m_afPosition[2] = cPos[2];

	push	2
	lea	ecx, DWORD PTR _cPos$5[ebp]
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	mov	esi, eax
	lea	ecx, DWORD PTR _i$6[ebp]
	call	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator->
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax+ecx+4], edx

; 197  : 
; 198  :                 // transform the dimensions
; 199  :                 if (i->m_eType == CSpeedTreeRT::CO_SPHERE)

	lea	ecx, DWORD PTR _i$6[ebp]
	call	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator->
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@TransformA

; 200  :                 {
; 201  :                     // the sphere is always meant to be perfectly round,
; 202  :                     // so we've chosen to scale the radius arbitrarily by
; 203  :                     // the x-axis scale factor
; 204  :                     i->m_afDimensions[0] *= cTransform.m_afData[0][0];

	lea	ecx, DWORD PTR _i$6[ebp]
	call	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator->
	mov	ecx, 4
	imul	edx, ecx, 0
	lea	eax, DWORD PTR [eax+edx+16]
	mov	DWORD PTR tv183[ebp], eax
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _cTransform$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR tv183[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR tv183[ebp]
	movss	DWORD PTR [ecx], xmm0

; 205  :                 }

	jmp	$LN9@TransformA
$LN5@TransformA:

; 206  :                 else if (i->m_eType == CSpeedTreeRT::CO_CYLINDER)

	lea	ecx, DWORD PTR _i$6[ebp]
	call	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator->
	cmp	DWORD PTR [eax], 1
	jne	$LN7@TransformA

; 207  :                 {
; 208  :                     // the cylinder collision object was not meant to
; 209  :                     // lie on anything but the up axis, so an arbitrary
; 210  :                     // transform can wreak some havoc.
; 211  :                     i->m_afDimensions[0] *= cTransform.m_afData[0][0];

	lea	ecx, DWORD PTR _i$6[ebp]
	call	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator->
	mov	ecx, 4
	imul	edx, ecx, 0
	lea	eax, DWORD PTR [eax+edx+16]
	mov	DWORD PTR tv199[ebp], eax
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _cTransform$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR tv199[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR tv199[ebp]
	movss	DWORD PTR [ecx], xmm0

; 212  :                     i->m_afDimensions[1] *= cTransform.m_afData[0][0];

	lea	ecx, DWORD PTR _i$6[ebp]
	call	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator->
	mov	ecx, 4
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+16]
	mov	DWORD PTR tv211[ebp], edx
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _cTransform$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR tv211[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR tv211[ebp]
	movss	DWORD PTR [eax], xmm0

; 213  :                 }

	jmp	$LN9@TransformA
$LN7@TransformA:

; 214  :                 else if (i->m_eType == CSpeedTreeRT::CO_BOX)

	lea	ecx, DWORD PTR _i$6[ebp]
	call	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator->
	cmp	DWORD PTR [eax], 2
	jne	$LN9@TransformA

; 215  :                 {
; 216  :                     i->m_afDimensions[0] *= cTransform.m_afData[0][0];

	lea	ecx, DWORD PTR _i$6[ebp]
	call	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator->
	mov	ecx, 4
	imul	edx, ecx, 0
	lea	eax, DWORD PTR [eax+edx+16]
	mov	DWORD PTR tv227[ebp], eax
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _cTransform$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR tv227[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR tv227[ebp]
	movss	DWORD PTR [ecx], xmm0

; 217  :                     i->m_afDimensions[1] *= cTransform.m_afData[1][1];

	lea	ecx, DWORD PTR _i$6[ebp]
	call	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator->
	mov	ecx, 4
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+16]
	mov	DWORD PTR tv239[ebp], edx
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _cTransform$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR tv239[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR tv239[ebp]
	movss	DWORD PTR [eax], xmm0

; 218  :                     i->m_afDimensions[2] *= cTransform.m_afData[2][2];

	lea	ecx, DWORD PTR _i$6[ebp]
	call	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QBEPAUSShape@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShape> > >::operator->
	mov	ecx, 4
	shl	ecx, 1
	lea	edx, DWORD PTR [eax+ecx+16]
	mov	DWORD PTR tv251[ebp], edx
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _cTransform$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR tv251[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR tv251[ebp]
	movss	DWORD PTR [eax], xmm0
$LN9@TransformA:

; 219  :                 }

	jmp	$LN2@TransformA
$LN3@TransformA:

; 220  :             }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _i$6[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@XZ
	npad	1

; 221  :         }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@TransformA
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN17@TransformA:
	DD	2
	DD	$LN16@TransformA
$LN16@TransformA:
	DD	-44					; ffffffd4H
	DD	12					; 0000000cH
	DD	$LN13@TransformA
	DD	-64					; ffffffc0H
	DD	12					; 0000000cH
	DD	$LN14@TransformA
$LN14@TransformA:
	DB	99					; 00000063H
	DB	80					; 00000050H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	0
$LN13@TransformA:
	DB	105					; 00000069H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?TransformAll@SCollisionObjects@@QAEXAAVCTransform@@@Z$0:
	lea	ecx, DWORD PTR _i$6[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShape@@@std@@@std@@@std@@QAE@XZ
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?TransformAll@SCollisionObjects@@QAEXAAVCTransform@@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?TransformAll@SCollisionObjects@@QAEXAAVCTransform@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?TransformAll@SCollisionObjects@@QAEXAAVCTransform@@@Z ENDP ; SCollisionObjects::TransformAll
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??0SShape@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0SShape@@QAE@XZ PROC					; SShape::SShape, COMDAT
; _this$ = ecx

; 169  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 168  :             m_eType(CSpeedTreeRT::CO_SPHERE)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 170  :             m_afPosition[0] = m_afPosition[1] = m_afPosition[2] = 0.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+4], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+4], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+4], xmm0

; 171  :             m_afDimensions[0] = m_afDimensions[1] = m_afDimensions[2] = 0.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+16], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+16], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+16], xmm0

; 172  :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0SShape@@QAE@XZ ENDP					; SShape::SShape
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GSEmbeddedTexCoords@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GSEmbeddedTexCoords@@QAEPAXI@Z PROC			; SEmbeddedTexCoords::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SEmbeddedTexCoords@@QAE@XZ		; SEmbeddedTexCoords::~SEmbeddedTexCoords
	npad	1
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	84					; 00000054H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSEmbeddedTexCoords@@QAEPAXI@Z ENDP			; SEmbeddedTexCoords::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??4SEmbeddedTexCoords@@QAEABU0@ABU0@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
$T3 = -212						; size = 4
_this$ = -8						; size = 4
_sRight$ = 8						; size = 4
??4SEmbeddedTexCoords@@QAEABU0@ABU0@@Z PROC		; SEmbeddedTexCoords::operator=, COMDAT
; _this$ = ecx

; 115  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 116  :             if (&sRight != this)

	mov	eax, DWORD PTR _sRight$[ebp]
	cmp	eax, DWORD PTR _this$[ebp]
	je	$LN2@operator

; 117  :             {
; 118  :                 // copy leaf texture coordinates
; 119  :                 if (sRight.m_pLeafTexCoords)

	mov	eax, DWORD PTR _sRight$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@operator

; 120  :                 {
; 121  :                     m_nNumLeafMaps = sRight.m_nNumLeafMaps;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _sRight$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 122  :                     m_pLeafTexCoords = new float[m_nNumLeafMaps * 8];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	eax, 3
	mov	ecx, 4
	mul	ecx
	mov	edx, -1
	cmovb	eax, edx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [eax+4], ecx

; 123  :                     memcpy(m_pLeafTexCoords, sRight.m_pLeafTexCoords, m_nNumLeafMaps * 8 * sizeof(float));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	shl	ecx, 3
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _sRight$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@operator:

; 124  :                 }
; 125  :                 // copy billboard texture coordinates
; 126  :                 if (sRight.m_pBillboardTexCoords)

	mov	eax, DWORD PTR _sRight$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN4@operator

; 127  :                 {
; 128  :                     m_nNumBillboards = sRight.m_nNumBillboards;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _sRight$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 129  :                     m_pBillboardTexCoords = new float[m_nNumBillboards * 8];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	shl	eax, 3
	mov	ecx, 4
	mul	ecx
	mov	edx, -1
	cmovb	eax, edx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax+12], ecx

; 130  :                     memcpy(m_pBillboardTexCoords, sRight.m_pBillboardTexCoords, m_nNumBillboards * 8 * sizeof(float));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 3
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _sRight$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN4@operator:

; 131  :                 }
; 132  :                 // copy frond texture coordinates
; 133  :                 if (sRight.m_pFrondTexCoords)

	mov	eax, DWORD PTR _sRight$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN5@operator

; 134  :                 {
; 135  :                     m_nNumFrondMaps = sRight.m_nNumFrondMaps;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _sRight$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 136  :                     m_pFrondTexCoords = new float[m_nNumFrondMaps * 8];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	shl	eax, 3
	mov	ecx, 4
	mul	ecx
	mov	edx, -1
	cmovb	eax, edx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+20], ecx

; 137  :                     memcpy(m_pFrondTexCoords, sRight.m_pFrondTexCoords, m_nNumFrondMaps * 8 * sizeof(float));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	shl	ecx, 3
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _sRight$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN5@operator:

; 138  :                 }
; 139  : 
; 140  :                 m_strCompositeFilename = sRight.m_strCompositeFilename;

	mov	eax, DWORD PTR _sRight$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	npad	1

; 141  :                 memcpy(m_afShadowTexCoords, sRight.m_afShadowTexCoords, 8 * sizeof(float));

	push	32					; 00000020H
	mov	eax, DWORD PTR _sRight$[ebp]
	add	eax, 52					; 00000034H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN2@operator:

; 142  :             }
; 143  : 
; 144  :             return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 145  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4SEmbeddedTexCoords@@QAEABU0@ABU0@@Z ENDP		; SEmbeddedTexCoords::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??1SEmbeddedTexCoords@@QAE@XZ
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
$T3 = -212						; size = 4
_this$ = -8						; size = 4
??1SEmbeddedTexCoords@@QAE@XZ PROC			; SEmbeddedTexCoords::~SEmbeddedTexCoords, COMDAT
; _this$ = ecx

; 103  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 104  :             delete[] m_pLeafTexCoords;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 105  :             m_pLeafTexCoords = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 106  : 
; 107  :             delete[] m_pBillboardTexCoords;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 108  :             m_pBillboardTexCoords = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 109  : 
; 110  :             delete[] m_pFrondTexCoords;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 111  :             m_pFrondTexCoords = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 112  :         }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1SEmbeddedTexCoords@@QAE@XZ ENDP			; SEmbeddedTexCoords::~SEmbeddedTexCoords
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??0SEmbeddedTexCoords@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0SEmbeddedTexCoords@@QAE@XZ PROC			; SEmbeddedTexCoords::SEmbeddedTexCoords, COMDAT
; _this$ = ecx

; 88   :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 82   :             m_nNumLeafMaps(0),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 83   :             m_pLeafTexCoords(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 84   :             m_nNumBillboards(0),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 85   :             m_pBillboardTexCoords(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 86   :             m_nNumFrondMaps(0),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 87   :             m_pFrondTexCoords(NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 88   :         {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 89   :             m_afShadowTexCoords[0] = 1.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx+52], xmm0

; 90   :             m_afShadowTexCoords[1] = 1.0f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+eax+52], xmm0

; 91   : 
; 92   :             m_afShadowTexCoords[2] = 0.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+52], xmm0

; 93   :             m_afShadowTexCoords[3] = 1.0f;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx+52], xmm0

; 94   : 
; 95   :             m_afShadowTexCoords[4] = 0.0f;

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+52], xmm0

; 96   :             m_afShadowTexCoords[5] = 0.0f;

	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx+52], xmm0

; 97   : 
; 98   :             m_afShadowTexCoords[6] = 1.0f;

	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx+52], xmm0

; 99   :             m_afShadowTexCoords[7] = 0.0f;

	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx+52], xmm0

; 100  :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0SEmbeddedTexCoords@@QAE@XZ ENDP			; SEmbeddedTexCoords::SEmbeddedTexCoords
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__Fg_strKey@@YAXXZ
text$yd	SEGMENT
??__Fg_strKey@@YAXXZ PROC				; `dynamic atexit destructor for 'g_strKey'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?g_strKey@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__Fg_strKey@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_strKey''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??__Eg_strKey@@YAXXZ
text$di	SEGMENT
??__Eg_strKey@@YAXXZ PROC				; `dynamic initializer for 'g_strKey'', COMDAT

; 54   : static string g_strKey;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?g_strKey@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	push	OFFSET ??__Fg_strKey@@YAXXZ		; `dynamic atexit destructor for 'g_strKey''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eg_strKey@@YAXXZ ENDP				; `dynamic initializer for 'g_strKey''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__Fg_strError@@YAXXZ
text$yd	SEGMENT
??__Fg_strError@@YAXXZ PROC				; `dynamic atexit destructor for 'g_strError'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?g_strError@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__Fg_strError@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_strError''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??__Eg_strError@@YAXXZ
text$di	SEGMENT
??__Eg_strError@@YAXXZ PROC				; `dynamic initializer for 'g_strError'', COMDAT

; 53   : static string g_strError;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?g_strError@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	push	OFFSET ??__Fg_strError@@YAXXZ		; `dynamic atexit destructor for 'g_strError''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eg_strError@@YAXXZ ENDP				; `dynamic initializer for 'g_strError''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A@@YAXXZ
text$yd	SEGMENT
??__F?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'SInstanceList::m_vUniqueTrees'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A ; SInstanceList::m_vUniqueTrees
	call	??1?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::~vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'SInstanceList::m_vUniqueTrees''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??__E?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A@@YAXXZ
text$di	SEGMENT
??__E?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'SInstanceList::m_vUniqueTrees'', COMDAT

; 45   : vector<CSpeedTreeRT*> SInstanceList::m_vUniqueTrees;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A ; SInstanceList::m_vUniqueTrees
	call	??0?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >
	npad	1
	push	OFFSET ??__F?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'SInstanceList::m_vUniqueTrees''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'SInstanceList::m_vUniqueTrees''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GCProjectedShadow@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GCProjectedShadow@@QAEPAXI@Z PROC			; CProjectedShadow::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CProjectedShadow@@QAE@XZ
	npad	1
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	64					; 00000040H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCProjectedShadow@@QAEPAXI@Z ENDP			; CProjectedShadow::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??4CProjectedShadow@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4CProjectedShadow@@QAEAAV0@ABV0@@Z PROC		; CProjectedShadow::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4CProjectedShadow@@QAEAAV0@ABV0@@Z ENDP		; CProjectedShadow::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1CProjectedShadow@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1CProjectedShadow@@QAE@XZ PROC			; CProjectedShadow::~CProjectedShadow, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CProjectedShadow@@QAE@XZ ENDP			; CProjectedShadow::~CProjectedShadow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\ProjectedShadow.h
;	COMDAT ?GetSelfShadowFilename@CProjectedShadow@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSelfShadowFilename@CProjectedShadow@@QAEPBDXZ PROC	; CProjectedShadow::GetSelfShadowFilename, COMDAT
; _this$ = ecx

; 42   :         const char*     GetSelfShadowFilename(void)             { return m_strSelfShadowMap.c_str( ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSelfShadowFilename@CProjectedShadow@@QAEPBDXZ ENDP	; CProjectedShadow::GetSelfShadowFilename
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GCFrondEngine@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GCFrondEngine@@QAEPAXI@Z PROC			; CFrondEngine::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CFrondEngine@@QAE@XZ			; CFrondEngine::~CFrondEngine
	npad	1
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	108					; 0000006cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCFrondEngine@@QAEPAXI@Z ENDP			; CFrondEngine::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??A?$vector@USFrondTexture@@V?$allocator@USFrondTexture@@@std@@@std@@QBEABUSFrondTexture@@I@Z
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@USFrondTexture@@V?$allocator@USFrondTexture@@@std@@@std@@QBEABUSFrondTexture@@I@Z PROC ; std::vector<SFrondTexture,std::allocator<SFrondTexture> >::operator[], COMDAT
; _this$ = ecx

; 1896 :     _NODISCARD _CONSTEXPR20 const _Ty& operator[](const size_type _Pos) const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1897 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax
$LN4@operator:

; 1898 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1899 :         _STL_VERIFY(

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 44					; 0000002cH
	idiv	ecx
	cmp	DWORD PTR __Pos$[ebp], eax
	jae	SHORT $LN8@operator
	jmp	SHORT $LN6@operator
$LN8@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1900					; 0000076cH
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	mov	esi, esp
	push	0
	push	1900					; 0000076cH
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@operator
$LN6@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator

; 1900 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1901 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1902 : 
; 1903 :         return _My_data._Myfirst[_Pos];

	imul	eax, DWORD PTR __Pos$[ebp], 44
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	eax, DWORD PTR [ecx+4]

; 1904 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@USFrondTexture@@V?$allocator@USFrondTexture@@@std@@@std@@QBEABUSFrondTexture@@I@Z ENDP ; std::vector<SFrondTexture,std::allocator<SFrondTexture> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??A?$vector@USFrondTexture@@V?$allocator@USFrondTexture@@@std@@@std@@QAEAAUSFrondTexture@@I@Z
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@USFrondTexture@@V?$allocator@USFrondTexture@@@std@@@std@@QAEAAUSFrondTexture@@I@Z PROC ; std::vector<SFrondTexture,std::allocator<SFrondTexture> >::operator[], COMDAT
; _this$ = ecx

; 1886 :     _NODISCARD _CONSTEXPR20 _Ty& operator[](const size_type _Pos) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1887 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax
$LN4@operator:

; 1888 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1889 :         _STL_VERIFY(

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 44					; 0000002cH
	idiv	ecx
	cmp	DWORD PTR __Pos$[ebp], eax
	jae	SHORT $LN8@operator
	jmp	SHORT $LN6@operator
$LN8@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1890					; 00000762H
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	mov	esi, esp
	push	0
	push	1890					; 00000762H
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@operator
$LN6@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator

; 1890 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1891 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1892 : 
; 1893 :         return _My_data._Myfirst[_Pos];

	imul	eax, DWORD PTR __Pos$[ebp], 44
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	eax, DWORD PTR [ecx+4]

; 1894 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@USFrondTexture@@V?$allocator@USFrondTexture@@@std@@@std@@QAEAAUSFrondTexture@@I@Z ENDP ; std::vector<SFrondTexture,std::allocator<SFrondTexture> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?size@?$vector@USFrondTexture@@V?$allocator@USFrondTexture@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?size@?$vector@USFrondTexture@@V?$allocator@USFrondTexture@@@std@@@std@@QBEIXZ PROC ; std::vector<SFrondTexture,std::allocator<SFrondTexture> >::size, COMDAT
; _this$ = ecx

; 1871 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1872 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1873 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 44					; 0000002cH
	idiv	ecx

; 1874 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@USFrondTexture@@V?$allocator@USFrondTexture@@@std@@@std@@QBEIXZ ENDP ; std::vector<SFrondTexture,std::allocator<SFrondTexture> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\FrondEngine.h
;	COMDAT ?SetTextureFilename@CFrondEngine@@QAEXIPBD@Z
_TEXT	SEGMENT
$T1 = -240						; size = 28
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_nIndex$ = 8						; size = 4
_pFilename$ = 12					; size = 4
?SetTextureFilename@CFrondEngine@@QAEXIPBD@Z PROC	; CFrondEngine::SetTextureFilename, COMDAT
; _this$ = ecx

; 116  :         void                                    SetTextureFilename(unsigned int nIndex, const char* pFilename)  { m_vTextures[nIndex].m_strFilename = pFilename; }

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _pFilename$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0CIdvFilename@@QAE@PBD@Z		; CIdvFilename::CIdvFilename
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR _nIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??A?$vector@USFrondTexture@@V?$allocator@USFrondTexture@@@std@@@std@@QAEAAUSFrondTexture@@I@Z ; std::vector<SFrondTexture,std::allocator<SFrondTexture> >::operator[]
	mov	ecx, eax
	call	??4CIdvFilename@@QAEAAV0@$$QAV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1CIdvFilename@@QAE@XZ
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetTextureFilename@CFrondEngine@@QAEXIPBD@Z ENDP	; CFrondEngine::SetTextureFilename
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\FrondEngine.h
;	COMDAT ?GetTextureFilename@CFrondEngine@@QBEPBDI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
?GetTextureFilename@CFrondEngine@@QBEPBDI@Z PROC	; CFrondEngine::GetTextureFilename, COMDAT
; _this$ = ecx

; 115  :         const char*                             GetTextureFilename(unsigned int nIndex) const                   { return m_vTextures[nIndex].m_strFilename.c_str( ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _nIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??A?$vector@USFrondTexture@@V?$allocator@USFrondTexture@@@std@@@std@@QBEABUSFrondTexture@@I@Z ; std::vector<SFrondTexture,std::allocator<SFrondTexture> >::operator[]
	mov	ecx, eax
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetTextureFilename@CFrondEngine@@QBEPBDI@Z ENDP	; CFrondEngine::GetTextureFilename
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\FrondEngine.h
;	COMDAT ?GetTextureCount@CFrondEngine@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetTextureCount@CFrondEngine@@QBEIXZ PROC		; CFrondEngine::GetTextureCount, COMDAT
; _this$ = ecx

; 114  :         unsigned int                            GetTextureCount(void) const                                     { return m_vTextures.size( ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	?size@?$vector@USFrondTexture@@V?$allocator@USFrondTexture@@@std@@@std@@QBEIXZ ; std::vector<SFrondTexture,std::allocator<SFrondTexture> >::size
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTextureCount@CFrondEngine@@QBEIXZ ENDP		; CFrondEngine::GetTextureCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GCLeafGeometry@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GCLeafGeometry@@QAEPAXI@Z PROC			; CLeafGeometry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CLeafGeometry@@QAE@XZ		; CLeafGeometry::~CLeafGeometry
	npad	1
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCLeafGeometry@@QAEPAXI@Z ENDP			; CLeafGeometry::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LeafGeometry.h
;	COMDAT ?IsVertexWeightingEnabled@CLeafGeometry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?IsVertexWeightingEnabled@CLeafGeometry@@QBE_NXZ PROC	; CLeafGeometry::IsVertexWeightingEnabled, COMDAT
; _this$ = ecx

; 57   :         bool                    IsVertexWeightingEnabled(void) const                { return m_bVertexWeighting; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+1]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsVertexWeightingEnabled@CLeafGeometry@@QBE_NXZ ENDP	; CLeafGeometry::IsVertexWeightingEnabled
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LeafGeometry.h
;	COMDAT ?GetTriangleCount@CLeafGeometry@@QBEII@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nLodLevel$ = 8						; size = 4
?GetTriangleCount@CLeafGeometry@@QBEII@Z PROC		; CLeafGeometry::GetTriangleCount, COMDAT
; _this$ = ecx

; 53   :         unsigned int            GetTriangleCount(unsigned int nLodLevel) const      { st_assert(m_pLods); return m_pLods[nLodLevel].m_usLeafCount * 2; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN2@GetTriangl
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DG@LPJNEMKC@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	edi, esp
	push	53					; 00000035H
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@GetTriangl:
	imul	eax, DWORD PTR _nLodLevel$[ebp], 68
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	movzx	eax, WORD PTR [edx+eax+12]
	shl	eax, 1
$LN1@GetTriangl:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetTriangleCount@CLeafGeometry@@QBEII@Z ENDP		; CLeafGeometry::GetTriangleCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LeafGeometry.h
;	COMDAT ?EnableVertexWeighting@CLeafGeometry@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_bFlag$ = 8						; size = 1
?EnableVertexWeighting@CLeafGeometry@@QAEX_N@Z PROC	; CLeafGeometry::EnableVertexWeighting, COMDAT
; _this$ = ecx

; 49   :         void                    EnableVertexWeighting(bool bFlag)                   { m_bVertexWeighting = bFlag; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bFlag$[ebp]
	mov	BYTE PTR [eax+1], cl
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EnableVertexWeighting@CLeafGeometry@@QAEX_N@Z ENDP	; CLeafGeometry::EnableVertexWeighting
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LeafGeometry.h
;	COMDAT ?EnableManualLighting@CLeafGeometry@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_bFlag$ = 8						; size = 1
?EnableManualLighting@CLeafGeometry@@QAEX_N@Z PROC	; CLeafGeometry::EnableManualLighting, COMDAT
; _this$ = ecx

; 48   :         void                    EnableManualLighting(bool bFlag)                    { m_bManualLighting = bFlag; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bFlag$[ebp]
	mov	BYTE PTR [eax], cl
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EnableManualLighting@CLeafGeometry@@QAEX_N@Z ENDP	; CLeafGeometry::EnableManualLighting
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?SetFrondMaterial@CLightingEngine@@QAEXPBM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pMaterial$ = 8						; size = 4
?SetFrondMaterial@CLightingEngine@@QAEXPBM@Z PROC	; CLightingEngine::SetFrondMaterial, COMDAT
; _this$ = ecx

; 97   :         void                SetFrondMaterial(const float* pMaterial)                { st_assert(pMaterial); memcpy(m_afFrondMaterial, pMaterial, c_nMaterialParamSize * sizeof(float)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _pMaterial$[ebp], 0
	jne	SHORT $LN2@SetFrondMa
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DI@KINJKJPN@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	edi, esp
	push	97					; 00000061H
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@SetFrondMa:
	push	52					; 00000034H
	mov	eax, DWORD PTR _pMaterial$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@SetFrondMa:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFrondMaterial@CLightingEngine@@QAEXPBM@Z ENDP	; CLightingEngine::SetFrondMaterial
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?GetFrondMaterial@CLightingEngine@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetFrondMaterial@CLightingEngine@@QBEPBMXZ PROC	; CLightingEngine::GetFrondMaterial, COMDAT
; _this$ = ecx

; 96   :         const float*        GetFrondMaterial(void) const                            { return m_afFrondMaterial; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 124				; 0000007cH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFrondMaterial@CLightingEngine@@QBEPBMXZ ENDP	; CLightingEngine::GetFrondMaterial
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?SetLeafMaterial@CLightingEngine@@QAEXPBM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pMaterial$ = 8						; size = 4
?SetLeafMaterial@CLightingEngine@@QAEXPBM@Z PROC	; CLightingEngine::SetLeafMaterial, COMDAT
; _this$ = ecx

; 94   :         void                SetLeafMaterial(const float* pMaterial)                 { st_assert(pMaterial); memcpy(m_afLeafMaterial, pMaterial, c_nMaterialParamSize * sizeof(float)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _pMaterial$[ebp], 0
	jne	SHORT $LN2@SetLeafMat
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DI@KINJKJPN@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	edi, esp
	push	94					; 0000005eH
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@SetLeafMat:
	push	52					; 00000034H
	mov	eax, DWORD PTR _pMaterial$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@SetLeafMat:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLeafMaterial@CLightingEngine@@QAEXPBM@Z ENDP	; CLightingEngine::SetLeafMaterial
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?GetLeafMaterial@CLightingEngine@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetLeafMaterial@CLightingEngine@@QBEPBMXZ PROC		; CLightingEngine::GetLeafMaterial, COMDAT
; _this$ = ecx

; 93   :         const float*        GetLeafMaterial(void) const                             { return m_afLeafMaterial; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 60					; 0000003cH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLeafMaterial@CLightingEngine@@QBEPBMXZ ENDP		; CLightingEngine::GetLeafMaterial
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?SetBranchMaterial@CLightingEngine@@QAEXPBM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pMaterial$ = 8						; size = 4
?SetBranchMaterial@CLightingEngine@@QAEXPBM@Z PROC	; CLightingEngine::SetBranchMaterial, COMDAT
; _this$ = ecx

; 91   :         void                SetBranchMaterial(const float* pMaterial)               { st_assert(pMaterial); memcpy(m_afBranchMaterial, pMaterial, c_nMaterialParamSize * sizeof(float)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _pMaterial$[ebp], 0
	jne	SHORT $LN2@SetBranchM
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DI@KINJKJPN@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	edi, esp
	push	91					; 0000005bH
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@SetBranchM:
	push	52					; 00000034H
	mov	eax, DWORD PTR _pMaterial$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@SetBranchM:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBranchMaterial@CLightingEngine@@QAEXPBM@Z ENDP	; CLightingEngine::SetBranchMaterial
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?GetBranchMaterial@CLightingEngine@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetBranchMaterial@CLightingEngine@@QBEPBMXZ PROC	; CLightingEngine::GetBranchMaterial, COMDAT
; _this$ = ecx

; 90   :         const float*        GetBranchMaterial(void) const                           { return m_afBranchMaterial; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBranchMaterial@CLightingEngine@@QBEPBMXZ ENDP	; CLightingEngine::GetBranchMaterial
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?GetLightAttributes@CLightingEngine@@SAPBMI@Z
_TEXT	SEGMENT
_nLightIndex$ = 8					; size = 4
?GetLightAttributes@CLightingEngine@@SAPBMI@Z PROC	; CLightingEngine::GetLightAttributes, COMDAT

; 87   : static  const float*        GetLightAttributes(unsigned int nLightIndex)            { st_assert(nLightIndex < c_nMaxLights); return m_afLightAttributes[nLightIndex]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _nLightIndex$[ebp], 8
	jb	SHORT $LN2@GetLightAt
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DI@KINJKJPN@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	edi, esp
	push	87					; 00000057H
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@GetLightAt:
	mov	eax, DWORD PTR _nLightIndex$[ebp]
	shl	eax, 6
	add	eax, OFFSET ?m_afLightAttributes@CLightingEngine@@0PAY0BA@MA ; CLightingEngine::m_afLightAttributes
$LN1@GetLightAt:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLightAttributes@CLightingEngine@@SAPBMI@Z ENDP	; CLightingEngine::GetLightAttributes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?SetLightState@CLightingEngine@@SAXI_N@Z
_TEXT	SEGMENT
_nLightIndex$ = 8					; size = 4
_bLightOn$ = 12						; size = 1
?SetLightState@CLightingEngine@@SAXI_N@Z PROC		; CLightingEngine::SetLightState, COMDAT

; 85   : static  void                SetLightState(unsigned int nLightIndex, bool bLightOn)  { st_assert(nLightIndex < c_nMaxLights); m_abLightEnabled[nLightIndex] = bLightOn; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _nLightIndex$[ebp], 8
	jb	SHORT $LN2@SetLightSt
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DI@KINJKJPN@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	edi, esp
	push	85					; 00000055H
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@SetLightSt:
	mov	eax, DWORD PTR _nLightIndex$[ebp]
	mov	cl, BYTE PTR _bLightOn$[ebp]
	mov	BYTE PTR ?m_abLightEnabled@CLightingEngine@@0PA_NA[eax], cl
$LN1@SetLightSt:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?SetLightState@CLightingEngine@@SAXI_N@Z ENDP		; CLightingEngine::SetLightState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?GetLightState@CLightingEngine@@SA_NI@Z
_TEXT	SEGMENT
_nLightIndex$ = 8					; size = 4
?GetLightState@CLightingEngine@@SA_NI@Z PROC		; CLightingEngine::GetLightState, COMDAT

; 84   : static  bool                GetLightState(unsigned int nLightIndex)                 { st_assert(nLightIndex < c_nMaxLights); return m_abLightEnabled[nLightIndex]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _nLightIndex$[ebp], 8
	jb	SHORT $LN2@GetLightSt
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DI@KINJKJPN@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	edi, esp
	push	84					; 00000054H
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@GetLightSt:
	mov	eax, DWORD PTR _nLightIndex$[ebp]
	mov	al, BYTE PTR ?m_abLightEnabled@CLightingEngine@@0PA_NA[eax]
$LN1@GetLightSt:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLightState@CLightingEngine@@SA_NI@Z ENDP		; CLightingEngine::GetLightState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?GetLeafLightingAdjustment@CLightingEngine@@QAEMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetLeafLightingAdjustment@CLightingEngine@@QAEMXZ PROC	; CLightingEngine::GetLeafLightingAdjustment, COMDAT
; _this$ = ecx

; 81   :         float               GetLeafLightingAdjustment( )                            { return m_fLeafLightingAdjustmentScalar; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+112]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLeafLightingAdjustment@CLightingEngine@@QAEMXZ ENDP	; CLightingEngine::GetLeafLightingAdjustment
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?SetLeafLightingAdjustment@CLightingEngine@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fScalar$ = 8						; size = 4
?SetLeafLightingAdjustment@CLightingEngine@@QAEXM@Z PROC ; CLightingEngine::SetLeafLightingAdjustment, COMDAT
; _this$ = ecx

; 80   :         void                SetLeafLightingAdjustment(float fScalar)                { st_assert(fScalar > 0.0f); m_fLeafLightingAdjustmentScalar = fScalar; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movss	xmm0, DWORD PTR _fScalar$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN2@SetLeafLig
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DI@KINJKJPN@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	edi, esp
	push	80					; 00000050H
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@SetLeafLig:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fScalar$[ebp]
	movss	DWORD PTR [eax+112], xmm0
$LN1@SetLeafLig:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLeafLightingAdjustment@CLightingEngine@@QAEXM@Z ENDP ; CLightingEngine::SetLeafLightingAdjustment
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?SetFrondLightingMethod@CLightingEngine@@QAEXW4ELightingMethod@CSpeedTreeRT@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_eMethod$ = 8						; size = 4
?SetFrondLightingMethod@CLightingEngine@@QAEXW4ELightingMethod@CSpeedTreeRT@@@Z PROC ; CLightingEngine::SetFrondLightingMethod, COMDAT
; _this$ = ecx

; 76   :         void                SetFrondLightingMethod(LightMethod eMethod)             { m_eFrondLightingMethod = eMethod; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eMethod$[ebp]
	mov	DWORD PTR [eax+120], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFrondLightingMethod@CLightingEngine@@QAEXW4ELightingMethod@CSpeedTreeRT@@@Z ENDP ; CLightingEngine::SetFrondLightingMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?GetFrondLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetFrondLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ PROC ; CLightingEngine::GetFrondLightingMethod, COMDAT
; _this$ = ecx

; 75   :         LightMethod         GetFrondLightingMethod(void) const                      { return m_eFrondLightingMethod; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+120]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFrondLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ ENDP ; CLightingEngine::GetFrondLightingMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?SetStaticLightingStyle@CLightingEngine@@QAEXW4EStaticLightingStyle@CSpeedTreeRT@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_eStyle$ = 8						; size = 4
?SetStaticLightingStyle@CLightingEngine@@QAEXW4EStaticLightingStyle@CSpeedTreeRT@@@Z PROC ; CLightingEngine::SetStaticLightingStyle, COMDAT
; _this$ = ecx

; 74   :         void                SetStaticLightingStyle(StaticStyle eStyle)              { m_eStaticLightingStyle = eStyle; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eStyle$[ebp]
	mov	DWORD PTR [eax+116], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetStaticLightingStyle@CLightingEngine@@QAEXW4EStaticLightingStyle@CSpeedTreeRT@@@Z ENDP ; CLightingEngine::SetStaticLightingStyle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?GetStaticLightingStyle@CLightingEngine@@QBE?AW4EStaticLightingStyle@CSpeedTreeRT@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetStaticLightingStyle@CLightingEngine@@QBE?AW4EStaticLightingStyle@CSpeedTreeRT@@XZ PROC ; CLightingEngine::GetStaticLightingStyle, COMDAT
; _this$ = ecx

; 73   :         StaticStyle         GetStaticLightingStyle(void) const                      { return m_eStaticLightingStyle; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+116]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetStaticLightingStyle@CLightingEngine@@QBE?AW4EStaticLightingStyle@CSpeedTreeRT@@XZ ENDP ; CLightingEngine::GetStaticLightingStyle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?SetLeafLightingMethod@CLightingEngine@@QAEXW4ELightingMethod@CSpeedTreeRT@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_eMethod$ = 8						; size = 4
?SetLeafLightingMethod@CLightingEngine@@QAEXW4ELightingMethod@CSpeedTreeRT@@@Z PROC ; CLightingEngine::SetLeafLightingMethod, COMDAT
; _this$ = ecx

; 72   :         void                SetLeafLightingMethod(LightMethod eMethod)              { m_eLeafLightingMethod = eMethod; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eMethod$[ebp]
	mov	DWORD PTR [eax+56], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLeafLightingMethod@CLightingEngine@@QAEXW4ELightingMethod@CSpeedTreeRT@@@Z ENDP ; CLightingEngine::SetLeafLightingMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?GetLeafLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetLeafLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ PROC ; CLightingEngine::GetLeafLightingMethod, COMDAT
; _this$ = ecx

; 71   :         LightMethod         GetLeafLightingMethod(void) const                       { return m_eLeafLightingMethod; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+56]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLeafLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ ENDP ; CLightingEngine::GetLeafLightingMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?SetBranchLightingMethod@CLightingEngine@@QAEXW4ELightingMethod@CSpeedTreeRT@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_eMethod$ = 8						; size = 4
?SetBranchLightingMethod@CLightingEngine@@QAEXW4ELightingMethod@CSpeedTreeRT@@@Z PROC ; CLightingEngine::SetBranchLightingMethod, COMDAT
; _this$ = ecx

; 70   :         void                SetBranchLightingMethod(LightMethod eMethod)            { m_eBranchLightingMethod = eMethod; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eMethod$[ebp]
	mov	DWORD PTR [eax], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBranchLightingMethod@CLightingEngine@@QAEXW4ELightingMethod@CSpeedTreeRT@@@Z ENDP ; CLightingEngine::SetBranchLightingMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LightingEngine.h
;	COMDAT ?GetBranchLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetBranchLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ PROC ; CLightingEngine::GetBranchLightingMethod, COMDAT
; _this$ = ecx

; 69   :         LightMethod         GetBranchLightingMethod(void) const                     { return m_eBranchLightingMethod; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBranchLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ ENDP ; CLightingEngine::GetBranchLightingMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SimpleBillboard.h
;	COMDAT ?Validate@CSimpleBillboard@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Validate@CSimpleBillboard@@QAEXXZ PROC			; CSimpleBillboard::Validate, COMDAT
; _this$ = ecx

; 68   :         void            Validate(void)                              { m_bValid = true; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+48], 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Validate@CSimpleBillboard@@QAEXXZ ENDP			; CSimpleBillboard::Validate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SimpleBillboard.h
;	COMDAT ?IsValid@CSimpleBillboard@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?IsValid@CSimpleBillboard@@QBE_NXZ PROC			; CSimpleBillboard::IsValid, COMDAT
; _this$ = ecx

; 67   :         bool            IsValid(void) const                         { return m_bValid; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+48]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsValid@CSimpleBillboard@@QBE_NXZ ENDP			; CSimpleBillboard::IsValid
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SimpleBillboard.h
;	COMDAT ?Invalidate@CSimpleBillboard@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Invalidate@CSimpleBillboard@@QAEXXZ PROC		; CSimpleBillboard::Invalidate, COMDAT
; _this$ = ecx

; 66   :         void            Invalidate(void)                            { m_bValid = false; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+48], 0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Invalidate@CSimpleBillboard@@QAEXXZ ENDP		; CSimpleBillboard::Invalidate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SimpleBillboard.h
;	COMDAT ?GetBillboardCoords@CSimpleBillboard@@QAEPBMMM@Z
_TEXT	SEGMENT
_afScale$1 = -32					; size = 12
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_fWidth$ = 8						; size = 4
_fHeight$ = 12						; size = 4
?GetBillboardCoords@CSimpleBillboard@@QAEPBMMM@Z PROC	; CSimpleBillboard::GetBillboardCoords, COMDAT
; _this$ = ecx

; 38   :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 39   :             if (!IsValid( ))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValid@CSimpleBillboard@@QBE_NXZ	; CSimpleBillboard::IsValid
	movzx	eax, al
	test	eax, eax
	jne	$LN2@GetBillboa

; 40   :             {
; 41   : #ifdef UPVECTOR_POS_Y
; 42   :                 float afScale[3] = { fWidth, fHeight, fWidth };
; 43   : #else
; 44   :                 float afScale[3] = { fWidth, fWidth, fHeight };

	movss	xmm0, DWORD PTR _fWidth$[ebp]
	movss	DWORD PTR _afScale$1[ebp], xmm0
	movss	xmm0, DWORD PTR _fWidth$[ebp]
	movss	DWORD PTR _afScale$1[ebp+4], xmm0
	movss	xmm0, DWORD PTR _fHeight$[ebp]
	movss	DWORD PTR _afScale$1[ebp+8], xmm0

; 45   : #endif
; 46   : 
; 47   :                 m_acTreeBillboard[0] = afScale[0] * m_acUnitBillboard[0][0];

	mov	eax, 4
	imul	esi, eax, 0
	push	0
	mov	ecx, 12					; 0000000cH
	imul	ecx, ecx, 0
	add	ecx, OFFSET ?m_acUnitBillboard@CSimpleBillboard@@0PAVCVec3@@A ; CSimpleBillboard::m_acUnitBillboard
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	movss	xmm0, DWORD PTR _afScale$1[ebp+esi]
	mulss	xmm0, DWORD PTR [eax]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 48   :                 m_acTreeBillboard[1] = afScale[1] * m_acUnitBillboard[0][1];

	mov	esi, 4
	shl	esi, 0
	push	1
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, OFFSET ?m_acUnitBillboard@CSimpleBillboard@@0PAVCVec3@@A ; CSimpleBillboard::m_acUnitBillboard
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	movss	xmm0, DWORD PTR _afScale$1[ebp+esi]
	mulss	xmm0, DWORD PTR [eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 49   :                 m_acTreeBillboard[2] = afScale[2] * m_acUnitBillboard[0][2];

	mov	esi, 4
	shl	esi, 1
	push	2
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, OFFSET ?m_acUnitBillboard@CSimpleBillboard@@0PAVCVec3@@A ; CSimpleBillboard::m_acUnitBillboard
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	movss	xmm0, DWORD PTR _afScale$1[ebp+esi]
	mulss	xmm0, DWORD PTR [eax]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 50   :                 m_acTreeBillboard[3] = afScale[0] * m_acUnitBillboard[1][0];

	mov	eax, 4
	imul	esi, eax, 0
	push	0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, OFFSET ?m_acUnitBillboard@CSimpleBillboard@@0PAVCVec3@@A ; CSimpleBillboard::m_acUnitBillboard
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	movss	xmm0, DWORD PTR _afScale$1[ebp+esi]
	mulss	xmm0, DWORD PTR [eax]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 51   :                 m_acTreeBillboard[4] = afScale[1] * m_acUnitBillboard[1][1];

	mov	esi, 4
	shl	esi, 0
	push	1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, OFFSET ?m_acUnitBillboard@CSimpleBillboard@@0PAVCVec3@@A ; CSimpleBillboard::m_acUnitBillboard
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	movss	xmm0, DWORD PTR _afScale$1[ebp+esi]
	mulss	xmm0, DWORD PTR [eax]
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 52   :                 m_acTreeBillboard[5] = afScale[2] * m_acUnitBillboard[1][2];

	mov	esi, 4
	shl	esi, 1
	push	2
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, OFFSET ?m_acUnitBillboard@CSimpleBillboard@@0PAVCVec3@@A ; CSimpleBillboard::m_acUnitBillboard
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	movss	xmm0, DWORD PTR _afScale$1[ebp+esi]
	mulss	xmm0, DWORD PTR [eax]
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 53   :                 m_acTreeBillboard[6] = afScale[0] * m_acUnitBillboard[2][0];

	mov	eax, 4
	imul	esi, eax, 0
	push	0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, OFFSET ?m_acUnitBillboard@CSimpleBillboard@@0PAVCVec3@@A ; CSimpleBillboard::m_acUnitBillboard
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	movss	xmm0, DWORD PTR _afScale$1[ebp+esi]
	mulss	xmm0, DWORD PTR [eax]
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 54   :                 m_acTreeBillboard[7] = afScale[1] * m_acUnitBillboard[2][1];

	mov	esi, 4
	shl	esi, 0
	push	1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, OFFSET ?m_acUnitBillboard@CSimpleBillboard@@0PAVCVec3@@A ; CSimpleBillboard::m_acUnitBillboard
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	movss	xmm0, DWORD PTR _afScale$1[ebp+esi]
	mulss	xmm0, DWORD PTR [eax]
	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 55   :                 m_acTreeBillboard[8] = afScale[2] * m_acUnitBillboard[2][2];

	mov	esi, 4
	shl	esi, 1
	push	2
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, OFFSET ?m_acUnitBillboard@CSimpleBillboard@@0PAVCVec3@@A ; CSimpleBillboard::m_acUnitBillboard
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	movss	xmm0, DWORD PTR _afScale$1[ebp+esi]
	mulss	xmm0, DWORD PTR [eax]
	mov	eax, 4
	shl	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 56   :                 m_acTreeBillboard[9] = afScale[0] * m_acUnitBillboard[3][0];

	mov	eax, 4
	imul	esi, eax, 0
	push	0
	mov	ecx, 12					; 0000000cH
	imul	ecx, ecx, 3
	add	ecx, OFFSET ?m_acUnitBillboard@CSimpleBillboard@@0PAVCVec3@@A ; CSimpleBillboard::m_acUnitBillboard
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	movss	xmm0, DWORD PTR _afScale$1[ebp+esi]
	mulss	xmm0, DWORD PTR [eax]
	mov	edx, 4
	imul	eax, edx, 9
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 57   :                 m_acTreeBillboard[10] = afScale[1] * m_acUnitBillboard[3][1];

	mov	esi, 4
	shl	esi, 0
	push	1
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	add	ecx, OFFSET ?m_acUnitBillboard@CSimpleBillboard@@0PAVCVec3@@A ; CSimpleBillboard::m_acUnitBillboard
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	movss	xmm0, DWORD PTR _afScale$1[ebp+esi]
	mulss	xmm0, DWORD PTR [eax]
	mov	ecx, 4
	imul	edx, ecx, 10
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 58   :                 m_acTreeBillboard[11] = afScale[2] * m_acUnitBillboard[3][2];

	mov	esi, 4
	shl	esi, 1
	push	2
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	add	ecx, OFFSET ?m_acUnitBillboard@CSimpleBillboard@@0PAVCVec3@@A ; CSimpleBillboard::m_acUnitBillboard
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	movss	xmm0, DWORD PTR _afScale$1[ebp+esi]
	mulss	xmm0, DWORD PTR [eax]
	mov	ecx, 4
	imul	edx, ecx, 11
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 59   : 
; 60   :                 Validate( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Validate@CSimpleBillboard@@QAEXXZ	; CSimpleBillboard::Validate
	npad	1
$LN2@GetBillboa:

; 61   :             }
; 62   :             
; 63   :             return m_acTreeBillboard;

	mov	eax, DWORD PTR _this$[ebp]

; 64   :         }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetBillboa
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN6@GetBillboa:
	DD	1
	DD	$LN5@GetBillboa
$LN5@GetBillboa:
	DD	-32					; ffffffe0H
	DD	12					; 0000000cH
	DD	$LN4@GetBillboa
$LN4@GetBillboa:
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	83					; 00000053H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
?GetBillboardCoords@CSimpleBillboard@@QAEPBMMM@Z ENDP	; CSimpleBillboard::GetBillboardCoords
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\UpVector.h
;	COMDAT ?ComputeAzimuth@@YAMPBM@Z
_TEXT	SEGMENT
_cAdjustedDirection$ = -20				; size = 12
__$ArrayPad$ = -4					; size = 4
_pCameraDir$ = 8					; size = 4
?ComputeAzimuth@@YAMPBM@Z PROC				; ComputeAzimuth, COMDAT

; 139  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 140  :     // find the angle that point is on
; 141  :     CVec3 cAdjustedDirection;

	lea	ecx, DWORD PTR _cAdjustedDirection$[ebp]
	call	??0CVec3@@QAE@XZ			; CVec3::CVec3
	npad	1

; 142  :     Assign3d(cAdjustedDirection, pCameraDir);

	mov	eax, DWORD PTR _pCameraDir$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cAdjustedDirection$[ebp]
	call	??BCVec3@@QAEPAMXZ			; CVec3::operator float *
	push	eax
	call	?Assign3d@@YAXPAMPBM@Z			; Assign3d
	add	esp, 8

; 143  : 
; 144  :     return VecRad2Deg(atan2f(cAdjustedDirection[1], cAdjustedDirection[0]));

	push	0
	lea	ecx, DWORD PTR _cAdjustedDirection$[ebp]
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	push	1
	lea	ecx, DWORD PTR _cAdjustedDirection$[ebp]
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	call	_atan2f
	add	esp, 4
	fstp	DWORD PTR [esp]
	call	?VecRad2Deg@@YAMM@Z			; VecRad2Deg
	add	esp, 4

; 145  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@ComputeAzi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@ComputeAzi:
	DD	1
	DD	$LN4@ComputeAzi
$LN4@ComputeAzi:
	DD	-20					; ffffffecH
	DD	12					; 0000000cH
	DD	$LN3@ComputeAzi
$LN3@ComputeAzi:
	DB	99					; 00000063H
	DB	65					; 00000041H
	DB	100					; 00000064H
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
?ComputeAzimuth@@YAMPBM@Z ENDP				; ComputeAzimuth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\UpVector.h
;	COMDAT ?Assign3d@@YAXPAMPBM@Z
_TEXT	SEGMENT
_pDest$ = 8						; size = 4
_pSource$ = 12						; size = 4
?Assign3d@@YAXPAMPBM@Z PROC				; Assign3d, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 50   :     pDest[0] = pSource[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pDest$[ebp]
	mov	esi, DWORD PTR _pSource$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx

; 51   :     pDest[1] = pSource[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pDest$[ebp]
	mov	esi, DWORD PTR _pSource$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 52   :     pDest[2] = pSource[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pDest$[ebp]
	mov	esi, DWORD PTR _pSource$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Assign3d@@YAXPAMPBM@Z ENDP				; Assign3d
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?GetSpeedWindRustleScalar@CWindEngine@@QBEMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSpeedWindRustleScalar@CWindEngine@@QBEMXZ PROC	; CWindEngine::GetSpeedWindRustleScalar, COMDAT
; _this$ = ecx

; 129  :         float                       GetSpeedWindRustleScalar(void) const                { return m_fSpeedWindRustleScalar; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+64]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSpeedWindRustleScalar@CWindEngine@@QBEMXZ ENDP	; CWindEngine::GetSpeedWindRustleScalar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?SetSpeedWindRustleScalar@CWindEngine@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fRustleScalar$ = 8					; size = 4
?SetSpeedWindRustleScalar@CWindEngine@@QAEXM@Z PROC	; CWindEngine::SetSpeedWindRustleScalar, COMDAT
; _this$ = ecx

; 128  :         void                        SetSpeedWindRustleScalar(float fRustleScalar)       { m_fSpeedWindRustleScalar = fRustleScalar; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fRustleScalar$[ebp]
	movss	DWORD PTR [eax+64], xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSpeedWindRustleScalar@CWindEngine@@QAEXM@Z ENDP	; CWindEngine::SetSpeedWindRustleScalar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?GetSpeedWindRockScalar@CWindEngine@@QBEMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSpeedWindRockScalar@CWindEngine@@QBEMXZ PROC	; CWindEngine::GetSpeedWindRockScalar, COMDAT
; _this$ = ecx

; 127  :         float                       GetSpeedWindRockScalar(void) const                  { return m_fSpeedWindRockScalar; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSpeedWindRockScalar@CWindEngine@@QBEMXZ ENDP	; CWindEngine::GetSpeedWindRockScalar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?SetSpeedWindRockScalar@CWindEngine@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fRockScalar$ = 8					; size = 4
?SetSpeedWindRockScalar@CWindEngine@@QAEXM@Z PROC	; CWindEngine::SetSpeedWindRockScalar, COMDAT
; _this$ = ecx

; 126  :         void                        SetSpeedWindRockScalar(float fRockScalar)           { m_fSpeedWindRockScalar = fRockScalar; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fRockScalar$[ebp]
	movss	DWORD PTR [eax+60], xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSpeedWindRockScalar@CWindEngine@@QAEXM@Z ENDP	; CWindEngine::SetSpeedWindRockScalar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?GetLocalMatrices@CWindEngine@@QAEXAAI0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nStartingMatrix$ = 8					; size = 4
_nMatrixSpan$ = 12					; size = 4
?GetLocalMatrices@CWindEngine@@QAEXAAI0@Z PROC		; CWindEngine::GetLocalMatrices, COMDAT
; _this$ = ecx

; 116  :         void                        GetLocalMatrices(unsigned int& nStartingMatrix, unsigned int& nMatrixSpan) { nStartingMatrix = m_nStartingMatrix; nMatrixSpan = m_nMatrixSpan; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _nStartingMatrix$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _nMatrixSpan$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax], edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetLocalMatrices@CWindEngine@@QAEXAAI0@Z ENDP		; CWindEngine::GetLocalMatrices
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?SetWindMatrix@CWindEngine@@SAXGPBM@Z
_TEXT	SEGMENT
_nMatrixIndex$ = 8					; size = 2
_pMatrix$ = 12						; size = 4
?SetWindMatrix@CWindEngine@@SAXGPBM@Z PROC		; CWindEngine::SetWindMatrix, COMDAT

; 115  : static  void                        SetWindMatrix(unsigned short nMatrixIndex, const float* pMatrix) { m_cWindMatrices.SetMatrix(nMatrixIndex, pMatrix); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _pMatrix$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nMatrixIndex$[ebp]
	push	ecx
	mov	ecx, OFFSET ?m_cWindMatrices@CWindEngine@@0VCWindMatrices@@A ; CWindEngine::m_cWindMatrices
	call	?SetMatrix@CWindMatrices@@QAEXGPBM@Z	; CWindMatrices::SetMatrix
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?SetWindMatrix@CWindEngine@@SAXGPBM@Z ENDP		; CWindEngine::SetWindMatrix
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?SetNumWindMatrices@CWindEngine@@SAXG@Z
_TEXT	SEGMENT
_usNumMatrices$ = 8					; size = 2
?SetNumWindMatrices@CWindEngine@@SAXG@Z PROC		; CWindEngine::SetNumWindMatrices, COMDAT

; 113  : static  void                        SetNumWindMatrices(unsigned short usNumMatrices)    { m_cWindMatrices.Resize(usNumMatrices); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	eax, WORD PTR _usNumMatrices$[ebp]
	push	eax
	mov	ecx, OFFSET ?m_cWindMatrices@CWindEngine@@0VCWindMatrices@@A ; CWindEngine::m_cWindMatrices
	call	?Resize@CWindMatrices@@QAEXG@Z		; CWindMatrices::Resize
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?SetNumWindMatrices@CWindEngine@@SAXG@Z ENDP		; CWindEngine::SetNumWindMatrices
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?GetNumWindMatrices@CWindEngine@@SAIXZ
_TEXT	SEGMENT
?GetNumWindMatrices@CWindEngine@@SAIXZ PROC		; CWindEngine::GetNumWindMatrices, COMDAT

; 112  : static  unsigned int                GetNumWindMatrices(void)                            { return m_cWindMatrices.GetSize( ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?m_cWindMatrices@CWindEngine@@0VCWindMatrices@@A ; CWindEngine::m_cWindMatrices
	call	?GetSize@CWindMatrices@@QBEGXZ		; CWindMatrices::GetSize
	movzx	eax, ax
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumWindMatrices@CWindEngine@@SAIXZ ENDP		; CWindEngine::GetNumWindMatrices
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?SetLeafRockingState@CWindEngine@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_bFlag$ = 8						; size = 1
?SetLeafRockingState@CWindEngine@@QAEX_N@Z PROC		; CWindEngine::SetLeafRockingState, COMDAT
; _this$ = ecx

; 108  :         void                        SetLeafRockingState(bool bFlag)             { m_bRockingLeaves = bFlag; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bFlag$[ebp]
	mov	BYTE PTR [eax+20], cl
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLeafRockingState@CWindEngine@@QAEX_N@Z ENDP		; CWindEngine::SetLeafRockingState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?GetLeafRockingState@CWindEngine@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetLeafRockingState@CWindEngine@@QBE_NXZ PROC		; CWindEngine::GetLeafRockingState, COMDAT
; _this$ = ecx

; 107  :         bool                        GetLeafRockingState(void) const             { return m_bRockingLeaves; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+20]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLeafRockingState@CWindEngine@@QBE_NXZ ENDP		; CWindEngine::GetLeafRockingState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?SetLeafWindMethod@CWindEngine@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_eMethod$ = 8						; size = 4
?SetLeafWindMethod@CWindEngine@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z PROC ; CWindEngine::SetLeafWindMethod, COMDAT
; _this$ = ecx

; 106  :         void                        SetLeafWindMethod(CSpeedTreeRT::EWindMethod eMethod)    { m_eLeafMethod = eMethod; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eMethod$[ebp]
	mov	DWORD PTR [eax+16], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLeafWindMethod@CWindEngine@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z ENDP ; CWindEngine::SetLeafWindMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?GetLeafWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetLeafWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ PROC ; CWindEngine::GetLeafWindMethod, COMDAT
; _this$ = ecx

; 105  :         CSpeedTreeRT::EWindMethod   GetLeafWindMethod(void) const               { return m_eLeafMethod; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLeafWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ ENDP ; CWindEngine::GetLeafWindMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?SetFrondWindMethod@CWindEngine@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_eMethod$ = 8						; size = 4
?SetFrondWindMethod@CWindEngine@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z PROC ; CWindEngine::SetFrondWindMethod, COMDAT
; _this$ = ecx

; 102  :         void                        SetFrondWindMethod(CSpeedTreeRT::EWindMethod eMethod)  { m_eFrondMethod = eMethod; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eMethod$[ebp]
	mov	DWORD PTR [eax+12], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFrondWindMethod@CWindEngine@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z ENDP ; CWindEngine::SetFrondWindMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?GetFrondWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetFrondWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ PROC ; CWindEngine::GetFrondWindMethod, COMDAT
; _this$ = ecx

; 101  :         CSpeedTreeRT::EWindMethod   GetFrondWindMethod(void) const             { return m_eFrondMethod; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFrondWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ ENDP ; CWindEngine::GetFrondWindMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?SetBranchWindMethod@CWindEngine@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_eMethod$ = 8						; size = 4
?SetBranchWindMethod@CWindEngine@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z PROC ; CWindEngine::SetBranchWindMethod, COMDAT
; _this$ = ecx

; 98   :         void                        SetBranchWindMethod(CSpeedTreeRT::EWindMethod eMethod)  { m_eBranchMethod = eMethod; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eMethod$[ebp]
	mov	DWORD PTR [eax+8], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBranchWindMethod@CWindEngine@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z ENDP ; CWindEngine::SetBranchWindMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?GetBranchWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetBranchWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ PROC ; CWindEngine::GetBranchWindMethod, COMDAT
; _this$ = ecx

; 97   :         CSpeedTreeRT::EWindMethod   GetBranchWindMethod(void) const             { return m_eBranchMethod; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBranchWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ ENDP ; CWindEngine::GetBranchWindMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?GetFrequencyTimeShift@CWindEngine@@QBEMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetFrequencyTimeShift@CWindEngine@@QBEMXZ PROC		; CWindEngine::GetFrequencyTimeShift, COMDAT
; _this$ = ecx

; 94   :         float                       GetFrequencyTimeShift(void) const           { return m_fTimeFrequencyShift; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFrequencyTimeShift@CWindEngine@@QBEMXZ ENDP		; CWindEngine::GetFrequencyTimeShift
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?SetTime@CWindEngine@@SAXM@Z
_TEXT	SEGMENT
_fTime$ = 8						; size = 4
?SetTime@CWindEngine@@SAXM@Z PROC			; CWindEngine::SetTime, COMDAT

; 92   : static  void                        SetTime(float fTime)                        { m_fTime = fTime; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	movss	xmm0, DWORD PTR _fTime$[ebp]
	movss	DWORD PTR ?m_fTime@CWindEngine@@0MA, xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetTime@CWindEngine@@SAXM@Z ENDP			; CWindEngine::SetTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?GetWindStrength@CWindEngine@@QBEMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetWindStrength@CWindEngine@@QBEMXZ PROC		; CWindEngine::GetWindStrength, COMDAT
; _this$ = ecx

; 87   :         float                       GetWindStrength(void) const                 { return m_fWindStrength; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWindStrength@CWindEngine@@QBEMXZ ENDP		; CWindEngine::GetWindStrength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?SetMatrix@CWindMatrices@@QAEXGPBM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_usIndex$ = 8						; size = 2
_pMatrix$ = 12						; size = 4
?SetMatrix@CWindMatrices@@QAEXGPBM@Z PROC		; CWindMatrices::SetMatrix, COMDAT
; _this$ = ecx

; 67   :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 68   :             st_assert(usIndex < m_usNumMatrices);

	movzx	eax, WORD PTR _usIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx]
	cmp	eax, edx
	jl	SHORT $LN2@SetMatrix
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DE@PACCNLEK@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	edi, esp
	push	68					; 00000044H
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@SetMatrix:

; 69   :             memcpy(m_pMatrices[usIndex].m_afData, pMatrix, 16 * sizeof(float));

	push	64					; 00000040H
	mov	eax, DWORD PTR _pMatrix$[ebp]
	push	eax
	movzx	ecx, WORD PTR _usIndex$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@SetMatrix:

; 70   :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetMatrix@CWindMatrices@@QAEXGPBM@Z ENDP		; CWindMatrices::SetMatrix
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?Resize@CWindMatrices@@QAEXG@Z
_TEXT	SEGMENT
tv94 = -280						; size = 4
$T2 = -272						; size = 4
$T3 = -260						; size = 4
$T4 = -248						; size = 4
$T5 = -236						; size = 4
_i$6 = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_usCount$ = 8						; size = 2
?Resize@CWindMatrices@@QAEXG@Z PROC			; CWindMatrices::Resize, COMDAT
; _this$ = ecx

; 58   :         {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Resize@CWindMatrices@@QAEXG@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-88]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 59   :             delete[] m_pMatrices;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T5[ebp], ecx
	mov	edx, DWORD PTR $T5[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 60   :             m_usNumMatrices = usCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _usCount$[ebp]
	mov	WORD PTR [eax], cx

; 61   :             m_pMatrices = new CTransform[usCount];

	movzx	eax, WORD PTR _usCount$[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	eax, DWORD PTR $T4[ebp]
	mov	ecx, 64					; 00000040H
	mul	ecx
	mov	edx, -1
	cmovb	eax, edx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN6@Resize
	push	OFFSET ??0CTransform@@QAE@XZ		; CTransform::CTransform
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	push	64					; 00000040H
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??_H@YGXPAXIIP6EPAX0@Z@Z
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR tv94[ebp], edx
	jmp	SHORT $LN7@Resize
$LN6@Resize:
	mov	DWORD PTR tv94[ebp], 0
$LN7@Resize:
	mov	eax, DWORD PTR tv94[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx+4], edx

; 62   : 
; 63   :             for (int i = 0; i < usCount; ++i)

	mov	DWORD PTR _i$6[ebp], 0
	jmp	SHORT $LN4@Resize
$LN2@Resize:
	mov	eax, DWORD PTR _i$6[ebp]
	add	eax, 1
	mov	DWORD PTR _i$6[ebp], eax
$LN4@Resize:
	movzx	eax, WORD PTR _usCount$[ebp]
	cmp	DWORD PTR _i$6[ebp], eax
	jge	SHORT $LN3@Resize

; 64   :                 m_pMatrices[i].LoadIdentity( );

	mov	ecx, DWORD PTR _i$6[ebp]
	shl	ecx, 6
	mov	eax, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?LoadIdentity@CTransform@@QAEXXZ	; CTransform::LoadIdentity
	npad	1
	jmp	SHORT $LN2@Resize
$LN3@Resize:

; 65   :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Resize@CWindMatrices@@QAEXG@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	mov	ecx, 64					; 00000040H
	mul	ecx
	mov	ecx, eax
	mov	eax, -1
	cmovb	ecx, eax
	push	ecx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?Resize@CWindMatrices@@QAEXG@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Resize@CWindMatrices@@QAEXG@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Resize@CWindMatrices@@QAEXG@Z ENDP			; CWindMatrices::Resize
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\WindEngine.h
;	COMDAT ?GetSize@CWindMatrices@@QBEGXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSize@CWindMatrices@@QBEGXZ PROC			; CWindMatrices::GetSize, COMDAT
; _this$ = ecx

; 56   :         unsigned short  GetSize(void) const                     { return m_usNumMatrices; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@CWindMatrices@@QBEGXZ ENDP			; CWindMatrices::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?GetNumBranchLodLevels@CTreeEngine@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetNumBranchLodLevels@CTreeEngine@@QBEIXZ PROC		; CTreeEngine::GetNumBranchLodLevels, COMDAT
; _this$ = ecx

; 222  :         unsigned int                GetNumBranchLodLevels(void) const               { return m_nNumBranchLodLevels; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumBranchLodLevels@CTreeEngine@@QBEIXZ ENDP		; CTreeEngine::GetNumBranchLodLevels
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?GetNumLeafLodLevels@CTreeEngine@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetNumLeafLodLevels@CTreeEngine@@QBEHXZ PROC		; CTreeEngine::GetNumLeafLodLevels, COMDAT
; _this$ = ecx

; 220  :         int                         GetNumLeafLodLevels(void) const                 { return m_sLeafInfo.m_nNumLeafLodLevels; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+180]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumLeafLodLevels@CTreeEngine@@QBEHXZ ENDP		; CTreeEngine::GetNumLeafLodLevels
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?GetLod@CTreeEngine@@QBEMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetLod@CTreeEngine@@QBEMXZ PROC			; CTreeEngine::GetLod, COMDAT
; _this$ = ecx

; 216  :         float                       GetLod(void) const                              { return m_fLod; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+20]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLod@CTreeEngine@@QBEMXZ ENDP			; CTreeEngine::GetLod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?SetLod@CTreeEngine@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fLod$ = 8						; size = 4
?SetLod@CTreeEngine@@QAEXM@Z PROC			; CTreeEngine::SetLod, COMDAT
; _this$ = ecx

; 215  :         void                        SetLod(float fLod)                              { m_fLod = fLod; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fLod$[ebp]
	movss	DWORD PTR [eax+20], xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLod@CTreeEngine@@QAEXM@Z ENDP			; CTreeEngine::SetLod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?GetSeed@CTreeEngine@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSeed@CTreeEngine@@QBEHXZ PROC			; CTreeEngine::GetSeed, COMDAT
; _this$ = ecx

; 207  :         int                         GetSeed(void) const                             { return m_sTreeInfo.m_nSeed; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+72]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSeed@CTreeEngine@@QBEHXZ ENDP			; CTreeEngine::GetSeed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?GetBranchTextureFilename@CTreeEngine@@QBEABVCIdvFilename@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetBranchTextureFilename@CTreeEngine@@QBEABVCIdvFilename@@XZ PROC ; CTreeEngine::GetBranchTextureFilename, COMDAT
; _this$ = ecx

; 206  :         const CIdvFilename&         GetBranchTextureFilename(void) const            { return m_sTreeInfo.m_strBranchTextureFilename; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBranchTextureFilename@CTreeEngine@@QBEABVCIdvFilename@@XZ ENDP ; CTreeEngine::GetBranchTextureFilename
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?GetBranchLevelForWeighting@CTreeEngine@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetBranchLevelForWeighting@CTreeEngine@@QAEHXZ PROC	; CTreeEngine::GetBranchLevelForWeighting, COMDAT
; _this$ = ecx

; 199  :         int                         GetBranchLevelForWeighting( )                   { return m_nBranchesWeightLevel; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+228]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBranchLevelForWeighting@CTreeEngine@@QAEHXZ ENDP	; CTreeEngine::GetBranchLevelForWeighting
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?SetBranchLevelForWeighting@CTreeEngine@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nLevel$ = 8						; size = 4
?SetBranchLevelForWeighting@CTreeEngine@@QAEXH@Z PROC	; CTreeEngine::SetBranchLevelForWeighting, COMDAT
; _this$ = ecx

; 198  :         void                        SetBranchLevelForWeighting(int nLevel)          { m_nBranchesWeightLevel = nLevel; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nLevel$[ebp]
	mov	DWORD PTR [eax+228], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBranchLevelForWeighting@CTreeEngine@@QAEXH@Z ENDP	; CTreeEngine::SetBranchLevelForWeighting
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?GetWindData@CTreeEngine@@QBEABUSIdvWindInfo@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetWindData@CTreeEngine@@QBEABUSIdvWindInfo@@XZ PROC	; CTreeEngine::GetWindData, COMDAT
; _this$ = ecx

; 197  :         const SIdvWindInfo&         GetWindData(void) const                         { return m_sWindInfo; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 232				; 000000e8H
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWindData@CTreeEngine@@QBEABUSIdvWindInfo@@XZ ENDP	; CTreeEngine::GetWindData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?SetNumLeafRockingGroups@CTreeEngine@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nCount$ = 8						; size = 4
?SetNumLeafRockingGroups@CTreeEngine@@QAEXH@Z PROC	; CTreeEngine::SetNumLeafRockingGroups, COMDAT
; _this$ = ecx

; 194  :         void                        SetNumLeafRockingGroups(int nCount)             { m_sLeafInfo.m_nNumRockingGroups = nCount; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nCount$[ebp]
	mov	DWORD PTR [eax+176], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetNumLeafRockingGroups@CTreeEngine@@QAEXH@Z ENDP	; CTreeEngine::SetNumLeafRockingGroups
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?InitTables@CTreeEngine@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?InitTables@CTreeEngine@@QAEXXZ PROC			; CTreeEngine::InitTables, COMDAT
; _this$ = ecx

; 193  :         void                        InitTables( )                                   { m_sLeafInfo.InitTables(m_sLeafInfo.m_vLeafTextures.size( )); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	call	?size@?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@QBEIXZ ; std::vector<SIdvLeafTexture,std::allocator<SIdvLeafTexture> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?InitTables@SIdvLeafInfo@@QAEXH@Z	; SIdvLeafInfo::InitTables
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?InitTables@CTreeEngine@@QAEXXZ ENDP			; CTreeEngine::InitTables
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?GetLeafTextures@CTreeEngine@@QBEABV?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetLeafTextures@CTreeEngine@@QBEABV?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@XZ PROC ; CTreeEngine::GetLeafTextures, COMDAT
; _this$ = ecx

; 192  :         const vector<SIdvLeafTexture>& GetLeafTextures(void) const                  { return m_sLeafInfo.m_vLeafTextures; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLeafTextures@CTreeEngine@@QBEABV?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@XZ ENDP ; CTreeEngine::GetLeafTextures
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?GetLeafInfo@CTreeEngine@@QBEABUSIdvLeafInfo@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetLeafInfo@CTreeEngine@@QBEABUSIdvLeafInfo@@XZ PROC	; CTreeEngine::GetLeafInfo, COMDAT
; _this$ = ecx

; 191  :         const SIdvLeafInfo&         GetLeafInfo(void) const                         { return m_sLeafInfo; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 132				; 00000084H
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLeafInfo@CTreeEngine@@QBEABUSIdvLeafInfo@@XZ ENDP	; CTreeEngine::GetLeafInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?GetAllLeaves@CTreeEngine@@QBEPAV?$vector@PAVCBillboardLeaf@@V?$allocator@PAVCBillboardLeaf@@@std@@@std@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetAllLeaves@CTreeEngine@@QBEPAV?$vector@PAVCBillboardLeaf@@V?$allocator@PAVCBillboardLeaf@@@std@@@std@@XZ PROC ; CTreeEngine::GetAllLeaves, COMDAT
; _this$ = ecx

; 190  :         vector<CBillboardLeaf*>*    GetAllLeaves(void) const                        { return m_vLeafLods; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+200]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAllLeaves@CTreeEngine@@QBEPAV?$vector@PAVCBillboardLeaf@@V?$allocator@PAVCBillboardLeaf@@@std@@@std@@XZ ENDP ; CTreeEngine::GetAllLeaves
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?TransientDataIntact@CTreeEngine@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?TransientDataIntact@CTreeEngine@@QBE_NXZ PROC		; CTreeEngine::TransientDataIntact, COMDAT
; _this$ = ecx

; 187  :         bool                        TransientDataIntact(void) const                 { return m_bTransientDataIntact; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+33]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransientDataIntact@CTreeEngine@@QBE_NXZ ENDP		; CTreeEngine::TransientDataIntact
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?GetPropagateFlexibility@CIdvBranch@@SA_NXZ
_TEXT	SEGMENT
?GetPropagateFlexibility@CIdvBranch@@SA_NXZ PROC	; CIdvBranch::GetPropagateFlexibility, COMDAT

; 109  : static  bool                        GetPropagateFlexibility( )                              { return m_bPropagateFlexibility; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	movzx	eax, BYTE PTR ?m_bPropagateFlexibility@CIdvBranch@@0_NA ; CIdvBranch::m_bPropagateFlexibility
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPropagateFlexibility@CIdvBranch@@SA_NXZ ENDP	; CIdvBranch::GetPropagateFlexibility
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?SetPropagateFlexibility@CIdvBranch@@SAX_N@Z
_TEXT	SEGMENT
_bState$ = 8						; size = 1
?SetPropagateFlexibility@CIdvBranch@@SAX_N@Z PROC	; CIdvBranch::SetPropagateFlexibility, COMDAT

; 108  : static  void                        SetPropagateFlexibility(bool bState)                    { m_bPropagateFlexibility = bState; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	movzx	eax, BYTE PTR _bState$[ebp]
	mov	BYTE PTR ?m_bPropagateFlexibility@CIdvBranch@@0_NA, al ; CIdvBranch::m_bPropagateFlexibility
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetPropagateFlexibility@CIdvBranch@@SAX_N@Z ENDP	; CIdvBranch::SetPropagateFlexibility
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?SetFrondEngine@CIdvBranch@@SAXPAVCFrondEngine@@@Z
_TEXT	SEGMENT
_pFrondEngine$ = 8					; size = 4
?SetFrondEngine@CIdvBranch@@SAXPAVCFrondEngine@@@Z PROC	; CIdvBranch::SetFrondEngine, COMDAT

; 106  : static  void                        SetFrondEngine(CFrondEngine* pFrondEngine)              { m_pFrondEngine = pFrondEngine; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pFrondEngine$[ebp]
	mov	DWORD PTR ?m_pFrondEngine@CIdvBranch@@0PAVCFrondEngine@@A, eax ; CIdvBranch::m_pFrondEngine
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetFrondEngine@CIdvBranch@@SAXPAVCFrondEngine@@@Z ENDP	; CIdvBranch::SetFrondEngine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?SetLightingEngine@CIdvBranch@@SAXPAVCLightingEngine@@@Z
_TEXT	SEGMENT
_pLightingEngine$ = 8					; size = 4
?SetLightingEngine@CIdvBranch@@SAXPAVCLightingEngine@@@Z PROC ; CIdvBranch::SetLightingEngine, COMDAT

; 105  : static  void                        SetLightingEngine(CLightingEngine* pLightingEngine)     { m_pLightingEngine = pLightingEngine; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pLightingEngine$[ebp]
	mov	DWORD PTR ?m_pLightingEngine@CIdvBranch@@0PAVCLightingEngine@@A, eax ; CIdvBranch::m_pLightingEngine
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetLightingEngine@CIdvBranch@@SAXPAVCLightingEngine@@@Z ENDP ; CIdvBranch::SetLightingEngine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?SetPosition@CIdvCamera@@QAEXABVCVec3@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cPosition$ = 8						; size = 4
?SetPosition@CIdvCamera@@QAEXABVCVec3@@@Z PROC		; CIdvCamera::SetPosition, COMDAT
; _this$ = ecx

; 62   :         void                    SetPosition(const CVec3& cPosition)                         { m_cPosition = cPosition; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _cPosition$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetPosition@CIdvCamera@@QAEXABVCVec3@@@Z ENDP		; CIdvCamera::SetPosition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?GetPosition@CIdvCamera@@QBEABVCVec3@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetPosition@CIdvCamera@@QBEABVCVec3@@XZ PROC		; CIdvCamera::GetPosition, COMDAT
; _this$ = ecx

; 61   :         const CVec3&            GetPosition(void) const                                     { return m_cPosition; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPosition@CIdvCamera@@QBEABVCVec3@@XZ ENDP		; CIdvCamera::GetPosition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?GetCamera@CIdvCamera@@SAXAAVCVec3@@0@Z
_TEXT	SEGMENT
_cCameraPos$ = 8					; size = 4
_cCameraDir$ = 12					; size = 4
?GetCamera@CIdvCamera@@SAXAAVCVec3@@0@Z PROC		; CIdvCamera::GetCamera, COMDAT

; 59   : static  void                    GetCamera(CVec3& cCameraPos, CVec3& cCameraDir)             { cCameraPos = m_cCameraPos; cCameraDir = m_cCameraDir; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _cCameraPos$[ebp]
	mov	ecx, DWORD PTR ?m_cCameraPos@CIdvCamera@@1VCVec3@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?m_cCameraPos@CIdvCamera@@1VCVec3@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR ?m_cCameraPos@CIdvCamera@@1VCVec3@@A+8
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR _cCameraDir$[ebp]
	mov	ecx, DWORD PTR ?m_cCameraDir@CIdvCamera@@1VCVec3@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?m_cCameraDir@CIdvCamera@@1VCVec3@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR ?m_cCameraDir@CIdvCamera@@1VCVec3@@A+8
	mov	DWORD PTR [eax+8], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCamera@CIdvCamera@@SAXAAVCVec3@@0@Z ENDP		; CIdvCamera::GetCamera
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\TreeEngine.h
;	COMDAT ?SetCamera@CIdvCamera@@SAXABVCVec3@@0@Z
_TEXT	SEGMENT
_cCameraPos$ = 8					; size = 4
_cCameraDir$ = 12					; size = 4
?SetCamera@CIdvCamera@@SAXABVCVec3@@0@Z PROC		; CIdvCamera::SetCamera, COMDAT

; 58   : static  void                    SetCamera(const CVec3& cCameraPos, const CVec3& cCameraDir) { m_cCameraPos = cCameraPos; m_cCameraDir = cCameraDir; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _cCameraPos$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR ?m_cCameraPos@CIdvCamera@@1VCVec3@@A, ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR ?m_cCameraPos@CIdvCamera@@1VCVec3@@A+4, edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR ?m_cCameraPos@CIdvCamera@@1VCVec3@@A+8, eax
	mov	eax, DWORD PTR _cCameraDir$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR ?m_cCameraDir@CIdvCamera@@1VCVec3@@A, ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR ?m_cCameraDir@CIdvCamera@@1VCVec3@@A+4, edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR ?m_cCameraDir@CIdvCamera@@1VCVec3@@A+8, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetCamera@CIdvCamera@@SAXABVCVec3@@0@Z ENDP		; CIdvCamera::SetCamera
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1CTreeFileAccess@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1CTreeFileAccess@@QAE@XZ PROC				; CTreeFileAccess::~CTreeFileAccess, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CTreeFileAccess@@QAE@XZ ENDP				; CTreeFileAccess::~CTreeFileAccess
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\FileAccess.h
;	COMDAT ?EndOfFile@CTreeFileAccess@@QBE_NXZ
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
?EndOfFile@CTreeFileAccess@@QBE_NXZ PROC		; CTreeFileAccess::EndOfFile, COMDAT
; _this$ = ecx

; 324  :         bool                    EndOfFile(void) const                           { return (unsigned int) m_nIndex >= m_vMemory.size( ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], eax
	jb	SHORT $LN3@EndOfFile
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@EndOfFile
$LN3@EndOfFile:
	mov	DWORD PTR tv69[ebp], 0
$LN4@EndOfFile:
	movzx	eax, BYTE PTR tv69[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?EndOfFile@CTreeFileAccess@@QBE_NXZ ENDP		; CTreeFileAccess::EndOfFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\FileAccess.h
;	COMDAT ?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_eToken$ = 8						; size = 4
?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z PROC	; CTreeFileAccess::SaveToken, COMDAT
; _this$ = ecx

; 319  :         void                    SaveToken(EFileToken eToken)                    { SaveInt(static_cast<int>(eToken)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _eToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SaveInt@CTreeFileAccess@@QAEXH@Z	; CTreeFileAccess::SaveInt
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ENDP	; CTreeFileAccess::SaveToken
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\FileAccess.h
;	COMDAT ?SaveBool@CTreeFileAccess@@QAEX_N@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
_bBool$ = 8						; size = 1
?SaveBool@CTreeFileAccess@@QAEX_N@Z PROC		; CTreeFileAccess::SaveBool, COMDAT
; _this$ = ecx

; 311  :         void                    SaveBool(bool bBool)                            { m_vMemory.push_back((unsigned char) (bBool)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR _bBool$[ebp]
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SaveBool@CTreeFileAccess@@QAEX_N@Z ENDP		; CTreeFileAccess::SaveBool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\FileAccess.h
;	COMDAT ?ParseToken@CTreeFileAccess@@QAE?AW4EFileToken@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?ParseToken@CTreeFileAccess@@QAE?AW4EFileToken@@XZ PROC	; CTreeFileAccess::ParseToken, COMDAT
; _this$ = ecx

; 305  :         EFileToken              ParseToken(void)                                { return static_cast<EFileToken>(ParseInt( )); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ParseInt@CTreeFileAccess@@QAEHXZ	; CTreeFileAccess::ParseInt
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ParseToken@CTreeFileAccess@@QAE?AW4EFileToken@@XZ ENDP	; CTreeFileAccess::ParseToken
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\FileAccess.h
;	COMDAT ?ParseBool@CTreeFileAccess@@QAE_NXZ
_TEXT	SEGMENT
tv75 = -212						; size = 4
tv71 = -208						; size = 4
_this$ = -8						; size = 4
?ParseBool@CTreeFileAccess@@QAE_NXZ PROC		; CTreeFileAccess::ParseBool, COMDAT
; _this$ = ecx

; 297  :         bool                    ParseBool(void)                                 { return m_vMemory[m_nIndex++] != 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-20]
	mov	ecx, 5
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv71[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR tv71[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
	movzx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN3@ParseBool
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@ParseBool
$LN3@ParseBool:
	mov	DWORD PTR tv75[ebp], 0
$LN4@ParseBool:
	movzx	eax, BYTE PTR tv75[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 212				; 000000d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ParseBool@CTreeFileAccess@@QAE_NXZ ENDP		; CTreeFileAccess::ParseBool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\FileAccess.h
;	COMDAT ??0CTreeFileAccess@@QAE@PBEH@Z
_TEXT	SEGMENT
_i$2 = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_pMemory$ = 8						; size = 4
_nNumBytes$ = 12					; size = 4
??0CTreeFileAccess@@QAE@PBEH@Z PROC			; CTreeFileAccess::CTreeFileAccess, COMDAT
; _this$ = ecx

; 289  :         {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CTreeFileAccess@@QAE@PBEH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 288  :             m_nIndex(0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 289  :         {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 290  :             m_vMemory.resize(nNumBytes);

	mov	eax, DWORD PTR _nNumBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	npad	1

; 291  :             for (int i = 0; i < nNumBytes; ++i)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@CTreeFileA
$LN2@CTreeFileA:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@CTreeFileA:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _nNumBytes$[ebp]
	jge	SHORT $LN3@CTreeFileA

; 292  :                 m_vMemory[i] = pMemory[i];

	mov	eax, DWORD PTR _i$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
	mov	ecx, DWORD PTR _pMemory$[ebp]
	add	ecx, DWORD PTR _i$2[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $LN2@CTreeFileA
$LN3@CTreeFileA:

; 293  :         }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CTreeFileAccess@@QAE@PBEH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0CTreeFileAccess@@QAE@PBEH@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CTreeFileAccess@@QAE@PBEH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CTreeFileAccess@@QAE@PBEH@Z ENDP			; CTreeFileAccess::CTreeFileAccess
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\FileAccess.h
;	COMDAT ??0CTreeFileAccess@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0CTreeFileAccess@@QAE@XZ PROC				; CTreeFileAccess::CTreeFileAccess, COMDAT
; _this$ = ecx

; 284  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 283  :             m_nIndex(0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 284  :         {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1

; 285  :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CTreeFileAccess@@QAE@XZ ENDP				; CTreeFileAccess::CTreeFileAccess
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??A?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@QBEABUSIdvLeafTexture@@I@Z
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@QBEABUSIdvLeafTexture@@I@Z PROC ; std::vector<SIdvLeafTexture,std::allocator<SIdvLeafTexture> >::operator[], COMDAT
; _this$ = ecx

; 1896 :     _NODISCARD _CONSTEXPR20 const _Ty& operator[](const size_type _Pos) const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1897 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax
$LN4@operator:

; 1898 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1899 :         _STL_VERIFY(

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 84					; 00000054H
	idiv	ecx
	cmp	DWORD PTR __Pos$[ebp], eax
	jae	SHORT $LN8@operator
	jmp	SHORT $LN6@operator
$LN8@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1900					; 0000076cH
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	mov	esi, esp
	push	0
	push	1900					; 0000076cH
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@operator
$LN6@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator

; 1900 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1901 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1902 : 
; 1903 :         return _My_data._Myfirst[_Pos];

	imul	eax, DWORD PTR __Pos$[ebp], 84
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	eax, DWORD PTR [ecx+4]

; 1904 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@QBEABUSIdvLeafTexture@@I@Z ENDP ; std::vector<SIdvLeafTexture,std::allocator<SIdvLeafTexture> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?size@?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?size@?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@QBEIXZ PROC ; std::vector<SIdvLeafTexture,std::allocator<SIdvLeafTexture> >::size, COMDAT
; _this$ = ecx

; 1871 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1872 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1873 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 84					; 00000054H
	idiv	ecx

; 1874 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@QBEIXZ ENDP ; std::vector<SIdvLeafTexture,std::allocator<SIdvLeafTexture> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??4CIdvFilename@@QAEAAV0@$$QAV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4CIdvFilename@@QAEAAV0@$$QAV0@@Z PROC			; CIdvFilename::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4CIdvFilename@@QAEAAV0@$$QAV0@@Z ENDP			; CIdvFilename::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1CIdvFilename@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1CIdvFilename@@QAE@XZ PROC				; CIdvFilename::~CIdvFilename, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CIdvFilename@@QAE@XZ ENDP				; CIdvFilename::~CIdvFilename
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibFilename_Source\IdvFilename.h
;	COMDAT ?NoPath@CIdvFilename@@QBE?AV1@XZ
_TEXT	SEGMENT
tv165 = -1736						; size = 4
$T1 = -1725						; size = 1
$T2 = -1716						; size = 4
$T3 = -1704						; size = 4
$T4 = -1692						; size = 4
_k$5 = -1104						; size = 4
_j$6 = -1092						; size = 4
_k$7 = -1080						; size = 4
_i$8 = -1068						; size = 4
_nLength$ = -1056					; size = 4
_szPath$ = -1044					; size = 1024
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?NoPath@CIdvFilename@@QBE?AV1@XZ PROC			; CIdvFilename::NoPath, COMDAT
; _this$ = ecx

; 203  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1736				; 000006c8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1160]
	mov	ecx, 290				; 00000122H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0

; 204  :     IdvTmpString szPath;
; 205  : 
; 206  :     strcpy(szPath, c_str( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	lea	eax, DWORD PTR _szPath$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 207  :     int nLength = length( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	mov	DWORD PTR _nLength$[ebp], eax

; 208  :     for (int i = nLength - 1; i >= 0; i--)

	mov	eax, DWORD PTR _nLength$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$8[ebp], eax
	jmp	SHORT $LN4@NoPath
$LN2@NoPath:
	mov	eax, DWORD PTR _i$8[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$8[ebp], eax
$LN4@NoPath:
	cmp	DWORD PTR _i$8[ebp], 0
	jl	$LN3@NoPath

; 209  :         if ((*this)[i] == '/' || (*this)[i] == '\\')

	mov	eax, DWORD PTR _i$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN9@NoPath
	mov	eax, DWORD PTR _i$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	$LN8@NoPath
$LN9@NoPath:

; 210  :         {

	mov	BYTE PTR $T1[ebp], 0

; 211  : 			int k;
; 212  :             for (int j = i + 1, k = 0; j < nLength; j++, k++)

	mov	eax, DWORD PTR _i$8[ebp]
	add	eax, 1
	mov	DWORD PTR _j$6[ebp], eax
	mov	DWORD PTR _k$5[ebp], 0
	jmp	SHORT $LN7@NoPath
$LN5@NoPath:
	mov	eax, DWORD PTR _j$6[ebp]
	add	eax, 1
	mov	DWORD PTR _j$6[ebp], eax
	mov	ecx, DWORD PTR _k$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$5[ebp], ecx
$LN7@NoPath:
	mov	eax, DWORD PTR _j$6[ebp]
	cmp	eax, DWORD PTR _nLength$[ebp]
	jge	SHORT $LN6@NoPath

; 213  :                 szPath[k] = (*this)[j];

	mov	eax, DWORD PTR _j$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	ecx, DWORD PTR _k$5[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR _szPath$[ebp+ecx], dl
	jmp	SHORT $LN5@NoPath
$LN6@NoPath:

; 214  :             szPath[k] = '\0';

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN16@NoPath
	push	OFFSET $LN17@NoPath
	call	__RTC_UninitUse
	add	esp, 4
$LN16@NoPath:
	mov	eax, DWORD PTR _k$7[ebp]
	mov	DWORD PTR $T4[ebp], eax
	cmp	DWORD PTR $T4[ebp], 1024		; 00000400H
	jae	SHORT $LN11@NoPath
	jmp	SHORT $LN12@NoPath
$LN11@NoPath:
	call	___report_rangecheckfailure
	npad	1
$LN12@NoPath:
	mov	ecx, DWORD PTR $T4[ebp]
	mov	BYTE PTR _szPath$[ebp+ecx], 0

; 215  :             break;

	jmp	SHORT $LN3@NoPath
$LN8@NoPath:

; 216  :         }

	jmp	$LN2@NoPath
$LN3@NoPath:

; 217  : 
; 218  :     return string(szPath);

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	eax, DWORD PTR _szPath$[ebp]
	push	eax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0CIdvFilename@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CIdvFilename::CIdvFilename
	mov	DWORD PTR tv165[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@NoPath:

; 219  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@NoPath
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1736				; 000006c8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN20@NoPath:
	DD	1
	DD	$LN19@NoPath
$LN19@NoPath:
	DD	-1044					; fffffbecH
	DD	1024					; 00000400H
	DD	$LN18@NoPath
$LN18@NoPath:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN17@NoPath:
	DB	107					; 0000006bH
	DB	0
?NoPath@CIdvFilename@@QBE?AV1@XZ ENDP			; CIdvFilename::NoPath
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibFilename_Source\IdvFilename.h
;	COMDAT ??0CIdvFilename@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_strFilename$ = 8					; size = 28
??0CIdvFilename@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CIdvFilename::CIdvFilename, COMDAT
; _this$ = ecx

; 83   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CIdvFilename@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 82   : inline CIdvFilename::CIdvFilename(string strFilename) : string(strFilename)

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR _strFilename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 84   : 
; 85   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strFilename$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CIdvFilename@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	lea	ecx, DWORD PTR _strFilename$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0CIdvFilename@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CIdvFilename@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CIdvFilename@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CIdvFilename::CIdvFilename
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibFilename_Source\IdvFilename.h
;	COMDAT ??0CIdvFilename@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pFilename$ = 8						; size = 4
??0CIdvFilename@@QAE@PBD@Z PROC				; CIdvFilename::CIdvFilename, COMDAT
; _this$ = ecx

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 62   : inline CIdvFilename::CIdvFilename(const char* pFilename) : string(pFilename)

	mov	eax, DWORD PTR _pFilename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 64   : 
; 65   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0CIdvFilename@@QAE@PBD@Z ENDP				; CIdvFilename::CIdvFilename
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GSInstanceList@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GSInstanceList@@QAEPAXI@Z PROC			; SInstanceList::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SInstanceList@@QAE@XZ
	npad	1
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSInstanceList@@QAEPAXI@Z ENDP			; SInstanceList::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1SInstanceList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1SInstanceList@@QAE@XZ PROC				; SInstanceList::~SInstanceList, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::~vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1SInstanceList@@QAE@XZ ENDP				; SInstanceList::~SInstanceList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0SInstanceList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0SInstanceList@@QAE@XZ PROC				; SInstanceList::SInstanceList, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0SInstanceList@@QAE@XZ ENDP				; SInstanceList::SInstanceList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PAVCSpeedTreeRT@@@std@@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@2@$00@std@@QBEABV?$allocator@PAVCSpeedTreeRT@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@PAVCSpeedTreeRT@@@std@@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@2@$00@std@@QBEABV?$allocator@PAVCSpeedTreeRT@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<CSpeedTreeRT *>,std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1507 :     constexpr const _Ty1& _Get_first() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1508 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1509 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PAVCSpeedTreeRT@@@std@@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@2@$00@std@@QBEABV?$allocator@PAVCSpeedTreeRT@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<CSpeedTreeRT *>,std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PAVCSpeedTreeRT@@@std@@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVCSpeedTreeRT@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@PAVCSpeedTreeRT@@@std@@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVCSpeedTreeRT@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<CSpeedTreeRT *>,std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1503 :     constexpr _Ty1& _Get_first() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1504 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1505 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PAVCSpeedTreeRT@@@std@@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVCSpeedTreeRT@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<CSpeedTreeRT *>,std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >, COMDAT
; _this$ = ecx

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Getal@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEABV?$allocator@PAVCSpeedTreeRT@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEABV?$allocator@PAVCSpeedTreeRT@@@2@XZ PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Getal, COMDAT
; _this$ = ecx

; 2188 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2189 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@PAVCSpeedTreeRT@@@std@@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@2@$00@std@@QBEABV?$allocator@PAVCSpeedTreeRT@@@2@XZ ; std::_Compressed_pair<std::allocator<CSpeedTreeRT *>,std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >,1>::_Get_first

; 2190 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEABV?$allocator@PAVCSpeedTreeRT@@@2@XZ ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Getal@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAV?$allocator@PAVCSpeedTreeRT@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAV?$allocator@PAVCSpeedTreeRT@@@2@XZ PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Getal, COMDAT
; _this$ = ecx

; 2184 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2185 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@PAVCSpeedTreeRT@@@std@@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVCSpeedTreeRT@@@2@XZ ; std::_Compressed_pair<std::allocator<CSpeedTreeRT *>,std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >,1>::_Get_first

; 2186 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAV?$allocator@PAVCSpeedTreeRT@@@2@XZ ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 2169 :     _CONSTEXPR20 void _Orphan_range(pointer _First, pointer _Last) const {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2170 :         // orphan iterators within specified (inclusive) range
; 2171 : #if _HAS_CXX20
; 2172 :         if (_STD is_constant_evaluated()) {
; 2173 :             _Orphan_range_unlocked(_First, _Last);
; 2174 :         } else
; 2175 : #endif // _HAS_CXX20
; 2176 :         {
; 2177 :             _Orphan_range_locked(_First, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range_locked@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Orphan_range_locked
	npad	1

; 2178 :         }
; 2179 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Orphan_range@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Orphan_range_locked@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z
_TEXT	SEGMENT
__Lock$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range_locked@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Orphan_range_locked, COMDAT
; _this$ = ecx

; 2164 :     void _Orphan_range_locked(pointer _First, pointer _Last) const {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_range_locked@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2165 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2166 :         _Orphan_range_unlocked(_First, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range_unlocked@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Orphan_range_unlocked
	npad	1

; 2167 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@Orphan_ran
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN7@Orphan_ran:
	DD	1
	DD	$LN6@Orphan_ran
$LN6@Orphan_ran:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN4@Orphan_ran
$LN4@Orphan_ran:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range_locked@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?_Orphan_range_locked@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_range_locked@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_range_locked@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Orphan_range_locked
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Orphan_range_unlocked@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z
_TEXT	SEGMENT
__Temp$1 = -44						; size = 4
__Pnextptr$2 = -32					; size = 4
__Pnext$ = -20						; size = 4
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range_unlocked@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Orphan_range_unlocked, COMDAT
; _this$ = ecx

; 2150 :     _CONSTEXPR20 void _Orphan_range_unlocked(pointer _First, pointer _Last) const {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2151 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$[ebp], ecx
$LN2@Orphan_ran:

; 2152 :         while (*_Pnext) {

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Orphan_ran

; 2153 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Pnextptr$2[ebp], edx

; 2154 :             const auto _Temp     = *_Pnext;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Temp$1[ebp], ecx

; 2155 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator

	mov	eax, DWORD PTR __Pnextptr$2[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jb	SHORT $LN6@Orphan_ran
	mov	eax, DWORD PTR __Last$[ebp]
	cmp	eax, DWORD PTR __Pnextptr$2[ebp]
	jae	SHORT $LN4@Orphan_ran
$LN6@Orphan_ran:

; 2156 :                 _Pnext = &_Temp->_Mynextiter;

	mov	eax, DWORD PTR __Temp$1[ebp]
	add	eax, 4
	mov	DWORD PTR __Pnext$[ebp], eax

; 2157 :             } else { // orphan the iterator

	jmp	SHORT $LN5@Orphan_ran
$LN4@Orphan_ran:

; 2158 :                 _Temp->_Myproxy = nullptr;

	mov	eax, DWORD PTR __Temp$1[ebp]
	mov	DWORD PTR [eax], 0

; 2159 :                 *_Pnext         = _Temp->_Mynextiter;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR __Temp$1[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
$LN5@Orphan_ran:

; 2160 :             }
; 2161 :         }

	jmp	SHORT $LN2@Orphan_ran
$LN3@Orphan_ran:

; 2162 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?_Orphan_range_unlocked@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Orphan_range_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@CAXXZ PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Xlength, COMDAT

; 2141 :     [[noreturn]] static void _Xlength() {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2142 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
	npad	1
$LN1@Xlength:

; 2143 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlength@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@CAXXZ ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Myend$ = -80						; size = 4
__Mylast$ = -68						; size = 4
__Myfirst$ = -56					; size = 4
__My_data$ = -44					; size = 4
__Al$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEXXZ PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Tidy, COMDAT
; _this$ = ecx

; 2039 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Tidy@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2040 :         auto& _Al         = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAV?$allocator@PAVCSpeedTreeRT@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 2041 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2042 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 2043 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 2044 :         pointer& _Myend   = _My_data._Myend;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Myend$[ebp], eax

; 2045 : 
; 2046 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 2047 : 
; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR __Myfirst$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Tidy

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Destroy_range@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAXPAPAVCSpeedTreeRT@@QAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z ; std::_Destroy_range<std::allocator<CSpeedTreeRT *> >
	add	esp, 12					; 0000000cH

; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@PAVCSpeedTreeRT@@@std@@QAEXQAPAVCSpeedTreeRT@@I@Z ; std::allocator<CSpeedTreeRT *>::deallocate
	npad	1

; 2052 : 
; 2053 :             _Myfirst = nullptr;

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	DWORD PTR [eax], 0

; 2054 :             _Mylast  = nullptr;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [eax], 0

; 2055 :             _Myend   = nullptr;

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@Tidy:

; 2056 :         }
; 2057 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEXXZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEXXZ ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Tidy
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEXQAPAVCSpeedTreeRT@@II@Z
_TEXT	SEGMENT
__Myend$ = -68						; size = 4
__Mylast$ = -56						; size = 4
__Myfirst$ = -44					; size = 4
__My_data$ = -32					; size = 4
__Al$ = -20						; size = 4
_this$ = -8						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEXQAPAVCSpeedTreeRT@@II@Z PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Change_array, COMDAT
; _this$ = ecx

; 2017 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2018 :         // orphan all iterators, discard old array, acquire new array
; 2019 :         auto& _Al         = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAV?$allocator@PAVCSpeedTreeRT@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 2020 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2021 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 2022 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 2023 :         pointer& _Myend   = _My_data._Myend;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Myend$[ebp], eax

; 2024 : 
; 2025 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 2026 : 
; 2027 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR __Myfirst$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Change_arr

; 2028 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Destroy_range@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@YAXPAPAVCSpeedTreeRT@@QAPAV1@AAV?$allocator@PAVCSpeedTreeRT@@@0@@Z ; std::_Destroy_range<std::allocator<CSpeedTreeRT *> >
	add	esp, 12					; 0000000cH

; 2029 :             _ASAN_VECTOR_REMOVE;
; 2030 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@PAVCSpeedTreeRT@@@std@@QAEXQAPAVCSpeedTreeRT@@I@Z ; std::allocator<CSpeedTreeRT *>::deallocate
	npad	1
$LN2@Change_arr:

; 2031 :         }
; 2032 : 
; 2033 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [eax], ecx

; 2034 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [eax], edx

; 2035 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Myend$[ebp]
	mov	DWORD PTR [eax], edx

; 2036 :         _ASAN_VECTOR_CREATE;
; 2037 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Change_array@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEXQAPAVCSpeedTreeRT@@II@Z ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Geometric$ = -44					; size = 4
__Max$ = -32						; size = 4
__Oldcapacity$ = -20					; size = 4
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEII@Z PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1965 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1966 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1967 :         const size_type _Oldcapacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QBEIXZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::capacity
	mov	DWORD PTR __Oldcapacity$[ebp], eax

; 1968 :         const auto _Max              = max_size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QBEIXZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::max_size
	mov	DWORD PTR __Max$[ebp], eax

; 1969 : 
; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	eax, DWORD PTR __Oldcapacity$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR __Max$[ebp]
	sub	ecx, eax
	cmp	DWORD PTR __Oldcapacity$[ebp], ecx
	jbe	SHORT $LN2@Calculate_

; 1971 :             return _Max; // geometric growth would overflow

	mov	eax, DWORD PTR __Max$[ebp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1972 :         }
; 1973 : 
; 1974 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	mov	eax, DWORD PTR __Oldcapacity$[ebp]
	shr	eax, 1
	add	eax, DWORD PTR __Oldcapacity$[ebp]
	mov	DWORD PTR __Geometric$[ebp], eax

; 1975 : 
; 1976 :         if (_Geometric < _Newsize) {

	mov	eax, DWORD PTR __Geometric$[ebp]
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@Calculate_

; 1977 :             return _Newsize; // geometric growth would be insufficient

	mov	eax, DWORD PTR __Newsize$[ebp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1978 :         }
; 1979 : 
; 1980 :         return _Geometric; // geometric growth is sufficient

	mov	eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1981 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Calculate_growth@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEII@Z ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?capacity@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?capacity@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QBEIXZ PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::capacity, COMDAT
; _this$ = ecx

; 1881 :     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1882 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1883 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1884 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QBEIXZ ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?max_size@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
$T2 = -212						; size = 4
_this$ = -8						; size = 4
?max_size@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QBEIXZ PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::max_size, COMDAT
; _this$ = ecx

; 1876 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1877 :         return (_STD min)(

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEABV?$allocator@PAVCSpeedTreeRT@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Getal
	push	eax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@SAIABV?$allocator@PAVCSpeedTreeRT@@@2@@Z ; std::_Default_allocator_traits<std::allocator<CSpeedTreeRT *> >::max_size
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	call	?max@?$numeric_limits@H@std@@SAHXZ	; std::numeric_limits<int>::max
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$min@I@std@@YAABIABI0@Z		; std::min<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 1878 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1879 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QBEIXZ ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?end@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::end, COMDAT
; _this$ = ecx

; 1808 :     _NODISCARD _CONSTEXPR20 iterator end() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1809 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1810 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@PAPAVCSpeedTreeRT@@PBU_Container_base12@1@@Z
	npad	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1811 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?begin@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::begin, COMDAT
; _this$ = ecx

; 1798 :     _NODISCARD _CONSTEXPR20 iterator begin() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1799 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1800 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@PAPAVCSpeedTreeRT@@PBU_Container_base12@1@@Z
	npad	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1801 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?erase@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Mylast$ = -56						; size = 4
__My_data$ = -44					; size = 4
__Whereptr$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?erase@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@@Z PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::erase, COMDAT
; _this$ = ecx

; 1721 :         is_nothrow_move_assignable_v<value_type>) /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1722 :         const pointer _Whereptr = _Where._Ptr;

	mov	eax, DWORD PTR __Where$[ebp+8]
	mov	DWORD PTR __Whereptr$[ebp], eax

; 1723 :         auto& _My_data          = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1724 :         pointer& _Mylast        = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax
$LN4@erase:

; 1725 : 
; 1726 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1727 :         _STL_VERIFY(

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	esi, eax
	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LN8@erase
	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Whereptr$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN8@erase
	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Whereptr$[ebp]
	jbe	SHORT $LN8@erase
	jmp	SHORT $LN6@erase
$LN8@erase:
	mov	esi, esp
	push	OFFSET ??_C@_0CE@EAMOGAIE@vector?5erase?5iterator?5outside?5r@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1729					; 000006c1H
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@erase
	int	3
$LN11@erase:
	mov	esi, esp
	push	0
	push	1729					; 000006c1H
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1EM@BEMPOGMM@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@erase
$LN6@erase:
	xor	eax, eax
	jne	$LN4@erase

; 1728 :             _Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _My_data._Myfirst && _Mylast > _Whereptr,
; 1729 :             "vector erase iterator outside range");
; 1730 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1731 : 
; 1732 :         _Orphan_range(_Whereptr, _Mylast);

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Whereptr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@ABEXPAPAVCSpeedTreeRT@@0@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Orphan_range
	npad	1

; 1733 :         _STD _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);

	mov	eax, DWORD PTR __Whereptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Whereptr$[ebp]
	add	eax, 4
	push	eax
	call	??$_Move_unchecked@PAPAVCSpeedTreeRT@@PAPAV1@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@00@Z ; std::_Move_unchecked<CSpeedTreeRT * *,CSpeedTreeRT * *>
	add	esp, 12					; 0000000cH

; 1734 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	push	ecx
	call	??$_Unfancy@PAVCSpeedTreeRT@@@std@@YAPAPAVCSpeedTreeRT@@PAPAV1@@Z ; std::_Unfancy<CSpeedTreeRT *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAV?$allocator@PAVCSpeedTreeRT@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Getal
	push	eax
	call	??$destroy@PAVCSpeedTreeRT@@@?$_Default_allocator_traits@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@SAXAAV?$allocator@PAVCSpeedTreeRT@@@1@QAPAVCSpeedTreeRT@@@Z ; std::_Default_allocator_traits<std::allocator<CSpeedTreeRT *> >::destroy<CSpeedTreeRT *>
	add	esp, 8

; 1735 :         _ASAN_VECTOR_MODIFY(-1);
; 1736 :         --_Mylast;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 4
	mov	edx, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [edx], ecx

; 1737 :         return iterator(_Whereptr, _STD addressof(_My_data));

	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Whereptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@PAPAVCSpeedTreeRT@@PBU_Container_base12@1@@Z
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	npad	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1738 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?erase@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@@Z ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::erase
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?push_back@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAEX$$QAPAVCSpeedTreeRT@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAEX$$QAPAVCSpeedTreeRT@@@Z PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::push_back, COMDAT
; _this$ = ecx

; 870  :     _CONSTEXPR20 void push_back(_Ty&& _Val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 871  :         // insert by moving into element at end, provide strong guarantee
; 872  :         _Emplace_one_at_back(_STD move(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$move@AAPAVCSpeedTreeRT@@@std@@YA$$QAPAVCSpeedTreeRT@@AAPAV1@@Z ; std::move<CSpeedTreeRT * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Emplace_one_at_back@PAVCSpeedTreeRT@@@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAPAVCSpeedTreeRT@@$$QAPAV2@@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Emplace_one_at_back<CSpeedTreeRT *>
	npad	1

; 873  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAEX$$QAPAVCSpeedTreeRT@@@Z ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??1?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -236						; size = 4
_$S3$ = -29						; size = 1
__Alproxy$ = -20					; size = 4
_this$ = -8						; size = 4
??1?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::~vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >, COMDAT
; _this$ = ecx

; 760  :     _CONSTEXPR20 ~vector() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 761  :         _Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEXXZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Tidy
	npad	1

; 762  : #if _ITERATOR_DEBUG_LEVEL != 0
; 763  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAV?$allocator@PAVCSpeedTreeRT@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Getal
	push	eax
	lea	ecx, DWORD PTR _$S3$[ebp]
	call	??$?0PAVCSpeedTreeRT@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVCSpeedTreeRT@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><CSpeedTreeRT *>
	lea	eax, DWORD PTR _$S3$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 764  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

	mov	DWORD PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR __Alproxy$[ebp]
	push	edx
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 765  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 766  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@vector
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@vector:
	DD	1
	DD	$LN5@vector
$LN5@vector:
	DD	-29					; ffffffe3H
	DD	1
	DD	$LN4@vector
$LN4@vector:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	51					; 00000033H
	DB	0
??1?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::~vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -233						; size = 1
$T3 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ PROC ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >, COMDAT
; _this$ = ecx

; 601  :     _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@PAVCSpeedTreeRT@@@std@@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<CSpeedTreeRT *>,std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >,1>::_Compressed_pair<std::allocator<CSpeedTreeRT *>,std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> >,1><>
	npad	1

; 602  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@AAEAAV?$allocator@PAVCSpeedTreeRT@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::_Getal
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0PAVCSpeedTreeRT@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVCSpeedTreeRT@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><CSpeedTreeRT *>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
	npad	1

; 603  :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE@XZ ENDP ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@SAIABV?$allocator@PAVCSpeedTreeRT@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@SAIABV?$allocator@PAVCSpeedTreeRT@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<CSpeedTreeRT *> >::max_size, COMDAT

; 713  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 714  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	eax, 1073741823				; 3fffffffH

; 715  :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@SAIABV?$allocator@PAVCSpeedTreeRT@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<CSpeedTreeRT *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCSpeedTreeRT@@@std@@QAEPAPAVCSpeedTreeRT@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCSpeedTreeRT@@@std@@QAEPAPAVCSpeedTreeRT@@I@Z PROC ; std::allocator<CSpeedTreeRT *>::allocate, COMDAT
; _this$ = ecx

; 953  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$03@std@@YAII@Z	; std::_Get_size_of_n<4>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
	add	esp, 4

; 956  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVCSpeedTreeRT@@@std@@QAEPAPAVCSpeedTreeRT@@I@Z ENDP ; std::allocator<CSpeedTreeRT *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCSpeedTreeRT@@@std@@QAEXQAPAVCSpeedTreeRT@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCSpeedTreeRT@@@std@@QAEXQAPAVCSpeedTreeRT@@I@Z PROC ; std::allocator<CSpeedTreeRT *>::deallocate, COMDAT
; _this$ = ecx

; 947  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN4@deallocate:

; 948  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN10@deallocate
	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN8@deallocate
$LN10@deallocate:
	jmp	SHORT $LN6@deallocate
$LN8@deallocate:
	mov	esi, esp
	push	OFFSET ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	948					; 000003b4H
	push	OFFSET ??_C@_0GC@GDGMGNBP@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN12@deallocate
	int	3
$LN12@deallocate:
	mov	esi, esp
	push	0
	push	948					; 000003b4H
	push	OFFSET ??_C@_1ME@KJJNLLPL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@deallocate
$LN6@deallocate:
	xor	eax, eax
	jne	SHORT $LN4@deallocate

; 949  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07@std@@YAXPAXI@Z	; std::_Deallocate<8>
	add	esp, 8

; 951  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVCSpeedTreeRT@@@std@@QAEXQAPAVCSpeedTreeRT@@I@Z ENDP ; std::allocator<CSpeedTreeRT *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$allocator@PAVCSpeedTreeRT@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@PAVCSpeedTreeRT@@@std@@QAE@XZ PROC	; std::allocator<CSpeedTreeRT *>::allocator<CSpeedTreeRT *>, COMDAT
; _this$ = ecx

; 939  :     constexpr allocator() noexcept {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVCSpeedTreeRT@@@std@@QAE@XZ ENDP	; std::allocator<CSpeedTreeRT *>::allocator<CSpeedTreeRT *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\Instances.h
;	COMDAT ??0STreeInstanceData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0STreeInstanceData@@QAE@XZ PROC			; STreeInstanceData::STreeInstanceData, COMDAT
; _this$ = ecx

; 41   :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 39   :             m_pParent(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 41   :         {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0CVec3@@QAE@XZ			; CVec3::CVec3
	npad	1

; 40   :             m_fLodLevel(1.0f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+16], xmm0

; 42   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0STreeInstanceData@@QAE@XZ ENDP			; STreeInstanceData::STreeInstanceData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??A?$vector@GV?$allocator@G@std@@@std@@QBEABGI@Z
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@GV?$allocator@G@std@@@std@@QBEABGI@Z PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 1896 :     _NODISCARD _CONSTEXPR20 const _Ty& operator[](const size_type _Pos) const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1897 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax
$LN4@operator:

; 1898 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1899 :         _STL_VERIFY(

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 1
	cmp	DWORD PTR __Pos$[ebp], edx
	jae	SHORT $LN8@operator
	jmp	SHORT $LN6@operator
$LN8@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1900					; 0000076cH
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	mov	esi, esp
	push	0
	push	1900					; 0000076cH
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@operator
$LN6@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator

; 1900 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1901 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1902 : 
; 1903 :         return _My_data._Myfirst[_Pos];

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*2]

; 1904 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@GV?$allocator@G@std@@@std@@QBEABGI@Z ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?empty@?$vector@GV?$allocator@G@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv69 = -220						; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?empty@?$vector@GV?$allocator@G@std@@@std@@QBE_NXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::empty, COMDAT
; _this$ = ecx

; 1866 :     _NODISCARD_EMPTY_MEMBER _CONSTEXPR20 bool empty() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1867 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1868 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv69[ebp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv69[ebp]

; 1869 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$vector@GV?$allocator@G@std@@@std@@QBE_NXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?size@?$vector@PAGV?$allocator@PAG@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?size@?$vector@PAGV?$allocator@PAG@std@@@std@@QBEIXZ PROC ; std::vector<unsigned short *,std::allocator<unsigned short *> >::size, COMDAT
; _this$ = ecx

; 1871 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1872 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1873 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1874 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAGV?$allocator@PAG@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned short *,std::allocator<unsigned short *> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 1018 :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1019 :     _Ostr.put(_Ostr.widen('\n'));

	mov	esi, esp
	push	10					; 0000000aH
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	call	DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1

; 1020 :     _Ostr.flush();

	mov	esi, esp
	mov	ecx, DWORD PTR __Ostr$[ebp]
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1

; 1021 :     return _Ostr;

	mov	eax, DWORD PTR __Ostr$[ebp]

; 1022 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GCIndexedGeometry@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GCIndexedGeometry@@QAEPAXI@Z PROC			; CIndexedGeometry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CIndexedGeometry@@QAE@XZ		; CIndexedGeometry::~CIndexedGeometry
	npad	1
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	272					; 00000110H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCIndexedGeometry@@QAEPAXI@Z ENDP			; CIndexedGeometry::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$allocator@E@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$allocator@E@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1507 :     constexpr const _Ty1& _Get_first() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1508 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1509 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$allocator@E@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$allocator@E@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$allocator@E@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1503 :     constexpr _Ty1& _Get_first() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1504 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1505 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$allocator@E@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >, COMDAT
; _this$ = ecx

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Getal@?$vector@EV?$allocator@E@std@@@std@@ABEABV?$allocator@E@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$vector@EV?$allocator@E@std@@@std@@ABEABV?$allocator@E@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal, COMDAT
; _this$ = ecx

; 2188 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2189 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first

; 2190 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$vector@EV?$allocator@E@std@@@std@@ABEABV?$allocator@E@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal, COMDAT
; _this$ = ecx

; 2184 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2185 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first

; 2186 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range, COMDAT
; _this$ = ecx

; 2169 :     _CONSTEXPR20 void _Orphan_range(pointer _First, pointer _Last) const {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2170 :         // orphan iterators within specified (inclusive) range
; 2171 : #if _HAS_CXX20
; 2172 :         if (_STD is_constant_evaluated()) {
; 2173 :             _Orphan_range_unlocked(_First, _Last);
; 2174 :         } else
; 2175 : #endif // _HAS_CXX20
; 2176 :         {
; 2177 :             _Orphan_range_locked(_First, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range_locked@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range_locked
	npad	1

; 2178 :         }
; 2179 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Orphan_range_locked@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z
_TEXT	SEGMENT
__Lock$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range_locked@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range_locked, COMDAT
; _this$ = ecx

; 2164 :     void _Orphan_range_locked(pointer _First, pointer _Last) const {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_range_locked@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2165 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2166 :         _Orphan_range_unlocked(_First, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range_unlocked@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range_unlocked
	npad	1

; 2167 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@Orphan_ran
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN7@Orphan_ran:
	DD	1
	DD	$LN6@Orphan_ran
$LN6@Orphan_ran:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN4@Orphan_ran
$LN4@Orphan_ran:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range_locked@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?_Orphan_range_locked@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_range_locked@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_range_locked@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range_locked
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Orphan_range_unlocked@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z
_TEXT	SEGMENT
__Temp$1 = -44						; size = 4
__Pnextptr$2 = -32					; size = 4
__Pnext$ = -20						; size = 4
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range_unlocked@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range_unlocked, COMDAT
; _this$ = ecx

; 2150 :     _CONSTEXPR20 void _Orphan_range_unlocked(pointer _First, pointer _Last) const {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2151 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$[ebp], ecx
$LN2@Orphan_ran:

; 2152 :         while (*_Pnext) {

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Orphan_ran

; 2153 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Pnextptr$2[ebp], edx

; 2154 :             const auto _Temp     = *_Pnext;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Temp$1[ebp], ecx

; 2155 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator

	mov	eax, DWORD PTR __Pnextptr$2[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jb	SHORT $LN6@Orphan_ran
	mov	eax, DWORD PTR __Last$[ebp]
	cmp	eax, DWORD PTR __Pnextptr$2[ebp]
	jae	SHORT $LN4@Orphan_ran
$LN6@Orphan_ran:

; 2156 :                 _Pnext = &_Temp->_Mynextiter;

	mov	eax, DWORD PTR __Temp$1[ebp]
	add	eax, 4
	mov	DWORD PTR __Pnext$[ebp], eax

; 2157 :             } else { // orphan the iterator

	jmp	SHORT $LN5@Orphan_ran
$LN4@Orphan_ran:

; 2158 :                 _Temp->_Myproxy = nullptr;

	mov	eax, DWORD PTR __Temp$1[ebp]
	mov	DWORD PTR [eax], 0

; 2159 :                 *_Pnext         = _Temp->_Mynextiter;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR __Temp$1[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
$LN5@Orphan_ran:

; 2160 :             }
; 2161 :         }

	jmp	SHORT $LN2@Orphan_ran
$LN3@Orphan_ran:

; 2162 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?_Orphan_range_unlocked@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength, COMDAT

; 2141 :     [[noreturn]] static void _Xlength() {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2142 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
	npad	1
$LN1@Xlength:

; 2143 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Myend$ = -80						; size = 4
__Mylast$ = -68						; size = 4
__Myfirst$ = -56					; size = 4
__My_data$ = -44					; size = 4
__Al$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy, COMDAT
; _this$ = ecx

; 2039 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2040 :         auto& _Al         = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 2041 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2042 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 2043 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 2044 :         pointer& _Myend   = _My_data._Myend;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Myend$[ebp], eax

; 2045 : 
; 2046 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 2047 : 
; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR __Myfirst$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Tidy

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
	add	esp, 12					; 0000000cH

; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@E@std@@QAEXQAEI@Z ; std::allocator<unsigned char>::deallocate
	npad	1

; 2052 : 
; 2053 :             _Myfirst = nullptr;

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	DWORD PTR [eax], 0

; 2054 :             _Mylast  = nullptr;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [eax], 0

; 2055 :             _Myend   = nullptr;

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@Tidy:

; 2056 :         }
; 2057 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z
_TEXT	SEGMENT
__Myend$ = -68						; size = 4
__Mylast$ = -56						; size = 4
__Myfirst$ = -44					; size = 4
__My_data$ = -32					; size = 4
__Al$ = -20						; size = 4
_this$ = -8						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array, COMDAT
; _this$ = ecx

; 2017 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2018 :         // orphan all iterators, discard old array, acquire new array
; 2019 :         auto& _Al         = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 2020 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2021 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 2022 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 2023 :         pointer& _Myend   = _My_data._Myend;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Myend$[ebp], eax

; 2024 : 
; 2025 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 2026 : 
; 2027 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR __Myfirst$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Change_arr

; 2028 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
	add	esp, 12					; 0000000cH

; 2029 :             _ASAN_VECTOR_REMOVE;
; 2030 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@E@std@@QAEXQAEI@Z ; std::allocator<unsigned char>::deallocate
	npad	1
$LN2@Change_arr:

; 2031 :         }
; 2032 : 
; 2033 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [eax], ecx

; 2034 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newvec$[ebp]
	add	eax, DWORD PTR __Newsize$[ebp]
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [ecx], eax

; 2035 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newvec$[ebp]
	add	eax, DWORD PTR __Newcapacity$[ebp]
	mov	ecx, DWORD PTR __Myend$[ebp]
	mov	DWORD PTR [ecx], eax

; 2036 :         _ASAN_VECTOR_CREATE;
; 2037 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Geometric$ = -44					; size = 4
__Max$ = -32						; size = 4
__Oldcapacity$ = -20					; size = 4
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1965 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1966 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1967 :         const size_type _Oldcapacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
	mov	DWORD PTR __Oldcapacity$[ebp], eax

; 1968 :         const auto _Max              = max_size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
	mov	DWORD PTR __Max$[ebp], eax

; 1969 : 
; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	eax, DWORD PTR __Oldcapacity$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR __Max$[ebp]
	sub	ecx, eax
	cmp	DWORD PTR __Oldcapacity$[ebp], ecx
	jbe	SHORT $LN2@Calculate_

; 1971 :             return _Max; // geometric growth would overflow

	mov	eax, DWORD PTR __Max$[ebp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1972 :         }
; 1973 : 
; 1974 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	mov	eax, DWORD PTR __Oldcapacity$[ebp]
	shr	eax, 1
	add	eax, DWORD PTR __Oldcapacity$[ebp]
	mov	DWORD PTR __Geometric$[ebp], eax

; 1975 : 
; 1976 :         if (_Geometric < _Newsize) {

	mov	eax, DWORD PTR __Geometric$[ebp]
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@Calculate_

; 1977 :             return _Newsize; // geometric growth would be insufficient

	mov	eax, DWORD PTR __Newsize$[ebp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1978 :         }
; 1979 : 
; 1980 :         return _Geometric; // geometric growth is sufficient

	mov	eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1981 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??A?$vector@EV?$allocator@E@std@@@std@@QBEABEI@Z
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@EV?$allocator@E@std@@@std@@QBEABEI@Z PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::operator[], COMDAT
; _this$ = ecx

; 1896 :     _NODISCARD _CONSTEXPR20 const _Ty& operator[](const size_type _Pos) const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1897 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax
$LN4@operator:

; 1898 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1899 :         _STL_VERIFY(

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR __Pos$[ebp], edx
	jae	SHORT $LN8@operator
	jmp	SHORT $LN6@operator
$LN8@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1900					; 0000076cH
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	mov	esi, esp
	push	0
	push	1900					; 0000076cH
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@operator
$LN6@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator

; 1900 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1901 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1902 : 
; 1903 :         return _My_data._Myfirst[_Pos];

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR __Pos$[ebp]

; 1904 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@EV?$allocator@E@std@@@std@@QBEABEI@Z ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::operator[], COMDAT
; _this$ = ecx

; 1886 :     _NODISCARD _CONSTEXPR20 _Ty& operator[](const size_type _Pos) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1887 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax
$LN4@operator:

; 1888 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1889 :         _STL_VERIFY(

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR __Pos$[ebp], edx
	jae	SHORT $LN8@operator
	jmp	SHORT $LN6@operator
$LN8@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1890					; 00000762H
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	mov	esi, esp
	push	0
	push	1890					; 00000762H
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@operator
$LN6@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator

; 1890 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1891 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1892 : 
; 1893 :         return _My_data._Myfirst[_Pos];

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR __Pos$[ebp]

; 1894 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity, COMDAT
; _this$ = ecx

; 1881 :     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1882 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1883 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]

; 1884 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
$T2 = -212						; size = 4
_this$ = -8						; size = 4
?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size, COMDAT
; _this$ = ecx

; 1876 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1877 :         return (_STD min)(

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@EV?$allocator@E@std@@@std@@ABEABV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
	push	eax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	call	?max@?$numeric_limits@H@std@@SAHXZ	; std::numeric_limits<int>::max
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$min@I@std@@YAABIABI0@Z		; std::min<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 1878 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1879 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::size, COMDAT
; _this$ = ecx

; 1871 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1872 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1873 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]

; 1874 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?empty@?$vector@EV?$allocator@E@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv69 = -220						; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?empty@?$vector@EV?$allocator@E@std@@@std@@QBE_NXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::empty, COMDAT
; _this$ = ecx

; 1866 :     _NODISCARD_EMPTY_MEMBER _CONSTEXPR20 bool empty() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1867 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1868 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv69[ebp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv69[ebp]

; 1869 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$vector@EV?$allocator@E@std@@@std@@QBE_NXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::resize, COMDAT
; _this$ = ecx

; 1584 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1585 :         // trim or append value-initialized elements, provide strong guarantee
; 1586 :         _Resize(_Newsize, _Value_init_tag{});

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
	npad	1

; 1587 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back, COMDAT
; _this$ = ecx

; 870  :     _CONSTEXPR20 void push_back(_Ty&& _Val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 871  :         // insert by moving into element at end, provide strong guarantee
; 872  :         _Emplace_one_at_back(_STD move(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$move@AAE@std@@YA$$QAEAAE@Z		; std::move<unsigned char &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Emplace_one_at_back@E@?$vector@EV?$allocator@E@std@@@std@@AAEAAE$$QAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_one_at_back<unsigned char>
	npad	1

; 873  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -236						; size = 4
_$S4$ = -29						; size = 1
__Alproxy$ = -20					; size = 4
_this$ = -8						; size = 4
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 760  :     _CONSTEXPR20 ~vector() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 761  :         _Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
	npad	1

; 762  : #if _ITERATOR_DEBUG_LEVEL != 0
; 763  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
	push	eax
	lea	ecx, DWORD PTR _$S4$[ebp]
	call	??$?0E@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@E@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned char>
	lea	eax, DWORD PTR _$S4$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 764  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

	mov	DWORD PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR __Alproxy$[ebp]
	push	edx
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 765  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 766  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@vector
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@vector:
	DD	1
	DD	$LN5@vector
$LN5@vector:
	DD	-29					; ffffffe3H
	DD	1
	DD	$LN4@vector
$LN4@vector:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	52					; 00000034H
	DB	0
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -233						; size = 1
$T3 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 601  :     _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
	npad	1

; 602  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0E@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@E@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
	npad	1

; 603  :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size, COMDAT

; 713  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 714  :         return static_cast<size_t>(-1) / sizeof(value_type);

	or	eax, -1

; 715  :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?allocate@?$allocator@E@std@@QAEPAEI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@E@std@@QAEPAEI@Z PROC		; std::allocator<unsigned char>::allocate, COMDAT
; _this$ = ecx

; 953  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$00@std@@YAII@Z	; std::_Get_size_of_n<1>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
	add	esp, 4

; 956  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@E@std@@QAEPAEI@Z ENDP		; std::allocator<unsigned char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXQAEI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@E@std@@QAEXQAEI@Z PROC		; std::allocator<unsigned char>::deallocate, COMDAT
; _this$ = ecx

; 947  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN4@deallocate:

; 948  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN10@deallocate
	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN8@deallocate
$LN10@deallocate:
	jmp	SHORT $LN6@deallocate
$LN8@deallocate:
	mov	esi, esp
	push	OFFSET ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	948					; 000003b4H
	push	OFFSET ??_C@_0GC@GDGMGNBP@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN12@deallocate
	int	3
$LN12@deallocate:
	mov	esi, esp
	push	0
	push	948					; 000003b4H
	push	OFFSET ??_C@_1ME@KJJNLLPL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@deallocate
$LN6@deallocate:
	xor	eax, eax
	jne	SHORT $LN4@deallocate

; 949  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07@std@@YAXPAXI@Z	; std::_Deallocate<8>
	add	esp, 8

; 951  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@E@std@@QAEXQAEI@Z ENDP		; std::allocator<unsigned char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$allocator@E@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@E@std@@QAE@XZ PROC			; std::allocator<unsigned char>::allocator<unsigned char>, COMDAT
; _this$ = ecx

; 939  :     constexpr allocator() noexcept {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@E@std@@QAE@XZ ENDP			; std::allocator<unsigned char>::allocator<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??A?$vector@MV?$allocator@M@std@@@std@@QBEABMI@Z
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@MV?$allocator@M@std@@@std@@QBEABMI@Z PROC	; std::vector<float,std::allocator<float> >::operator[], COMDAT
; _this$ = ecx

; 1896 :     _NODISCARD _CONSTEXPR20 const _Ty& operator[](const size_type _Pos) const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1897 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax
$LN4@operator:

; 1898 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1899 :         _STL_VERIFY(

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR __Pos$[ebp], edx
	jae	SHORT $LN8@operator
	jmp	SHORT $LN6@operator
$LN8@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1900					; 0000076cH
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	mov	esi, esp
	push	0
	push	1900					; 0000076cH
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@operator
$LN6@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator

; 1900 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1901 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1902 : 
; 1903 :         return _My_data._Myfirst[_Pos];

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 1904 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@MV?$allocator@M@std@@@std@@QBEABMI@Z ENDP	; std::vector<float,std::allocator<float> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ PROC	; std::vector<float,std::allocator<float> >::size, COMDAT
; _this$ = ecx

; 1871 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1872 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1873 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1874 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ENDP	; std::vector<float,std::allocator<float> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?empty@?$vector@MV?$allocator@M@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv69 = -220						; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?empty@?$vector@MV?$allocator@M@std@@@std@@QBE_NXZ PROC	; std::vector<float,std::allocator<float> >::empty, COMDAT
; _this$ = ecx

; 1866 :     _NODISCARD_EMPTY_MEMBER _CONSTEXPR20 bool empty() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1867 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1868 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv69[ebp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv69[ebp]

; 1869 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$vector@MV?$allocator@M@std@@@std@@QBE_NXZ ENDP	; std::vector<float,std::allocator<float> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??A?$vector@KV?$allocator@K@std@@@std@@QBEABKI@Z
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@KV?$allocator@K@std@@@std@@QBEABKI@Z PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::operator[], COMDAT
; _this$ = ecx

; 1896 :     _NODISCARD _CONSTEXPR20 const _Ty& operator[](const size_type _Pos) const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1897 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax
$LN4@operator:

; 1898 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1899 :         _STL_VERIFY(

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR __Pos$[ebp], edx
	jae	SHORT $LN8@operator
	jmp	SHORT $LN6@operator
$LN8@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1900					; 0000076cH
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	mov	esi, esp
	push	0
	push	1900					; 0000076cH
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@operator
$LN6@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator

; 1900 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1901 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1902 : 
; 1903 :         return _My_data._Myfirst[_Pos];

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 1904 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@KV?$allocator@K@std@@@std@@QBEABKI@Z ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?empty@?$vector@KV?$allocator@K@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv69 = -220						; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?empty@?$vector@KV?$allocator@K@std@@@std@@QBE_NXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::empty, COMDAT
; _this$ = ecx

; 1866 :     _NODISCARD_EMPTY_MEMBER _CONSTEXPR20 bool empty() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1867 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1868 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv69[ebp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv69[ebp]

; 1869 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$vector@KV?$allocator@K@std@@@std@@QBE_NXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??A?$vector@V?$vector@PAGV?$allocator@PAG@std@@@std@@V?$allocator@V?$vector@PAGV?$allocator@PAG@std@@@std@@@2@@std@@QBEABV?$vector@PAGV?$allocator@PAG@std@@@1@I@Z
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@V?$vector@PAGV?$allocator@PAG@std@@@std@@V?$allocator@V?$vector@PAGV?$allocator@PAG@std@@@std@@@2@@std@@QBEABV?$vector@PAGV?$allocator@PAG@std@@@1@I@Z PROC ; std::vector<std::vector<unsigned short *,std::allocator<unsigned short *> >,std::allocator<std::vector<unsigned short *,std::allocator<unsigned short *> > > >::operator[], COMDAT
; _this$ = ecx

; 1896 :     _NODISCARD _CONSTEXPR20 const _Ty& operator[](const size_type _Pos) const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1897 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax
$LN4@operator:

; 1898 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1899 :         _STL_VERIFY(

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	cmp	DWORD PTR __Pos$[ebp], edx
	jae	SHORT $LN8@operator
	jmp	SHORT $LN6@operator
$LN8@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1900					; 0000076cH
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	mov	esi, esp
	push	0
	push	1900					; 0000076cH
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@operator
$LN6@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator

; 1900 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1901 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1902 : 
; 1903 :         return _My_data._Myfirst[_Pos];

	mov	eax, DWORD PTR __Pos$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	eax, DWORD PTR [ecx+4]

; 1904 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@V?$vector@PAGV?$allocator@PAG@std@@@std@@V?$allocator@V?$vector@PAGV?$allocator@PAG@std@@@std@@@2@@std@@QBEABV?$vector@PAGV?$allocator@PAG@std@@@1@I@Z ENDP ; std::vector<std::vector<unsigned short *,std::allocator<unsigned short *> >,std::allocator<std::vector<unsigned short *,std::allocator<unsigned short *> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??A?$vector@V?$vector@GV?$allocator@G@std@@@std@@V?$allocator@V?$vector@GV?$allocator@G@std@@@std@@@2@@std@@QBEABV?$vector@GV?$allocator@G@std@@@1@I@Z
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@V?$vector@GV?$allocator@G@std@@@std@@V?$allocator@V?$vector@GV?$allocator@G@std@@@std@@@2@@std@@QBEABV?$vector@GV?$allocator@G@std@@@1@I@Z PROC ; std::vector<std::vector<unsigned short,std::allocator<unsigned short> >,std::allocator<std::vector<unsigned short,std::allocator<unsigned short> > > >::operator[], COMDAT
; _this$ = ecx

; 1896 :     _NODISCARD _CONSTEXPR20 const _Ty& operator[](const size_type _Pos) const noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1897 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax
$LN4@operator:

; 1898 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1899 :         _STL_VERIFY(

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	cmp	DWORD PTR __Pos$[ebp], edx
	jae	SHORT $LN8@operator
	jmp	SHORT $LN6@operator
$LN8@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1900					; 0000076cH
	push	OFFSET ??_C@_0GB@FNOFBLAA@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	mov	esi, esp
	push	0
	push	1900					; 0000076cH
	push	OFFSET ??_C@_1MC@PMNMOCLC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@operator
$LN6@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator

; 1900 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1901 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1902 : 
; 1903 :         return _My_data._Myfirst[_Pos];

	mov	eax, DWORD PTR __Pos$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	eax, DWORD PTR [ecx+4]

; 1904 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@V?$vector@GV?$allocator@G@std@@@std@@V?$allocator@V?$vector@GV?$allocator@G@std@@@std@@@2@@std@@QBEABV?$vector@GV?$allocator@G@std@@@1@I@Z ENDP ; std::vector<std::vector<unsigned short,std::allocator<unsigned short> >,std::allocator<std::vector<unsigned short,std::allocator<unsigned short> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?Invalidate@CIndexedGeometry@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Invalidate@CIndexedGeometry@@QAEXXZ PROC		; CIndexedGeometry::Invalidate, COMDAT
; _this$ = ecx

; 123  :         void                    Invalidate(void)                                    { m_bValid = false; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+18], 0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Invalidate@CIndexedGeometry@@QAEXXZ ENDP		; CIndexedGeometry::Invalidate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?GetVertexTexIndices@CIndexedGeometry@@QBEPBEXZ
_TEXT	SEGMENT
tv73 = -208						; size = 4
_this$ = -8						; size = 4
?GetVertexTexIndices@CIndexedGeometry@@QBEPBEXZ PROC	; CIndexedGeometry::GetVertexTexIndices, COMDAT
; _this$ = ecx

; 113  :         const unsigned char*    GetVertexTexIndices(void) const                     { return m_vTexIndices0.empty( ) ? NULL : &(m_vTexIndices0[0]); }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 208				; 000000d0H
	call	?empty@?$vector@EV?$allocator@E@std@@@std@@QBE_NXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@GetVertexT
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN4@GetVertexT
$LN3@GetVertexT:
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 208				; 000000d0H
	call	??A?$vector@EV?$allocator@E@std@@@std@@QBEABEI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
	mov	DWORD PTR tv73[ebp], eax
$LN4@GetVertexT:
	mov	eax, DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVertexTexIndices@CIndexedGeometry@@QBEPBEXZ ENDP	; CIndexedGeometry::GetVertexTexIndices
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?GetVertexCount@CIndexedGeometry@@QBEGXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetVertexCount@CIndexedGeometry@@QBEGXZ PROC		; CIndexedGeometry::GetVertexCount, COMDAT
; _this$ = ecx

; 111  :         unsigned short          GetVertexCount(void) const                          { return static_cast<unsigned short>(m_vCoords.size( ) / 3); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::size
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVertexCount@CIndexedGeometry@@QBEGXZ ENDP		; CIndexedGeometry::GetVertexCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?GetVertexWindMatrixIndices@CIndexedGeometry@@QBEPBEXZ
_TEXT	SEGMENT
tv73 = -208						; size = 4
_this$ = -8						; size = 4
?GetVertexWindMatrixIndices@CIndexedGeometry@@QBEPBEXZ PROC ; CIndexedGeometry::GetVertexWindMatrixIndices, COMDAT
; _this$ = ecx

; 106  :         const unsigned char*    GetVertexWindMatrixIndices(void) const              { return m_vWindMatrixIndices.empty( ) ? NULL : &(m_vWindMatrixIndices[0]); }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 256				; 00000100H
	call	?empty@?$vector@EV?$allocator@E@std@@@std@@QBE_NXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@GetVertexW
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN4@GetVertexW
$LN3@GetVertexW:
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 256				; 00000100H
	call	??A?$vector@EV?$allocator@E@std@@@std@@QBEABEI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
	mov	DWORD PTR tv73[ebp], eax
$LN4@GetVertexW:
	mov	eax, DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVertexWindMatrixIndices@CIndexedGeometry@@QBEPBEXZ ENDP ; CIndexedGeometry::GetVertexWindMatrixIndices
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?GetVertexWindWeights@CIndexedGeometry@@QBEPBMXZ
_TEXT	SEGMENT
tv73 = -208						; size = 4
_this$ = -8						; size = 4
?GetVertexWindWeights@CIndexedGeometry@@QBEPBMXZ PROC	; CIndexedGeometry::GetVertexWindWeights, COMDAT
; _this$ = ecx

; 105  :         const float*            GetVertexWindWeights(void) const                    { return m_vWindWeights.empty( ) ? NULL : &(m_vWindWeights[0]); }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 240				; 000000f0H
	call	?empty@?$vector@MV?$allocator@M@std@@@std@@QBE_NXZ ; std::vector<float,std::allocator<float> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@GetVertexW
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN4@GetVertexW
$LN3@GetVertexW:
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 240				; 000000f0H
	call	??A?$vector@MV?$allocator@M@std@@@std@@QBEABMI@Z ; std::vector<float,std::allocator<float> >::operator[]
	mov	DWORD PTR tv73[ebp], eax
$LN4@GetVertexW:
	mov	eax, DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVertexWindWeights@CIndexedGeometry@@QBEPBMXZ ENDP	; CIndexedGeometry::GetVertexWindWeights
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?GetVertexTexCoords1@CIndexedGeometry@@QBEPBMXZ
_TEXT	SEGMENT
tv73 = -208						; size = 4
_this$ = -8						; size = 4
?GetVertexTexCoords1@CIndexedGeometry@@QBEPBMXZ PROC	; CIndexedGeometry::GetVertexTexCoords1, COMDAT
; _this$ = ecx

; 104  :         const float*            GetVertexTexCoords1(void) const                     { return m_vTexCoords1.empty( ) ? NULL : &(m_vTexCoords1[0]); }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 224				; 000000e0H
	call	?empty@?$vector@MV?$allocator@M@std@@@std@@QBE_NXZ ; std::vector<float,std::allocator<float> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@GetVertexT
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN4@GetVertexT
$LN3@GetVertexT:
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 224				; 000000e0H
	call	??A?$vector@MV?$allocator@M@std@@@std@@QBEABMI@Z ; std::vector<float,std::allocator<float> >::operator[]
	mov	DWORD PTR tv73[ebp], eax
$LN4@GetVertexT:
	mov	eax, DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVertexTexCoords1@CIndexedGeometry@@QBEPBMXZ ENDP	; CIndexedGeometry::GetVertexTexCoords1
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?GetVertexTexCoords0@CIndexedGeometry@@QBEPBMXZ
_TEXT	SEGMENT
tv73 = -208						; size = 4
_this$ = -8						; size = 4
?GetVertexTexCoords0@CIndexedGeometry@@QBEPBMXZ PROC	; CIndexedGeometry::GetVertexTexCoords0, COMDAT
; _this$ = ecx

; 103  :         const float*            GetVertexTexCoords0(void) const                     { return m_vTexCoords0.empty( ) ? NULL : &(m_vTexCoords0[0]); }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	?empty@?$vector@MV?$allocator@M@std@@@std@@QBE_NXZ ; std::vector<float,std::allocator<float> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@GetVertexT
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN4@GetVertexT
$LN3@GetVertexT:
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	??A?$vector@MV?$allocator@M@std@@@std@@QBEABMI@Z ; std::vector<float,std::allocator<float> >::operator[]
	mov	DWORD PTR tv73[ebp], eax
$LN4@GetVertexT:
	mov	eax, DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVertexTexCoords0@CIndexedGeometry@@QBEPBMXZ ENDP	; CIndexedGeometry::GetVertexTexCoords0
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?GetVertexTangents@CIndexedGeometry@@QBEPBMXZ
_TEXT	SEGMENT
tv73 = -208						; size = 4
_this$ = -8						; size = 4
?GetVertexTangents@CIndexedGeometry@@QBEPBMXZ PROC	; CIndexedGeometry::GetVertexTangents, COMDAT
; _this$ = ecx

; 102  :         const float*            GetVertexTangents(void) const                       { return m_vTangents.empty( ) ? NULL : &(m_vTangents[0]); }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	call	?empty@?$vector@MV?$allocator@M@std@@@std@@QBE_NXZ ; std::vector<float,std::allocator<float> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@GetVertexT
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN4@GetVertexT
$LN3@GetVertexT:
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	call	??A?$vector@MV?$allocator@M@std@@@std@@QBEABMI@Z ; std::vector<float,std::allocator<float> >::operator[]
	mov	DWORD PTR tv73[ebp], eax
$LN4@GetVertexT:
	mov	eax, DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVertexTangents@CIndexedGeometry@@QBEPBMXZ ENDP	; CIndexedGeometry::GetVertexTangents
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?GetVertexBinormals@CIndexedGeometry@@QBEPBMXZ
_TEXT	SEGMENT
tv73 = -208						; size = 4
_this$ = -8						; size = 4
?GetVertexBinormals@CIndexedGeometry@@QBEPBMXZ PROC	; CIndexedGeometry::GetVertexBinormals, COMDAT
; _this$ = ecx

; 101  :         const float*            GetVertexBinormals(void) const                      { return m_vBinormals.empty( ) ? NULL : &(m_vBinormals[0]); }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	call	?empty@?$vector@MV?$allocator@M@std@@@std@@QBE_NXZ ; std::vector<float,std::allocator<float> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@GetVertexB
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN4@GetVertexB
$LN3@GetVertexB:
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	call	??A?$vector@MV?$allocator@M@std@@@std@@QBEABMI@Z ; std::vector<float,std::allocator<float> >::operator[]
	mov	DWORD PTR tv73[ebp], eax
$LN4@GetVertexB:
	mov	eax, DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVertexBinormals@CIndexedGeometry@@QBEPBMXZ ENDP	; CIndexedGeometry::GetVertexBinormals
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?GetVertexNormals@CIndexedGeometry@@QBEPBMXZ
_TEXT	SEGMENT
tv73 = -208						; size = 4
_this$ = -8						; size = 4
?GetVertexNormals@CIndexedGeometry@@QBEPBMXZ PROC	; CIndexedGeometry::GetVertexNormals, COMDAT
; _this$ = ecx

; 100  :         const float*            GetVertexNormals(void) const                        { return m_vNormals.empty( ) ? NULL : &(m_vNormals[0]); }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	call	?empty@?$vector@MV?$allocator@M@std@@@std@@QBE_NXZ ; std::vector<float,std::allocator<float> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@GetVertexN
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN4@GetVertexN
$LN3@GetVertexN:
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	call	??A?$vector@MV?$allocator@M@std@@@std@@QBEABMI@Z ; std::vector<float,std::allocator<float> >::operator[]
	mov	DWORD PTR tv73[ebp], eax
$LN4@GetVertexN:
	mov	eax, DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVertexNormals@CIndexedGeometry@@QBEPBMXZ ENDP	; CIndexedGeometry::GetVertexNormals
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?GetVertexCoords@CIndexedGeometry@@QBEPBMXZ
_TEXT	SEGMENT
tv73 = -208						; size = 4
_this$ = -8						; size = 4
?GetVertexCoords@CIndexedGeometry@@QBEPBMXZ PROC	; CIndexedGeometry::GetVertexCoords, COMDAT
; _this$ = ecx

; 99   :         const float*            GetVertexCoords(void) const                         { return m_vCoords.empty( ) ? NULL : &(m_vCoords[0]); }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	?empty@?$vector@MV?$allocator@M@std@@@std@@QBE_NXZ ; std::vector<float,std::allocator<float> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@GetVertexC
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN4@GetVertexC
$LN3@GetVertexC:
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	??A?$vector@MV?$allocator@M@std@@@std@@QBEABMI@Z ; std::vector<float,std::allocator<float> >::operator[]
	mov	DWORD PTR tv73[ebp], eax
$LN4@GetVertexC:
	mov	eax, DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVertexCoords@CIndexedGeometry@@QBEPBMXZ ENDP	; CIndexedGeometry::GetVertexCoords
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?GetVertexColors@CIndexedGeometry@@QBEPBKXZ
_TEXT	SEGMENT
tv73 = -208						; size = 4
_this$ = -8						; size = 4
?GetVertexColors@CIndexedGeometry@@QBEPBKXZ PROC	; CIndexedGeometry::GetVertexColors, COMDAT
; _this$ = ecx

; 98   :         const unsigned long*    GetVertexColors(void) const                         { return m_vColors.empty( ) ? NULL : &(m_vColors[0]); }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	?empty@?$vector@KV?$allocator@K@std@@@std@@QBE_NXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@GetVertexC
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN4@GetVertexC
$LN3@GetVertexC:
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	??A?$vector@KV?$allocator@K@std@@@std@@QBEABKI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::operator[]
	mov	DWORD PTR tv73[ebp], eax
$LN4@GetVertexC:
	mov	eax, DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVertexColors@CIndexedGeometry@@QBEPBKXZ ENDP	; CIndexedGeometry::GetVertexColors
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?GetStripLengthsPointer@CIndexedGeometry@@QBEPBGG@Z
_TEXT	SEGMENT
tv132 = -208						; size = 4
_this$ = -8						; size = 4
_nLodLevel$ = 8						; size = 2
?GetStripLengthsPointer@CIndexedGeometry@@QBEPBGG@Z PROC ; CIndexedGeometry::GetStripLengthsPointer, COMDAT
; _this$ = ecx

; 180  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 181  :     st_assert(nLodLevel < m_nNumLodLevels);

	movzx	eax, WORD PTR _nLodLevel$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+24]
	cmp	eax, edx
	jl	SHORT $LN2@GetStripLe
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DJ@PPMMOPLM@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0??GetStripLengthsPointer@CIndexedGeometry@@QBEPBGG@Z@4JA
	add	eax, 1
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@GetStripLe:

; 182  :     return m_vStripLengths[nLodLevel].empty( ) ? NULL : &(m_vStripLengths[nLodLevel][0]);

	movzx	eax, WORD PTR _nLodLevel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??A?$vector@V?$vector@GV?$allocator@G@std@@@std@@V?$allocator@V?$vector@GV?$allocator@G@std@@@std@@@2@@std@@QBEABV?$vector@GV?$allocator@G@std@@@1@I@Z ; std::vector<std::vector<unsigned short,std::allocator<unsigned short> >,std::allocator<std::vector<unsigned short,std::allocator<unsigned short> > > >::operator[]
	mov	ecx, eax
	call	?empty@?$vector@GV?$allocator@G@std@@@std@@QBE_NXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::empty
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@GetStripLe
	mov	DWORD PTR tv132[ebp], 0
	jmp	SHORT $LN5@GetStripLe
$LN4@GetStripLe:
	push	0
	movzx	edx, WORD PTR _nLodLevel$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??A?$vector@V?$vector@GV?$allocator@G@std@@@std@@V?$allocator@V?$vector@GV?$allocator@G@std@@@std@@@2@@std@@QBEABV?$vector@GV?$allocator@G@std@@@1@I@Z ; std::vector<std::vector<unsigned short,std::allocator<unsigned short> >,std::allocator<std::vector<unsigned short,std::allocator<unsigned short> > > >::operator[]
	mov	ecx, eax
	call	??A?$vector@GV?$allocator@G@std@@@std@@QBEABGI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::operator[]
	mov	DWORD PTR tv132[ebp], eax
$LN5@GetStripLe:
	mov	eax, DWORD PTR tv132[ebp]
$LN1@GetStripLe:

; 183  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetStripLengthsPointer@CIndexedGeometry@@QBEPBGG@Z ENDP ; CIndexedGeometry::GetStripLengthsPointer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?GetNumStrips@CIndexedGeometry@@QBEGF@Z
_TEXT	SEGMENT
tv93 = -206						; size = 2
_this$ = -8						; size = 4
_sLodLevel$ = 8						; size = 2
?GetNumStrips@CIndexedGeometry@@QBEGF@Z PROC		; CIndexedGeometry::GetNumStrips, COMDAT
; _this$ = ecx

; 174  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 175  :     st_assert(sLodLevel < m_nNumLodLevels);

	movsx	eax, WORD PTR _sLodLevel$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+24]
	cmp	eax, edx
	jl	SHORT $LN2@GetNumStri
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DJ@PPMMOPLM@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0??GetNumStrips@CIndexedGeometry@@QBEGF@Z@4JA
	add	eax, 1
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@GetNumStri:

; 176  :     return (sLodLevel > -1) ? static_cast<unsigned short>(m_vStrips[sLodLevel].size( )) : static_cast<unsigned short>(0);

	movsx	eax, WORD PTR _sLodLevel$[ebp]
	cmp	eax, -1
	jle	SHORT $LN4@GetNumStri
	movsx	ecx, WORD PTR _sLodLevel$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??A?$vector@V?$vector@PAGV?$allocator@PAG@std@@@std@@V?$allocator@V?$vector@PAGV?$allocator@PAG@std@@@std@@@2@@std@@QBEABV?$vector@PAGV?$allocator@PAG@std@@@1@I@Z ; std::vector<std::vector<unsigned short *,std::allocator<unsigned short *> >,std::allocator<std::vector<unsigned short *,std::allocator<unsigned short *> > > >::operator[]
	mov	ecx, eax
	call	?size@?$vector@PAGV?$allocator@PAG@std@@@std@@QBEIXZ ; std::vector<unsigned short *,std::allocator<unsigned short *> >::size
	mov	WORD PTR tv93[ebp], ax
	jmp	SHORT $LN5@GetNumStri
$LN4@GetNumStri:
	xor	edx, edx
	mov	WORD PTR tv93[ebp], dx
$LN5@GetNumStri:
	mov	ax, WORD PTR tv93[ebp]
$LN1@GetNumStri:

; 177  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumStrips@CIndexedGeometry@@QBEGF@Z ENDP		; CIndexedGeometry::GetNumStrips
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?GetNumLodLevels@CIndexedGeometry@@QAEGXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetNumLodLevels@CIndexedGeometry@@QAEGXZ PROC		; CIndexedGeometry::GetNumLodLevels, COMDAT
; _this$ = ecx

; 80   :         unsigned short          GetNumLodLevels( )                                  { return m_nNumLodLevels; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [eax+24]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumLodLevels@CIndexedGeometry@@QAEGXZ ENDP		; CIndexedGeometry::GetNumLodLevels
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?SetWindMethod@CIndexedGeometry@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_eMethod$ = 8						; size = 4
?SetWindMethod@CIndexedGeometry@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z PROC ; CIndexedGeometry::SetWindMethod, COMDAT
; _this$ = ecx

; 57   :         void                    SetWindMethod(CSpeedTreeRT::EWindMethod eMethod)    { m_eWindMethod = eMethod; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eMethod$[ebp]
	mov	DWORD PTR [eax+20], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetWindMethod@CIndexedGeometry@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z ENDP ; CIndexedGeometry::SetWindMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?IsVertexWeightingEnabled@CIndexedGeometry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?IsVertexWeightingEnabled@CIndexedGeometry@@QBE_NXZ PROC ; CIndexedGeometry::IsVertexWeightingEnabled, COMDAT
; _this$ = ecx

; 55   :         bool                    IsVertexWeightingEnabled(void) const                { return m_bVertexWeighting; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+8]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsVertexWeightingEnabled@CIndexedGeometry@@QBE_NXZ ENDP ; CIndexedGeometry::IsVertexWeightingEnabled
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?EnableVertexWeighting@CIndexedGeometry@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_bFlag$ = 8						; size = 1
?EnableVertexWeighting@CIndexedGeometry@@QAEX_N@Z PROC	; CIndexedGeometry::EnableVertexWeighting, COMDAT
; _this$ = ecx

; 52   :         void                    EnableVertexWeighting(bool bFlag)                   { m_bVertexWeighting = bFlag; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bFlag$[ebp]
	mov	BYTE PTR [eax+8], cl
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EnableVertexWeighting@CIndexedGeometry@@QAEX_N@Z ENDP	; CIndexedGeometry::EnableVertexWeighting
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\IndexedGeometry.h
;	COMDAT ?EnableManualLighting@CIndexedGeometry@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_bFlag$ = 8						; size = 1
?EnableManualLighting@CIndexedGeometry@@QAEX_N@Z PROC	; CIndexedGeometry::EnableManualLighting, COMDAT
; _this$ = ecx

; 51   :         void                    EnableManualLighting(bool bFlag)                    { m_bManualLighting = bFlag; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bFlag$[ebp]
	mov	BYTE PTR [eax+9], cl
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EnableManualLighting@CIndexedGeometry@@QAEX_N@Z ENDP	; CIndexedGeometry::EnableManualLighting
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibVector_Source\IdvVector.h
;	COMDAT ?VecInterpolate@@YAMMMM@Z
_TEXT	SEGMENT
tv70 = -196						; size = 4
_fStart$ = 8						; size = 4
_fEnd$ = 12						; size = 4
_fPercent$ = 16						; size = 4
?VecInterpolate@@YAMMMM@Z PROC				; VecInterpolate, COMDAT

; 1177 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi

; 1178 :     return fStart + (fEnd - fStart) * fPercent;

	movss	xmm0, DWORD PTR _fEnd$[ebp]
	subss	xmm0, DWORD PTR _fStart$[ebp]
	mulss	xmm0, DWORD PTR _fPercent$[ebp]
	addss	xmm0, DWORD PTR _fStart$[ebp]
	movss	DWORD PTR tv70[ebp], xmm0
	fld	DWORD PTR tv70[ebp]

; 1179 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VecInterpolate@@YAMMMM@Z ENDP				; VecInterpolate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibVector_Source\IdvVector.h
;	COMDAT ?VecRad2Deg@@YAMM@Z
_TEXT	SEGMENT
tv67 = -196						; size = 4
_fRad$ = 8						; size = 4
?VecRad2Deg@@YAMM@Z PROC				; VecRad2Deg, COMDAT

; 1167 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi

; 1168 :     return fRad * 57.295779513082320876798154814105f;

	movss	xmm0, DWORD PTR _fRad$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	DWORD PTR tv67[ebp], xmm0
	fld	DWORD PTR tv67[ebp]

; 1169 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VecRad2Deg@@YAMM@Z ENDP				; VecRad2Deg
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
tv135 = -304						; size = 8
tv336 = -296						; size = 8
tv322 = -288						; size = 8
tv283 = -288						; size = 8
tv284 = -284						; size = 4
tv137 = -284						; size = 4
$T2 = -276						; size = 4
__Ok$ = -72						; size = 8
__Pad$ = -56						; size = 8
__Count$ = -40						; size = 8
__State$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 774  : basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-112]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 775  :     // insert NTBS into char stream
; 776  :     using _Elem = char;
; 777  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 778  : 
; 779  :     ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 780  :     streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
	add	esp, 4
	xor	ecx, ecx
	mov	DWORD PTR __Count$[ebp], eax
	mov	DWORD PTR __Count$[ebp+4], ecx

; 781  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv322[ebp], eax
	mov	DWORD PTR tv322[ebp+4], edx
	cmp	DWORD PTR tv322[ebp+4], 0
	jl	SHORT $LN17@operator
	jg	SHORT $LN24@operator
	cmp	DWORD PTR tv322[ebp], 0
	jbe	SHORT $LN17@operator
$LN24@operator:
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv336[ebp], eax
	mov	DWORD PTR tv336[ebp+4], edx
	mov	eax, DWORD PTR tv336[ebp+4]
	cmp	eax, DWORD PTR __Count$[ebp+4]
	jl	SHORT $LN17@operator
	jg	SHORT $LN25@operator
	mov	ecx, DWORD PTR tv336[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jbe	SHORT $LN17@operator
$LN25@operator:
	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	sub	eax, DWORD PTR __Count$[ebp]
	sbb	edx, DWORD PTR __Count$[ebp+4]
	mov	DWORD PTR tv135[ebp], eax
	mov	DWORD PTR tv135[ebp+4], edx
	jmp	SHORT $LN18@operator
$LN17@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR tv135[ebp], xmm0
$LN18@operator:
	mov	ecx, DWORD PTR tv135[ebp]
	mov	edx, DWORD PTR tv135[ebp+4]
	mov	DWORD PTR __Pad$[ebp], ecx
	mov	DWORD PTR __Pad$[ebp+4], edx

; 782  :     const typename _Myos::sentry _Ok(_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 783  : 
; 784  :     if (!_Ok) {

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@operator

; 785  :         _State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 786  :     } else { // state okay, insert

	jmp	$LN22@operator
$LN8@operator:

; 787  :         _TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 788  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN3@operator

; 789  :             for (; 0 < _Pad; --_Pad) { // pad on left

	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR __Pad$[ebp+4]
	sbb	ecx, 0
	mov	DWORD PTR __Pad$[ebp], eax
	mov	DWORD PTR __Pad$[ebp+4], ecx
$LN4@operator:
	cmp	DWORD PTR __Pad$[ebp+4], 0
	jl	$LN3@operator
	jg	SHORT $LN26@operator
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	SHORT $LN3@operator
$LN26@operator:

; 790  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	mov	edi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv137[ebp], eax
	mov	eax, DWORD PTR tv137[ebp]
	push	eax
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	push	eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@operator

; 791  :                     _State |= ios_base::badbit; // insertion failed, quit

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 792  :                     break;

	jmp	SHORT $LN3@operator
$LN12@operator:

; 793  :                 }
; 794  :             }

	jmp	$LN2@operator
$LN3@operator:

; 795  :         }
; 796  : 
; 797  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN13@operator
	mov	esi, esp
	mov	eax, DWORD PTR __Count$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	edi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv283[ebp], eax
	mov	DWORD PTR tv283[ebp+4], edx
	mov	eax, DWORD PTR tv283[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jne	SHORT $LN27@operator
	mov	ecx, DWORD PTR tv283[ebp+4]
	cmp	ecx, DWORD PTR __Count$[ebp+4]
	je	SHORT $LN13@operator
$LN27@operator:

; 798  :             _State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$LN13@operator:

; 799  :         }
; 800  : 
; 801  :         if (_State == ios_base::goodbit) {

	cmp	DWORD PTR __State$[ebp], 0
	jne	$LN6@operator

; 802  :             for (; 0 < _Pad; --_Pad) { // pad on right

	jmp	SHORT $LN7@operator
$LN5@operator:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR __Pad$[ebp+4]
	sbb	ecx, 0
	mov	DWORD PTR __Pad$[ebp], eax
	mov	DWORD PTR __Pad$[ebp+4], ecx
$LN7@operator:
	cmp	DWORD PTR __Pad$[ebp+4], 0
	jl	$LN6@operator
	jg	SHORT $LN28@operator
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	SHORT $LN6@operator
$LN28@operator:

; 803  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	mov	edi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv284[ebp], eax
	mov	eax, DWORD PTR tv284[ebp]
	push	eax
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	push	eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@operator

; 804  :                     _State |= ios_base::badbit; // insertion failed, quit

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 805  :                     break;

	jmp	SHORT $LN6@operator
$LN15@operator:

; 806  :                 }
; 807  :             }

	jmp	$LN5@operator
$LN6@operator:

; 808  :         }
; 809  : 
; 810  :         _Ostr.width(0);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	jmp	SHORT $LN19@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 811  :         _CATCH_IO_(ios_base, _Ostr)

	mov	esi, esp
	push	1
	push	4
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	eax, $LN23@operator
	ret	0
$LN19@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN22@operator
$LN23@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN22@operator:

; 812  :     }
; 813  : 
; 814  :     _Ostr.setstate(_State);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1

; 815  :     return _Ostr;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T2[ebp]

; 816  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN32@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN32@operator:
	DD	1
	DD	$LN31@operator
$LN31@operator:
	DD	-72					; ffffffb8H
	DD	8
	DD	$LN29@operator
$LN29@operator:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-308]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1CRegion@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1CRegion@@QAE@XZ PROC					; CRegion::~CRegion, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??1CVec@@QAE@XZ				; CVec::~CVec
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CVec@@QAE@XZ				; CVec::~CVec
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CRegion@@QAE@XZ ENDP					; CRegion::~CRegion
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibVector_Source\IdvVector.h
;	COMDAT ??DCVec3@@QBE?AV0@ABVCTransform@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
_cTransform$ = 12					; size = 4
??DCVec3@@QBE?AV0@ABVCTransform@@@Z PROC		; CVec3::operator*, COMDAT
; _this$ = ecx

; 872  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 873  :     return CVec3(m_afData[0] * cTransform.m_afData[0][0] +

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _cTransform$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _cTransform$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [ecx+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _cTransform$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [ecx+edx]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _cTransform$[ebp]
	mov	edx, 4
	shl	edx, 1
	addss	xmm0, DWORD PTR [ecx+edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _cTransform$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _cTransform$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [ecx+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _cTransform$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [ecx+edx]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _cTransform$[ebp]
	mov	edx, 4
	shl	edx, 0
	addss	xmm0, DWORD PTR [ecx+edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _cTransform$[ebp]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _cTransform$[ebp]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [ecx+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _cTransform$[ebp]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [ecx+edx]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _cTransform$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	addss	xmm0, DWORD PTR [ecx+eax]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	npad	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 874  :                  m_afData[1] * cTransform.m_afData[1][0] +
; 875  :                  m_afData[2] * cTransform.m_afData[2][0] +
; 876  :                                cTransform.m_afData[3][0],
; 877  :                  m_afData[0] * cTransform.m_afData[0][1] +
; 878  :                  m_afData[1] * cTransform.m_afData[1][1] +
; 879  :                  m_afData[2] * cTransform.m_afData[2][1] +
; 880  :                                cTransform.m_afData[3][1],
; 881  :                  m_afData[0] * cTransform.m_afData[0][2] +
; 882  :                  m_afData[1] * cTransform.m_afData[1][2] +
; 883  :                  m_afData[2] * cTransform.m_afData[2][2] +
; 884  :                                cTransform.m_afData[3][2]);
; 885  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??DCVec3@@QBE?AV0@ABVCTransform@@@Z ENDP		; CVec3::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibVector_Source\IdvVector.h
;	COMDAT ??9CVec3@@QBE_NABV0@@Z
_TEXT	SEGMENT
tv85 = -208						; size = 4
_this$ = -8						; size = 4
_cVec$ = 8						; size = 4
??9CVec3@@QBE_NABV0@@Z PROC				; CVec3::operator!=, COMDAT
; _this$ = ecx

; 864  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 865  :     return m_afData[0] != cVec.m_afData[0] ||

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _cVec$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	ucomiss	xmm0, DWORD PTR [esi+eax]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _cVec$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	ucomiss	xmm0, DWORD PTR [esi+ecx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _cVec$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	ucomiss	xmm0, DWORD PTR [esi+ecx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	DWORD PTR tv85[ebp], 0
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv85[ebp], 1
$LN4@operator:
	movzx	eax, BYTE PTR tv85[ebp]

; 866  :            m_afData[1] != cVec.m_afData[1] ||
; 867  :            m_afData[2] != cVec.m_afData[2];
; 868  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??9CVec3@@QBE_NABV0@@Z ENDP				; CVec3::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibVector_Source\IdvVector.h
;	COMDAT ??DCVec3@@QBE?AV0@M@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
_fScale$ = 12						; size = 4
??DCVec3@@QBE?AV0@M@Z PROC				; CVec3::operator*, COMDAT
; _this$ = ecx

; 820  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 821  :     return CVec3(m_afData[0] * fScale,

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _fScale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _fScale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _fScale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	npad	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 822  :                  m_afData[1] * fScale,
; 823  :                  m_afData[2] * fScale);
; 824  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??DCVec3@@QBE?AV0@M@Z ENDP				; CVec3::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibVector_Source\IdvVector.h
;	COMDAT ??GCVec3@@QBE?AV0@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
??GCVec3@@QBE?AV0@XZ PROC				; CVec3::operator-, COMDAT
; _this$ = ecx

; 784  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 785  :     return CVec3(-m_afData[0],

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	npad	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 786  :                  -m_afData[1],
; 787  :                  -m_afData[2]);
; 788  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??GCVec3@@QBE?AV0@XZ ENDP				; CVec3::operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibVector_Source\IdvVector.h
;	COMDAT ??HCVec3@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
_cVec$ = 12						; size = 4
??HCVec3@@QBE?AV0@ABV0@@Z PROC				; CVec3::operator+, COMDAT
; _this$ = ecx

; 748  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 749  :     return CVec3(m_afData[0] + cVec.m_afData[0],

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _cVec$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	addss	xmm0, DWORD PTR [esi+ecx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _cVec$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	addss	xmm0, DWORD PTR [esi+ecx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _cVec$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	addss	xmm0, DWORD PTR [esi+eax]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	npad	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 750  :                  m_afData[1] + cVec.m_afData[1],
; 751  :                  m_afData[2] + cVec.m_afData[2]);
; 752  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??HCVec3@@QBE?AV0@ABV0@@Z ENDP				; CVec3::operator+
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibVector_Source\IdvVector.h
;	COMDAT ??ACVec3@@QAEAAMH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
??ACVec3@@QAEAAMH@Z PROC				; CVec3::operator[], COMDAT
; _this$ = ecx

; 147  :         float&      operator[](int nIndex)                                  { return m_afData[nIndex]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _nIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??ACVec3@@QAEAAMH@Z ENDP				; CVec3::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibVector_Source\IdvVector.h
;	COMDAT ??BCVec3@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??BCVec3@@QAEPAMXZ PROC					; CVec3::operator float *, COMDAT
; _this$ = ecx

; 145  :                     operator float*( )                                      { return &m_afData[0]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 4
	imul	eax, eax, 0
	add	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BCVec3@@QAEPAMXZ ENDP					; CVec3::operator float *
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibVector_Source\IdvVector.h
;	COMDAT ?Set@CVec3@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fX$ = 8						; size = 4
_fY$ = 12						; size = 4
_fZ$ = 16						; size = 4
?Set@CVec3@@QAEXMMM@Z PROC				; CVec3::Set, COMDAT
; _this$ = ecx

; 684  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 685  :     m_afData[0] = fX;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fX$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 686  :     m_afData[1] = fY;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fY$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 687  :     m_afData[2] = fZ;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fZ$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 688  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Set@CVec3@@QAEXMMM@Z ENDP				; CVec3::Set
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibVector_Source\IdvVector.h
;	COMDAT ?Distance@CVec3@@QBEMABV1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cVec$ = 8						; size = 4
?Distance@CVec3@@QBEMABV1@@Z PROC			; CVec3::Distance, COMDAT
; _this$ = ecx

; 598  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 599  :     return _idv_sqrt1(

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _cVec$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _cVec$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx]
	subss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _cVec$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	subss	xmm1, DWORD PTR [esi+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _cVec$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR [edx+eax]
	subss	xmm2, DWORD PTR [esi+ecx]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _cVec$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	subss	xmm1, DWORD PTR [esi+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _cVec$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR [edx+eax]
	subss	xmm2, DWORD PTR [esi+ecx]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?_idv_sqrt1@@YAMM@Z			; _idv_sqrt1
	add	esp, 4

; 600  :                 ((cVec.m_afData[0] - m_afData[0]) * (cVec.m_afData[0] - m_afData[0])) +
; 601  :                 ((cVec.m_afData[1] - m_afData[1]) * (cVec.m_afData[1] - m_afData[1])) +
; 602  :                 ((cVec.m_afData[2] - m_afData[2]) * (cVec.m_afData[2] - m_afData[2]))
; 603  :                 );
; 604  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Distance@CVec3@@QBEMABV1@@Z ENDP			; CVec3::Distance
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibVector_Source\IdvVector.h
;	COMDAT ??0CVec3@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fX$ = 8						; size = 4
_fY$ = 12						; size = 4
_fZ$ = 16						; size = 4
??0CVec3@@QAE@MMM@Z PROC				; CVec3::CVec3, COMDAT
; _this$ = ecx

; 547  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 548  :     m_afData[0] = fX;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fX$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 549  :     m_afData[1] = fY;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fY$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 550  :     m_afData[2] = fZ;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fZ$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 551  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0CVec3@@QAE@MMM@Z ENDP				; CVec3::CVec3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibVector_Source\IdvVector.h
;	COMDAT ??0CVec3@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0CVec3@@QAE@XZ PROC					; CVec3::CVec3, COMDAT
; _this$ = ecx

; 541  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 542  :     m_afData[0] = m_afData[1] = m_afData[2] = 0.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 543  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CVec3@@QAE@XZ ENDP					; CVec3::CVec3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibVector_Source\IdvFastMath.h
;	COMDAT ?_idv_sqrt1@@YAMM@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_fVal$ = 8						; size = 4
?_idv_sqrt1@@YAMM@Z PROC				; _idv_sqrt1, COMDAT

; 2229 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi

; 2230 :     int i = ((*(int*)&fVal) >> 1 ) + 0x1fc00000; 

	mov	eax, DWORD PTR _fVal$[ebp]
	sar	eax, 1
	add	eax, 532676608				; 1fc00000H
	mov	DWORD PTR _i$[ebp], eax

; 2231 :     return *(float*)&i;

	fld	DWORD PTR _i$[ebp]

; 2232 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_idv_sqrt1@@YAMM@Z ENDP				; _idv_sqrt1
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??4CSpeedTreeRT@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4CSpeedTreeRT@@QAEAAV0@ABV0@@Z PROC			; CSpeedTreeRT::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, 39					; 00000027H
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edi, DWORD PTR _this$[ebp]
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4CSpeedTreeRT@@QAEAAV0@ABV0@@Z ENDP			; CSpeedTreeRT::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetupHorizontalBillboard@CSpeedTreeRT@@AAEXXZ
_TEXT	SEGMENT
$T1 = -336						; size = 12
$T2 = -316						; size = 12
$T3 = -296						; size = 12
$T4 = -276						; size = 12
_fHalfHeight$5 = -64					; size = 4
_afMax$6 = -52						; size = 12
_afMin$7 = -32						; size = 12
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?SetupHorizontalBillboard@CSpeedTreeRT@@AAEXXZ PROC	; CSpeedTreeRT::SetupHorizontalBillboard, COMDAT
; _this$ = ecx

; 3470 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 3471 :     if (m_pEmbeddedTexCoords && m_bHorizontalBillboard)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	$LN2@SetupHoriz
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+105]
	test	ecx, ecx
	je	$LN2@SetupHoriz

; 3472 :     {
; 3473 :         float afMin[3];;
; 3474 :         Assign3d(afMin, m_pTreeSizes + 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	lea	edx, DWORD PTR _afMin$7[ebp]
	push	edx
	call	?Assign3d@@YAXPAMPBM@Z			; Assign3d
	add	esp, 8

; 3475 :         float afMax[3];
; 3476 :         Assign3d(afMax, m_pTreeSizes + 3);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	add	ecx, 12					; 0000000cH
	push	ecx
	lea	edx, DWORD PTR _afMax$6[ebp]
	push	edx
	call	?Assign3d@@YAXPAMPBM@Z			; Assign3d
	add	esp, 8

; 3477 : 
; 3478 :         float fHalfHeight = (afMin[2] + afMax[2]) * 0.5f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _afMin$7[ebp+eax]
	addss	xmm0, DWORD PTR _afMax$6[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _fHalfHeight$5[ebp], xmm0

; 3479 : 
; 3480 :         // ccw from max x, max y to match the stored tex coords
; 3481 :         //m_afHorizontalCoords[0] = m_pTreeSizes[3];
; 3482 :         //m_afHorizontalCoords[1] = m_pTreeSizes[4];
; 3483 :         //m_afHorizontalCoords[2] = fHalfHeight;
; 3484 :         Assign3d(m_afHorizontalCoords + 0, CVec3(afMax[0], afMax[1], fHalfHeight));

	push	ecx
	movss	xmm0, DWORD PTR _fHalfHeight$5[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR _afMax$6[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR _afMax$6[ebp+edx]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	mov	ecx, eax
	call	??BCVec3@@QAEPAMXZ			; CVec3::operator float *
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 108				; 0000006cH
	push	eax
	call	?Assign3d@@YAXPAMPBM@Z			; Assign3d
	add	esp, 8

; 3485 : 
; 3486 :         //m_afHorizontalCoords[3] = m_pTreeSizes[0];
; 3487 :         //m_afHorizontalCoords[4] = m_pTreeSizes[4];
; 3488 :         //m_afHorizontalCoords[5] = fHalfHeight;
; 3489 :         Assign3d(m_afHorizontalCoords + 3, CVec3(afMin[0], afMax[1], fHalfHeight));

	push	ecx
	movss	xmm0, DWORD PTR _fHalfHeight$5[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR _afMax$6[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR _afMin$7[ebp+edx]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	mov	ecx, eax
	call	??BCVec3@@QAEPAMXZ			; CVec3::operator float *
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 120				; 00000078H
	push	eax
	call	?Assign3d@@YAXPAMPBM@Z			; Assign3d
	add	esp, 8

; 3490 : 
; 3491 :         //m_afHorizontalCoords[6] = m_pTreeSizes[0];
; 3492 :         //m_afHorizontalCoords[7] = m_pTreeSizes[1];
; 3493 :         //m_afHorizontalCoords[8] = fHalfHeight;
; 3494 :         Assign3d(m_afHorizontalCoords + 6, CVec3(afMin[0], afMin[1], fHalfHeight));

	push	ecx
	movss	xmm0, DWORD PTR _fHalfHeight$5[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR _afMin$7[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR _afMin$7[ebp+edx]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	mov	ecx, eax
	call	??BCVec3@@QAEPAMXZ			; CVec3::operator float *
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 132				; 00000084H
	push	eax
	call	?Assign3d@@YAXPAMPBM@Z			; Assign3d
	add	esp, 8

; 3495 : 
; 3496 :         //m_afHorizontalCoords[9] = m_pTreeSizes[3];
; 3497 :         //m_afHorizontalCoords[10] = m_pTreeSizes[1];
; 3498 :         //m_afHorizontalCoords[11] = fHalfHeight;
; 3499 :         Assign3d(m_afHorizontalCoords + 9, CVec3(afMax[0], afMin[1], fHalfHeight));

	push	ecx
	movss	xmm0, DWORD PTR _fHalfHeight$5[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR _afMin$7[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR _afMax$6[ebp+edx]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	mov	ecx, eax
	call	??BCVec3@@QAEPAMXZ			; CVec3::operator float *
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	push	eax
	call	?Assign3d@@YAXPAMPBM@Z			; Assign3d
	add	esp, 8
$LN2@SetupHoriz:

; 3500 :     }
; 3501 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@SetupHoriz
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@SetupHoriz:
	DD	2
	DD	$LN6@SetupHoriz
$LN6@SetupHoriz:
	DD	-32					; ffffffe0H
	DD	12					; 0000000cH
	DD	$LN4@SetupHoriz
	DD	-52					; ffffffccH
	DD	12					; 0000000cH
	DD	$LN5@SetupHoriz
$LN5@SetupHoriz:
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	120					; 00000078H
	DB	0
$LN4@SetupHoriz:
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	77					; 0000004dH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	0
?SetupHorizontalBillboard@CSpeedTreeRT@@AAEXXZ ENDP	; CSpeedTreeRT::SetupHorizontalBillboard
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetTransitionValues@CSpeedTreeRT@@CAXMGMMMMAAM0AAF1@Z
_TEXT	SEGMENT
tv180 = -268						; size = 4
tv157 = -268						; size = 4
tv141 = -268						; size = 4
tv131 = -266						; size = 2
_fAmountOfLow$1 = -68					; size = 4
_fAmountOfHigh$2 = -56					; size = 4
_fTransitionStage$3 = -44				; size = 4
_fDistanceToTransitionPoint$ = -32			; size = 4
_usDiscreteTransitionPoint$ = -20			; size = 2
_fLodWidth$ = -8					; size = 4
_fLodLevel$ = 8						; size = 4
_usLodCount$ = 12					; size = 2
_fOverlapRadius$ = 16					; size = 4
_fTransitionFactor$ = 20				; size = 4
_fCurveExponent$ = 24					; size = 4
_fTargetAlphaValue$ = 28				; size = 4
_fHighValue$ = 32					; size = 4
_fLowValue$ = 36					; size = 4
_sHighLod$ = 40						; size = 4
_sLowLod$ = 44						; size = 4
?GetTransitionValues@CSpeedTreeRT@@CAXMGMMMMAAM0AAF1@Z PROC ; CSpeedTreeRT::GetTransitionValues, COMDAT

; 3225 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-76]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3226 :     float fLodWidth = 1.0f / usLodCount;

	movzx	eax, WORD PTR _usLodCount$[ebp]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movss	DWORD PTR _fLodWidth$[ebp], xmm1

; 3227 :     unsigned short usDiscreteTransitionPoint = static_cast<unsigned short>(RoundToNearestInt((1.0f - fLodLevel) / fLodWidth));

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _fLodLevel$[ebp]
	divss	xmm0, DWORD PTR _fLodWidth$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?RoundToNearestInt@@YAHM@Z		; RoundToNearestInt
	add	esp, 4
	mov	WORD PTR _usDiscreteTransitionPoint$[ebp], ax

; 3228 :     float fDistanceToTransitionPoint = (1.0f - fLodLevel) - usDiscreteTransitionPoint * fLodWidth;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _fLodLevel$[ebp]
	movzx	eax, WORD PTR _usDiscreteTransitionPoint$[ebp]
	cvtsi2ss xmm1, eax
	mulss	xmm1, DWORD PTR _fLodWidth$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _fDistanceToTransitionPoint$[ebp], xmm0

; 3229 : 
; 3230 :     // check to see if there is no overlap
; 3231 :     if (usDiscreteTransitionPoint == 0 ||
; 3232 :         usDiscreteTransitionPoint == usLodCount ||

	movzx	eax, WORD PTR _usDiscreteTransitionPoint$[ebp]
	test	eax, eax
	je	SHORT $LN4@GetTransit
	movzx	eax, WORD PTR _usDiscreteTransitionPoint$[ebp]
	movzx	ecx, WORD PTR _usLodCount$[ebp]
	cmp	eax, ecx
	je	SHORT $LN4@GetTransit
	push	ecx
	movss	xmm0, DWORD PTR _fDistanceToTransitionPoint$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv180[ebp]
	movss	xmm0, DWORD PTR tv180[ebp]
	comiss	xmm0, DWORD PTR _fOverlapRadius$[ebp]
	jbe	$LN2@GetTransit
$LN4@GetTransit:

; 3233 :         fabs(fDistanceToTransitionPoint) > fOverlapRadius)
; 3234 :     {
; 3235 :         // high LOD
; 3236 :         fHighValue = fTargetAlphaValue;

	mov	eax, DWORD PTR _fHighValue$[ebp]
	movss	xmm0, DWORD PTR _fTargetAlphaValue$[ebp]
	movss	DWORD PTR [eax], xmm0

; 3237 :         sHighLod = static_cast<short>((1.0f - fLodLevel) * usLodCount);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _fLodLevel$[ebp]
	movzx	eax, WORD PTR _usLodCount$[ebp]
	cvtsi2ss xmm1, eax
	mulss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _sHighLod$[ebp]
	mov	WORD PTR [edx], cx

; 3238 :         sHighLod = __min(sHighLod, static_cast<short>(usLodCount - 1));

	mov	eax, DWORD PTR _sHighLod$[ebp]
	movsx	ecx, WORD PTR [eax]
	movzx	edx, WORD PTR _usLodCount$[ebp]
	sub	edx, 1
	movsx	eax, dx
	cmp	ecx, eax
	jge	SHORT $LN6@GetTransit
	mov	ecx, DWORD PTR _sHighLod$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR tv131[ebp], dx
	jmp	SHORT $LN7@GetTransit
$LN6@GetTransit:
	movzx	eax, WORD PTR _usLodCount$[ebp]
	sub	eax, 1
	mov	WORD PTR tv131[ebp], ax
$LN7@GetTransit:
	mov	ecx, DWORD PTR _sHighLod$[ebp]
	mov	dx, WORD PTR tv131[ebp]
	mov	WORD PTR [ecx], dx

; 3239 : 
; 3240 :         // low LOD (inactive)
; 3241 :         fLowValue = 255.0f;

	mov	eax, DWORD PTR _fLowValue$[ebp]
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [eax], xmm0

; 3242 :         sLowLod = -1;

	or	eax, -1
	mov	ecx, DWORD PTR _sLowLod$[ebp]
	mov	WORD PTR [ecx], ax

; 3243 :     }

	jmp	$LN3@GetTransit
$LN2@GetTransit:

; 3244 :     else // yes there is an overlap, so two factors are needed
; 3245 :     {
; 3246 :         // transition stage ranges from 0.0 (high LOD side) to 1.0 (low LOD side)
; 3247 :         float fTransitionStage = 1.0f - (fOverlapRadius - fDistanceToTransitionPoint) / (2.0f * fOverlapRadius);

	movss	xmm0, DWORD PTR _fOverlapRadius$[ebp]
	subss	xmm0, DWORD PTR _fDistanceToTransitionPoint$[ebp]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, DWORD PTR _fOverlapRadius$[ebp]
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR _fTransitionStage$3[ebp], xmm1

; 3248 : 
; 3249 :         // high LOD
; 3250 :         float fAmountOfHigh = 1.0f - (fTransitionStage - fTransitionFactor) / (1.0f - fTransitionFactor);

	movss	xmm0, DWORD PTR _fTransitionStage$3[ebp]
	subss	xmm0, DWORD PTR _fTransitionFactor$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _fTransitionFactor$[ebp]
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR _fAmountOfHigh$2[ebp], xmm1

; 3251 :         fAmountOfHigh = __min(fAmountOfHigh, 1.0f); // cap at 1.0

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _fAmountOfHigh$2[ebp]
	jbe	SHORT $LN8@GetTransit
	movss	xmm0, DWORD PTR _fAmountOfHigh$2[ebp]
	movss	DWORD PTR tv141[ebp], xmm0
	jmp	SHORT $LN9@GetTransit
$LN8@GetTransit:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv141[ebp], xmm0
$LN9@GetTransit:
	movss	xmm0, DWORD PTR tv141[ebp]
	movss	DWORD PTR _fAmountOfHigh$2[ebp], xmm0

; 3252 :         sHighLod = usDiscreteTransitionPoint - 1;

	movzx	eax, WORD PTR _usDiscreteTransitionPoint$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _sHighLod$[ebp]
	mov	WORD PTR [ecx], ax

; 3253 :         fHighValue = VecInterpolate(fTargetAlphaValue, 255.0f, powf((1.0f - fAmountOfHigh), fCurveExponent));

	push	ecx
	movss	xmm0, DWORD PTR _fCurveExponent$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _fAmountOfHigh$2[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_powf
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fTargetAlphaValue$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?VecInterpolate@@YAMMMM@Z		; VecInterpolate
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _fHighValue$[ebp]
	fstp	DWORD PTR [eax]

; 3254 : 
; 3255 :         // low LOD
; 3256 :         float fAmountOfLow = fTransitionStage / (1.0f - fTransitionFactor);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _fTransitionFactor$[ebp]
	movss	xmm1, DWORD PTR _fTransitionStage$3[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _fAmountOfLow$1[ebp], xmm1

; 3257 :         fAmountOfLow = __min(fAmountOfLow, 1.0f); // cap at 1.0

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _fAmountOfLow$1[ebp]
	jbe	SHORT $LN10@GetTransit
	movss	xmm0, DWORD PTR _fAmountOfLow$1[ebp]
	movss	DWORD PTR tv157[ebp], xmm0
	jmp	SHORT $LN11@GetTransit
$LN10@GetTransit:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv157[ebp], xmm0
$LN11@GetTransit:
	movss	xmm0, DWORD PTR tv157[ebp]
	movss	DWORD PTR _fAmountOfLow$1[ebp], xmm0

; 3258 :         sLowLod = usDiscreteTransitionPoint;

	mov	eax, DWORD PTR _sLowLod$[ebp]
	mov	cx, WORD PTR _usDiscreteTransitionPoint$[ebp]
	mov	WORD PTR [eax], cx

; 3259 :         fLowValue = VecInterpolate(fTargetAlphaValue, 255.0f, powf((1.0f - fAmountOfLow), fCurveExponent));

	push	ecx
	movss	xmm0, DWORD PTR _fCurveExponent$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _fAmountOfLow$1[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_powf
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fTargetAlphaValue$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?VecInterpolate@@YAMMMM@Z		; VecInterpolate
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _fLowValue$[ebp]
	fstp	DWORD PTR [eax]
$LN3@GetTransit:

; 3260 :     }
; 3261 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTransitionValues@CSpeedTreeRT@@CAXMGMMMMAAM0AAF1@Z ENDP ; CSpeedTreeRT::GetTransitionValues
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetSimpleBillboardGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@@Z
_TEXT	SEGMENT
tv195 = -268						; size = 4
tv145 = -268						; size = 4
_sLowLod$1 = -68					; size = 2
_sHighLod$2 = -56					; size = 2
_fLowLodAlphaValue$3 = -44				; size = 4
_fHighLodAlphaValue$4 = -32				; size = 4
_usLodStageCount$5 = -20				; size = 2
_this$ = -8						; size = 4
_sGeometry$ = 8						; size = 4
?GetSimpleBillboardGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@@Z PROC ; CSpeedTreeRT::GetSimpleBillboardGeometry, COMDAT
; _this$ = ecx

; 3147 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-76]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3148 :     // determine alpha test value and visibility
; 3149 :     if (m_bDropToBillboard && m_pEmbeddedTexCoords && m_pEmbeddedTexCoords->m_nNumBillboards > 0)

	movzx	eax, BYTE PTR ?m_bDropToBillboard@CSpeedTreeRT@@0_NA ; CSpeedTreeRT::m_bDropToBillboard
	test	eax, eax
	je	$LN2@GetSimpleB
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	$LN2@GetSimpleB
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	cmp	DWORD PTR [ecx+8], 0
	jle	$LN2@GetSimpleB

; 3150 :     {
; 3151 :         unsigned short usLodStageCount = GetNumLeafLodLevels( ) + 1; // add one for billboard

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumLeafLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumLeafLodLevels
	movzx	eax, ax
	add	eax, 1
	mov	WORD PTR _usLodStageCount$5[ebp], ax

; 3152 :         float fHighLodAlphaValue = -1.0f, fLowLodAlphaValue = -1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _fHighLodAlphaValue$4[ebp], xmm0
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _fLowLodAlphaValue$3[ebp], xmm0

; 3153 :         short sHighLod = -1, sLowLod = -1;

	or	eax, -1
	mov	WORD PTR _sHighLod$2[ebp], ax
	or	eax, -1
	mov	WORD PTR _sLowLod$1[ebp], ax

; 3154 :         GetTransitionValues(GetLodLevel( ), usLodStageCount, m_fLeafLodTransitionRadius, m_fLeafTransitionFactor, m_fLeafLodCurveExponent,

	lea	eax, DWORD PTR _sLowLod$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _sHighLod$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _fLowLodAlphaValue$3[ebp]
	push	edx
	lea	eax, DWORD PTR _fHighLodAlphaValue$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+68]
	cvtsi2ss xmm0, edx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+28]
	movss	DWORD PTR [esp], xmm0
	movzx	eax, WORD PTR _usLodStageCount$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLodLevel@CSpeedTreeRT@@QBEMXZ	; CSpeedTreeRT::GetLodLevel
	push	ecx
	fstp	DWORD PTR [esp]
	call	?GetTransitionValues@CSpeedTreeRT@@CAXMGMMMMAAM0AAF1@Z ; CSpeedTreeRT::GetTransitionValues
	add	esp, 40					; 00000028H

; 3155 :             float(m_ucTargetAlphaValue), fHighLodAlphaValue, fLowLodAlphaValue, sHighLod, sLowLod);
; 3156 : 
; 3157 :         // determine if either leaf LOD level should be a billboard
; 3158 :         sGeometry.m_sBillboard0.m_fAlphaTestValue = -1.0f;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+252], xmm0

; 3159 :         if (sHighLod == usLodStageCount - 1)

	movsx	eax, WORD PTR _sHighLod$2[ebp]
	movzx	ecx, WORD PTR _usLodStageCount$5[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	jne	SHORT $LN4@GetSimpleB

; 3160 :             sGeometry.m_sBillboard0.m_fAlphaTestValue = fHighLodAlphaValue;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	movss	xmm0, DWORD PTR _fHighLodAlphaValue$4[ebp]
	movss	DWORD PTR [eax+252], xmm0
	jmp	SHORT $LN6@GetSimpleB
$LN4@GetSimpleB:

; 3161 :         else if (sLowLod == usLodStageCount - 1)

	movsx	eax, WORD PTR _sLowLod$1[ebp]
	movzx	ecx, WORD PTR _usLodStageCount$5[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	jne	SHORT $LN6@GetSimpleB

; 3162 :             sGeometry.m_sBillboard0.m_fAlphaTestValue = fLowLodAlphaValue;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	movss	xmm0, DWORD PTR _fLowLodAlphaValue$3[ebp]
	movss	DWORD PTR [eax+252], xmm0
$LN6@GetSimpleB:

; 3163 : 
; 3164 :         // setup first billboard layer
; 3165 :         sGeometry.m_sBillboard0.m_bIsActive = (sGeometry.m_sBillboard0.m_fAlphaTestValue != -1.0f);

	mov	eax, DWORD PTR _sGeometry$[ebp]
	movss	xmm0, DWORD PTR [eax+252]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@GetSimpleB
	mov	DWORD PTR tv145[ebp], 1
	jmp	SHORT $LN12@GetSimpleB
$LN11@GetSimpleB:
	mov	DWORD PTR tv145[ebp], 0
$LN12@GetSimpleB:
	mov	ecx, DWORD PTR _sGeometry$[ebp]
	mov	dl, BYTE PTR tv145[ebp]
	mov	BYTE PTR [ecx+240], dl

; 3166 :         if (sGeometry.m_sBillboard0.m_bIsActive)

	mov	eax, DWORD PTR _sGeometry$[ebp]
	movzx	ecx, BYTE PTR [eax+240]
	test	ecx, ecx
	je	SHORT $LN7@GetSimpleB

; 3167 :         {
; 3168 :             // find appropriate coordinates
; 3169 :             #ifdef UPVECTOR_POS_Z
; 3170 :                 sGeometry.m_sBillboard0.m_pCoords = m_pSimpleBillboard->GetBillboardCoords(m_pTreeSizes[STS_BB_SIZE], m_pTreeSizes[STS_MAX_BOX + 2]);

	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?GetBillboardCoords@CSimpleBillboard@@QAEPBMMM@Z ; CSimpleBillboard::GetBillboardCoords
	mov	ecx, DWORD PTR _sGeometry$[ebp]
	mov	DWORD PTR [ecx+248], eax

; 3171 :             #else
; 3172 :                 sGeometry.m_sBillboard0.m_pCoords = m_pSimpleBillboard->GetBillboardCoords(m_pTreeSizes[STS_BB_SIZE], fabs(m_pTreeSizes[STS_MAX_BOX + 1]));
; 3173 :             #endif
; 3174 : 
; 3175 :             // assign texture coordinates - the 0 (zero) can be a billboard index ranging from
; 3176 :             // zero to m_pEmbeddedTexCoords->m_nNumBillboards - 1
; 3177 :             sGeometry.m_sBillboard0.m_pTexCoords = m_pEmbeddedTexCoords->m_pBillboardTexCoords + 0 * 8;;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _sGeometry$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+244], eax
$LN7@GetSimpleB:

; 3178 :         }
; 3179 : 
; 3180 :         // second billboard layer is always off for simple billboard
; 3181 :         sGeometry.m_sBillboard1.m_bIsActive = false;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	BYTE PTR [eax+256], 0

; 3182 : 
; 3183 :         // horizontal billboard
; 3184 :         if (m_bHorizontalBillboard)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+105]
	test	ecx, ecx
	je	$LN8@GetSimpleB

; 3185 :         {
; 3186 :             // always the plane that bisects the bounding box (computed once at initialization)
; 3187 :             sGeometry.m_sHorizontalBillboard.m_pCoords = m_afHorizontalCoords;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 108				; 0000006cH
	mov	ecx, DWORD PTR _sGeometry$[ebp]
	mov	DWORD PTR [ecx+280], eax

; 3188 : 
; 3189 :             // the horizontal billboard is always the last billboard in the billboard sequence
; 3190 :             sGeometry.m_sHorizontalBillboard.m_pTexCoords = m_pEmbeddedTexCoords->m_pBillboardTexCoords + (m_pEmbeddedTexCoords->m_nNumBillboards - 1) * 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	edx, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [edx*8-8]
	mov	ecx, DWORD PTR [ecx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	DWORD PTR [eax+276], edx

; 3191 :             sGeometry.m_sHorizontalBillboard.m_fAlphaTestValue = sGeometry.m_sBillboard0.m_fAlphaTestValue;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	ecx, DWORD PTR _sGeometry$[ebp]
	mov	edx, DWORD PTR [ecx+252]
	mov	DWORD PTR [eax+284], edx

; 3192 :             sGeometry.m_sHorizontalBillboard.m_bIsActive = sGeometry.m_sHorizontalBillboard.m_fAlphaTestValue >= 0.0f;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	movss	xmm0, DWORD PTR [eax+284]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN13@GetSimpleB
	mov	DWORD PTR tv195[ebp], 1
	jmp	SHORT $LN14@GetSimpleB
$LN13@GetSimpleB:
	mov	DWORD PTR tv195[ebp], 0
$LN14@GetSimpleB:
	mov	ecx, DWORD PTR _sGeometry$[ebp]
	mov	dl, BYTE PTR tv195[ebp]
	mov	BYTE PTR [ecx+272], dl

; 3193 : 
; 3194 :             // compute the alpha fade value based on the camera angle
; 3195 :             sGeometry.m_sHorizontalBillboard.m_fAlphaTestValue = m_fHorizontalFadeValue;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	movss	xmm0, DWORD PTR ?m_fHorizontalFadeValue@CSpeedTreeRT@@0MA
	movss	DWORD PTR [eax+284], xmm0

; 3196 :         }

	jmp	SHORT $LN9@GetSimpleB
$LN8@GetSimpleB:

; 3197 :         else
; 3198 :             sGeometry.m_sHorizontalBillboard.m_bIsActive = false;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	BYTE PTR [eax+272], 0
$LN9@GetSimpleB:

; 3199 :     }

	jmp	SHORT $LN3@GetSimpleB
$LN2@GetSimpleB:

; 3200 :     else
; 3201 :     {
; 3202 :         sGeometry.m_sBillboard0.m_bIsActive = false;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	BYTE PTR [eax+240], 0

; 3203 :         sGeometry.m_sBillboard1.m_bIsActive = false;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	BYTE PTR [eax+256], 0

; 3204 :         sGeometry.m_sHorizontalBillboard.m_bIsActive = false;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	BYTE PTR [eax+272], 0
$LN3@GetSimpleB:

; 3205 :     }
; 3206 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@GetSimpleB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN20@GetSimpleB:
	DD	4
	DD	$LN19@GetSimpleB
$LN19@GetSimpleB:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN15@GetSimpleB
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN16@GetSimpleB
	DD	-56					; ffffffc8H
	DD	2
	DD	$LN17@GetSimpleB
	DD	-68					; ffffffbcH
	DD	2
	DD	$LN18@GetSimpleB
$LN18@GetSimpleB:
	DB	115					; 00000073H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	0
$LN17@GetSimpleB:
	DB	115					; 00000073H
	DB	72					; 00000048H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	0
$LN16@GetSimpleB:
	DB	102					; 00000066H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN15@GetSimpleB:
	DB	102					; 00000066H
	DB	72					; 00000048H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
?GetSimpleBillboardGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@@Z ENDP ; CSpeedTreeRT::GetSimpleBillboardGeometry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?Get360BillboardGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@K@Z
_TEXT	SEGMENT
$T1 = -372						; size = 12
_fLodValue$2 = -160					; size = 4
_fLodWidth$3 = -148					; size = 4
_usLodStageCount$4 = -136				; size = 2
_sSecondaryLod$5 = -124					; size = 2
_sPrimaryLod$6 = -112					; size = 2
_fSecondaryLodAlphaValue$7 = -100			; size = 4
_fPrimaryLodAlphaValue$8 = -88				; size = 4
_fAzimuth$9 = -76					; size = 4
_cCameraDir$10 = -64					; size = 12
_cCameraPos$11 = -44					; size = 12
_fFade$12 = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_sGeometry$ = 8						; size = 4
_ulBitVector$ = 12					; size = 4
?Get360BillboardGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@K@Z PROC ; CSpeedTreeRT::Get360BillboardGeometry, COMDAT
; _this$ = ecx

; 3070 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 376				; 00000178H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-184]
	mov	ecx, 46					; 0000002eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 3071 :     GetSimpleBillboardGeometry(sGeometry);

	mov	eax, DWORD PTR _sGeometry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSimpleBillboardGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@@Z ; CSpeedTreeRT::GetSimpleBillboardGeometry
	npad	1

; 3072 : 
; 3073 :     if (sGeometry.m_sBillboard0.m_bIsActive &&

	mov	eax, DWORD PTR _sGeometry$[ebp]
	movzx	ecx, BYTE PTR [eax+240]
	test	ecx, ecx
	je	$LN7@Get360Bill
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	$LN7@Get360Bill

; 3074 :         m_pEmbeddedTexCoords)
; 3075 :     {
; 3076 :         // the call to GetSimpleBillboardGoemetry() determines an alpha value that
; 3077 :         // reflects how much of the billboard should be seen vs. the 3D tree.  we
; 3078 :         // need to convert that to a floating scalar to multiply against the cross
; 3079 :         // fading alpha's determined below
; 3080 :         float fFade = (sGeometry.m_sBillboard0.m_fAlphaTestValue - m_ucTargetAlphaValue) / (255.0f - m_ucTargetAlphaValue);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+68]
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _sGeometry$[ebp]
	movss	xmm1, DWORD PTR [edx+252]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+68]
	cvtsi2ss xmm0, ecx
	movss	xmm2, DWORD PTR __real@437f0000
	subss	xmm2, xmm0
	divss	xmm1, xmm2
	movss	DWORD PTR _fFade$12[ebp], xmm1

; 3081 : 
; 3082 :         // get camera attributes
; 3083 :         CVec3 cCameraPos, cCameraDir;

	lea	ecx, DWORD PTR _cCameraPos$11[ebp]
	call	??0CVec3@@QAE@XZ			; CVec3::CVec3
	npad	1
	lea	ecx, DWORD PTR _cCameraDir$10[ebp]
	call	??0CVec3@@QAE@XZ			; CVec3::CVec3
	npad	1

; 3084 :         CTreeEngine::GetCamera(cCameraPos, cCameraDir);

	lea	eax, DWORD PTR _cCameraDir$10[ebp]
	push	eax
	lea	ecx, DWORD PTR _cCameraPos$11[ebp]
	push	ecx
	call	?GetCamera@CIdvCamera@@SAXAAVCVec3@@0@Z	; CIdvCamera::GetCamera
	add	esp, 8

; 3085 :         cCameraDir = -cCameraDir;

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _cCameraDir$10[ebp]
	call	??GCVec3@@QBE?AV0@XZ			; CVec3::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cCameraDir$10[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _cCameraDir$10[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _cCameraDir$10[ebp+8], eax

; 3086 :         float fAzimuth = ComputeAzimuth(cCameraDir);

	lea	ecx, DWORD PTR _cCameraDir$10[ebp]
	call	??BCVec3@@QAEPAMXZ			; CVec3::operator float *
	push	eax
	call	?ComputeAzimuth@@YAMPBM@Z		; ComputeAzimuth
	add	esp, 4
	fstp	DWORD PTR _fAzimuth$9[ebp]

; 3087 :         if (fAzimuth < 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _fAzimuth$9[ebp]
	jbe	SHORT $LN3@Get360Bill

; 3088 :             fAzimuth += 360.0f;

	movss	xmm0, DWORD PTR _fAzimuth$9[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _fAzimuth$9[ebp], xmm0
$LN3@Get360Bill:

; 3089 : 
; 3090 :         // find blending/LOD values for 360 degree blending between two billboards
; 3091 :         float fPrimaryLodAlphaValue = -1.0f, fSecondaryLodAlphaValue = -1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _fPrimaryLodAlphaValue$8[ebp], xmm0
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _fSecondaryLodAlphaValue$7[ebp], xmm0

; 3092 :         short sPrimaryLod = -1, sSecondaryLod = -1;

	or	eax, -1
	mov	WORD PTR _sPrimaryLod$6[ebp], ax
	or	eax, -1
	mov	WORD PTR _sSecondaryLod$5[ebp], ax

; 3093 :         unsigned short usLodStageCount = static_cast<unsigned short>(m_pEmbeddedTexCoords->m_nNumBillboards);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	dx, WORD PTR [ecx+8]
	mov	WORD PTR _usLodStageCount$4[ebp], dx

; 3094 :         float fLodWidth = 0.5f / usLodStageCount;

	movzx	eax, WORD PTR _usLodStageCount$4[ebp]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR __real@3f000000
	divss	xmm1, xmm0
	movss	DWORD PTR _fLodWidth$3[ebp], xmm1

; 3095 :         float fLodValue = VecInterpolate(fLodWidth, 1.0f - fLodWidth, fAzimuth / 360.0f);

	movss	xmm0, DWORD PTR _fAzimuth$9[ebp]
	divss	xmm0, DWORD PTR __real@43b40000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _fLodWidth$3[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fLodWidth$3[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?VecInterpolate@@YAMMMM@Z		; VecInterpolate
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR _fLodValue$2[ebp]

; 3096 :         GetTransitionValues(fLodValue, usLodStageCount, 0.5f / usLodStageCount, m_fLeafTransitionFactor, m_fLeafLodCurveExponent,

	lea	eax, DWORD PTR _sSecondaryLod$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _sPrimaryLod$6[ebp]
	push	ecx
	lea	edx, DWORD PTR _fSecondaryLodAlphaValue$7[ebp]
	push	edx
	lea	eax, DWORD PTR _fPrimaryLodAlphaValue$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+68]
	cvtsi2ss xmm0, edx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR [esp], xmm0
	movzx	edx, WORD PTR _usLodStageCount$4[ebp]
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR __real@3f000000
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movzx	eax, WORD PTR _usLodStageCount$4[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _fLodValue$2[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?GetTransitionValues@CSpeedTreeRT@@CAXMGMMMMAAM0AAF1@Z ; CSpeedTreeRT::GetTransitionValues
	add	esp, 40					; 00000028H

; 3097 :             float(m_ucTargetAlphaValue), fPrimaryLodAlphaValue, fSecondaryLodAlphaValue, sPrimaryLod, sSecondaryLod);
; 3098 : 
; 3099 :         // reverse them to account for leaf LOD reversed behavior
; 3100 :         sPrimaryLod = static_cast<short>((m_pEmbeddedTexCoords->m_nNumBillboards - 1) - sPrimaryLod);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 1
	movsx	eax, WORD PTR _sPrimaryLod$6[ebp]
	sub	edx, eax
	mov	WORD PTR _sPrimaryLod$6[ebp], dx

; 3101 :         sSecondaryLod = static_cast<unsigned short>((m_pEmbeddedTexCoords->m_nNumBillboards - 1) - sSecondaryLod);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 1
	movsx	eax, WORD PTR _sSecondaryLod$5[ebp]
	sub	edx, eax
	mov	WORD PTR _sSecondaryLod$5[ebp], dx

; 3102 : 
; 3103 :         // wrap index value if necessary
; 3104 :         if (sPrimaryLod == usLodStageCount - 1)

	movsx	eax, WORD PTR _sPrimaryLod$6[ebp]
	movzx	ecx, WORD PTR _usLodStageCount$4[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	jne	SHORT $LN4@Get360Bill

; 3105 :             sPrimaryLod = 0;

	xor	eax, eax
	mov	WORD PTR _sPrimaryLod$6[ebp], ax
$LN4@Get360Bill:

; 3106 :         if (sSecondaryLod == usLodStageCount - 1)

	movsx	eax, WORD PTR _sSecondaryLod$5[ebp]
	movzx	ecx, WORD PTR _usLodStageCount$4[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	jne	SHORT $LN5@Get360Bill

; 3107 :             sSecondaryLod = 0;

	xor	eax, eax
	mov	WORD PTR _sSecondaryLod$5[ebp], ax
$LN5@Get360Bill:

; 3108 : 
; 3109 :         if (ulBitVector & SpeedTree_Nearest360Override)

	mov	eax, DWORD PTR _ulBitVector$[ebp]
	and	eax, 32					; 00000020H
	je	$LN6@Get360Bill

; 3110 :         {
; 3111 :             sGeometry.m_sBillboard0.m_bIsActive = true;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	BYTE PTR [eax+240], 1

; 3112 : 
; 3113 :             // which billboard is dominant?
; 3114 :             if (fPrimaryLodAlphaValue < fSecondaryLodAlphaValue)

	movss	xmm0, DWORD PTR _fSecondaryLodAlphaValue$7[ebp]
	comiss	xmm0, DWORD PTR _fPrimaryLodAlphaValue$8[ebp]
	jbe	SHORT $LN8@Get360Bill

; 3115 :             {
; 3116 :                 sGeometry.m_sBillboard0.m_pTexCoords = m_pEmbeddedTexCoords->m_pBillboardTexCoords + sPrimaryLod * 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	movsx	edx, WORD PTR _sPrimaryLod$6[ebp]
	shl	edx, 3
	mov	eax, DWORD PTR [ecx+12]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _sGeometry$[ebp]
	mov	DWORD PTR [edx+244], ecx

; 3117 :                 sGeometry.m_sBillboard0.m_fAlphaTestValue = VecInterpolate(float(m_ucTargetAlphaValue), 255.0f, fFade);

	push	ecx
	movss	xmm0, DWORD PTR _fFade$12[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+68]
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?VecInterpolate@@YAMMMM@Z		; VecInterpolate
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _sGeometry$[ebp]
	fstp	DWORD PTR [edx+252]

; 3118 :                 sGeometry.m_sBillboard1.m_bIsActive = false;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	BYTE PTR [eax+256], 0

; 3119 :             }

	jmp	SHORT $LN9@Get360Bill
$LN8@Get360Bill:

; 3120 :             else
; 3121 :             {
; 3122 :                 sGeometry.m_sBillboard0.m_pTexCoords = m_pEmbeddedTexCoords->m_pBillboardTexCoords + sSecondaryLod * 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	movsx	edx, WORD PTR _sSecondaryLod$5[ebp]
	shl	edx, 3
	mov	eax, DWORD PTR [ecx+12]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _sGeometry$[ebp]
	mov	DWORD PTR [edx+244], ecx

; 3123 :                 sGeometry.m_sBillboard0.m_fAlphaTestValue = VecInterpolate(float(m_ucTargetAlphaValue), 255.0f, fFade);

	push	ecx
	movss	xmm0, DWORD PTR _fFade$12[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+68]
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?VecInterpolate@@YAMMMM@Z		; VecInterpolate
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _sGeometry$[ebp]
	fstp	DWORD PTR [edx+252]

; 3124 :                 sGeometry.m_sBillboard1.m_bIsActive = false;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	BYTE PTR [eax+256], 0
$LN9@Get360Bill:

; 3125 :             }
; 3126 :         }

	jmp	$LN7@Get360Bill
$LN6@Get360Bill:

; 3127 :         else
; 3128 :         {
; 3129 :             // assign texture coordinates - the 0 (zero) can be a billboard index ranging from
; 3130 :             // zero to m_pEmbeddedTexCoords->m_nNumBillboards - 1
; 3131 :             sGeometry.m_sBillboard0.m_pTexCoords = m_pEmbeddedTexCoords->m_pBillboardTexCoords + sPrimaryLod * 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	movsx	edx, WORD PTR _sPrimaryLod$6[ebp]
	shl	edx, 3
	mov	eax, DWORD PTR [ecx+12]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _sGeometry$[ebp]
	mov	DWORD PTR [edx+244], ecx

; 3132 :             sGeometry.m_sBillboard0.m_fAlphaTestValue = VecInterpolate(fPrimaryLodAlphaValue, 255.0f, fFade);

	push	ecx
	movss	xmm0, DWORD PTR _fFade$12[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fPrimaryLodAlphaValue$8[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?VecInterpolate@@YAMMMM@Z		; VecInterpolate
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _sGeometry$[ebp]
	fstp	DWORD PTR [eax+252]

; 3133 : 
; 3134 :             sGeometry.m_sBillboard1.m_pCoords = sGeometry.m_sBillboard0.m_pCoords;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	ecx, DWORD PTR _sGeometry$[ebp]
	mov	edx, DWORD PTR [ecx+248]
	mov	DWORD PTR [eax+264], edx

; 3135 :             sGeometry.m_sBillboard1.m_pTexCoords = m_pEmbeddedTexCoords->m_pBillboardTexCoords + sSecondaryLod * 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	movsx	edx, WORD PTR _sSecondaryLod$5[ebp]
	shl	edx, 3
	mov	eax, DWORD PTR [ecx+12]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _sGeometry$[ebp]
	mov	DWORD PTR [edx+260], ecx

; 3136 :             sGeometry.m_sBillboard1.m_bIsActive = true;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	BYTE PTR [eax+256], 1

; 3137 :             sGeometry.m_sBillboard1.m_fAlphaTestValue = VecInterpolate(fSecondaryLodAlphaValue, 255.0f, fFade);

	push	ecx
	movss	xmm0, DWORD PTR _fFade$12[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fSecondaryLodAlphaValue$7[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?VecInterpolate@@YAMMMM@Z		; VecInterpolate
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _sGeometry$[ebp]
	fstp	DWORD PTR [eax+268]
$LN7@Get360Bill:

; 3138 :         }
; 3139 :     }
; 3140 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@Get360Bill
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 376				; 00000178H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN18@Get360Bill:
	DD	6
	DD	$LN17@Get360Bill
$LN17@Get360Bill:
	DD	-44					; ffffffd4H
	DD	12					; 0000000cH
	DD	$LN11@Get360Bill
	DD	-64					; ffffffc0H
	DD	12					; 0000000cH
	DD	$LN12@Get360Bill
	DD	-88					; ffffffa8H
	DD	4
	DD	$LN13@Get360Bill
	DD	-100					; ffffff9cH
	DD	4
	DD	$LN14@Get360Bill
	DD	-112					; ffffff90H
	DD	2
	DD	$LN15@Get360Bill
	DD	-124					; ffffff84H
	DD	2
	DD	$LN16@Get360Bill
$LN16@Get360Bill:
	DB	115					; 00000073H
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	0
$LN15@Get360Bill:
	DB	115					; 00000073H
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	0
$LN14@Get360Bill:
	DB	102					; 00000066H
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN13@Get360Bill:
	DB	102					; 00000066H
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN12@Get360Bill:
	DB	99					; 00000063H
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	0
$LN11@Get360Bill:
	DB	99					; 00000063H
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	80					; 00000050H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	0
?Get360BillboardGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@K@Z ENDP ; CSpeedTreeRT::Get360BillboardGeometry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetLeafGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@F@Z
_TEXT	SEGMENT
tv353 = -380						; size = 4
tv247 = -380						; size = 4
tv223 = -380						; size = 4
tv91 = -380						; size = 4
_usDiscreteLodLevel$1 = -180				; size = 2
_sLowLod$2 = -168					; size = 2
_sHighLod$3 = -156					; size = 2
_fLowLodAlphaValue$4 = -144				; size = 4
_fHighLodAlphaValue$5 = -132				; size = 4
_fPitch$ = -120						; size = 4
_fAzimuth$ = -108					; size = 4
_cAdjustedDirection$ = -96				; size = 12
_cCameraDirection$ = -76				; size = 12
_cCameraPos$ = -56					; size = 12
_usLodStageCount$ = -36					; size = 2
_usLeafLodCount$ = -24					; size = 2
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_sGeometry$ = 8						; size = 4
_sOverrideLeafLodValue$ = 12				; size = 2
?GetLeafGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@F@Z PROC ; CSpeedTreeRT::GetLeafGeometry, COMDAT
; _this$ = ecx

; 2983 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 380				; 0000017cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-188]
	mov	ecx, 47					; 0000002fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2984 :     st_assert(m_pLeafGeometry);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@GetLeafGeo
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0??GetLeafGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@2@F@Z@4JA
	add	eax, 1
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@GetLeafGeo:

; 2985 : 
; 2986 :     unsigned short usLeafLodCount = GetNumLeafLodLevels( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumLeafLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumLeafLodLevels
	mov	WORD PTR _usLeafLodCount$[ebp], ax

; 2987 :     unsigned short usLodStageCount = usLeafLodCount + ((m_bDropToBillboard && m_pEmbeddedTexCoords && m_pEmbeddedTexCoords->m_nNumBillboards > 0) ? 1 : 0);

	movzx	eax, BYTE PTR ?m_bDropToBillboard@CSpeedTreeRT@@0_NA ; CSpeedTreeRT::m_bDropToBillboard
	test	eax, eax
	je	SHORT $LN14@GetLeafGeo
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+76], 0
	je	SHORT $LN14@GetLeafGeo
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	cmp	DWORD PTR [eax+8], 0
	jle	SHORT $LN14@GetLeafGeo
	mov	DWORD PTR tv91[ebp], 1
	jmp	SHORT $LN15@GetLeafGeo
$LN14@GetLeafGeo:
	mov	DWORD PTR tv91[ebp], 0
$LN15@GetLeafGeo:
	movzx	ecx, WORD PTR _usLeafLodCount$[ebp]
	add	ecx, DWORD PTR tv91[ebp]
	mov	WORD PTR _usLodStageCount$[ebp], cx

; 2988 : 
; 2989 :     // get camera attributes for billboarding
; 2990 :     CVec3 cCameraPos, cCameraDirection, cAdjustedDirection;

	lea	ecx, DWORD PTR _cCameraPos$[ebp]
	call	??0CVec3@@QAE@XZ			; CVec3::CVec3
	npad	1
	lea	ecx, DWORD PTR _cCameraDirection$[ebp]
	call	??0CVec3@@QAE@XZ			; CVec3::CVec3
	npad	1
	lea	ecx, DWORD PTR _cAdjustedDirection$[ebp]
	call	??0CVec3@@QAE@XZ			; CVec3::CVec3
	npad	1

; 2991 :     CTreeEngine::GetCamera(cCameraPos, cCameraDirection);

	lea	eax, DWORD PTR _cCameraDirection$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cCameraPos$[ebp]
	push	ecx
	call	?GetCamera@CIdvCamera@@SAXAAVCVec3@@0@Z	; CIdvCamera::GetCamera
	add	esp, 8

; 2992 : 
; 2993 :     // direction should be adjusted for application coordinate system
; 2994 :     Assign3d(cAdjustedDirection, cCameraDirection);

	lea	ecx, DWORD PTR _cCameraDirection$[ebp]
	call	??BCVec3@@QAEPAMXZ			; CVec3::operator float *
	push	eax
	lea	ecx, DWORD PTR _cAdjustedDirection$[ebp]
	call	??BCVec3@@QAEPAMXZ			; CVec3::operator float *
	push	eax
	call	?Assign3d@@YAXPAMPBM@Z			; Assign3d
	add	esp, 8

; 2995 :     float fAzimuth = VecRad2Deg(atan2f(cAdjustedDirection[1], cAdjustedDirection[0]));

	push	0
	lea	ecx, DWORD PTR _cAdjustedDirection$[ebp]
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	push	1
	lea	ecx, DWORD PTR _cAdjustedDirection$[ebp]
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	call	_atan2f
	add	esp, 4
	fstp	DWORD PTR [esp]
	call	?VecRad2Deg@@YAMM@Z			; VecRad2Deg
	add	esp, 4
	fstp	DWORD PTR _fAzimuth$[ebp]

; 2996 :     float fPitch = -VecRad2Deg(asinf(cAdjustedDirection[2]));

	push	2
	lea	ecx, DWORD PTR _cAdjustedDirection$[ebp]
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	call	_asinf
	fstp	DWORD PTR [esp]
	call	?VecRad2Deg@@YAMM@Z			; VecRad2Deg
	add	esp, 4
	fstp	DWORD PTR tv353[ebp]
	movss	xmm0, DWORD PTR tv353[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _fPitch$[ebp], xmm0

; 2997 : 
; 2998 :     if (sOverrideLeafLodValue > -1)

	movsx	eax, WORD PTR _sOverrideLeafLodValue$[ebp]
	cmp	eax, -1
	jle	$LN3@GetLeafGeo

; 2999 :     {
; 3000 :         st_assert(sOverrideLeafLodValue < GetNumLeafLodLevels( ));

	movsx	esi, WORD PTR _sOverrideLeafLodValue$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumLeafLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumLeafLodLevels
	movzx	eax, ax
	cmp	esi, eax
	jl	SHORT $LN5@GetLeafGeo
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0??GetLeafGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@2@F@Z@4JA
	add	eax, 17					; 00000011H
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN5@GetLeafGeo:

; 3001 : 
; 3002 :         // higher LOD layer only (since the app is requesting a single discrete LOD)
; 3003 :         m_pLeafGeometry->Update(sGeometry.m_sLeaves0, sOverrideLeafLodValue, fAzimuth, fPitch, m_fLeafSizeIncreaseFactor);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fPitch$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fAzimuth$[ebp]
	movss	DWORD PTR [esp], xmm0
	movzx	ecx, WORD PTR _sOverrideLeafLodValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sGeometry$[ebp]
	add	edx, 120				; 00000078H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?Update@CLeafGeometry@@QAEXAAUSLeaf@SGeometry@CSpeedTreeRT@@GMMM@Z ; CLeafGeometry::Update
	npad	1

; 3004 :         sGeometry.m_sLeaves0.m_bIsActive = true;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	BYTE PTR [eax+120], 1

; 3005 :         sGeometry.m_sLeaves0.m_fAlphaTestValue = m_ucTargetAlphaValue;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+68]
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _sGeometry$[ebp]
	movss	DWORD PTR [edx+124], xmm0

; 3006 : 
; 3007 :         // no LOD layer
; 3008 :         sGeometry.m_sLeaves1.m_bIsActive = false;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	BYTE PTR [eax+180], 0

; 3009 :     }

	jmp	$LN11@GetLeafGeo
$LN3@GetLeafGeo:

; 3010 :     else
; 3011 :     {
; 3012 :         // LOD_SMOOTH is most common
; 3013 :         if (m_eLeafLodMethod == LOD_SMOOTH)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 1
	jne	$LN6@GetLeafGeo

; 3014 :         {
; 3015 :             // determine alpha values for both leaf layers
; 3016 :             float fHighLodAlphaValue = -1.0f, fLowLodAlphaValue = -1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _fHighLodAlphaValue$5[ebp], xmm0
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _fLowLodAlphaValue$4[ebp], xmm0

; 3017 :             short sHighLod = -1, sLowLod = -1;

	or	eax, -1
	mov	WORD PTR _sHighLod$3[ebp], ax
	or	eax, -1
	mov	WORD PTR _sLowLod$2[ebp], ax

; 3018 :             GetTransitionValues(GetLodLevel( ), usLodStageCount, m_fLeafLodTransitionRadius, m_fLeafTransitionFactor, m_fLeafLodCurveExponent,

	lea	eax, DWORD PTR _sLowLod$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _sHighLod$3[ebp]
	push	ecx
	lea	edx, DWORD PTR _fLowLodAlphaValue$4[ebp]
	push	edx
	lea	eax, DWORD PTR _fHighLodAlphaValue$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+68]
	cvtsi2ss xmm0, edx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+28]
	movss	DWORD PTR [esp], xmm0
	movzx	eax, WORD PTR _usLodStageCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLodLevel@CSpeedTreeRT@@QBEMXZ	; CSpeedTreeRT::GetLodLevel
	push	ecx
	fstp	DWORD PTR [esp]
	call	?GetTransitionValues@CSpeedTreeRT@@CAXMGMMMMAAM0AAF1@Z ; CSpeedTreeRT::GetTransitionValues
	add	esp, 40					; 00000028H

; 3019 :                 float(m_ucTargetAlphaValue), fHighLodAlphaValue, fLowLodAlphaValue, sHighLod, sLowLod);
; 3020 : 
; 3021 :             // assign higher LOD layer
; 3022 :             sGeometry.m_sLeaves0.m_bIsActive = (sHighLod != -1 && sHighLod < usLeafLodCount);

	movsx	eax, WORD PTR _sHighLod$3[ebp]
	cmp	eax, -1
	je	SHORT $LN16@GetLeafGeo
	movsx	ecx, WORD PTR _sHighLod$3[ebp]
	movzx	edx, WORD PTR _usLeafLodCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN16@GetLeafGeo
	mov	DWORD PTR tv223[ebp], 1
	jmp	SHORT $LN17@GetLeafGeo
$LN16@GetLeafGeo:
	mov	DWORD PTR tv223[ebp], 0
$LN17@GetLeafGeo:
	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	cl, BYTE PTR tv223[ebp]
	mov	BYTE PTR [eax+120], cl

; 3023 :             if (sGeometry.m_sLeaves0.m_bIsActive)

	mov	eax, DWORD PTR _sGeometry$[ebp]
	movzx	ecx, BYTE PTR [eax+120]
	test	ecx, ecx
	je	SHORT $LN8@GetLeafGeo

; 3024 :             {
; 3025 :                 m_pLeafGeometry->Update(sGeometry.m_sLeaves0, sHighLod, fAzimuth, fPitch, m_fLeafSizeIncreaseFactor);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fPitch$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fAzimuth$[ebp]
	movss	DWORD PTR [esp], xmm0
	movzx	ecx, WORD PTR _sHighLod$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _sGeometry$[ebp]
	add	edx, 120				; 00000078H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?Update@CLeafGeometry@@QAEXAAUSLeaf@SGeometry@CSpeedTreeRT@@GMMM@Z ; CLeafGeometry::Update
	npad	1

; 3026 :                 sGeometry.m_sLeaves0.m_fAlphaTestValue = fHighLodAlphaValue;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	movss	xmm0, DWORD PTR _fHighLodAlphaValue$5[ebp]
	movss	DWORD PTR [eax+124], xmm0
$LN8@GetLeafGeo:

; 3027 :             }
; 3028 : 
; 3029 :             // assign lower LOD layer
; 3030 :             sGeometry.m_sLeaves1.m_bIsActive = (sLowLod != -1 && sLowLod < usLeafLodCount);

	movsx	eax, WORD PTR _sLowLod$2[ebp]
	cmp	eax, -1
	je	SHORT $LN18@GetLeafGeo
	movsx	ecx, WORD PTR _sLowLod$2[ebp]
	movzx	edx, WORD PTR _usLeafLodCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN18@GetLeafGeo
	mov	DWORD PTR tv247[ebp], 1
	jmp	SHORT $LN19@GetLeafGeo
$LN18@GetLeafGeo:
	mov	DWORD PTR tv247[ebp], 0
$LN19@GetLeafGeo:
	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	cl, BYTE PTR tv247[ebp]
	mov	BYTE PTR [eax+180], cl

; 3031 :             if (sGeometry.m_sLeaves1.m_bIsActive)

	mov	eax, DWORD PTR _sGeometry$[ebp]
	movzx	ecx, BYTE PTR [eax+180]
	test	ecx, ecx
	je	SHORT $LN9@GetLeafGeo

; 3032 :             {
; 3033 :                 m_pLeafGeometry->Update(sGeometry.m_sLeaves1, sLowLod, fAzimuth, fPitch, m_fLeafSizeIncreaseFactor);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fPitch$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fAzimuth$[ebp]
	movss	DWORD PTR [esp], xmm0
	movzx	ecx, WORD PTR _sLowLod$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _sGeometry$[ebp]
	add	edx, 180				; 000000b4H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?Update@CLeafGeometry@@QAEXAAUSLeaf@SGeometry@CSpeedTreeRT@@GMMM@Z ; CLeafGeometry::Update
	npad	1

; 3034 :                 sGeometry.m_sLeaves1.m_fAlphaTestValue = fLowLodAlphaValue;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	movss	xmm0, DWORD PTR _fLowLodAlphaValue$4[ebp]
	movss	DWORD PTR [eax+184], xmm0
$LN9@GetLeafGeo:

; 3035 :             }
; 3036 :         }

	jmp	$LN11@GetLeafGeo
$LN6@GetLeafGeo:

; 3037 :         // no LOD is active, always use highest
; 3038 :         else if (m_eLeafLodMethod == LOD_NONE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 3
	jne	SHORT $LN10@GetLeafGeo

; 3039 :         {
; 3040 :             // set leaf layer 0
; 3041 :             m_pLeafGeometry->Update(sGeometry.m_sLeaves0, 0, fAzimuth, fPitch, m_fLeafSizeIncreaseFactor);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fPitch$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fAzimuth$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR _sGeometry$[ebp]
	add	ecx, 120				; 00000078H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	call	?Update@CLeafGeometry@@QAEXAAUSLeaf@SGeometry@CSpeedTreeRT@@GMMM@Z ; CLeafGeometry::Update
	npad	1

; 3042 :             sGeometry.m_sLeaves0.m_bIsActive = true;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	BYTE PTR [eax+120], 1

; 3043 :             sGeometry.m_sLeaves0.m_fAlphaTestValue = m_ucTargetAlphaValue;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+68]
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _sGeometry$[ebp]
	movss	DWORD PTR [edx+124], xmm0

; 3044 :             
; 3045 :             // set leaf layer 1
; 3046 :             sGeometry.m_sLeaves1.m_bIsActive = false;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	BYTE PTR [eax+180], 0

; 3047 :         }

	jmp	$LN11@GetLeafGeo
$LN10@GetLeafGeo:

; 3048 :         else // assume LOD_POP (do hard transitions between LODs)
; 3049 :         {
; 3050 :             // set leaf layer 0
; 3051 :             unsigned short usDiscreteLodLevel = GetDiscreteLeafLodLevel( );

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiscreteLeafLodLevel@CSpeedTreeRT@@QBEGM@Z ; CSpeedTreeRT::GetDiscreteLeafLodLevel
	mov	WORD PTR _usDiscreteLodLevel$1[ebp], ax

; 3052 :             if (usDiscreteLodLevel < GetNumLeafLodLevels( ))

	movzx	esi, WORD PTR _usDiscreteLodLevel$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumLeafLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumLeafLodLevels
	movzx	eax, ax
	cmp	esi, eax
	jge	SHORT $LN12@GetLeafGeo

; 3053 :             {
; 3054 :                 m_pLeafGeometry->Update(sGeometry.m_sLeaves0, usDiscreteLodLevel, fAzimuth, fPitch, m_fLeafSizeIncreaseFactor);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fPitch$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fAzimuth$[ebp]
	movss	DWORD PTR [esp], xmm0
	movzx	ecx, WORD PTR _usDiscreteLodLevel$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _sGeometry$[ebp]
	add	edx, 120				; 00000078H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?Update@CLeafGeometry@@QAEXAAUSLeaf@SGeometry@CSpeedTreeRT@@GMMM@Z ; CLeafGeometry::Update
	npad	1

; 3055 :                 sGeometry.m_sLeaves0.m_bIsActive = true;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	BYTE PTR [eax+120], 1

; 3056 :                 sGeometry.m_sLeaves0.m_fAlphaTestValue = m_ucTargetAlphaValue;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+68]
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _sGeometry$[ebp]
	movss	DWORD PTR [edx+124], xmm0
$LN12@GetLeafGeo:

; 3057 :             }
; 3058 :             
; 3059 :             // set leaf layer 1
; 3060 :             sGeometry.m_sLeaves1.m_bIsActive = false;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	BYTE PTR [eax+180], 0
$LN11@GetLeafGeo:
$LN1@GetLeafGeo:

; 3061 :         }
; 3062 :     }
; 3063 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN28@GetLeafGeo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 380				; 0000017cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN28@GetLeafGeo:
	DD	7
	DD	$LN27@GetLeafGeo
$LN27@GetLeafGeo:
	DD	-56					; ffffffc8H
	DD	12					; 0000000cH
	DD	$LN20@GetLeafGeo
	DD	-76					; ffffffb4H
	DD	12					; 0000000cH
	DD	$LN21@GetLeafGeo
	DD	-96					; ffffffa0H
	DD	12					; 0000000cH
	DD	$LN22@GetLeafGeo
	DD	-132					; ffffff7cH
	DD	4
	DD	$LN23@GetLeafGeo
	DD	-144					; ffffff70H
	DD	4
	DD	$LN24@GetLeafGeo
	DD	-156					; ffffff64H
	DD	2
	DD	$LN25@GetLeafGeo
	DD	-168					; ffffff58H
	DD	2
	DD	$LN26@GetLeafGeo
$LN26@GetLeafGeo:
	DB	115					; 00000073H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	0
$LN25@GetLeafGeo:
	DB	115					; 00000073H
	DB	72					; 00000048H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	0
$LN24@GetLeafGeo:
	DB	102					; 00000066H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN23@GetLeafGeo:
	DB	102					; 00000066H
	DB	72					; 00000048H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN22@GetLeafGeo:
	DB	99					; 00000063H
	DB	65					; 00000041H
	DB	100					; 00000064H
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN21@GetLeafGeo:
	DB	99					; 00000063H
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN20@GetLeafGeo:
	DB	99					; 00000063H
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	80					; 00000050H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	0
?GetLeafGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@F@Z ENDP ; CSpeedTreeRT::GetLeafGeometry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetFrondGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@F@Z
_TEXT	SEGMENT
tv144 = -290						; size = 2
_sLowLod$1 = -92					; size = 2
_sHighLod$2 = -80					; size = 2
_fLowLodAlphaValue$3 = -68				; size = 4
_fHighLodAlphaValue$4 = -56				; size = 4
_usLodStageCount$5 = -44				; size = 2
_sLodLevel$6 = -32					; size = 2
_sFronds$7 = -20					; size = 4
_this$ = -8						; size = 4
_sGeometry$ = 8						; size = 4
_sOverrideLodValue$ = 12				; size = 2
?GetFrondGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@F@Z PROC ; CSpeedTreeRT::GetFrondGeometry, COMDAT
; _this$ = ecx

; 2927 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-100]
	mov	ecx, 25					; 00000019H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2928 :     if (m_pFrondGeometry)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	$LN2@GetFrondGe

; 2929 :     {
; 2930 :         SGeometry::SIndexed& sFronds = sGeometry.m_sFronds;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	add	eax, 60					; 0000003cH
	mov	DWORD PTR _sFronds$7[ebp], eax

; 2931 : 
; 2932 :         // get vertex attributes
; 2933 :         sFronds.m_usVertexCount = m_pFrondGeometry->GetVertexCount( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	?GetVertexCount@CIndexedGeometry@@QBEGXZ ; CIndexedGeometry::GetVertexCount
	mov	ecx, DWORD PTR _sFronds$7[ebp]
	mov	WORD PTR [ecx+16], ax

; 2934 :         sFronds.m_pColors = m_pFrondGeometry->GetVertexColors( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	?GetVertexColors@CIndexedGeometry@@QBEPBKXZ ; CIndexedGeometry::GetVertexColors
	mov	ecx, DWORD PTR _sFronds$7[ebp]
	mov	DWORD PTR [ecx+20], eax

; 2935 :         sFronds.m_pCoords = m_pFrondGeometry->GetVertexCoords( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	?GetVertexCoords@CIndexedGeometry@@QBEPBMXZ ; CIndexedGeometry::GetVertexCoords
	mov	ecx, DWORD PTR _sFronds$7[ebp]
	mov	DWORD PTR [ecx+36], eax

; 2936 :         sFronds.m_pNormals = m_pFrondGeometry->GetVertexNormals( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	?GetVertexNormals@CIndexedGeometry@@QBEPBMXZ ; CIndexedGeometry::GetVertexNormals
	mov	ecx, DWORD PTR _sFronds$7[ebp]
	mov	DWORD PTR [ecx+24], eax

; 2937 :         sFronds.m_pBinormals = m_pFrondGeometry->GetVertexBinormals( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	?GetVertexBinormals@CIndexedGeometry@@QBEPBMXZ ; CIndexedGeometry::GetVertexBinormals
	mov	ecx, DWORD PTR _sFronds$7[ebp]
	mov	DWORD PTR [ecx+28], eax

; 2938 :         sFronds.m_pTangents = m_pFrondGeometry->GetVertexTangents( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	?GetVertexTangents@CIndexedGeometry@@QBEPBMXZ ; CIndexedGeometry::GetVertexTangents
	mov	ecx, DWORD PTR _sFronds$7[ebp]
	mov	DWORD PTR [ecx+32], eax

; 2939 :         sFronds.m_pTexCoords0 = m_pFrondGeometry->GetVertexTexCoords0( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	?GetVertexTexCoords0@CIndexedGeometry@@QBEPBMXZ ; CIndexedGeometry::GetVertexTexCoords0
	mov	ecx, DWORD PTR _sFronds$7[ebp]
	mov	DWORD PTR [ecx+40], eax

; 2940 :         sFronds.m_pTexCoords1 = m_pFrondGeometry->GetVertexTexCoords1( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	?GetVertexTexCoords1@CIndexedGeometry@@QBEPBMXZ ; CIndexedGeometry::GetVertexTexCoords1
	mov	ecx, DWORD PTR _sFronds$7[ebp]
	mov	DWORD PTR [ecx+44], eax

; 2941 :         sFronds.m_pWindWeights = m_pFrondGeometry->GetVertexWindWeights( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	?GetVertexWindWeights@CIndexedGeometry@@QBEPBMXZ ; CIndexedGeometry::GetVertexWindWeights
	mov	ecx, DWORD PTR _sFronds$7[ebp]
	mov	DWORD PTR [ecx+48], eax

; 2942 :         sFronds.m_pWindMatrixIndices = m_pFrondGeometry->GetVertexWindMatrixIndices( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	?GetVertexWindMatrixIndices@CIndexedGeometry@@QBEPBEXZ ; CIndexedGeometry::GetVertexWindMatrixIndices
	mov	ecx, DWORD PTR _sFronds$7[ebp]
	mov	DWORD PTR [ecx+52], eax

; 2943 : 
; 2944 :         // get indexing data
; 2945 :         short sLodLevel = (sOverrideLodValue == -1) ? GetDiscreteFrondLodLevel( ) : sOverrideLodValue;

	movsx	eax, WORD PTR _sOverrideLodValue$[ebp]
	cmp	eax, -1
	jne	SHORT $LN11@GetFrondGe
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiscreteFrondLodLevel@CSpeedTreeRT@@QBEFM@Z ; CSpeedTreeRT::GetDiscreteFrondLodLevel
	mov	WORD PTR tv144[ebp], ax
	jmp	SHORT $LN12@GetFrondGe
$LN11@GetFrondGe:
	mov	cx, WORD PTR _sOverrideLodValue$[ebp]
	mov	WORD PTR tv144[ebp], cx
$LN12@GetFrondGe:
	mov	dx, WORD PTR tv144[ebp]
	mov	WORD PTR _sLodLevel$6[ebp], dx

; 2946 : 
; 2947 :         sFronds.m_nDiscreteLodLevel = sLodLevel;

	movsx	eax, WORD PTR _sLodLevel$6[ebp]
	mov	ecx, DWORD PTR _sFronds$7[ebp]
	mov	DWORD PTR [ecx], eax

; 2948 :         sFronds.m_usNumStrips = m_pFrondGeometry->GetNumStrips(sLodLevel);

	movzx	eax, WORD PTR _sLodLevel$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+92]
	call	?GetNumStrips@CIndexedGeometry@@QBEGF@Z	; CIndexedGeometry::GetNumStrips
	mov	edx, DWORD PTR _sFronds$7[ebp]
	mov	WORD PTR [edx+4], ax

; 2949 :         sFronds.m_pStripLengths = m_pFrondGeometry->GetStripLengthsPointer(sLodLevel);

	movzx	eax, WORD PTR _sLodLevel$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+92]
	call	?GetStripLengthsPointer@CIndexedGeometry@@QBEPBGG@Z ; CIndexedGeometry::GetStripLengthsPointer
	mov	edx, DWORD PTR _sFronds$7[ebp]
	mov	DWORD PTR [edx+8], eax

; 2950 :         sFronds.m_pStrips = (const unsigned short**) m_pFrondGeometry->GetStripsPointer(sLodLevel);

	movzx	eax, WORD PTR _sLodLevel$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+92]
	call	?GetStripsPointer@CIndexedGeometry@@QBEPAPAGG@Z ; CIndexedGeometry::GetStripsPointer
	mov	edx, DWORD PTR _sFronds$7[ebp]
	mov	DWORD PTR [edx+12], eax

; 2951 : 
; 2952 :         // determine alpha test value
; 2953 :         if (m_bDropToBillboard && m_pEmbeddedTexCoords && m_pEmbeddedTexCoords->m_nNumBillboards > 0)

	movzx	eax, BYTE PTR ?m_bDropToBillboard@CSpeedTreeRT@@0_NA ; CSpeedTreeRT::m_bDropToBillboard
	test	eax, eax
	je	$LN4@GetFrondGe
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	$LN4@GetFrondGe
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	cmp	DWORD PTR [ecx+8], 0
	jle	$LN4@GetFrondGe

; 2954 :         {
; 2955 :             unsigned short usLodStageCount = GetNumLeafLodLevels( ) + 1; // add one for billboard

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumLeafLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumLeafLodLevels
	movzx	eax, ax
	add	eax, 1
	mov	WORD PTR _usLodStageCount$5[ebp], ax

; 2956 :             float fHighLodAlphaValue = -1.0f, fLowLodAlphaValue = -1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _fHighLodAlphaValue$4[ebp], xmm0
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _fLowLodAlphaValue$3[ebp], xmm0

; 2957 :             short sHighLod = -1, sLowLod = -1;

	or	eax, -1
	mov	WORD PTR _sHighLod$2[ebp], ax
	or	eax, -1
	mov	WORD PTR _sLowLod$1[ebp], ax

; 2958 :             GetTransitionValues(GetLodLevel( ), usLodStageCount, m_fLeafLodTransitionRadius, m_fLeafTransitionFactor, m_fLeafLodCurveExponent,

	lea	eax, DWORD PTR _sLowLod$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _sHighLod$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _fLowLodAlphaValue$3[ebp]
	push	edx
	lea	eax, DWORD PTR _fHighLodAlphaValue$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+68]
	cvtsi2ss xmm0, edx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+28]
	movss	DWORD PTR [esp], xmm0
	movzx	eax, WORD PTR _usLodStageCount$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLodLevel@CSpeedTreeRT@@QBEMXZ	; CSpeedTreeRT::GetLodLevel
	push	ecx
	fstp	DWORD PTR [esp]
	call	?GetTransitionValues@CSpeedTreeRT@@CAXMGMMMMAAM0AAF1@Z ; CSpeedTreeRT::GetTransitionValues
	add	esp, 40					; 00000028H

; 2959 :                 float(m_ucTargetAlphaValue), fHighLodAlphaValue, fLowLodAlphaValue, sHighLod, sLowLod);
; 2960 : 
; 2961 :             if (sHighLod == usLodStageCount - 2)

	movsx	eax, WORD PTR _sHighLod$2[ebp]
	movzx	ecx, WORD PTR _usLodStageCount$5[ebp]
	sub	ecx, 2
	cmp	eax, ecx
	jne	SHORT $LN6@GetFrondGe

; 2962 :                 sGeometry.m_fFrondAlphaTestValue = fHighLodAlphaValue;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	movss	xmm0, DWORD PTR _fHighLodAlphaValue$4[ebp]
	movss	DWORD PTR [eax+116], xmm0
	jmp	SHORT $LN9@GetFrondGe
$LN6@GetFrondGe:

; 2963 :             else if (sHighLod == usLodStageCount - 1)

	movsx	eax, WORD PTR _sHighLod$2[ebp]
	movzx	ecx, WORD PTR _usLodStageCount$5[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	jne	SHORT $LN8@GetFrondGe

; 2964 :             {
; 2965 :                 sGeometry.m_fFrondAlphaTestValue = 255.0f; // completely off

	mov	eax, DWORD PTR _sGeometry$[ebp]
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [eax+116], xmm0

; 2966 :                 sFronds.m_nDiscreteLodLevel = -1;

	mov	eax, DWORD PTR _sFronds$7[ebp]
	mov	DWORD PTR [eax], -1

; 2967 :             }

	jmp	SHORT $LN9@GetFrondGe
$LN8@GetFrondGe:

; 2968 :             else
; 2969 :                 sGeometry.m_fFrondAlphaTestValue = m_ucTargetAlphaValue;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+68]
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _sGeometry$[ebp]
	movss	DWORD PTR [edx+116], xmm0
$LN9@GetFrondGe:

; 2970 :         }

	jmp	SHORT $LN5@GetFrondGe
$LN4@GetFrondGe:

; 2971 :         else
; 2972 :             sGeometry.m_fFrondAlphaTestValue = m_ucTargetAlphaValue;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+68]
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _sGeometry$[ebp]
	movss	DWORD PTR [edx+116], xmm0
$LN5@GetFrondGe:

; 2973 :     }

	jmp	SHORT $LN3@GetFrondGe
$LN2@GetFrondGe:

; 2974 :     else
; 2975 :         SetError("no frond geometry exists, possible prior call to DeleteFrondGeometry");

	push	OFFSET ??_C@_0EF@KKLNJEEH@no?5frond?5geometry?5exists?0?5possi@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN3@GetFrondGe:

; 2976 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@GetFrondGe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 292				; 00000124H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN18@GetFrondGe:
	DD	4
	DD	$LN17@GetFrondGe
$LN17@GetFrondGe:
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN13@GetFrondGe
	DD	-68					; ffffffbcH
	DD	4
	DD	$LN14@GetFrondGe
	DD	-80					; ffffffb0H
	DD	2
	DD	$LN15@GetFrondGe
	DD	-92					; ffffffa4H
	DD	2
	DD	$LN16@GetFrondGe
$LN16@GetFrondGe:
	DB	115					; 00000073H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	0
$LN15@GetFrondGe:
	DB	115					; 00000073H
	DB	72					; 00000048H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	0
$LN14@GetFrondGe:
	DB	102					; 00000066H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN13@GetFrondGe:
	DB	102					; 00000066H
	DB	72					; 00000048H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
?GetFrondGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@F@Z ENDP ; CSpeedTreeRT::GetFrondGeometry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetBranchGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@F@Z
_TEXT	SEGMENT
tv144 = -290						; size = 2
_sLowLod$1 = -92					; size = 2
_sHighLod$2 = -80					; size = 2
_fLowLodAlphaValue$3 = -68				; size = 4
_fHighLodAlphaValue$4 = -56				; size = 4
_usLodStageCount$5 = -44				; size = 2
_sLodLevel$6 = -32					; size = 2
_sBranches$7 = -20					; size = 4
_this$ = -8						; size = 4
_sGeometry$ = 8						; size = 4
_sOverrideLodValue$ = 12				; size = 2
?GetBranchGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@F@Z PROC ; CSpeedTreeRT::GetBranchGeometry, COMDAT
; _this$ = ecx

; 2867 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-100]
	mov	ecx, 25					; 00000019H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2868 :     if (m_pBranchGeometry)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN2@GetBranchG

; 2869 :     {
; 2870 :         SGeometry::SIndexed& sBranches = sGeometry.m_sBranches;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	mov	DWORD PTR _sBranches$7[ebp], eax

; 2871 : 
; 2872 :         // get vertex attributes
; 2873 :         sBranches.m_usVertexCount = m_pBranchGeometry->GetVertexCount( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetVertexCount@CIndexedGeometry@@QBEGXZ ; CIndexedGeometry::GetVertexCount
	mov	ecx, DWORD PTR _sBranches$7[ebp]
	mov	WORD PTR [ecx+16], ax

; 2874 :         sBranches.m_pColors = m_pBranchGeometry->GetVertexColors( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetVertexColors@CIndexedGeometry@@QBEPBKXZ ; CIndexedGeometry::GetVertexColors
	mov	ecx, DWORD PTR _sBranches$7[ebp]
	mov	DWORD PTR [ecx+20], eax

; 2875 :         sBranches.m_pCoords = m_pBranchGeometry->GetVertexCoords( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetVertexCoords@CIndexedGeometry@@QBEPBMXZ ; CIndexedGeometry::GetVertexCoords
	mov	ecx, DWORD PTR _sBranches$7[ebp]
	mov	DWORD PTR [ecx+36], eax

; 2876 :         sBranches.m_pNormals = m_pBranchGeometry->GetVertexNormals( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetVertexNormals@CIndexedGeometry@@QBEPBMXZ ; CIndexedGeometry::GetVertexNormals
	mov	ecx, DWORD PTR _sBranches$7[ebp]
	mov	DWORD PTR [ecx+24], eax

; 2877 :         sBranches.m_pBinormals = m_pBranchGeometry->GetVertexBinormals( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetVertexBinormals@CIndexedGeometry@@QBEPBMXZ ; CIndexedGeometry::GetVertexBinormals
	mov	ecx, DWORD PTR _sBranches$7[ebp]
	mov	DWORD PTR [ecx+28], eax

; 2878 :         sBranches.m_pTangents = m_pBranchGeometry->GetVertexTangents( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetVertexTangents@CIndexedGeometry@@QBEPBMXZ ; CIndexedGeometry::GetVertexTangents
	mov	ecx, DWORD PTR _sBranches$7[ebp]
	mov	DWORD PTR [ecx+32], eax

; 2879 :         sBranches.m_pTexCoords0 = m_pBranchGeometry->GetVertexTexCoords0( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetVertexTexCoords0@CIndexedGeometry@@QBEPBMXZ ; CIndexedGeometry::GetVertexTexCoords0
	mov	ecx, DWORD PTR _sBranches$7[ebp]
	mov	DWORD PTR [ecx+40], eax

; 2880 :         sBranches.m_pTexCoords1 = m_pBranchGeometry->GetVertexTexCoords1( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetVertexTexCoords1@CIndexedGeometry@@QBEPBMXZ ; CIndexedGeometry::GetVertexTexCoords1
	mov	ecx, DWORD PTR _sBranches$7[ebp]
	mov	DWORD PTR [ecx+44], eax

; 2881 :         sBranches.m_pWindWeights = m_pBranchGeometry->GetVertexWindWeights( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetVertexWindWeights@CIndexedGeometry@@QBEPBMXZ ; CIndexedGeometry::GetVertexWindWeights
	mov	ecx, DWORD PTR _sBranches$7[ebp]
	mov	DWORD PTR [ecx+48], eax

; 2882 :         sBranches.m_pWindMatrixIndices = m_pBranchGeometry->GetVertexWindMatrixIndices( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetVertexWindMatrixIndices@CIndexedGeometry@@QBEPBEXZ ; CIndexedGeometry::GetVertexWindMatrixIndices
	mov	ecx, DWORD PTR _sBranches$7[ebp]
	mov	DWORD PTR [ecx+52], eax

; 2883 : 
; 2884 :         // get indexing data
; 2885 :         short sLodLevel = (sOverrideLodValue == -1) ? GetDiscreteBranchLodLevel( ) : sOverrideLodValue;

	movsx	eax, WORD PTR _sOverrideLodValue$[ebp]
	cmp	eax, -1
	jne	SHORT $LN11@GetBranchG
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiscreteBranchLodLevel@CSpeedTreeRT@@QBEFM@Z ; CSpeedTreeRT::GetDiscreteBranchLodLevel
	mov	WORD PTR tv144[ebp], ax
	jmp	SHORT $LN12@GetBranchG
$LN11@GetBranchG:
	mov	cx, WORD PTR _sOverrideLodValue$[ebp]
	mov	WORD PTR tv144[ebp], cx
$LN12@GetBranchG:
	mov	dx, WORD PTR tv144[ebp]
	mov	WORD PTR _sLodLevel$6[ebp], dx

; 2886 : 
; 2887 :         sBranches.m_nDiscreteLodLevel = sLodLevel;

	movsx	eax, WORD PTR _sLodLevel$6[ebp]
	mov	ecx, DWORD PTR _sBranches$7[ebp]
	mov	DWORD PTR [ecx], eax

; 2888 :         sBranches.m_usNumStrips = m_pBranchGeometry->GetNumStrips(sLodLevel);

	movzx	eax, WORD PTR _sLodLevel$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetNumStrips@CIndexedGeometry@@QBEGF@Z	; CIndexedGeometry::GetNumStrips
	mov	edx, DWORD PTR _sBranches$7[ebp]
	mov	WORD PTR [edx+4], ax

; 2889 :         sBranches.m_pStripLengths = m_pBranchGeometry->GetStripLengthsPointer(sLodLevel);

	movzx	eax, WORD PTR _sLodLevel$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetStripLengthsPointer@CIndexedGeometry@@QBEPBGG@Z ; CIndexedGeometry::GetStripLengthsPointer
	mov	edx, DWORD PTR _sBranches$7[ebp]
	mov	DWORD PTR [edx+8], eax

; 2890 :         sBranches.m_pStrips = const_cast<const unsigned short**>(m_pBranchGeometry->GetStripsPointer(sLodLevel));

	movzx	eax, WORD PTR _sLodLevel$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetStripsPointer@CIndexedGeometry@@QBEPAPAGG@Z ; CIndexedGeometry::GetStripsPointer
	mov	edx, DWORD PTR _sBranches$7[ebp]
	mov	DWORD PTR [edx+12], eax

; 2891 : 
; 2892 :         // determine alpha test value
; 2893 :         if (m_bDropToBillboard && m_pEmbeddedTexCoords && m_pEmbeddedTexCoords->m_nNumBillboards > 0)

	movzx	eax, BYTE PTR ?m_bDropToBillboard@CSpeedTreeRT@@0_NA ; CSpeedTreeRT::m_bDropToBillboard
	test	eax, eax
	je	$LN4@GetBranchG
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	$LN4@GetBranchG
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	cmp	DWORD PTR [ecx+8], 0
	jle	$LN4@GetBranchG

; 2894 :         {
; 2895 :             unsigned short usLodStageCount = GetNumLeafLodLevels( ) + 1; // add one for billboard

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumLeafLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumLeafLodLevels
	movzx	eax, ax
	add	eax, 1
	mov	WORD PTR _usLodStageCount$5[ebp], ax

; 2896 :             float fHighLodAlphaValue = -1.0f, fLowLodAlphaValue = -1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _fHighLodAlphaValue$4[ebp], xmm0
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _fLowLodAlphaValue$3[ebp], xmm0

; 2897 :             short sHighLod = -1, sLowLod = -1;

	or	eax, -1
	mov	WORD PTR _sHighLod$2[ebp], ax
	or	eax, -1
	mov	WORD PTR _sLowLod$1[ebp], ax

; 2898 :             GetTransitionValues(GetLodLevel( ), usLodStageCount, m_fLeafLodTransitionRadius, m_fLeafTransitionFactor, m_fLeafLodCurveExponent,

	lea	eax, DWORD PTR _sLowLod$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _sHighLod$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _fLowLodAlphaValue$3[ebp]
	push	edx
	lea	eax, DWORD PTR _fHighLodAlphaValue$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+68]
	cvtsi2ss xmm0, edx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+28]
	movss	DWORD PTR [esp], xmm0
	movzx	eax, WORD PTR _usLodStageCount$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLodLevel@CSpeedTreeRT@@QBEMXZ	; CSpeedTreeRT::GetLodLevel
	push	ecx
	fstp	DWORD PTR [esp]
	call	?GetTransitionValues@CSpeedTreeRT@@CAXMGMMMMAAM0AAF1@Z ; CSpeedTreeRT::GetTransitionValues
	add	esp, 40					; 00000028H

; 2899 :                 float(m_ucTargetAlphaValue), fHighLodAlphaValue, fLowLodAlphaValue, sHighLod, sLowLod);
; 2900 : 
; 2901 :             if (sHighLod == usLodStageCount - 2)

	movsx	eax, WORD PTR _sHighLod$2[ebp]
	movzx	ecx, WORD PTR _usLodStageCount$5[ebp]
	sub	ecx, 2
	cmp	eax, ecx
	jne	SHORT $LN6@GetBranchG

; 2902 :             {
; 2903 :                 sGeometry.m_fBranchAlphaTestValue = fHighLodAlphaValue;

	mov	eax, DWORD PTR _sGeometry$[ebp]
	movss	xmm0, DWORD PTR _fHighLodAlphaValue$4[ebp]
	movss	DWORD PTR [eax+56], xmm0

; 2904 :             }

	jmp	SHORT $LN9@GetBranchG
$LN6@GetBranchG:

; 2905 :             else if (sHighLod == usLodStageCount - 1)

	movsx	eax, WORD PTR _sHighLod$2[ebp]
	movzx	ecx, WORD PTR _usLodStageCount$5[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	jne	SHORT $LN8@GetBranchG

; 2906 :             {
; 2907 :                 sGeometry.m_fBranchAlphaTestValue = 255.0f; // completely off

	mov	eax, DWORD PTR _sGeometry$[ebp]
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [eax+56], xmm0

; 2908 :                 sBranches.m_nDiscreteLodLevel = -1;

	mov	eax, DWORD PTR _sBranches$7[ebp]
	mov	DWORD PTR [eax], -1

; 2909 :             }

	jmp	SHORT $LN9@GetBranchG
$LN8@GetBranchG:

; 2910 :             else
; 2911 :             {
; 2912 :                 sGeometry.m_fBranchAlphaTestValue = m_ucTargetAlphaValue;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+68]
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _sGeometry$[ebp]
	movss	DWORD PTR [edx+56], xmm0
$LN9@GetBranchG:

; 2913 :             }
; 2914 :         }

	jmp	SHORT $LN5@GetBranchG
$LN4@GetBranchG:

; 2915 :         else
; 2916 :             sGeometry.m_fBranchAlphaTestValue = m_ucTargetAlphaValue;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+68]
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _sGeometry$[ebp]
	movss	DWORD PTR [edx+56], xmm0
$LN5@GetBranchG:

; 2917 :     }

	jmp	SHORT $LN3@GetBranchG
$LN2@GetBranchG:

; 2918 :     else
; 2919 :         SetError("no branch geometry exists, possible prior call to DeleteBranchGeometry");

	push	OFFSET ??_C@_0EH@MBPGMKE@no?5branch?5geometry?5exists?0?5poss@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN3@GetBranchG:

; 2920 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@GetBranchG
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 292				; 00000124H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN18@GetBranchG:
	DD	4
	DD	$LN17@GetBranchG
$LN17@GetBranchG:
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN13@GetBranchG
	DD	-68					; ffffffbcH
	DD	4
	DD	$LN14@GetBranchG
	DD	-80					; ffffffb0H
	DD	2
	DD	$LN15@GetBranchG
	DD	-92					; ffffffa4H
	DD	2
	DD	$LN16@GetBranchG
$LN16@GetBranchG:
	DB	115					; 00000073H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	0
$LN15@GetBranchG:
	DB	115					; 00000073H
	DB	72					; 00000048H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	0
$LN14@GetBranchG:
	DB	102					; 00000066H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN13@GetBranchG:
	DB	102					; 00000066H
	DB	72					; 00000048H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
?GetBranchGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@F@Z ENDP ; CSpeedTreeRT::GetBranchGeometry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?CopyUserData@CSpeedTreeRT@@CAPADPBD@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
_pCopy$ = -20						; size = 4
_nLength$ = -8						; size = 4
_pOrig$ = 8						; size = 4
?CopyUserData@CSpeedTreeRT@@CAPADPBD@Z PROC		; CSpeedTreeRT::CopyUserData, COMDAT

; 3528 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3529 :     int nLength = strlen(pOrig);

	mov	eax, DWORD PTR _pOrig$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nLength$[ebp], eax

; 3530 : 
; 3531 :     char* pCopy = new char[nLength + 1];

	mov	eax, DWORD PTR _nLength$[ebp]
	add	eax, 1
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _pCopy$[ebp], ecx

; 3532 :     memcpy(pCopy, pOrig, nLength + 1);

	mov	eax, DWORD PTR _nLength$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _pOrig$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCopy$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3533 : 
; 3534 :     return pCopy;

	mov	eax, DWORD PTR _pCopy$[ebp]

; 3535 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyUserData@CSpeedTreeRT@@CAPADPBD@Z ENDP		; CSpeedTreeRT::CopyUserData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?ParseSupplementalTexCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
_TEXT	SEGMENT
tv177 = -444						; size = 4
tv174 = -444						; size = 4
tv68 = -444						; size = 4
$T2 = -436						; size = 28
$T3 = -400						; size = 12
$T4 = -380						; size = 28
$T5 = -344						; size = 12
$T6 = -324						; size = 28
$T7 = -288						; size = 4
_i$8 = -84						; size = 4
_cFile$9 = -72						; size = 28
_nToken$10 = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pFile$ = 8						; size = 4
?ParseSupplementalTexCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z PROC ; CSpeedTreeRT::ParseSupplementalTexCoordInfo, COMDAT
; _this$ = ecx

; 3626 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ParseSupplementalTexCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 432				; 000001b0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3627 :     if (m_pEmbeddedTexCoords)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	$LN3@ParseSuppl

; 3628 :     {
; 3629 :         int nToken = pFile->ParseToken( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseToken@CTreeFileAccess@@QAE?AW4EFileToken@@XZ ; CTreeFileAccess::ParseToken
	mov	DWORD PTR _nToken$10[ebp], eax
$LN4@ParseSuppl:

; 3630 :         do
; 3631 :         {
; 3632 :             switch (nToken)

	mov	eax, DWORD PTR _nToken$10[ebp]
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR tv68[ebp]
	sub	ecx, 20002				; 00004e22H
	mov	DWORD PTR tv68[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 3
	ja	$LN15@ParseSuppl
	mov	edx, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN24@ParseSuppl[edx*4]
$LN11@ParseSuppl:

; 3633 :             {
; 3634 :             case File_SupplementalCompositeFilename:
; 3635 :             {
; 3636 :                 CIdvFilename cFile = pFile->ParseString( );

	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T7[ebp], esp
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseString@CTreeFileAccess@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CTreeFileAccess::ParseString
	lea	ecx, DWORD PTR _cFile$9[ebp]
	call	??0CIdvFilename@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CIdvFilename::CIdvFilename
	mov	DWORD PTR tv174[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3637 :                 m_pEmbeddedTexCoords->m_strCompositeFilename = cFile.NoPath( );

	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	lea	ecx, DWORD PTR _cFile$9[ebp]
	call	?NoPath@CIdvFilename@@QBE?AV1@XZ	; CIdvFilename::NoPath
	mov	DWORD PTR tv177[ebp], eax
	mov	ecx, DWORD PTR tv177[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+76]
	add	ecx, 24					; 00000018H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1CIdvFilename@@QAE@XZ
	npad	1

; 3638 :             }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cFile$9[ebp]
	call	??1CIdvFilename@@QAE@XZ
	npad	1

; 3639 :             break;

	jmp	$LN5@ParseSuppl
$LN12@ParseSuppl:

; 3640 :             case File_SupplementalHorizontalBillboard:
; 3641 :             {
; 3642 :                 m_bHorizontalBillboard = pFile->ParseBool( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseBool@CTreeFileAccess@@QAE_NXZ	; CTreeFileAccess::ParseBool
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+105], al

; 3643 :             }
; 3644 :             break;

	jmp	$LN5@ParseSuppl
$LN13@ParseSuppl:

; 3645 :             case File_Supplemental360Billboard:
; 3646 :             {
; 3647 :                 m_b360Billboard = pFile->ParseBool( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseBool@CTreeFileAccess@@QAE_NXZ	; CTreeFileAccess::ParseBool
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+104], al

; 3648 :             }
; 3649 :             break;

	jmp	$LN5@ParseSuppl
$LN14@ParseSuppl:

; 3650 :             case File_SupplementalShadowTexCoords:
; 3651 :             {
; 3652 :                 for (int i = 0; i < 8; ++i)

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN9@ParseSuppl
$LN7@ParseSuppl:
	mov	eax, DWORD PTR _i$8[ebp]
	add	eax, 1
	mov	DWORD PTR _i$8[ebp], eax
$LN9@ParseSuppl:
	cmp	DWORD PTR _i$8[ebp], 8
	jge	SHORT $LN8@ParseSuppl

; 3653 :                     m_pEmbeddedTexCoords->m_afShadowTexCoords[i] = pFile->ParseFloat( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _i$8[ebp]
	fstp	DWORD PTR [ecx+edx*4+52]
	jmp	SHORT $LN7@ParseSuppl
$LN8@ParseSuppl:

; 3654 :             }
; 3655 :             break;

	jmp	SHORT $LN5@ParseSuppl
$LN15@ParseSuppl:

; 3656 :             default:
; 3657 :                 throw(IdvFileError("malformed texture coord info"));

	push	OFFSET ??_C@_0BN@HDKMKOP@malformed?5texture?5coord?5info@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	0
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; IdvFileError::IdvFileError
	push	OFFSET __TI3?AVIdvFileError@@
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	call	__CxxThrowException@8
	npad	1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN5@ParseSuppl:

; 3658 :             }
; 3659 : 
; 3660 :             if (pFile->EndOfFile( ))

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?EndOfFile@CTreeFileAccess@@QBE_NXZ	; CTreeFileAccess::EndOfFile
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@ParseSuppl

; 3661 :                 throw(IdvFileError("premature end of file reached parsing texture coordinate info"));

	push	OFFSET ??_C@_0DO@PNMFDPBL@premature?5end?5of?5file?5reached?5p@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; IdvFileError::IdvFileError
	push	OFFSET __TI3?AVIdvFileError@@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	__CxxThrowException@8
	npad	1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	jmp	SHORT $LN17@ParseSuppl
$LN16@ParseSuppl:

; 3662 :             else
; 3663 :                 nToken = pFile->ParseToken( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseToken@CTreeFileAccess@@QAE?AW4EFileToken@@XZ ; CTreeFileAccess::ParseToken
	mov	DWORD PTR _nToken$10[ebp], eax
$LN17@ParseSuppl:

; 3664 : 
; 3665 :         } while (nToken != File_EndSupplementalTexCoordInfo);

	cmp	DWORD PTR _nToken$10[ebp], 20001	; 00004e21H
	jne	$LN4@ParseSuppl
$LN3@ParseSuppl:
$LN1@ParseSuppl:

; 3666 :     }
; 3667 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN28@ParseSuppl
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 444				; 000001bcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN28@ParseSuppl:
	DD	1
	DD	$LN27@ParseSuppl
$LN27@ParseSuppl:
	DD	-72					; ffffffb8H
	DD	28					; 0000001cH
	DD	$LN25@ParseSuppl
$LN25@ParseSuppl:
	DB	99					; 00000063H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
	npad	2
$LN24@ParseSuppl:
	DD	$LN11@ParseSuppl
	DD	$LN12@ParseSuppl
	DD	$LN13@ParseSuppl
	DD	$LN14@ParseSuppl
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ParseSupplementalTexCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$1:
	lea	ecx, DWORD PTR _cFile$9[ebp]
	jmp	??1CIdvFilename@@QAE@XZ
__unwindfunclet$?ParseSupplementalTexCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$3:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ParseSupplementalTexCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?ParseSupplementalTexCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-448]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ParseSupplementalTexCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ParseSupplementalTexCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ENDP ; CSpeedTreeRT::ParseSupplementalTexCoordInfo
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SaveSupplementalTexCoordInfo@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
_i$2 = -20						; size = 4
_this$ = -8						; size = 4
_pFile$ = 8						; size = 4
?SaveSupplementalTexCoordInfo@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z PROC ; CSpeedTreeRT::SaveSupplementalTexCoordInfo, COMDAT
; _this$ = ecx

; 3599 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3600 :     if (m_pEmbeddedTexCoords)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	$LN5@SaveSupple

; 3601 :     {
; 3602 :         pFile->SaveToken(File_BeginSupplementalTexCoordInfo);

	push	20000					; 00004e20H
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 3603 : 
; 3604 :         pFile->SaveToken(File_SupplementalCompositeFilename);

	push	20002					; 00004e22H
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 3605 :         pFile->SaveString(m_pEmbeddedTexCoords->m_strCompositeFilename);

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T1[ebp], esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+76]
	add	edx, 24					; 00000018H
	push	edx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveString@CTreeFileAccess@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CTreeFileAccess::SaveString
	npad	1

; 3606 : 
; 3607 :         pFile->SaveToken(File_SupplementalHorizontalBillboard);

	push	20003					; 00004e23H
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 3608 :         pFile->SaveBool(m_bHorizontalBillboard);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+105]
	push	ecx
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveBool@CTreeFileAccess@@QAEX_N@Z	; CTreeFileAccess::SaveBool
	npad	1

; 3609 : 
; 3610 :         pFile->SaveToken(File_Supplemental360Billboard);

	push	20004					; 00004e24H
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 3611 :         pFile->SaveBool(m_b360Billboard);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+104]
	push	ecx
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveBool@CTreeFileAccess@@QAEX_N@Z	; CTreeFileAccess::SaveBool
	npad	1

; 3612 : 
; 3613 :         pFile->SaveToken(File_SupplementalShadowTexCoords);

	push	20005					; 00004e25H
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 3614 :         for (int i = 0; i < 8; ++i)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@SaveSupple
$LN2@SaveSupple:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@SaveSupple:
	cmp	DWORD PTR _i$2[ebp], 8
	jge	SHORT $LN3@SaveSupple

; 3615 :             pFile->SaveFloat(m_pEmbeddedTexCoords->m_afShadowTexCoords[i]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _i$2[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx*4+52]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1
	jmp	SHORT $LN2@SaveSupple
$LN3@SaveSupple:

; 3616 : 
; 3617 :         pFile->SaveToken(File_EndSupplementalTexCoordInfo);

	push	20001					; 00004e21H
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1
$LN5@SaveSupple:

; 3618 :     }
; 3619 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SaveSupplementalTexCoordInfo@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z ENDP ; CSpeedTreeRT::SaveSupplementalTexCoordInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?ParseUserData@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
_TEXT	SEGMENT
tv82 = -276						; size = 4
tv83 = -272						; size = 4
tv66 = -272						; size = 4
$T2 = -264						; size = 28
_nToken$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pFile$ = 8						; size = 4
?ParseUserData@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z PROC ; CSpeedTreeRT::ParseUserData, COMDAT
; _this$ = ecx

; 3441 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ParseUserData@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3442 :     int nToken = pFile->ParseToken( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseToken@CTreeFileAccess@@QAE?AW4EFileToken@@XZ ; CTreeFileAccess::ParseToken
	mov	DWORD PTR _nToken$[ebp], eax
$LN4@ParseUserD:

; 3443 :     do
; 3444 :     {
; 3445 :         switch (nToken)

	mov	eax, DWORD PTR _nToken$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 19002		; 00004a3aH
	je	SHORT $LN7@ParseUserD
	jmp	SHORT $LN5@ParseUserD
$LN7@ParseUserD:

; 3446 :         {
; 3447 :         case File_UserData:
; 3448 :             m_pUserData = CopyUserData(pFile->ParseString( ).c_str( ));

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseString@CTreeFileAccess@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CTreeFileAccess::ParseString
	mov	DWORD PTR tv83[ebp], eax
	mov	ecx, DWORD PTR tv83[ebp]
	mov	DWORD PTR tv82[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv82[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?CopyUserData@CSpeedTreeRT@@CAPADPBD@Z	; CSpeedTreeRT::CopyUserData
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN5@ParseUserD:

; 3449 :             break;
; 3450 :         }
; 3451 :         nToken = pFile->ParseToken( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseToken@CTreeFileAccess@@QAE?AW4EFileToken@@XZ ; CTreeFileAccess::ParseToken
	mov	DWORD PTR _nToken$[ebp], eax

; 3452 : 
; 3453 :     } while (nToken != File_EndUserData);

	cmp	DWORD PTR _nToken$[ebp], 19001		; 00004a39H
	jne	SHORT $LN4@ParseUserD

; 3454 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ParseUserData@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?ParseUserData@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ParseUserData@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ParseUserData@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ENDP ; CSpeedTreeRT::ParseUserData
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SaveUserData@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
_pFile$ = 8						; size = 4
?SaveUserData@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z PROC ; CSpeedTreeRT::SaveUserData, COMDAT
; _this$ = ecx

; 3424 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3425 :     if (m_pUserData)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+100], 0
	je	SHORT $LN2@SaveUserDa

; 3426 :     {
; 3427 :         pFile->SaveToken(File_BeginUserData);

	push	19000					; 00004a38H
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 3428 : 
; 3429 :         pFile->SaveToken(File_UserData);

	push	19002					; 00004a3aH
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 3430 :         pFile->SaveString(string(m_pUserData));

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T1[ebp], esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+100]
	push	edx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveString@CTreeFileAccess@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CTreeFileAccess::SaveString
	npad	1

; 3431 : 
; 3432 :         pFile->SaveToken(File_EndUserData);

	push	19001					; 00004a39H
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1
$LN2@SaveUserDa:

; 3433 :     }
; 3434 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SaveUserData@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z ENDP ; CSpeedTreeRT::SaveUserData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?ParseShadowProjectionInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
_TEXT	SEGMENT
tv76 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_pFile$ = 8						; size = 4
?ParseShadowProjectionInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z PROC ; CSpeedTreeRT::ParseShadowProjectionInfo, COMDAT
; _this$ = ecx

; 3291 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ParseShadowProjectionInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3292 :     m_pProjectedShadow = new CProjectedShadow;

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN3@ParseShado
	mov	ecx, DWORD PTR $T2[ebp]
	call	??0CProjectedShadow@@QAE@XZ		; CProjectedShadow::CProjectedShadow
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@ParseShado
$LN3@ParseShado:
	mov	DWORD PTR tv76[ebp], 0
$LN4@ParseShado:
	mov	eax, DWORD PTR tv76[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx+80], edx

; 3293 : 
; 3294 :     m_pProjectedShadow->Parse(*pFile);

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+80]
	call	?Parse@CProjectedShadow@@QAEXAAVCTreeFileAccess@@@Z ; CProjectedShadow::Parse
	npad	1

; 3295 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ParseShadowProjectionInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$0:
	push	64					; 00000040H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?ParseShadowProjectionInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ParseShadowProjectionInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ParseShadowProjectionInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ENDP ; CSpeedTreeRT::ParseShadowProjectionInfo
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SaveCollisionObjects@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z
_TEXT	SEGMENT
tv138 = -232						; size = 4
tv80 = -232						; size = 4
_sShape$1 = -32						; size = 4
_i$2 = -20						; size = 4
_this$ = -8						; size = 4
_pFile$ = 8						; size = 4
?SaveCollisionObjects@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z PROC ; CSpeedTreeRT::SaveCollisionObjects, COMDAT
; _this$ = ecx

; 2729 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2730 :     if (m_pCollisionObjects)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	$LN9@SaveCollis

; 2731 :     {
; 2732 :         pFile->SaveToken(File_BeginCollisionInfo);

	push	12000					; 00002ee0H
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 2733 :         for (unsigned int i = 0; i < m_pCollisionObjects->m_vObjects.size( ); ++i)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@SaveCollis
$LN2@SaveCollis:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@SaveCollis:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	call	?size@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ ; std::vector<SShape,std::allocator<SShape> >::size
	cmp	DWORD PTR _i$2[ebp], eax
	jae	$LN3@SaveCollis

; 2734 :         {
; 2735 :             SShape& sShape = m_pCollisionObjects->m_vObjects[i];

	mov	eax, DWORD PTR _i$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+84]
	call	??A?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAEAAUSShape@@I@Z ; std::vector<SShape,std::allocator<SShape> >::operator[]
	mov	DWORD PTR _sShape$1[ebp], eax

; 2736 :             switch (sShape.m_eType)

	mov	eax, DWORD PTR _sShape$1[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv80[ebp], ecx
	cmp	DWORD PTR tv80[ebp], 0
	je	SHORT $LN10@SaveCollis
	cmp	DWORD PTR tv80[ebp], 1
	je	SHORT $LN11@SaveCollis
	cmp	DWORD PTR tv80[ebp], 2
	je	SHORT $LN12@SaveCollis
	jmp	SHORT $LN5@SaveCollis
$LN10@SaveCollis:

; 2737 :             {
; 2738 :             case CSpeedTreeRT::CO_SPHERE:
; 2739 :                 pFile->SaveToken(File_CollisionSphere);

	push	12002					; 00002ee2H
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 2740 :                 break;

	jmp	SHORT $LN5@SaveCollis
$LN11@SaveCollis:

; 2741 :             case CSpeedTreeRT::CO_CYLINDER:
; 2742 :                 pFile->SaveToken(File_CollisionCylinder);

	push	12003					; 00002ee3H
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 2743 :                 break;

	jmp	SHORT $LN5@SaveCollis
$LN12@SaveCollis:

; 2744 :             case CSpeedTreeRT::CO_BOX:
; 2745 :                 pFile->SaveToken(File_CollisionBox);

	push	12004					; 00002ee4H
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1
$LN5@SaveCollis:

; 2746 :                 break;
; 2747 :             }
; 2748 : 
; 2749 :             pFile->SaveFloat(sShape.m_afPosition[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sShape$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx+4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1

; 2750 :             pFile->SaveFloat(sShape.m_afPosition[1]);

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _sShape$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1

; 2751 :             pFile->SaveFloat(sShape.m_afPosition[2]);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _sShape$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1

; 2752 : 
; 2753 :             switch (sShape.m_eType)

	mov	eax, DWORD PTR _sShape$1[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv138[ebp], ecx
	cmp	DWORD PTR tv138[ebp], 0
	je	SHORT $LN13@SaveCollis
	cmp	DWORD PTR tv138[ebp], 1
	je	SHORT $LN14@SaveCollis
	cmp	DWORD PTR tv138[ebp], 2
	je	SHORT $LN15@SaveCollis
	jmp	$LN7@SaveCollis
$LN13@SaveCollis:

; 2754 :             {
; 2755 :             case CSpeedTreeRT::CO_SPHERE:
; 2756 :                 pFile->SaveFloat(sShape.m_afDimensions[0]);  // radius

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sShape$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx+16]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1

; 2757 :                 break;

	jmp	$LN7@SaveCollis
$LN14@SaveCollis:

; 2758 :             case CSpeedTreeRT::CO_CYLINDER:
; 2759 :                 pFile->SaveFloat(sShape.m_afDimensions[0]);  // radius

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sShape$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx+16]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1

; 2760 :                 pFile->SaveFloat(sShape.m_afDimensions[1]);  // height

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _sShape$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+16]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1

; 2761 :                 break;

	jmp	SHORT $LN7@SaveCollis
$LN15@SaveCollis:

; 2762 :             case CSpeedTreeRT::CO_BOX:
; 2763 :                 pFile->SaveFloat(sShape.m_afDimensions[0]);  // x

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sShape$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx+16]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1

; 2764 :                 pFile->SaveFloat(sShape.m_afDimensions[1]);  // y

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _sShape$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+16]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1

; 2765 :                 pFile->SaveFloat(sShape.m_afDimensions[2]);  // z

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _sShape$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+16]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1
$LN7@SaveCollis:

; 2766 :                 break;
; 2767 :             }
; 2768 :         }

	jmp	$LN2@SaveCollis
$LN3@SaveCollis:

; 2769 :         pFile->SaveToken(File_EndCollisionInfo);

	push	12001					; 00002ee1H
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1
$LN9@SaveCollis:

; 2770 :     }
; 2771 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SaveCollisionObjects@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z ENDP ; CSpeedTreeRT::SaveCollisionObjects
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SaveTextureCoords@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z
_TEXT	SEGMENT
_l$1 = -80						; size = 4
_i$2 = -68						; size = 4
_k$3 = -56						; size = 4
_i$4 = -44						; size = 4
_j$5 = -32						; size = 4
_i$6 = -20						; size = 4
_this$ = -8						; size = 4
_pFile$ = 8						; size = 4
?SaveTextureCoords@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z PROC ; CSpeedTreeRT::SaveTextureCoords, COMDAT
; _this$ = ecx

; 2685 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 21					; 00000015H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2686 :     if (m_pEmbeddedTexCoords)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	$LN20@SaveTextur

; 2687 :     {
; 2688 :         pFile->SaveToken(File_BeginTextureCoordInfo);

	push	10000					; 00002710H
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 2689 : 
; 2690 :         // leaves
; 2691 :         pFile->SaveToken(File_LeafTextureCoords);

	push	10002					; 00002712H
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 2692 :         pFile->SaveInt(m_pEmbeddedTexCoords->m_nNumLeafMaps);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveInt@CTreeFileAccess@@QAEXH@Z	; CTreeFileAccess::SaveInt
	npad	1

; 2693 :         for (int i = 0; i < m_pEmbeddedTexCoords->m_nNumLeafMaps; ++i)

	mov	DWORD PTR _i$6[ebp], 0
	jmp	SHORT $LN4@SaveTextur
$LN2@SaveTextur:
	mov	eax, DWORD PTR _i$6[ebp]
	add	eax, 1
	mov	DWORD PTR _i$6[ebp], eax
$LN4@SaveTextur:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _i$6[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN3@SaveTextur

; 2694 :             for (int j = 0; j < 8; ++j)

	mov	DWORD PTR _j$5[ebp], 0
	jmp	SHORT $LN7@SaveTextur
$LN5@SaveTextur:
	mov	eax, DWORD PTR _j$5[ebp]
	add	eax, 1
	mov	DWORD PTR _j$5[ebp], eax
$LN7@SaveTextur:
	cmp	DWORD PTR _j$5[ebp], 8
	jge	SHORT $LN6@SaveTextur

; 2695 :                 pFile->SaveFloat(m_pEmbeddedTexCoords->m_pLeafTexCoords[i * 8 + j]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _i$6[ebp]
	mov	eax, DWORD PTR _j$5[ebp]
	lea	edx, DWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1
	jmp	SHORT $LN5@SaveTextur
$LN6@SaveTextur:
	jmp	SHORT $LN2@SaveTextur
$LN3@SaveTextur:

; 2696 : 
; 2697 :         // billboards
; 2698 :         pFile->SaveToken(File_BillboardTextureCoords);

	push	10003					; 00002713H
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 2699 :         pFile->SaveInt(m_pEmbeddedTexCoords->m_nNumBillboards);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveInt@CTreeFileAccess@@QAEXH@Z	; CTreeFileAccess::SaveInt
	npad	1

; 2700 :         for (int i = 0; i < m_pEmbeddedTexCoords->m_nNumBillboards; ++i)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN10@SaveTextur
$LN8@SaveTextur:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN10@SaveTextur:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _i$4[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	SHORT $LN9@SaveTextur

; 2701 :             for (int k = 0; k < 8; ++k)

	mov	DWORD PTR _k$3[ebp], 0
	jmp	SHORT $LN13@SaveTextur
$LN11@SaveTextur:
	mov	eax, DWORD PTR _k$3[ebp]
	add	eax, 1
	mov	DWORD PTR _k$3[ebp], eax
$LN13@SaveTextur:
	cmp	DWORD PTR _k$3[ebp], 8
	jge	SHORT $LN12@SaveTextur

; 2702 :                 pFile->SaveFloat(m_pEmbeddedTexCoords->m_pBillboardTexCoords[i * 8 + k]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _i$4[ebp]
	mov	eax, DWORD PTR _k$3[ebp]
	lea	edx, DWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR [ecx+12]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1
	jmp	SHORT $LN11@SaveTextur
$LN12@SaveTextur:
	jmp	SHORT $LN8@SaveTextur
$LN9@SaveTextur:

; 2703 : 
; 2704 :         // fronds
; 2705 :         pFile->SaveToken(File_FrondTextureCoords);

	push	10004					; 00002714H
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 2706 :         pFile->SaveInt(m_pEmbeddedTexCoords->m_nNumFrondMaps);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveInt@CTreeFileAccess@@QAEXH@Z	; CTreeFileAccess::SaveInt
	npad	1

; 2707 :         for (int i = 0; i < m_pEmbeddedTexCoords->m_nNumFrondMaps; ++i)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN16@SaveTextur
$LN14@SaveTextur:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN16@SaveTextur:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _i$2[ebp]
	cmp	edx, DWORD PTR [ecx+16]
	jge	SHORT $LN15@SaveTextur

; 2708 :             for (int l = 0; l < 8; ++l)

	mov	DWORD PTR _l$1[ebp], 0
	jmp	SHORT $LN19@SaveTextur
$LN17@SaveTextur:
	mov	eax, DWORD PTR _l$1[ebp]
	add	eax, 1
	mov	DWORD PTR _l$1[ebp], eax
$LN19@SaveTextur:
	cmp	DWORD PTR _l$1[ebp], 8
	jge	SHORT $LN18@SaveTextur

; 2709 :                 pFile->SaveFloat(m_pEmbeddedTexCoords->m_pFrondTexCoords[i * 8 + l]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _i$2[ebp]
	mov	eax, DWORD PTR _l$1[ebp]
	lea	edx, DWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR [ecx+20]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1
	jmp	SHORT $LN17@SaveTextur
$LN18@SaveTextur:
	jmp	SHORT $LN14@SaveTextur
$LN15@SaveTextur:

; 2710 : 
; 2711 :     //    pFile->SaveToken(File_CompositeFilename);
; 2712 :     //    pFile->SaveString(m_pEmbeddedTexCoords->m_strCompositeFilename);
; 2713 :     //
; 2714 :     //    pFile->SaveToken(File_HorizontalBillboard);
; 2715 :     //    pFile->SaveBool(m_bHorizontalBillboard);
; 2716 :     //
; 2717 :     //    pFile->SaveToken(File_360Billboard);
; 2718 :     //    pFile->SaveBool(m_b360Billboard);
; 2719 : 
; 2720 :         pFile->SaveToken(File_EndTextureCoordInfo);

	push	10001					; 00002711H
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1
$LN20@SaveTextur:

; 2721 :     }
; 2722 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SaveTextureCoords@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z ENDP ; CSpeedTreeRT::SaveTextureCoords
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?ParseCollisionObjects@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
_TEXT	SEGMENT
tv136 = -472						; size = 4
tv77 = -472						; size = 4
tv73 = -472						; size = 4
$T2 = -464						; size = 28
$T3 = -428						; size = 12
$T4 = -408						; size = 28
$T5 = -372						; size = 12
$T6 = -352						; size = 28
$T7 = -316						; size = 12
$T8 = -296						; size = 4
_afPosition$9 = -92					; size = 12
_sShape$10 = -72					; size = 28
_nToken$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pFile$ = 8						; size = 4
?ParseCollisionObjects@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z PROC ; CSpeedTreeRT::ParseCollisionObjects, COMDAT
; _this$ = ecx

; 2624 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ParseCollisionObjects@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 460				; 000001ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2625 :     m_pCollisionObjects = new SCollisionObjects;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN20@ParseColli
	mov	ecx, DWORD PTR $T8[ebp]
	call	??0SCollisionObjects@@QAE@XZ
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN21@ParseColli
$LN20@ParseColli:
	mov	DWORD PTR tv73[ebp], 0
$LN21@ParseColli:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR [eax+84], ecx

; 2626 : 
; 2627 :     int nToken = pFile->ParseToken( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseToken@CTreeFileAccess@@QAE?AW4EFileToken@@XZ ; CTreeFileAccess::ParseToken
	mov	DWORD PTR _nToken$[ebp], eax
$LN4@ParseColli:

; 2628 :     do
; 2629 :     {
; 2630 :         SShape sShape;

	lea	ecx, DWORD PTR _sShape$10[ebp]
	call	??0SShape@@QAE@XZ			; SShape::SShape
	npad	1

; 2631 :         switch (nToken)

	mov	eax, DWORD PTR _nToken$[ebp]
	mov	DWORD PTR tv77[ebp], eax
	cmp	DWORD PTR tv77[ebp], 12002		; 00002ee2H
	je	SHORT $LN9@ParseColli
	cmp	DWORD PTR tv77[ebp], 12003		; 00002ee3H
	je	SHORT $LN10@ParseColli
	cmp	DWORD PTR tv77[ebp], 12004		; 00002ee4H
	je	SHORT $LN11@ParseColli
	jmp	SHORT $LN12@ParseColli
$LN9@ParseColli:

; 2632 :         {
; 2633 :         case File_CollisionSphere:
; 2634 :             sShape.m_eType = CSpeedTreeRT::CO_SPHERE;

	mov	DWORD PTR _sShape$10[ebp], 0

; 2635 :             break;

	jmp	SHORT $LN5@ParseColli
$LN10@ParseColli:

; 2636 :         case File_CollisionCylinder:
; 2637 :             sShape.m_eType = CSpeedTreeRT::CO_CYLINDER;

	mov	DWORD PTR _sShape$10[ebp], 1

; 2638 :             break;

	jmp	SHORT $LN5@ParseColli
$LN11@ParseColli:

; 2639 :         case File_CollisionBox:
; 2640 :             sShape.m_eType = CSpeedTreeRT::CO_BOX;

	mov	DWORD PTR _sShape$10[ebp], 2

; 2641 :             break;

	jmp	SHORT $LN5@ParseColli
$LN12@ParseColli:

; 2642 :         default:
; 2643 :             throw(IdvFileError("malformed collision object info"));

	push	OFFSET ??_C@_0CA@BIAOOLMK@malformed?5collision?5object?5info@
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	lea	ecx, DWORD PTR $T7[ebp]
	call	??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; IdvFileError::IdvFileError
	push	OFFSET __TI3?AVIdvFileError@@
	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	call	__CxxThrowException@8
	npad	1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN5@ParseColli:

; 2644 :         }
; 2645 : 
; 2646 :         float afPosition[3];
; 2647 :         afPosition[0] = pFile->ParseFloat( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _afPosition$9[ebp+ecx]

; 2648 :         afPosition[1] = pFile->ParseFloat( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _afPosition$9[ebp+eax]

; 2649 :         afPosition[2] = pFile->ParseFloat( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _afPosition$9[ebp+eax]

; 2650 :         Assign3d(sShape.m_afPosition, afPosition);

	lea	eax, DWORD PTR _afPosition$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _sShape$10[ebp+4]
	push	ecx
	call	?Assign3d@@YAXPAMPBM@Z			; Assign3d
	add	esp, 8

; 2651 : 
; 2652 :         switch (sShape.m_eType)

	mov	eax, DWORD PTR _sShape$10[ebp]
	mov	DWORD PTR tv136[ebp], eax
	cmp	DWORD PTR tv136[ebp], 0
	je	SHORT $LN13@ParseColli
	cmp	DWORD PTR tv136[ebp], 1
	je	SHORT $LN14@ParseColli
	cmp	DWORD PTR tv136[ebp], 2
	je	SHORT $LN15@ParseColli
	jmp	$LN16@ParseColli
$LN13@ParseColli:

; 2653 :         {
; 2654 :         case CSpeedTreeRT::CO_SPHERE:
; 2655 :             sShape.m_afDimensions[0] = pFile->ParseFloat( );    // radius

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _sShape$10[ebp+ecx+16]

; 2656 :             break;

	jmp	$LN7@ParseColli
$LN14@ParseColli:

; 2657 :         case CSpeedTreeRT::CO_CYLINDER:
; 2658 :             sShape.m_afDimensions[0] = pFile->ParseFloat( );    // radius

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _sShape$10[ebp+ecx+16]

; 2659 :             sShape.m_afDimensions[1] = pFile->ParseFloat( );    // height

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _sShape$10[ebp+eax+16]

; 2660 :             break;

	jmp	$LN7@ParseColli
$LN15@ParseColli:

; 2661 :         case CSpeedTreeRT::CO_BOX:
; 2662 :             sShape.m_afDimensions[0] = pFile->ParseFloat( );    // x

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _sShape$10[ebp+ecx+16]

; 2663 :             sShape.m_afDimensions[1] = pFile->ParseFloat( );    // y

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _sShape$10[ebp+eax+16]

; 2664 :             sShape.m_afDimensions[2] = pFile->ParseFloat( );    // z

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _sShape$10[ebp+eax+16]

; 2665 :             break;

	jmp	SHORT $LN7@ParseColli
$LN16@ParseColli:

; 2666 :         default:
; 2667 :             throw(IdvFileError("unknown collision object type"));

	push	OFFSET ??_C@_0BO@GLFBFGPF@unknown?5collision?5object?5type@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	0
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; IdvFileError::IdvFileError
	push	OFFSET __TI3?AVIdvFileError@@
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	call	__CxxThrowException@8
	npad	1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN7@ParseColli:

; 2668 :         }
; 2669 : 
; 2670 :         m_pCollisionObjects->m_vObjects.push_back(sShape);

	lea	eax, DWORD PTR _sShape$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+84]
	call	?push_back@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAEXABUSShape@@@Z ; std::vector<SShape,std::allocator<SShape> >::push_back
	npad	1

; 2671 : 
; 2672 :         if (pFile->EndOfFile( ))

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?EndOfFile@CTreeFileAccess@@QBE_NXZ	; CTreeFileAccess::EndOfFile
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@ParseColli

; 2673 :             throw(IdvFileError("premature end of file reached parsing collision object info"));

	push	OFFSET ??_C@_0DM@NOGHELOF@premature?5end?5of?5file?5reached?5p@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; IdvFileError::IdvFileError
	push	OFFSET __TI3?AVIdvFileError@@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	__CxxThrowException@8
	npad	1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	jmp	SHORT $LN18@ParseColli
$LN17@ParseColli:

; 2674 :         else
; 2675 :             nToken = pFile->ParseToken( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseToken@CTreeFileAccess@@QAE?AW4EFileToken@@XZ ; CTreeFileAccess::ParseToken
	mov	DWORD PTR _nToken$[ebp], eax
$LN18@ParseColli:

; 2676 : 
; 2677 :     } while (nToken != File_EndCollisionInfo);

	cmp	DWORD PTR _nToken$[ebp], 12001		; 00002ee1H
	jne	$LN4@ParseColli
$LN1@ParseColli:

; 2678 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN29@ParseColli
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 472				; 000001d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN29@ParseColli:
	DD	2
	DD	$LN28@ParseColli
$LN28@ParseColli:
	DD	-72					; ffffffb8H
	DD	28					; 0000001cH
	DD	$LN25@ParseColli
	DD	-92					; ffffffa4H
	DD	12					; 0000000cH
	DD	$LN26@ParseColli
$LN26@ParseColli:
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	80					; 00000050H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN25@ParseColli:
	DB	115					; 00000073H
	DB	83					; 00000053H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ParseCollisionObjects@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$0:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ParseCollisionObjects@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$1:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ParseCollisionObjects@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$2:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?ParseCollisionObjects@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-476]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ParseCollisionObjects@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ParseCollisionObjects@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ENDP ; CSpeedTreeRT::ParseCollisionObjects
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
_TEXT	SEGMENT
tv309 = -564						; size = 4
tv306 = -564						; size = 4
tv78 = -564						; size = 4
tv76 = -564						; size = 4
$T2 = -556						; size = 28
$T3 = -520						; size = 12
$T4 = -500						; size = 28
$T5 = -464						; size = 12
$T6 = -444						; size = 28
$T7 = -408						; size = 4
$T8 = -396						; size = 4
$T9 = -384						; size = 4
$T10 = -372						; size = 4
$T11 = -360						; size = 4
$T12 = -348						; size = 4
_cFile$13 = -144					; size = 28
_j$14 = -108						; size = 4
_i$15 = -96						; size = 4
_j$16 = -84						; size = 4
_i$17 = -72						; size = 4
_j$18 = -60						; size = 4
_i$19 = -48						; size = 4
_nToken$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pFile$ = 8						; size = 4
?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z PROC ; CSpeedTreeRT::ParseTextureCoordInfo, COMDAT
; _this$ = ecx

; 2502 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 552				; 00000228H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-372]
	mov	ecx, 90					; 0000005aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2503 :     m_pEmbeddedTexCoords = new SEmbeddedTexCoords;

	push	84					; 00000054H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN39@ParseTextu
	mov	ecx, DWORD PTR $T11[ebp]
	call	??0SEmbeddedTexCoords@@QAE@XZ		; SEmbeddedTexCoords::SEmbeddedTexCoords
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN40@ParseTextu
$LN39@ParseTextu:
	mov	DWORD PTR tv76[ebp], 0
$LN40@ParseTextu:
	mov	eax, DWORD PTR tv76[ebp]
	mov	DWORD PTR $T12[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T12[ebp]
	mov	DWORD PTR [ecx+76], edx

; 2504 : 
; 2505 :     int nToken = pFile->ParseToken( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseToken@CTreeFileAccess@@QAE?AW4EFileToken@@XZ ; CTreeFileAccess::ParseToken
	mov	DWORD PTR _nToken$[ebp], eax
$LN4@ParseTextu:

; 2506 :     do
; 2507 :     {
; 2508 :         switch (nToken)

	mov	eax, DWORD PTR _nToken$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	mov	ecx, DWORD PTR tv78[ebp]
	sub	ecx, 10002				; 00002712H
	mov	DWORD PTR tv78[ebp], ecx
	cmp	DWORD PTR tv78[ebp], 5
	ja	$LN35@ParseTextu
	mov	edx, DWORD PTR tv78[ebp]
	jmp	DWORD PTR $LN47@ParseTextu[edx*4]
$LN25@ParseTextu:

; 2509 :         {
; 2510 :         case File_LeafTextureCoords:
; 2511 :         {
; 2512 :             m_pEmbeddedTexCoords->m_nNumLeafMaps = pFile->ParseInt( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseInt@CTreeFileAccess@@QAEHXZ	; CTreeFileAccess::ParseInt
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [edx], eax

; 2513 :             if (m_pEmbeddedTexCoords->m_nNumLeafMaps > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	cmp	DWORD PTR [ecx], 0
	jle	$LN8@ParseTextu

; 2514 :             {
; 2515 :                 m_pEmbeddedTexCoords->m_pLeafTexCoords = new float[m_pEmbeddedTexCoords->m_nNumLeafMaps * 8];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	eax, DWORD PTR [ecx]
	shl	eax, 3
	mov	edx, 4
	mul	edx
	mov	ecx, -1
	cmovb	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T10[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR $T10[ebp]
	mov	DWORD PTR [eax+4], ecx

; 2516 :                 for (int i = 0; i < m_pEmbeddedTexCoords->m_nNumLeafMaps; ++i)

	mov	DWORD PTR _i$19[ebp], 0
	jmp	SHORT $LN9@ParseTextu
$LN7@ParseTextu:
	mov	eax, DWORD PTR _i$19[ebp]
	add	eax, 1
	mov	DWORD PTR _i$19[ebp], eax
$LN9@ParseTextu:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _i$19[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN8@ParseTextu

; 2517 :                 {
; 2518 :                     for (int j = 0; j < 8; ++j)

	mov	DWORD PTR _j$18[ebp], 0
	jmp	SHORT $LN12@ParseTextu
$LN10@ParseTextu:
	mov	eax, DWORD PTR _j$18[ebp]
	add	eax, 1
	mov	DWORD PTR _j$18[ebp], eax
$LN12@ParseTextu:
	cmp	DWORD PTR _j$18[ebp], 8
	jge	SHORT $LN11@ParseTextu

; 2519 :                         m_pEmbeddedTexCoords->m_pLeafTexCoords[i * 8 + j] = pFile->ParseFloat( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _i$19[ebp]
	mov	eax, DWORD PTR _j$18[ebp]
	lea	edx, DWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR [ecx+4]
	fstp	DWORD PTR [eax+edx*4]
	jmp	SHORT $LN10@ParseTextu
$LN11@ParseTextu:

; 2520 :                 }

	jmp	SHORT $LN7@ParseTextu
$LN8@ParseTextu:

; 2521 :             }
; 2522 :         }
; 2523 :         break;

	jmp	$LN5@ParseTextu
$LN27@ParseTextu:

; 2524 :         case File_BillboardTextureCoords:
; 2525 :         {
; 2526 :             m_pEmbeddedTexCoords->m_nNumBillboards = pFile->ParseInt( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseInt@CTreeFileAccess@@QAEHXZ	; CTreeFileAccess::ParseInt
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [edx+8], eax

; 2527 :             if (m_pEmbeddedTexCoords->m_nNumBillboards > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	cmp	DWORD PTR [ecx+8], 0
	jle	$LN14@ParseTextu

; 2528 :             {
; 2529 :                 m_pEmbeddedTexCoords->m_pBillboardTexCoords = new float[m_pEmbeddedTexCoords->m_nNumBillboards * 8];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	eax, DWORD PTR [ecx+8]
	shl	eax, 3
	mov	edx, 4
	mul	edx
	mov	ecx, -1
	cmovb	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR $T9[ebp]
	mov	DWORD PTR [eax+12], ecx

; 2530 :                 for (int i = 0; i < m_pEmbeddedTexCoords->m_nNumBillboards; ++i)

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN15@ParseTextu
$LN13@ParseTextu:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN15@ParseTextu:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	$LN14@ParseTextu

; 2531 :                 {
; 2532 :                     for (int j = 0; j < 8; ++j)

	mov	DWORD PTR _j$16[ebp], 0
	jmp	SHORT $LN18@ParseTextu
$LN16@ParseTextu:
	mov	eax, DWORD PTR _j$16[ebp]
	add	eax, 1
	mov	DWORD PTR _j$16[ebp], eax
$LN18@ParseTextu:
	cmp	DWORD PTR _j$16[ebp], 8
	jge	SHORT $LN17@ParseTextu

; 2533 :                     {
; 2534 :                         m_pEmbeddedTexCoords->m_pBillboardTexCoords[i * 8 + j] = pFile->ParseFloat( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _i$17[ebp]
	mov	eax, DWORD PTR _j$16[ebp]
	lea	edx, DWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR [ecx+12]
	fstp	DWORD PTR [eax+edx*4]

; 2535 :                         if (j % 2 && m_bTextureFlip) // flip T coordinates if necessary

	mov	eax, DWORD PTR _j$16[ebp]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN52@ParseTextu
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN52@ParseTextu:
	test	eax, eax
	je	SHORT $LN29@ParseTextu
	movzx	eax, BYTE PTR ?m_bTextureFlip@CSpeedTreeRT@@0_NA ; CSpeedTreeRT::m_bTextureFlip
	test	eax, eax
	je	SHORT $LN29@ParseTextu

; 2536 :                             m_pEmbeddedTexCoords->m_pBillboardTexCoords[i * 8 + j] = -m_pEmbeddedTexCoords->m_pBillboardTexCoords[i * 8 + j];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _i$17[ebp]
	mov	eax, DWORD PTR _j$16[ebp]
	lea	edx, DWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR [ecx+12]
	movss	xmm0, DWORD PTR [eax+edx*4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _i$17[ebp]
	mov	ecx, DWORD PTR _j$16[ebp]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR [edx+12]
	movss	DWORD PTR [ecx+eax*4], xmm0
$LN29@ParseTextu:

; 2537 :                     }

	jmp	$LN16@ParseTextu
$LN17@ParseTextu:

; 2538 :                 }

	jmp	$LN13@ParseTextu
$LN14@ParseTextu:

; 2539 :             }
; 2540 :         }
; 2541 :         break;

	jmp	$LN5@ParseTextu
$LN30@ParseTextu:

; 2542 :         case File_FrondTextureCoords:
; 2543 :         {
; 2544 :             m_pEmbeddedTexCoords->m_nNumFrondMaps = pFile->ParseInt( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseInt@CTreeFileAccess@@QAEHXZ	; CTreeFileAccess::ParseInt
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [edx+16], eax

; 2545 :             if (m_pEmbeddedTexCoords->m_nNumFrondMaps > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	cmp	DWORD PTR [ecx+16], 0
	jle	$LN20@ParseTextu

; 2546 :             {
; 2547 :                 m_pEmbeddedTexCoords->m_pFrondTexCoords = new float[m_pEmbeddedTexCoords->m_nNumFrondMaps * 8];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	eax, DWORD PTR [ecx+16]
	shl	eax, 3
	mov	edx, 4
	mul	edx
	mov	ecx, -1
	cmovb	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR $T8[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2548 :                 for (int i = 0; i < m_pEmbeddedTexCoords->m_nNumFrondMaps; ++i)

	mov	DWORD PTR _i$15[ebp], 0
	jmp	SHORT $LN21@ParseTextu
$LN19@ParseTextu:
	mov	eax, DWORD PTR _i$15[ebp]
	add	eax, 1
	mov	DWORD PTR _i$15[ebp], eax
$LN21@ParseTextu:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _i$15[ebp]
	cmp	edx, DWORD PTR [ecx+16]
	jge	SHORT $LN20@ParseTextu

; 2549 :                 {
; 2550 :                     for (int j = 0; j < 8; ++j)

	mov	DWORD PTR _j$14[ebp], 0
	jmp	SHORT $LN24@ParseTextu
$LN22@ParseTextu:
	mov	eax, DWORD PTR _j$14[ebp]
	add	eax, 1
	mov	DWORD PTR _j$14[ebp], eax
$LN24@ParseTextu:
	cmp	DWORD PTR _j$14[ebp], 8
	jge	SHORT $LN23@ParseTextu

; 2551 :                         m_pEmbeddedTexCoords->m_pFrondTexCoords[i * 8 + j] = pFile->ParseFloat( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _i$15[ebp]
	mov	eax, DWORD PTR _j$14[ebp]
	lea	edx, DWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR [ecx+20]
	fstp	DWORD PTR [eax+edx*4]
	jmp	SHORT $LN22@ParseTextu
$LN23@ParseTextu:

; 2552 :                 }

	jmp	SHORT $LN19@ParseTextu
$LN20@ParseTextu:

; 2553 :             }
; 2554 :         }
; 2555 :         break;

	jmp	$LN5@ParseTextu
$LN32@ParseTextu:

; 2556 :         case File_CompositeFilename:
; 2557 :         {
; 2558 :             CIdvFilename cFile = pFile->ParseString( );

	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T7[ebp], esp
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseString@CTreeFileAccess@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CTreeFileAccess::ParseString
	lea	ecx, DWORD PTR _cFile$13[ebp]
	call	??0CIdvFilename@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CIdvFilename::CIdvFilename
	mov	DWORD PTR tv306[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 2559 :             m_pEmbeddedTexCoords->m_strCompositeFilename = cFile.NoPath( );

	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	lea	ecx, DWORD PTR _cFile$13[ebp]
	call	?NoPath@CIdvFilename@@QBE?AV1@XZ	; CIdvFilename::NoPath
	mov	DWORD PTR tv309[ebp], eax
	mov	ecx, DWORD PTR tv309[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+76]
	add	ecx, 24					; 00000018H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1CIdvFilename@@QAE@XZ
	npad	1

; 2560 :         }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cFile$13[ebp]
	call	??1CIdvFilename@@QAE@XZ
	npad	1

; 2561 :         break;

	jmp	SHORT $LN5@ParseTextu
$LN33@ParseTextu:

; 2562 :         case File_HorizontalBillboard:
; 2563 :         {
; 2564 :             m_bHorizontalBillboard = pFile->ParseBool( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseBool@CTreeFileAccess@@QAE_NXZ	; CTreeFileAccess::ParseBool
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+105], al

; 2565 :         }
; 2566 :         break;

	jmp	SHORT $LN5@ParseTextu
$LN34@ParseTextu:

; 2567 :         case File_360Billboard:
; 2568 :         {
; 2569 :             m_b360Billboard = pFile->ParseBool( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseBool@CTreeFileAccess@@QAE_NXZ	; CTreeFileAccess::ParseBool
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+104], al

; 2570 :         }
; 2571 :         break;

	jmp	SHORT $LN5@ParseTextu
$LN35@ParseTextu:

; 2572 :         default:
; 2573 :             throw(IdvFileError("malformed texture coord info"));

	push	OFFSET ??_C@_0BN@HDKMKOP@malformed?5texture?5coord?5info@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	push	0
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; IdvFileError::IdvFileError
	push	OFFSET __TI3?AVIdvFileError@@
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	call	__CxxThrowException@8
	npad	1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN5@ParseTextu:

; 2574 :         }
; 2575 : 
; 2576 :         if (pFile->EndOfFile( ))

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?EndOfFile@CTreeFileAccess@@QBE_NXZ	; CTreeFileAccess::EndOfFile
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN36@ParseTextu

; 2577 :             throw(IdvFileError("premature end of file reached parsing texture coordinate info"));

	push	OFFSET ??_C@_0DO@PNMFDPBL@premature?5end?5of?5file?5reached?5p@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; IdvFileError::IdvFileError
	push	OFFSET __TI3?AVIdvFileError@@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	__CxxThrowException@8
	npad	1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	jmp	SHORT $LN37@ParseTextu
$LN36@ParseTextu:

; 2578 :         else
; 2579 :             nToken = pFile->ParseToken( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseToken@CTreeFileAccess@@QAE?AW4EFileToken@@XZ ; CTreeFileAccess::ParseToken
	mov	DWORD PTR _nToken$[ebp], eax
$LN37@ParseTextu:

; 2580 : 
; 2581 :     } while (nToken != File_EndTextureCoordInfo);

	cmp	DWORD PTR _nToken$[ebp], 10001		; 00002711H
	jne	$LN4@ParseTextu
$LN1@ParseTextu:

; 2582 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN51@ParseTextu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 564				; 00000234H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN51@ParseTextu:
	DD	1
	DD	$LN50@ParseTextu
$LN50@ParseTextu:
	DD	-144					; ffffff70H
	DD	28					; 0000001cH
	DD	$LN48@ParseTextu
$LN48@ParseTextu:
	DB	99					; 00000063H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
	npad	2
$LN47@ParseTextu:
	DD	$LN25@ParseTextu
	DD	$LN27@ParseTextu
	DD	$LN30@ParseTextu
	DD	$LN32@ParseTextu
	DD	$LN33@ParseTextu
	DD	$LN34@ParseTextu
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$0:
	push	84					; 00000054H
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$2:
	lea	ecx, DWORD PTR _cFile$13[ebp]
	jmp	??1CIdvFilename@@QAE@XZ
__unwindfunclet$?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$4:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$5:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-568]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ENDP ; CSpeedTreeRT::ParseTextureCoordInfo
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?ParseWindInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
_TEXT	SEGMENT
tv66 = -348						; size = 4
$T2 = -340						; size = 28
$T3 = -304						; size = 12
$T4 = -284						; size = 28
$T5 = -248						; size = 12
_nToken$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pFile$ = 8						; size = 4
?ParseWindInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z PROC ; CSpeedTreeRT::ParseWindInfo, COMDAT
; _this$ = ecx

; 2476 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ParseWindInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-156]
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2477 :     int nToken = pFile->ParseToken( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseToken@CTreeFileAccess@@QAE?AW4EFileToken@@XZ ; CTreeFileAccess::ParseToken
	mov	DWORD PTR _nToken$[ebp], eax
$LN4@ParseWindI:

; 2478 :     do
; 2479 :     {
; 2480 :         switch (nToken)

	mov	eax, DWORD PTR _nToken$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 11002		; 00002afaH
	je	SHORT $LN7@ParseWindI
	jmp	SHORT $LN8@ParseWindI
$LN7@ParseWindI:

; 2481 :         {
; 2482 :         case File_WindLevel:
; 2483 :             m_pEngine->SetBranchLevelForWeighting(pFile->ParseInt( ));

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseInt@CTreeFileAccess@@QAEHXZ	; CTreeFileAccess::ParseInt
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?SetBranchLevelForWeighting@CTreeEngine@@QAEXH@Z ; CTreeEngine::SetBranchLevelForWeighting
	npad	1

; 2484 :             break;

	jmp	SHORT $LN5@ParseWindI
$LN8@ParseWindI:

; 2485 :         default:
; 2486 :             throw(IdvFileError("malformed new wind info"));

	push	OFFSET ??_C@_0BI@IDEPHDPE@malformed?5new?5wind?5info@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; IdvFileError::IdvFileError
	push	OFFSET __TI3?AVIdvFileError@@
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	call	__CxxThrowException@8
	npad	1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN5@ParseWindI:

; 2487 :         }
; 2488 : 
; 2489 :         if (pFile->EndOfFile( ))

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?EndOfFile@CTreeFileAccess@@QBE_NXZ	; CTreeFileAccess::EndOfFile
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@ParseWindI

; 2490 :             throw(IdvFileError("premature end of file reached parsing new wind info"));

	push	OFFSET ??_C@_0DE@FHOGECHL@premature?5end?5of?5file?5reached?5p@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; IdvFileError::IdvFileError
	push	OFFSET __TI3?AVIdvFileError@@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	__CxxThrowException@8
	npad	1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	jmp	SHORT $LN10@ParseWindI
$LN9@ParseWindI:

; 2491 :         else
; 2492 :             nToken = pFile->ParseToken( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseToken@CTreeFileAccess@@QAE?AW4EFileToken@@XZ ; CTreeFileAccess::ParseToken
	mov	DWORD PTR _nToken$[ebp], eax
$LN10@ParseWindI:

; 2493 : 
; 2494 :     } while (nToken != File_EndNewWindInfo);

	cmp	DWORD PTR _nToken$[ebp], 11001		; 00002af9H
	jne	$LN4@ParseWindI
$LN1@ParseWindI:

; 2495 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 348				; 0000015cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ParseWindInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$0:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ParseWindInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$1:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?ParseWindInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-352]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ParseWindInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ParseWindInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ENDP ; CSpeedTreeRT::ParseWindInfo
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?ParseLodInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
_TEXT	SEGMENT
tv66 = -348						; size = 4
$T2 = -340						; size = 28
$T3 = -304						; size = 12
$T4 = -284						; size = 28
$T5 = -248						; size = 12
_nToken$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pFile$ = 8						; size = 4
?ParseLodInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z PROC ; CSpeedTreeRT::ParseLodInfo, COMDAT
; _this$ = ecx

; 2438 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ParseLodInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-156]
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2439 :     int nToken = pFile->ParseToken( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseToken@CTreeFileAccess@@QAE?AW4EFileToken@@XZ ; CTreeFileAccess::ParseToken
	mov	DWORD PTR _nToken$[ebp], eax
$LN4@ParseLodIn:

; 2440 :     do
; 2441 :     {
; 2442 :         switch (nToken)

	mov	eax, DWORD PTR _nToken$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR tv66[ebp]
	sub	ecx, 9002				; 0000232aH
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 7
	ja	SHORT $LN12@ParseLodIn
	mov	edx, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN18@ParseLodIn[edx*4]
$LN7@ParseLodIn:

; 2443 :         {
; 2444 :         case File_LeafTransitionMethod:
; 2445 :             m_eLeafLodMethod = static_cast<ELodMethod>(pFile->ParseInt( ));

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseInt@CTreeFileAccess@@QAEHXZ	; CTreeFileAccess::ParseInt
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 2446 :             break;

	jmp	$LN5@ParseLodIn
$LN8@ParseLodIn:

; 2447 :         case File_LeafTransitionRadius:
; 2448 :             m_fLeafLodTransitionRadius = pFile->ParseFloat();

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+28]

; 2449 :             break;

	jmp	$LN5@ParseLodIn
$LN9@ParseLodIn:

; 2450 :         case File_LeafCurveExponent:
; 2451 :             m_fLeafLodCurveExponent = pFile->ParseFloat( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+32]

; 2452 :             break;

	jmp	SHORT $LN5@ParseLodIn
$LN10@ParseLodIn:

; 2453 :         case File_LeafSizeIncreaseFactor:
; 2454 :             m_fLeafSizeIncreaseFactor = pFile->ParseFloat( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+36]

; 2455 :             break;

	jmp	SHORT $LN5@ParseLodIn
$LN11@ParseLodIn:

; 2456 :         case File_BeginEngineLodInfo:
; 2457 :             m_pEngine->ParseLodInfo(*pFile);

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?ParseLodInfo@CTreeEngine@@QAEXAAVCTreeFileAccess@@@Z ; CTreeEngine::ParseLodInfo
	npad	1

; 2458 :             break;

	jmp	SHORT $LN5@ParseLodIn
$LN12@ParseLodIn:

; 2459 :         default:
; 2460 :             throw(IdvFileError("malformed lod info"));

	push	OFFSET ??_C@_0BD@JMAANHEL@malformed?5lod?5info@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; IdvFileError::IdvFileError
	push	OFFSET __TI3?AVIdvFileError@@
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	call	__CxxThrowException@8
	npad	1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN5@ParseLodIn:

; 2461 :         }
; 2462 : 
; 2463 :         if (pFile->EndOfFile( ))

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?EndOfFile@CTreeFileAccess@@QBE_NXZ	; CTreeFileAccess::EndOfFile
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@ParseLodIn

; 2464 :             throw(IdvFileError("premature end of file reached parsing new lod info"));

	push	OFFSET ??_C@_0DD@JMFMAINC@premature?5end?5of?5file?5reached?5p@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; IdvFileError::IdvFileError
	push	OFFSET __TI3?AVIdvFileError@@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	__CxxThrowException@8
	npad	1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	jmp	SHORT $LN14@ParseLodIn
$LN13@ParseLodIn:

; 2465 :         else
; 2466 :             nToken = pFile->ParseToken( );

	mov	ecx, DWORD PTR _pFile$[ebp]
	call	?ParseToken@CTreeFileAccess@@QAE?AW4EFileToken@@XZ ; CTreeFileAccess::ParseToken
	mov	DWORD PTR _nToken$[ebp], eax
$LN14@ParseLodIn:

; 2467 : 
; 2468 :     } while (nToken != File_EndLodInfo);

	cmp	DWORD PTR _nToken$[ebp], 9001		; 00002329H
	jne	$LN4@ParseLodIn
$LN1@ParseLodIn:

; 2469 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 348				; 0000015cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN18@ParseLodIn:
	DD	$LN7@ParseLodIn
	DD	$LN8@ParseLodIn
	DD	$LN9@ParseLodIn
	DD	$LN11@ParseLodIn
	DD	$LN12@ParseLodIn
	DD	$LN12@ParseLodIn
	DD	$LN12@ParseLodIn
	DD	$LN10@ParseLodIn
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ParseLodInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$0:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ParseLodInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z$1:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?ParseLodInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-352]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ParseLodInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ParseLodInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ENDP ; CSpeedTreeRT::ParseLodInfo
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetError@CSpeedTreeRT@@CAXPBD@Z
_TEXT	SEGMENT
_pError$ = 8						; size = 4
?SetError@CSpeedTreeRT@@CAXPBD@Z PROC			; CSpeedTreeRT::SetError, COMDAT

; 2429 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2430 :     g_strError = pError;

	mov	eax, DWORD PTR _pError$[ebp]
	push	eax
	mov	ecx, OFFSET ?g_strError@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	npad	1

; 2431 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?SetError@CSpeedTreeRT@@CAXPBD@Z ENDP			; CSpeedTreeRT::SetError
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z
_TEXT	SEGMENT
tv193 = -356						; size = 4
tv190 = -356						; size = 4
tv199 = -352						; size = 4
tv198 = -352						; size = 4
tv196 = -352						; size = 4
tv195 = -352						; size = 4
tv188 = -352						; size = 4
tv65 = -352						; size = 4
tv197 = -349						; size = 1
$T2 = -344						; size = 28
$T3 = -308						; size = 28
$T4 = -272						; size = 12
$T5 = -249						; size = 1
_cException$6 = -48					; size = 4
_i$7 = -36						; size = 12
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_nMessage$ = 8						; size = 4
?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z PROC	; CSpeedTreeRT::NotifyAllTreesOfEvent, COMDAT

; 2395 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-164]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 2396 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2397 :     {
; 2398 :         for (vector<CSpeedTreeRT*>::iterator i = SInstanceList::m_vUniqueTrees.begin( ); i != SInstanceList::m_vUniqueTrees.end( ); ++i)

	lea	eax, DWORD PTR _i$7[ebp]
	push	eax
	mov	ecx, OFFSET ?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A ; SInstanceList::m_vUniqueTrees
	call	?begin@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::begin
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	jmp	SHORT $LN4@NotifyAllT
$LN2@NotifyAllT:
	lea	ecx, DWORD PTR _i$7[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator++
	npad	1
$LN4@NotifyAllT:
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, OFFSET ?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A ; SInstanceList::m_vUniqueTrees
	call	?end@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::end
	mov	DWORD PTR tv188[ebp], eax
	mov	ecx, DWORD PTR tv188[ebp]
	push	ecx
	lea	ecx, DWORD PTR _i$7[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator!=
	mov	BYTE PTR $T5[ebp], al
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	movzx	edx, BYTE PTR $T5[ebp]
	test	edx, edx
	je	$LN3@NotifyAllT

; 2399 :         {
; 2400 :             if (nMessage == STIE_CLIENT_CHANGED_WIND)

	cmp	DWORD PTR _nMessage$[ebp], 0
	jne	$LN6@NotifyAllT

; 2401 :             {
; 2402 :                 if ((*i)->GetBranchWindMethod( ) == WIND_CPU)

	lea	ecx, DWORD PTR _i$7[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEAAPAVCSpeedTreeRT@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator*
	mov	ecx, DWORD PTR [eax]
	call	?GetBranchWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ ; CSpeedTreeRT::GetBranchWindMethod
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 1
	jne	SHORT $LN8@NotifyAllT

; 2403 :                     (*i)->m_pBranchGeometry->Invalidate( );

	lea	ecx, DWORD PTR _i$7[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEAAPAVCSpeedTreeRT@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator*
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	call	?Invalidate@CIndexedGeometry@@QAEXXZ	; CIndexedGeometry::Invalidate
	npad	1
$LN8@NotifyAllT:

; 2404 : 
; 2405 :                 if ((*i)->GetFrondWindMethod( ) == WIND_CPU)

	lea	ecx, DWORD PTR _i$7[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEAAPAVCSpeedTreeRT@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator*
	mov	ecx, DWORD PTR [eax]
	call	?GetFrondWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ ; CSpeedTreeRT::GetFrondWindMethod
	mov	DWORD PTR tv195[ebp], eax
	cmp	DWORD PTR tv195[ebp], 1
	jne	SHORT $LN9@NotifyAllT

; 2406 :                     (*i)->m_pFrondGeometry->Invalidate( );

	lea	ecx, DWORD PTR _i$7[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEAAPAVCSpeedTreeRT@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator*
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+92]
	call	?Invalidate@CIndexedGeometry@@QAEXXZ	; CIndexedGeometry::Invalidate
	npad	1
$LN9@NotifyAllT:

; 2407 : 
; 2408 :                 if ((*i)->GetLeafWindMethod( ) == WIND_CPU ||

	lea	ecx, DWORD PTR _i$7[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEAAPAVCSpeedTreeRT@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator*
	mov	ecx, DWORD PTR [eax]
	call	?GetLeafWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ ; CSpeedTreeRT::GetLeafWindMethod
	mov	DWORD PTR tv196[ebp], eax
	cmp	DWORD PTR tv196[ebp], 1
	je	SHORT $LN11@NotifyAllT
	lea	ecx, DWORD PTR _i$7[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEAAPAVCSpeedTreeRT@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator*
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetLeafRockingState@CWindEngine@@QBE_NXZ ; CWindEngine::GetLeafRockingState
	mov	BYTE PTR tv197[ebp], al
	movzx	ecx, BYTE PTR tv197[ebp]
	test	ecx, ecx
	je	SHORT $LN10@NotifyAllT
$LN11@NotifyAllT:

; 2409 :                     (*i)->m_pWindEngine->GetLeafRockingState( ))
; 2410 :                     (*i)->m_pLeafGeometry->Invalidate( );

	lea	ecx, DWORD PTR _i$7[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEAAPAVCSpeedTreeRT@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator*
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+8]
	call	?Invalidate@CLeafGeometry@@QAEXXZ	; CLeafGeometry::Invalidate
	npad	1
$LN10@NotifyAllT:

; 2411 :             }

	jmp	SHORT $LN12@NotifyAllT
$LN6@NotifyAllT:

; 2412 :             else if (nMessage == STIE_CLIENT_CHANGED_CAMERA) // client changed camera

	cmp	DWORD PTR _nMessage$[ebp], 1
	jne	SHORT $LN12@NotifyAllT

; 2413 :             {
; 2414 :                 (*i)->m_pLeafGeometry->Invalidate( );

	lea	ecx, DWORD PTR _i$7[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEAAPAVCSpeedTreeRT@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator*
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+8]
	call	?Invalidate@CLeafGeometry@@QAEXXZ	; CLeafGeometry::Invalidate
	npad	1

; 2415 :                 (*i)->m_pSimpleBillboard->Invalidate( );

	lea	ecx, DWORD PTR _i$7[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEAAPAVCSpeedTreeRT@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator*
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+20]
	call	?Invalidate@CSimpleBillboard@@QAEXXZ	; CSimpleBillboard::Invalidate
	npad	1
$LN12@NotifyAllT:

; 2416 :             }

	jmp	$LN2@NotifyAllT
$LN3@NotifyAllT:

; 2417 :         }

	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR _i$7[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	npad	1

; 2418 :     }

	jmp	$LN14@NotifyAllT
__catch$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z$0:

; 2419 : 
; 2420 :     SpeedTreeCatch("CSpeedTreeRT::NotifyAllTreesOfEvent")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$6[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$6[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CE@LMHEPLMK@CSpeedTreeRT?3?3NotifyAllTreesOfE@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv198[ebp], eax
	mov	edx, DWORD PTR tv198[ebp]
	mov	DWORD PTR tv190[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv190[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN22@NotifyAllT
	ret	0
__catch$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z$1:

; 2421 :     SpeedTreeCatchAll("CSpeedTreeRT::NotifyAllTreesOfEvent");

	push	OFFSET ??_C@_0CE@LMHEPLMK@CSpeedTreeRT?3?3NotifyAllTreesOfE@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv199[ebp], eax
	mov	ecx, DWORD PTR tv199[ebp]
	mov	DWORD PTR tv193[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	mov	ecx, DWORD PTR tv193[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN24@NotifyAllT
	ret	0
$LN14@NotifyAllT:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN23@NotifyAllT
$LN24@NotifyAllT:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN21@NotifyAllT
$LN23@NotifyAllT:
	jmp	SHORT $LN21@NotifyAllT
$LN22@NotifyAllT:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN21@NotifyAllT:

; 2422 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN29@NotifyAllT
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 356				; 00000164H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN29@NotifyAllT:
	DD	2
	DD	$LN28@NotifyAllT
$LN28@NotifyAllT:
	DD	-36					; ffffffdcH
	DD	12					; 0000000cH
	DD	$LN25@NotifyAllT
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN26@NotifyAllT
$LN26@NotifyAllT:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN25@NotifyAllT:
	DB	105					; 00000069H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z$3:
	lea	ecx, DWORD PTR _i$7[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z$5:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z$6:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-360]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z ENDP	; CSpeedTreeRT::NotifyAllTreesOfEvent
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?ComputeSelfShadowTexCoords@CSpeedTreeRT@@AAEXXZ
_TEXT	SEGMENT
tv212 = -304						; size = 4
$T1 = -296						; size = 12
_cCenter$2 = -84					; size = 12
_fRadius$3 = -64					; size = 4
_cMax$4 = -52						; size = 12
_cMin$5 = -32						; size = 12
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?ComputeSelfShadowTexCoords@CSpeedTreeRT@@AAEXXZ PROC	; CSpeedTreeRT::ComputeSelfShadowTexCoords, COMDAT
; _this$ = ecx

; 3302 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-112]
	mov	ecx, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 3303 :     if (m_pBranchGeometry &&
; 3304 :         m_pFrondGeometry &&

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN4@ComputeSel
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	$LN4@ComputeSel
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	$LN4@ComputeSel

; 3305 :         m_pProjectedShadow)
; 3306 :     {
; 3307 :         // compute the radius of the circumscribing sphere
; 3308 :         CVec3 cMin(m_pTreeSizes[0], m_pTreeSizes[1], m_pTreeSizes[2]), cMax(m_pTreeSizes[3], m_pTreeSizes[4], m_pTreeSizes[5]);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _cMin$5[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	npad	1
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _cMax$4[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	npad	1

; 3309 :         float fRadius = cMin.Distance(cMax) * 0.5f;

	lea	eax, DWORD PTR _cMax$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _cMin$5[ebp]
	call	?Distance@CVec3@@QBEMABV1@@Z		; CVec3::Distance
	fstp	DWORD PTR tv212[ebp]
	movss	xmm0, DWORD PTR tv212[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _fRadius$3[ebp], xmm0

; 3310 : 
; 3311 :         // compute the center
; 3312 :         CVec3 cCenter = (cMin + cMax) * 0.5f;

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _cCenter$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _cMax$4[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _cMin$5[ebp]
	call	??HCVec3@@QBE?AV0@ABV0@@Z		; CVec3::operator+
	mov	ecx, eax
	call	??DCVec3@@QBE?AV0@M@Z			; CVec3::operator*
	npad	1

; 3313 :         
; 3314 :         if (m_pEmbeddedTexCoords)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	SHORT $LN3@ComputeSel

; 3315 :         {
; 3316 :             // compute branch tex coords
; 3317 :             m_pProjectedShadow->ComputeTexCoords(m_pBranchGeometry, cCenter, fRadius, m_pEmbeddedTexCoords->m_afShadowTexCoords);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	add	ecx, 52					; 00000034H
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _fRadius$3[ebp]
	movss	DWORD PTR [esp], xmm0
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	eax, DWORD PTR _cCenter$2[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _cCenter$2[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _cCenter$2[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	call	?ComputeTexCoords@CProjectedShadow@@QBEXPAVCIndexedGeometry@@VCVec3@@MPAM@Z ; CProjectedShadow::ComputeTexCoords
	npad	1

; 3318 : 
; 3319 :             // compute frond tex coords
; 3320 :             m_pProjectedShadow->ComputeTexCoords(m_pFrondGeometry, cCenter, fRadius, m_pEmbeddedTexCoords->m_afShadowTexCoords);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	add	ecx, 52					; 00000034H
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _fRadius$3[ebp]
	movss	DWORD PTR [esp], xmm0
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	eax, DWORD PTR _cCenter$2[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _cCenter$2[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _cCenter$2[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	call	?ComputeTexCoords@CProjectedShadow@@QBEXPAVCIndexedGeometry@@VCVec3@@MPAM@Z ; CProjectedShadow::ComputeTexCoords
	npad	1

; 3321 :         }

	jmp	SHORT $LN4@ComputeSel
$LN3@ComputeSel:

; 3322 :         else
; 3323 :         {
; 3324 :             // compute branch tex coords
; 3325 :             m_pProjectedShadow->ComputeTexCoords(m_pBranchGeometry, cCenter, fRadius);

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _fRadius$3[ebp]
	movss	DWORD PTR [esp], xmm0
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR _cCenter$2[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _cCenter$2[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _cCenter$2[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+80]
	call	?ComputeTexCoords@CProjectedShadow@@QBEXPAVCIndexedGeometry@@VCVec3@@MPAM@Z ; CProjectedShadow::ComputeTexCoords
	npad	1

; 3326 : 
; 3327 :             // compute frond tex coords
; 3328 :             m_pProjectedShadow->ComputeTexCoords(m_pFrondGeometry, cCenter, fRadius);

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _fRadius$3[ebp]
	movss	DWORD PTR [esp], xmm0
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR _cCenter$2[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _cCenter$2[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _cCenter$2[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+80]
	call	?ComputeTexCoords@CProjectedShadow@@QBEXPAVCIndexedGeometry@@VCVec3@@MPAM@Z ; CProjectedShadow::ComputeTexCoords
	npad	1
$LN4@ComputeSel:

; 3329 :         }
; 3330 :     }
; 3331 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@ComputeSel
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@ComputeSel:
	DD	3
	DD	$LN9@ComputeSel
$LN9@ComputeSel:
	DD	-32					; ffffffe0H
	DD	12					; 0000000cH
	DD	$LN6@ComputeSel
	DD	-52					; ffffffccH
	DD	12					; 0000000cH
	DD	$LN7@ComputeSel
	DD	-84					; ffffffacH
	DD	12					; 0000000cH
	DD	$LN8@ComputeSel
$LN8@ComputeSel:
	DB	99					; 00000063H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN7@ComputeSel:
	DB	99					; 00000063H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	120					; 00000078H
	DB	0
$LN6@ComputeSel:
	DB	99					; 00000063H
	DB	77					; 0000004dH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	0
?ComputeSelfShadowTexCoords@CSpeedTreeRT@@AAEXXZ ENDP	; CSpeedTreeRT::ComputeSelfShadowTexCoords
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ
_TEXT	SEGMENT
tv158 = -380						; size = 4
tv155 = -380						; size = 4
tv163 = -376						; size = 4
tv162 = -376						; size = 4
tv160 = -376						; size = 4
tv161 = -374						; size = 2
$T2 = -368						; size = 28
$T3 = -332						; size = 28
_cException$4 = -104					; size = 4
_pAllLeaves$5 = -92					; size = 4
_cTreeCenter$6 = -80					; size = 12
_afBoundingBox$7 = -60					; size = 24
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ PROC	; CSpeedTreeRT::ComputeLeafStaticLighting, COMDAT
; _this$ = ecx

; 2373 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 364				; 0000016cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-188]
	mov	ecx, 43					; 0000002bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2374 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2375 :     {
; 2376 :         float afBoundingBox[6];
; 2377 :         GetBoundingBox(afBoundingBox);

	lea	eax, DWORD PTR _afBoundingBox$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBoundingBox@CSpeedTreeRT@@QBEXPAM@Z	; CSpeedTreeRT::GetBoundingBox
	npad	1

; 2378 :         CVec3 cTreeCenter((afBoundingBox[0] + afBoundingBox[3]) * 0.5f,

	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _afBoundingBox$7[ebp+edx]
	addss	xmm0, DWORD PTR _afBoundingBox$7[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 2
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _afBoundingBox$7[ebp+ecx]
	addss	xmm0, DWORD PTR _afBoundingBox$7[ebp+eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _afBoundingBox$7[ebp+edx]
	addss	xmm0, DWORD PTR _afBoundingBox$7[ebp+eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _cTreeCenter$6[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	npad	1

; 2379 :                           (afBoundingBox[1] + afBoundingBox[4]) * 0.5f,
; 2380 :                           (afBoundingBox[2] + afBoundingBox[5]) * 0.5f);
; 2381 : 
; 2382 :         vector<CBillboardLeaf*>* pAllLeaves = m_pEngine->GetAllLeaves( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetAllLeaves@CTreeEngine@@QBEPAV?$vector@PAVCBillboardLeaf@@V?$allocator@PAVCBillboardLeaf@@@std@@@std@@XZ ; CTreeEngine::GetAllLeaves
	mov	DWORD PTR tv160[ebp], eax
	mov	ecx, DWORD PTR tv160[ebp]
	mov	DWORD PTR _pAllLeaves$5[ebp], ecx

; 2383 :         m_pLightingEngine->ComputeLeafStaticLighting(cTreeCenter, pAllLeaves, GetNumLeafLodLevels( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumLeafLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumLeafLodLevels
	mov	WORD PTR tv161[ebp], ax
	movzx	eax, WORD PTR tv161[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAllLeaves$5[ebp]
	push	ecx
	lea	edx, DWORD PTR _cTreeCenter$6[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?ComputeLeafStaticLighting@CLightingEngine@@QAEXABVCVec3@@PAV?$vector@PAVCBillboardLeaf@@V?$allocator@PAVCBillboardLeaf@@@std@@@std@@H@Z ; CLightingEngine::ComputeLeafStaticLighting
	npad	1

; 2384 :     }

	jmp	$LN4@ComputeLea
__catch$?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ$0:

; 2385 : 
; 2386 :     SpeedTreeCatch("CSpeedTreeRT::ComputeLeafStaticLighting")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CI@BADCNPAN@CSpeedTreeRT?3?3ComputeLeafStatic@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv162[ebp], eax
	mov	edx, DWORD PTR tv162[ebp]
	mov	DWORD PTR tv155[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv155[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN10@ComputeLea
	ret	0
__catch$?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ$1:

; 2387 :     SpeedTreeCatchAll("CSpeedTreeRT::ComputeLeafStaticLighting");

	push	OFFSET ??_C@_0CI@BADCNPAN@CSpeedTreeRT?3?3ComputeLeafStatic@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv163[ebp], eax
	mov	ecx, DWORD PTR tv163[ebp]
	mov	DWORD PTR tv158[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv158[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN12@ComputeLea
	ret	0
$LN4@ComputeLea:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN11@ComputeLea
$LN12@ComputeLea:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN9@ComputeLea
$LN11@ComputeLea:
	jmp	SHORT $LN9@ComputeLea
$LN10@ComputeLea:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@ComputeLea:

; 2388 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@ComputeLea
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 380				; 0000017cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN18@ComputeLea:
	DD	3
	DD	$LN17@ComputeLea
$LN17@ComputeLea:
	DD	-60					; ffffffc4H
	DD	24					; 00000018H
	DD	$LN13@ComputeLea
	DD	-80					; ffffffb0H
	DD	12					; 0000000cH
	DD	$LN14@ComputeLea
	DD	-104					; ffffff98H
	DD	4
	DD	$LN15@ComputeLea
$LN15@ComputeLea:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN14@ComputeLea:
	DB	99					; 00000063H
	DB	84					; 00000054H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	101					; 00000065H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN13@ComputeLea:
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	66					; 00000042H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	66					; 00000042H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-384]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ ENDP	; CSpeedTreeRT::ComputeLeafStaticLighting
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??0CSpeedTreeRT@@AAE@PBV0@@Z
_TEXT	SEGMENT
tv289 = -360						; size = 4
tv285 = -360						; size = 4
tv281 = -360						; size = 4
tv288 = -356						; size = 4
tv284 = -356						; size = 4
tv280 = -356						; size = 4
tv230 = -356						; size = 4
tv291 = -352						; size = 4
tv287 = -352						; size = 4
tv283 = -352						; size = 4
tv279 = -352						; size = 4
tv276 = -352						; size = 4
tv273 = -352						; size = 4
tv295 = -348						; size = 4
tv294 = -348						; size = 4
tv293 = -348						; size = 4
tv292 = -348						; size = 4
tv290 = -348						; size = 4
tv286 = -348						; size = 4
tv282 = -348						; size = 4
tv278 = -348						; size = 4
$T2 = -340						; size = 28
$T3 = -304						; size = 28
$T4 = -268						; size = 4
$T5 = -256						; size = 4
$T6 = -244						; size = 4
_cException$7 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_pOrig$ = 8						; size = 4
??0CSpeedTreeRT@@AAE@PBV0@@Z PROC			; CSpeedTreeRT::CSpeedTreeRT, COMDAT
; _this$ = ecx

; 504  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CSpeedTreeRT@@AAE@PBV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 344				; 00000158H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-168]
	mov	ecx, 38					; 00000026H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 469  :     m_pEngine(pOrig->m_pEngine),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 470  :     m_pBranchGeometry(pOrig->m_pBranchGeometry),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 471  :     m_pLeafGeometry(pOrig->m_pLeafGeometry),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 472  :     m_pLightingEngine(pOrig->m_pLightingEngine),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 473  :     m_pWindEngine(pOrig->m_pWindEngine),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 474  :     m_pSimpleBillboard(pOrig->m_pSimpleBillboard),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 480  :     // leaf lod
; 481  :     m_eLeafLodMethod(pOrig->m_eLeafLodMethod),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 482  :     m_fLeafLodTransitionRadius(pOrig->m_fLeafLodTransitionRadius),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx

; 483  :     m_fLeafLodCurveExponent(pOrig->m_fLeafLodCurveExponent),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx

; 484  :     m_fLeafSizeIncreaseFactor(pOrig->m_fLeafSizeIncreaseFactor),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx

; 485  :     m_fLeafTransitionFactor(pOrig->m_fLeafTransitionFactor),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx

; 486  :     m_pLeafLodSizeFactors(pOrig->m_pLeafLodSizeFactors),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], edx

; 487  :     // instancing
; 488  :     m_pInstanceRefCount(pOrig->m_pInstanceRefCount),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx

; 489  :     m_pInstanceList(pOrig->m_pInstanceList),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edx

; 478  :     m_nFrondLevel(pOrig->m_nFrondLevel),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+60], edx

; 490  :     // other
; 491  :     m_pTreeSizes(pOrig->m_pTreeSizes),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+64], edx

; 492  :     m_ucTargetAlphaValue(pOrig->m_ucTargetAlphaValue),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	dl, BYTE PTR [ecx+68]
	mov	BYTE PTR [eax+68], dl

; 493  :     m_bTreeComputed(pOrig->m_bTreeComputed),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	dl, BYTE PTR [ecx+69]
	mov	BYTE PTR [eax+69], dl

; 477  :     m_nBranchWindLevel(pOrig->m_nBranchWindLevel),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+72], edx

; 494  :     // texcoords
; 495  :     m_pEmbeddedTexCoords(pOrig->m_pEmbeddedTexCoords),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+76], edx

; 500  :     // shadow projection
; 501  :     m_pProjectedShadow(pOrig->m_pProjectedShadow),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+80], edx

; 498  :     // collision objects
; 499  :     m_pCollisionObjects(pOrig->m_pCollisionObjects),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+84], edx

; 475  :     m_pFrondEngine(pOrig->m_pFrondEngine),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax+88], edx

; 476  :     m_pFrondGeometry(pOrig->m_pFrondGeometry),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [eax+92], edx

; 479  :     m_usNumFrondLodLevels(pOrig->m_usNumFrondLodLevels),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	dx, WORD PTR [ecx+96]
	mov	WORD PTR [eax+96], dx

; 502  :     // user data
; 503  :     m_pUserData(pOrig->m_pUserData)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR [eax+100], edx

; 496  :     m_b360Billboard(pOrig->m_b360Billboard),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	dl, BYTE PTR [ecx+104]
	mov	BYTE PTR [eax+104], dl

; 497  :     m_bHorizontalBillboard(pOrig->m_bHorizontalBillboard),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOrig$[ebp]
	mov	dl, BYTE PTR [ecx+105]
	mov	BYTE PTR [eax+105], dl

; 505  :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 506  :     {
; 507  :         st_assert(pOrig);

	cmp	DWORD PTR _pOrig$[ebp], 0
	jne	$LN3@CSpeedTree
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv278[ebp], eax
	mov	ecx, DWORD PTR ?__LINE__Var@?0???0CSpeedTreeRT@@AAE@PBV1@@Z@4JA
	add	ecx, 40					; 00000028H
	mov	esi, esp
	push	ecx
	mov	ecx, DWORD PTR tv278[ebp]
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv279[ebp], eax
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	edx, DWORD PTR tv279[ebp]
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv280[ebp], eax
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	mov	eax, DWORD PTR tv280[ebp]
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv281[ebp], eax
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	ecx, DWORD PTR tv281[ebp]
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN3@CSpeedTree:

; 508  :         st_assert(pOrig->m_pEngine);

	mov	eax, DWORD PTR _pOrig$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$LN4@CSpeedTree
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv282[ebp], eax
	mov	ecx, DWORD PTR ?__LINE__Var@?0???0CSpeedTreeRT@@AAE@PBV1@@Z@4JA
	add	ecx, 41					; 00000029H
	mov	esi, esp
	push	ecx
	mov	ecx, DWORD PTR tv282[ebp]
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv283[ebp], eax
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	edx, DWORD PTR tv283[ebp]
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv284[ebp], eax
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	mov	eax, DWORD PTR tv284[ebp]
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv285[ebp], eax
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	ecx, DWORD PTR tv285[ebp]
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN4@CSpeedTree:

; 509  :         st_assert(m_pInstanceRefCount);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	$LN5@CSpeedTree
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv286[ebp], eax
	mov	ecx, DWORD PTR ?__LINE__Var@?0???0CSpeedTreeRT@@AAE@PBV1@@Z@4JA
	add	ecx, 42					; 0000002aH
	mov	esi, esp
	push	ecx
	mov	ecx, DWORD PTR tv286[ebp]
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv287[ebp], eax
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	edx, DWORD PTR tv287[ebp]
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv288[ebp], eax
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	mov	eax, DWORD PTR tv288[ebp]
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv289[ebp], eax
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	ecx, DWORD PTR tv289[ebp]
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN5@CSpeedTree:

; 510  : 
; 511  :         // add to parent's instance list
; 512  :         m_pInstanceList->m_vInstances.push_back(this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T6[ebp], eax
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?push_back@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAEX$$QAPAVCSpeedTreeRT@@@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::push_back
	npad	1

; 513  : 
; 514  :         // copy horizontal billboard coordinates
; 515  :         memcpy(m_afHorizontalCoords, pOrig->m_afHorizontalCoords, 12 * sizeof(float));

	push	48					; 00000030H
	mov	eax, DWORD PTR _pOrig$[ebp]
	add	eax, 108				; 0000006cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 516  : 
; 517  :         // reference counting for instances
; 518  :         (*m_pInstanceRefCount)++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [ecx], edx

; 519  :         m_pInstanceData = new STreeInstanceData;

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv290[ebp], eax
	mov	eax, DWORD PTR tv290[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN7@CSpeedTree
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0STreeInstanceData@@QAE@XZ		; STreeInstanceData::STreeInstanceData
	mov	DWORD PTR tv291[ebp], eax
	mov	ecx, DWORD PTR tv291[ebp]
	mov	DWORD PTR tv230[ebp], ecx
	jmp	SHORT $LN8@CSpeedTree
$LN7@CSpeedTree:
	mov	DWORD PTR tv230[ebp], 0
$LN8@CSpeedTree:
	mov	edx, DWORD PTR tv230[ebp]
	mov	DWORD PTR $T5[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR [eax+52], ecx

; 520  :         m_pInstanceData->m_pParent = pOrig;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _pOrig$[ebp]
	mov	DWORD PTR [ecx], edx

; 521  :         m_pInstanceData->m_cPosition = pOrig->m_pEngine->GetPosition( );

	mov	eax, DWORD PTR _pOrig$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetPosition@CIdvCamera@@QBEABVCVec3@@XZ ; CIdvCamera::GetPosition
	mov	DWORD PTR tv292[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	add	edx, 4
	mov	eax, DWORD PTR tv292[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 522  :         m_pInstanceData->m_fLodLevel = pOrig->GetLodLevel( );

	mov	ecx, DWORD PTR _pOrig$[ebp]
	call	?GetLodLevel@CSpeedTreeRT@@QBEMXZ	; CSpeedTreeRT::GetLodLevel
	fstp	DWORD PTR tv293[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	movss	xmm0, DWORD PTR tv293[ebp]
	movss	DWORD PTR [ecx+16], xmm0

; 523  : 
; 524  :         m_uiAllRefCount++;

	mov	eax, DWORD PTR ?m_uiAllRefCount@CSpeedTreeRT@@0IA ; CSpeedTreeRT::m_uiAllRefCount
	add	eax, 1
	mov	DWORD PTR ?m_uiAllRefCount@CSpeedTreeRT@@0IA, eax ; CSpeedTreeRT::m_uiAllRefCount

; 525  :     }

	jmp	$LN9@CSpeedTree
__catch$??0CSpeedTreeRT@@AAE@PBV0@@Z$0:

; 526  : 
; 527  :     SpeedTreeCatch("CSpeedTreeRT::CSpeedTreeRT(CSpeedTreeRT*)")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$7[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$7[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CK@KICMMLEH@CSpeedTreeRT?3?3CSpeedTreeRT?$CICSpe@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv294[ebp], eax
	mov	edx, DWORD PTR tv294[ebp]
	mov	DWORD PTR tv273[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv273[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN16@CSpeedTree
	ret	0
__catch$??0CSpeedTreeRT@@AAE@PBV0@@Z$1:

; 528  :     SpeedTreeCatchAll("CSpeedTreeRT::CSpeedTreeRT(CSpeedTreeRT*)");

	push	OFFSET ??_C@_0CK@KICMMLEH@CSpeedTreeRT?3?3CSpeedTreeRT?$CICSpe@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv295[ebp], eax
	mov	ecx, DWORD PTR tv295[ebp]
	mov	DWORD PTR tv276[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	mov	ecx, DWORD PTR tv276[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN18@CSpeedTree
	ret	0
$LN9@CSpeedTree:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN17@CSpeedTree
$LN18@CSpeedTree:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN15@CSpeedTree
$LN17@CSpeedTree:
	jmp	SHORT $LN15@CSpeedTree
$LN16@CSpeedTree:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN15@CSpeedTree:

; 529  : }

	mov	eax, DWORD PTR _this$[ebp]
$LN6@CSpeedTree:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@CSpeedTree
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 360				; 00000168H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN22@CSpeedTree:
	DD	1
	DD	$LN21@CSpeedTree
$LN21@CSpeedTree:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN19@CSpeedTree
$LN19@CSpeedTree:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CSpeedTreeRT@@AAE@PBV0@@Z$3:
	push	20					; 00000014H
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0CSpeedTreeRT@@AAE@PBV0@@Z$4:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CSpeedTreeRT@@AAE@PBV0@@Z$5:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0CSpeedTreeRT@@AAE@PBV0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-364]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CSpeedTreeRT@@AAE@PBV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CSpeedTreeRT@@AAE@PBV0@@Z ENDP			; CSpeedTreeRT::CSpeedTreeRT
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetUserData@CSpeedTreeRT@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetUserData@CSpeedTreeRT@@QBEPBDXZ PROC		; CSpeedTreeRT::GetUserData, COMDAT
; _this$ = ecx

; 3461 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3462 :     return m_pUserData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+100]

; 3463 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUserData@CSpeedTreeRT@@QBEPBDXZ ENDP		; CSpeedTreeRT::GetUserData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetCollisionObject@CSpeedTreeRT@@QAEXIAAW4ECollisionObjectType@1@PAM1@Z
_TEXT	SEGMENT
tv143 = -264						; size = 4
tv144 = -260						; size = 4
$T2 = -252						; size = 28
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_nIndex$ = 8						; size = 4
_eType$ = 12						; size = 4
_pPosition$ = 16					; size = 4
_pDimensions$ = 20					; size = 4
?GetCollisionObject@CSpeedTreeRT@@QAEXIAAW4ECollisionObjectType@1@PAM1@Z PROC ; CSpeedTreeRT::GetCollisionObject, COMDAT
; _this$ = ecx

; 2603 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetCollisionObject@CSpeedTreeRT@@QAEXIAAW4ECollisionObjectType@1@PAM1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2604 :     if (m_pCollisionObjects)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	$LN2@GetCollisi

; 2605 :     {
; 2606 :         if (nIndex >= m_pCollisionObjects->m_vObjects.size( ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	call	?size@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ ; std::vector<SShape,std::allocator<SShape> >::size
	cmp	DWORD PTR _nIndex$[ebp], eax
	jb	SHORT $LN4@GetCollisi

; 2607 :             SetError(IdvFormatString("collision object index (%d) exceeds maximum index (%d)", nIndex, m_pCollisionObjects->m_vObjects.size( )).c_str( ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	call	?size@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ ; std::vector<SShape,std::allocator<SShape> >::size
	push	eax
	mov	ecx, DWORD PTR _nIndex$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DH@IIFFBJOD@collision?5object?5index?5?$CI?$CFd?$CJ?5exc@
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv144[ebp], eax
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR tv143[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv143[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	jmp	SHORT $LN5@GetCollisi
$LN4@GetCollisi:

; 2608 :         else
; 2609 :         {
; 2610 :             eType = m_pCollisionObjects->m_vObjects[nIndex].m_eType;

	mov	eax, DWORD PTR _nIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+84]
	call	??A?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAEAAUSShape@@I@Z ; std::vector<SShape,std::allocator<SShape> >::operator[]
	mov	edx, DWORD PTR _eType$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 2611 :             memcpy(pPosition, m_pCollisionObjects->m_vObjects[nIndex].m_afPosition, 3 * sizeof(float));

	push	12					; 0000000cH
	mov	eax, DWORD PTR _nIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+84]
	call	??A?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAEAAUSShape@@I@Z ; std::vector<SShape,std::allocator<SShape> >::operator[]
	add	eax, 4
	push	eax
	mov	edx, DWORD PTR _pPosition$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2612 :             memcpy(pDimensions, m_pCollisionObjects->m_vObjects[nIndex].m_afDimensions, 3 * sizeof(float));

	push	12					; 0000000cH
	mov	eax, DWORD PTR _nIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+84]
	call	??A?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QAEAAUSShape@@I@Z ; std::vector<SShape,std::allocator<SShape> >::operator[]
	add	eax, 16					; 00000010H
	push	eax
	mov	edx, DWORD PTR _pDimensions$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN5@GetCollisi:

; 2613 :         }
; 2614 :     }

	jmp	SHORT $LN3@GetCollisi
$LN2@GetCollisi:

; 2615 :     else
; 2616 :         SetError("no collision objects are stored with this tree");

	push	OFFSET ??_C@_0CP@MJBCMBLO@no?5collision?5objects?5are?5stored@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN3@GetCollisi:

; 2617 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetCollisionObject@CSpeedTreeRT@@QAEXIAAW4ECollisionObjectType@1@PAM1@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?GetCollisionObject@CSpeedTreeRT@@QAEXIAAW4ECollisionObjectType@1@PAM1@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-268]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetCollisionObject@CSpeedTreeRT@@QAEXIAAW4ECollisionObjectType@1@PAM1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetCollisionObject@CSpeedTreeRT@@QAEXIAAW4ECollisionObjectType@1@PAM1@Z ENDP ; CSpeedTreeRT::GetCollisionObject
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetCollisionObjectCount@CSpeedTreeRT@@QAEIXZ
_TEXT	SEGMENT
_nCount$ = -20						; size = 4
_this$ = -8						; size = 4
?GetCollisionObjectCount@CSpeedTreeRT@@QAEIXZ PROC	; CSpeedTreeRT::GetCollisionObjectCount, COMDAT
; _this$ = ecx

; 2589 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2590 :     unsigned int nCount = 0;

	mov	DWORD PTR _nCount$[ebp], 0

; 2591 : 
; 2592 :     if (m_pCollisionObjects)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $LN2@GetCollisi

; 2593 :         nCount = m_pCollisionObjects->m_vObjects.size( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	call	?size@?$vector@USShape@@V?$allocator@USShape@@@std@@@std@@QBEIXZ ; std::vector<SShape,std::allocator<SShape> >::size
	mov	DWORD PTR _nCount$[ebp], eax
$LN2@GetCollisi:

; 2594 : 
; 2595 :     return nCount;

	mov	eax, DWORD PTR _nCount$[ebp]

; 2596 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCollisionObjectCount@CSpeedTreeRT@@QAEIXZ ENDP	; CSpeedTreeRT::GetCollisionObjectCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z
_TEXT	SEGMENT
tv134 = -340						; size = 4
tv131 = -340						; size = 4
tv139 = -336						; size = 4
tv138 = -336						; size = 4
tv137 = -336						; size = 4
tv136 = -334						; size = 2
$T2 = -328						; size = 28
$T3 = -292						; size = 28
_cException$4 = -64					; size = 4
_nDiscreteLevel$5 = -52					; size = 4
_nTriangleCount$ = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_fLodLevel$ = 8						; size = 4
?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z PROC	; CSpeedTreeRT::GetFrondTriangleCount, COMDAT
; _this$ = ecx

; 2352 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 324				; 00000144H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 33					; 00000021H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2353 :     unsigned int nTriangleCount = 0;

	mov	DWORD PTR _nTriangleCount$[ebp], 0

; 2354 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2355 :     {
; 2356 :         int nDiscreteLevel = GetDiscreteFrondLodLevel(fLodLevel);

	push	ecx
	movss	xmm0, DWORD PTR _fLodLevel$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiscreteFrondLodLevel@CSpeedTreeRT@@QBEFM@Z ; CSpeedTreeRT::GetDiscreteFrondLodLevel
	mov	WORD PTR tv136[ebp], ax
	movsx	eax, WORD PTR tv136[ebp]
	mov	DWORD PTR _nDiscreteLevel$5[ebp], eax

; 2357 :         if (nDiscreteLevel != -1 &&

	cmp	DWORD PTR _nDiscreteLevel$5[ebp], -1
	je	SHORT $LN3@GetFrondTr
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN3@GetFrondTr

; 2358 :             m_pFrondGeometry)
; 2359 :             nTriangleCount = m_pFrondGeometry->GetTriangleCount(static_cast<unsigned short>(nDiscreteLevel));

	movzx	eax, WORD PTR _nDiscreteLevel$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+92]
	call	?GetTriangleCount@CIndexedGeometry@@QBEIG@Z ; CIndexedGeometry::GetTriangleCount
	mov	DWORD PTR tv137[ebp], eax
	mov	edx, DWORD PTR tv137[ebp]
	mov	DWORD PTR _nTriangleCount$[ebp], edx
$LN3@GetFrondTr:

; 2360 :     }

	jmp	$LN5@GetFrondTr
__catch$?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z$0:

; 2361 : 
; 2362 :     SpeedTreeCatch("CSpeedTreeRT::GetFrondTriangleCount")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CE@JHCKAGHJ@CSpeedTreeRT?3?3GetFrondTriangleC@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv138[ebp], eax
	mov	edx, DWORD PTR tv138[ebp]
	mov	DWORD PTR tv131[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv131[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN11@GetFrondTr
	ret	0
__catch$?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z$1:

; 2363 :     SpeedTreeCatchAll("CSpeedTreeRT::GetFrondTriangleCount");

	push	OFFSET ??_C@_0CE@JHCKAGHJ@CSpeedTreeRT?3?3GetFrondTriangleC@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR tv139[ebp]
	mov	DWORD PTR tv134[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv134[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN13@GetFrondTr
	ret	0
$LN5@GetFrondTr:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN12@GetFrondTr
$LN13@GetFrondTr:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN10@GetFrondTr
$LN12@GetFrondTr:
	jmp	SHORT $LN10@GetFrondTr
$LN11@GetFrondTr:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN10@GetFrondTr:

; 2364 : 
; 2365 :     return nTriangleCount;

	mov	eax, DWORD PTR _nTriangleCount$[ebp]

; 2366 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@GetFrondTr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN17@GetFrondTr:
	DD	1
	DD	$LN16@GetFrondTr
$LN16@GetFrondTr:
	DD	-64					; ffffffc0H
	DD	4
	DD	$LN14@GetFrondTr
$LN14@GetFrondTr:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-344]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFrondTriangleCount@CSpeedTreeRT@@QBEIM@Z ENDP	; CSpeedTreeRT::GetFrondTriangleCount
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z
_TEXT	SEGMENT
tv134 = -340						; size = 4
tv131 = -340						; size = 4
tv139 = -336						; size = 4
tv138 = -336						; size = 4
tv137 = -336						; size = 4
tv136 = -334						; size = 2
$T2 = -328						; size = 28
$T3 = -292						; size = 28
_cException$4 = -64					; size = 4
_nDiscreteLevel$5 = -52					; size = 4
_nTriangleCount$ = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_fLodLevel$ = 8						; size = 4
?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z PROC	; CSpeedTreeRT::GetBranchTriangleCount, COMDAT
; _this$ = ecx

; 2331 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 324				; 00000144H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 33					; 00000021H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2332 :     unsigned int nTriangleCount = 0;

	mov	DWORD PTR _nTriangleCount$[ebp], 0

; 2333 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2334 :     {
; 2335 :         int nDiscreteLevel = GetDiscreteBranchLodLevel(fLodLevel);

	push	ecx
	movss	xmm0, DWORD PTR _fLodLevel$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiscreteBranchLodLevel@CSpeedTreeRT@@QBEFM@Z ; CSpeedTreeRT::GetDiscreteBranchLodLevel
	mov	WORD PTR tv136[ebp], ax
	movsx	eax, WORD PTR tv136[ebp]
	mov	DWORD PTR _nDiscreteLevel$5[ebp], eax

; 2336 :         if (nDiscreteLevel != -1 &&

	cmp	DWORD PTR _nDiscreteLevel$5[ebp], -1
	je	SHORT $LN3@GetBranchT
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@GetBranchT

; 2337 :             m_pBranchGeometry)
; 2338 :             nTriangleCount = m_pBranchGeometry->GetTriangleCount(static_cast<unsigned short>(nDiscreteLevel));

	movzx	eax, WORD PTR _nDiscreteLevel$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetTriangleCount@CIndexedGeometry@@QBEIG@Z ; CIndexedGeometry::GetTriangleCount
	mov	DWORD PTR tv137[ebp], eax
	mov	edx, DWORD PTR tv137[ebp]
	mov	DWORD PTR _nTriangleCount$[ebp], edx
$LN3@GetBranchT:

; 2339 :     }

	jmp	$LN5@GetBranchT
__catch$?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z$0:

; 2340 : 
; 2341 :     SpeedTreeCatch("CSpeedTreeRT::GetBranchTriangleCount")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CF@LDBPOABP@CSpeedTreeRT?3?3GetBranchTriangle@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv138[ebp], eax
	mov	edx, DWORD PTR tv138[ebp]
	mov	DWORD PTR tv131[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv131[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN11@GetBranchT
	ret	0
__catch$?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z$1:

; 2342 :     SpeedTreeCatchAll("CSpeedTreeRT::GetBranchTriangleCount");

	push	OFFSET ??_C@_0CF@LDBPOABP@CSpeedTreeRT?3?3GetBranchTriangle@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR tv139[ebp]
	mov	DWORD PTR tv134[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv134[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN13@GetBranchT
	ret	0
$LN5@GetBranchT:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN12@GetBranchT
$LN13@GetBranchT:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN10@GetBranchT
$LN12@GetBranchT:
	jmp	SHORT $LN10@GetBranchT
$LN11@GetBranchT:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN10@GetBranchT:

; 2343 : 
; 2344 :     return nTriangleCount;

	mov	eax, DWORD PTR _nTriangleCount$[ebp]

; 2345 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@GetBranchT
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN17@GetBranchT:
	DD	1
	DD	$LN16@GetBranchT
$LN16@GetBranchT:
	DD	-64					; ffffffc0H
	DD	4
	DD	$LN14@GetBranchT
$LN14@GetBranchT:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-344]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetBranchTriangleCount@CSpeedTreeRT@@QBEIM@Z ENDP	; CSpeedTreeRT::GetBranchTriangleCount
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetLeafTriangleCount@CSpeedTreeRT@@QBEIM@Z
_TEXT	SEGMENT
_nDiscreteLevel$ = -32					; size = 4
_nTriangleCount$ = -20					; size = 4
_this$ = -8						; size = 4
_fLodLevel$ = 8						; size = 4
?GetLeafTriangleCount@CSpeedTreeRT@@QBEIM@Z PROC	; CSpeedTreeRT::GetLeafTriangleCount, COMDAT
; _this$ = ecx

; 2315 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2316 :     int nTriangleCount = 0;

	mov	DWORD PTR _nTriangleCount$[ebp], 0

; 2317 :     int nDiscreteLevel = GetDiscreteLeafLodLevel(fLodLevel);

	push	ecx
	movss	xmm0, DWORD PTR _fLodLevel$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiscreteLeafLodLevel@CSpeedTreeRT@@QBEGM@Z ; CSpeedTreeRT::GetDiscreteLeafLodLevel
	movzx	eax, ax
	mov	DWORD PTR _nDiscreteLevel$[ebp], eax

; 2318 :     if (m_eLeafLodMethod == LOD_NONE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 3
	jne	SHORT $LN2@GetLeafTri

; 2319 :         nDiscreteLevel = 0;

	mov	DWORD PTR _nDiscreteLevel$[ebp], 0
	jmp	SHORT $LN4@GetLeafTri
$LN2@GetLeafTri:

; 2320 :     else if (nDiscreteLevel != -1)

	cmp	DWORD PTR _nDiscreteLevel$[ebp], -1
	je	SHORT $LN4@GetLeafTri

; 2321 :         nTriangleCount = m_pLeafGeometry->GetTriangleCount(nDiscreteLevel);

	mov	eax, DWORD PTR _nDiscreteLevel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?GetTriangleCount@CLeafGeometry@@QBEII@Z ; CLeafGeometry::GetTriangleCount
	mov	DWORD PTR _nTriangleCount$[ebp], eax
$LN4@GetLeafTri:

; 2322 : 
; 2323 :     return nTriangleCount;

	mov	eax, DWORD PTR _nTriangleCount$[ebp]

; 2324 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetLeafTriangleCount@CSpeedTreeRT@@QBEIM@Z ENDP	; CSpeedTreeRT::GetLeafTriangleCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetBoundingBox@CSpeedTreeRT@@QBEXPAM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pBounds$ = 8						; size = 4
?GetBoundingBox@CSpeedTreeRT@@QBEXPAM@Z PROC		; CSpeedTreeRT::GetBoundingBox, COMDAT
; _this$ = ecx

; 2303 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2304 :     if (pBounds)

	cmp	DWORD PTR _pBounds$[ebp], 0
	je	SHORT $LN2@GetBoundin

; 2305 :         memcpy(pBounds, m_pTreeSizes, 6 * sizeof(float));

	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _pBounds$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN3@GetBoundin
$LN2@GetBoundin:

; 2306 :     else
; 2307 :         SetError("GetBoundingBox() expects a non-NULL parameter");

	push	OFFSET ??_C@_0CO@OEGBIMIE@GetBoundingBox?$CI?$CJ?5expects?5a?5non?9@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN3@GetBoundin:

; 2308 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetBoundingBox@CSpeedTreeRT@@QBEXPAM@Z ENDP		; CSpeedTreeRT::GetBoundingBox
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?ResetError@CSpeedTreeRT@@SAXXZ
_TEXT	SEGMENT
?ResetError@CSpeedTreeRT@@SAXXZ PROC			; CSpeedTreeRT::ResetError, COMDAT

; 2294 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2295 :     g_strError = "";

	push	OFFSET ??_C@_00CNPNBAHC@@
	mov	ecx, OFFSET ?g_strError@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	npad	1

; 2296 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetError@CSpeedTreeRT@@SAXXZ ENDP			; CSpeedTreeRT::ResetError
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetCurrentError@CSpeedTreeRT@@SAPBDXZ
_TEXT	SEGMENT
?GetCurrentError@CSpeedTreeRT@@SAPBDXZ PROC		; CSpeedTreeRT::GetCurrentError, COMDAT

; 2285 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2286 :     return g_strError.c_str( );

	mov	ecx, OFFSET ?g_strError@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str

; 2287 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentError@CSpeedTreeRT@@SAPBDXZ ENDP		; CSpeedTreeRT::GetCurrentError
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?IsAuthorized@CSpeedTreeRT@@SA_NXZ
_TEXT	SEGMENT
?IsAuthorized@CSpeedTreeRT@@SA_NXZ PROC			; CSpeedTreeRT::IsAuthorized, COMDAT

; 2271 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 2272 : #ifdef FULL_VERSION
; 2273 :     return true;

	mov	al, 1

; 2274 : #else
; 2275 :     string strFailure;
; 2276 :     return EvalIsValid(g_strKey, strFailure);
; 2277 : #endif
; 2278 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAuthorized@CSpeedTreeRT@@SA_NXZ ENDP			; CSpeedTreeRT::IsAuthorized
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?Authorize@CSpeedTreeRT@@SAXPBD@Z
_TEXT	SEGMENT
_pKey$ = 8						; size = 4
?Authorize@CSpeedTreeRT@@SAXPBD@Z PROC			; CSpeedTreeRT::Authorize, COMDAT

; 2262 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2263 :     g_strKey = pKey;

	mov	eax, DWORD PTR _pKey$[ebp]
	push	eax
	mov	ecx, OFFSET ?g_strKey@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	npad	1

; 2264 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Authorize@CSpeedTreeRT@@SAXPBD@Z ENDP			; CSpeedTreeRT::Authorize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z
_TEXT	SEGMENT
tv144 = -316						; size = 4
tv141 = -316						; size = 4
tv147 = -312						; size = 4
tv146 = -312						; size = 4
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_nFrondMapIndex$ = 8					; size = 4
_pFilename$ = 12					; size = 4
?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z PROC	; CSpeedTreeRT::SetFrondTextureFilename, COMDAT
; _this$ = ecx

; 3582 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 3583 :     st_assert(m_pFrondEngine);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 0
	jne	SHORT $LN2@SetFrondTe
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0??SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z@4JA
	add	eax, 1
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@SetFrondTe:

; 3584 : 
; 3585 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 3586 :     {
; 3587 :         m_pFrondEngine->SetTextureFilename(nFrondMapIndex, pFilename);

	mov	eax, DWORD PTR _pFilename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nFrondMapIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+88]
	call	?SetTextureFilename@CFrondEngine@@QAEXIPBD@Z ; CFrondEngine::SetTextureFilename
	npad	1

; 3588 :     }

	jmp	$LN5@SetFrondTe
__catch$?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$0:

; 3589 : 
; 3590 :     SpeedTreeCatch("CSpeedTreeRT::SetFrondTextureFilename")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CG@MINPLDH@CSpeedTreeRT?3?3SetFrondTextureFi@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv146[ebp], eax
	mov	edx, DWORD PTR tv146[ebp]
	mov	DWORD PTR tv141[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv141[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN11@SetFrondTe
	ret	0
__catch$?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$1:

; 3591 :     SpeedTreeCatchAll("CSpeedTreeRT::SetFrondTextureFilename");

	push	OFFSET ??_C@_0CG@MINPLDH@CSpeedTreeRT?3?3SetFrondTextureFi@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv147[ebp], eax
	mov	ecx, DWORD PTR tv147[ebp]
	mov	DWORD PTR tv144[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv144[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN13@SetFrondTe
	ret	0
$LN5@SetFrondTe:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN12@SetFrondTe
$LN13@SetFrondTe:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN10@SetFrondTe
$LN12@SetFrondTe:
	jmp	SHORT $LN10@SetFrondTe
$LN11@SetFrondTe:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN10@SetFrondTe:
$LN1@SetFrondTe:

; 3592 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@SetFrondTe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN17@SetFrondTe:
	DD	1
	DD	$LN16@SetFrondTe
$LN16@SetFrondTe:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN14@SetFrondTe
$LN14@SetFrondTe:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetFrondTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z ENDP	; CSpeedTreeRT::SetFrondTextureFilename
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z
_TEXT	SEGMENT
tv150 = -316						; size = 4
tv147 = -316						; size = 4
tv154 = -312						; size = 4
tv153 = -312						; size = 4
tv152 = -309						; size = 1
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_nLeafMapIndex$ = 8					; size = 4
_pFilename$ = 12					; size = 4
?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z PROC	; CSpeedTreeRT::SetLeafTextureFilename, COMDAT
; _this$ = ecx

; 3562 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 3563 :     st_assert(m_pEngine);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@SetLeafTex
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0??SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z@4JA
	add	eax, 1
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@SetLeafTex:

; 3564 : 
; 3565 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 3566 :     {
; 3567 :         if (m_pEngine->TransientDataIntact( ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?TransientDataIntact@CTreeEngine@@QBE_NXZ ; CTreeEngine::TransientDataIntact
	mov	BYTE PTR tv152[ebp], al
	movzx	ecx, BYTE PTR tv152[ebp]
	test	ecx, ecx
	je	SHORT $LN4@SetLeafTex

; 3568 :             m_pEngine->SetLeafTextureFilename(nLeafMapIndex, pFilename);

	mov	eax, DWORD PTR _pFilename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nLeafMapIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?SetLeafTextureFilename@CTreeEngine@@QAEXIPBD@Z ; CTreeEngine::SetLeafTextureFilename
	npad	1
	jmp	SHORT $LN5@SetLeafTex
$LN4@SetLeafTex:

; 3569 :         else
; 3570 :             SetError("SetLeafTextureFilename() has no effect after DeleteTransientData() has been called");

	push	OFFSET ??_C@_0FD@LIMCGLOF@SetLeafTextureFilename?$CI?$CJ?5has?5no@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN5@SetLeafTex:

; 3571 :     }

	jmp	$LN7@SetLeafTex
__catch$?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$0:

; 3572 : 
; 3573 :     SpeedTreeCatch("CSpeedTreeRT::SetLeafTextureFilename")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CF@EPFLDMMH@CSpeedTreeRT?3?3SetLeafTextureFil@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv153[ebp], eax
	mov	edx, DWORD PTR tv153[ebp]
	mov	DWORD PTR tv147[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv147[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN13@SetLeafTex
	ret	0
__catch$?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$1:

; 3574 :     SpeedTreeCatchAll("CSpeedTreeRT::SetLeafTextureFilename");

	push	OFFSET ??_C@_0CF@EPFLDMMH@CSpeedTreeRT?3?3SetLeafTextureFil@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv154[ebp], eax
	mov	ecx, DWORD PTR tv154[ebp]
	mov	DWORD PTR tv150[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv150[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN15@SetLeafTex
	ret	0
$LN7@SetLeafTex:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN14@SetLeafTex
$LN15@SetLeafTex:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN12@SetLeafTex
$LN14@SetLeafTex:
	jmp	SHORT $LN12@SetLeafTex
$LN13@SetLeafTex:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN12@SetLeafTex:
$LN1@SetLeafTex:

; 3575 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@SetLeafTex
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN19@SetLeafTex:
	DD	1
	DD	$LN18@SetLeafTex
$LN18@SetLeafTex:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN16@SetLeafTex
$LN16@SetLeafTex:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetLeafTextureFilename@CSpeedTreeRT@@QAEXIPBD@Z ENDP	; CSpeedTreeRT::SetLeafTextureFilename
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z
_TEXT	SEGMENT
tv149 = -316						; size = 4
tv146 = -316						; size = 4
tv153 = -312						; size = 4
tv152 = -312						; size = 4
tv151 = -309						; size = 1
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_pFilename$ = 8						; size = 4
?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z PROC	; CSpeedTreeRT::SetBranchTextureFilename, COMDAT
; _this$ = ecx

; 3542 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 3543 :     st_assert(m_pEngine);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@SetBranchT
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0??SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z@4JA
	add	eax, 1
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@SetBranchT:

; 3544 : 
; 3545 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 3546 :     {
; 3547 :         if (m_pEngine->TransientDataIntact( ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?TransientDataIntact@CTreeEngine@@QBE_NXZ ; CTreeEngine::TransientDataIntact
	mov	BYTE PTR tv151[ebp], al
	movzx	ecx, BYTE PTR tv151[ebp]
	test	ecx, ecx
	je	SHORT $LN4@SetBranchT

; 3548 :             m_pEngine->SetBranchTextureFilename(pFilename);

	mov	eax, DWORD PTR _pFilename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?SetBranchTextureFilename@CTreeEngine@@QAEXPBD@Z ; CTreeEngine::SetBranchTextureFilename
	npad	1
	jmp	SHORT $LN5@SetBranchT
$LN4@SetBranchT:

; 3549 :         else
; 3550 :             SetError("SetBranchTextureFilename() has no effect after DeleteTransientData() has been called");

	push	OFFSET ??_C@_0FF@PAIDPLB@SetBranchTextureFilename?$CI?$CJ?5has?5@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN5@SetBranchT:

; 3551 :     }

	jmp	$LN7@SetBranchT
__catch$?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z$0:

; 3552 : 
; 3553 :     SpeedTreeCatch("CSpeedTreeRT::SetBranchTextureFilename")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CH@MDIENIJJ@CSpeedTreeRT?3?3SetBranchTextureF@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv152[ebp], eax
	mov	edx, DWORD PTR tv152[ebp]
	mov	DWORD PTR tv146[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv146[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN13@SetBranchT
	ret	0
__catch$?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z$1:

; 3554 :     SpeedTreeCatchAll("CSpeedTreeRT::SetBranchTextureFilename");

	push	OFFSET ??_C@_0CH@MDIENIJJ@CSpeedTreeRT?3?3SetBranchTextureF@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv153[ebp], eax
	mov	ecx, DWORD PTR tv153[ebp]
	mov	DWORD PTR tv149[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv149[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN15@SetBranchT
	ret	0
$LN7@SetBranchT:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN14@SetBranchT
$LN15@SetBranchT:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN12@SetBranchT
$LN14@SetBranchT:
	jmp	SHORT $LN12@SetBranchT
$LN13@SetBranchT:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN12@SetBranchT:
$LN1@SetBranchT:

; 3555 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@SetBranchT
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN19@SetBranchT:
	DD	1
	DD	$LN18@SetBranchT
$LN18@SetBranchT:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN16@SetBranchT
$LN16@SetBranchT:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetBranchTextureFilename@CSpeedTreeRT@@QAEXPBD@Z ENDP	; CSpeedTreeRT::SetBranchTextureFilename
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetTextureFlip@CSpeedTreeRT@@SAX_N@Z
_TEXT	SEGMENT
_bFlag$ = 8						; size = 1
?SetTextureFlip@CSpeedTreeRT@@SAX_N@Z PROC		; CSpeedTreeRT::SetTextureFlip, COMDAT

; 3517 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 3518 :     m_bTextureFlip = bFlag;

	movzx	eax, BYTE PTR _bFlag$[ebp]
	mov	BYTE PTR ?m_bTextureFlip@CSpeedTreeRT@@0_NA, al ; CSpeedTreeRT::m_bTextureFlip

; 3519 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetTextureFlip@CSpeedTreeRT@@SAX_N@Z ENDP		; CSpeedTreeRT::SetTextureFlip
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetTextureFlip@CSpeedTreeRT@@SA_NXZ
_TEXT	SEGMENT
?GetTextureFlip@CSpeedTreeRT@@SA_NXZ PROC		; CSpeedTreeRT::GetTextureFlip, COMDAT

; 3508 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 3509 :     return m_bTextureFlip;

	movzx	eax, BYTE PTR ?m_bTextureFlip@CSpeedTreeRT@@0_NA ; CSpeedTreeRT::m_bTextureFlip

; 3510 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTextureFlip@CSpeedTreeRT@@SA_NXZ ENDP		; CSpeedTreeRT::GetTextureFlip
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z
_TEXT	SEGMENT
tv133 = -316						; size = 4
tv130 = -316						; size = 4
tv136 = -312						; size = 4
tv135 = -312						; size = 4
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_nFrondMapIndex$ = 8					; size = 4
_pTexCoords$ = 12					; size = 4
?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z PROC	; CSpeedTreeRT::SetFrondTextureCoords, COMDAT
; _this$ = ecx

; 3407 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 3408 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 3409 :     {
; 3410 :         if (m_pFrondGeometry &&

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN3@SetFrondTe
	cmp	DWORD PTR _pTexCoords$[ebp], 0
	je	SHORT $LN3@SetFrondTe

; 3411 :             pTexCoords)
; 3412 :             m_pFrondEngine->SetTextureCoords(m_pFrondGeometry, nFrondMapIndex, pTexCoords, m_bTextureFlip);

	movzx	eax, BYTE PTR ?m_bTextureFlip@CSpeedTreeRT@@0_NA ; CSpeedTreeRT::m_bTextureFlip
	push	eax
	mov	ecx, DWORD PTR _pTexCoords$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nFrondMapIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+88]
	call	?SetTextureCoords@CFrondEngine@@QAEXPAVCIndexedGeometry@@IPBM_N@Z ; CFrondEngine::SetTextureCoords
	npad	1
$LN3@SetFrondTe:

; 3413 :     }

	jmp	$LN5@SetFrondTe
__catch$?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$0:

; 3414 : 
; 3415 :     SpeedTreeCatch("CSpeedTreeRT::SetFrondTextureCoords")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CE@MGEADCOJ@CSpeedTreeRT?3?3SetFrondTextureCo@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv135[ebp], eax
	mov	edx, DWORD PTR tv135[ebp]
	mov	DWORD PTR tv130[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv130[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN11@SetFrondTe
	ret	0
__catch$?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$1:

; 3416 :     SpeedTreeCatchAll("CSpeedTreeRT::SetFrondTextureCoords");

	push	OFFSET ??_C@_0CE@MGEADCOJ@CSpeedTreeRT?3?3SetFrondTextureCo@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv136[ebp], eax
	mov	ecx, DWORD PTR tv136[ebp]
	mov	DWORD PTR tv133[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv133[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN13@SetFrondTe
	ret	0
$LN5@SetFrondTe:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN12@SetFrondTe
$LN13@SetFrondTe:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN10@SetFrondTe
$LN12@SetFrondTe:
	jmp	SHORT $LN10@SetFrondTe
$LN11@SetFrondTe:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN10@SetFrondTe:

; 3417 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@SetFrondTe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN17@SetFrondTe:
	DD	1
	DD	$LN16@SetFrondTe
$LN16@SetFrondTe:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN14@SetFrondTe
$LN14@SetFrondTe:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetFrondTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z ENDP	; CSpeedTreeRT::SetFrondTextureCoords
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z
_TEXT	SEGMENT
tv220 = -324						; size = 4
tv219 = -320						; size = 4
tv218 = -316						; size = 4
tv214 = -316						; size = 4
tv211 = -316						; size = 4
tv222 = -312						; size = 4
tv221 = -312						; size = 4
tv217 = -312						; size = 4
tv216 = -312						; size = 4
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_nLeafMapIndex$ = 8					; size = 4
_pTexCoords$ = 12					; size = 4
?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z PROC	; CSpeedTreeRT::SetLeafTextureCoords, COMDAT
; _this$ = ecx

; 3386 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 308				; 00000134H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-132]
	mov	ecx, 29					; 0000001dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 3387 :     st_assert(m_pEngine);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@SetLeafTex
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0??SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z@4JA
	add	eax, 1
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@SetLeafTex:

; 3388 :     st_assert(nLeafMapIndex >= 0);

	cmp	DWORD PTR _nLeafMapIndex$[ebp], 0
	jae	SHORT $LN3@SetLeafTex
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0??SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z@4JA
	add	eax, 2
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN3@SetLeafTex:

; 3389 :     st_assert(pTexCoords);

	cmp	DWORD PTR _pTexCoords$[ebp], 0
	jne	SHORT $LN4@SetLeafTex
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0??SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z@4JA
	add	eax, 3
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN4@SetLeafTex:

; 3390 :     st_assert(m_pLeafGeometry);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN5@SetLeafTex
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0??SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z@4JA
	add	eax, 4
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN5@SetLeafTex:

; 3391 : 
; 3392 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 3393 :     {
; 3394 :         st_assert(nLeafMapIndex < m_pEngine->GetLeafTextures( ).size( ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetLeafTextures@CTreeEngine@@QBEABV?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@XZ ; CTreeEngine::GetLeafTextures
	mov	DWORD PTR tv216[ebp], eax
	mov	ecx, DWORD PTR tv216[ebp]
	call	?size@?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@QBEIXZ ; std::vector<SIdvLeafTexture,std::allocator<SIdvLeafTexture> >::size
	cmp	DWORD PTR _nLeafMapIndex$[ebp], eax
	jb	$LN7@SetLeafTex
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv217[ebp], eax
	mov	ecx, DWORD PTR ?__LINE__Var@?0??SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z@4JA
	add	ecx, 8
	mov	esi, esp
	push	ecx
	mov	ecx, DWORD PTR tv217[ebp]
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv218[ebp], eax
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	edx, DWORD PTR tv218[ebp]
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv219[ebp], eax
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	mov	eax, DWORD PTR tv219[ebp]
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv220[ebp], eax
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	ecx, DWORD PTR tv220[ebp]
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN7@SetLeafTex:

; 3395 :         m_pLeafGeometry->SetTextureCoords(nLeafMapIndex, pTexCoords);

	mov	eax, DWORD PTR _pTexCoords$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nLeafMapIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	call	?SetTextureCoords@CLeafGeometry@@QAEXIPBM@Z ; CLeafGeometry::SetTextureCoords
	npad	1

; 3396 :     }

	jmp	$LN9@SetLeafTex
__catch$?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$0:

; 3397 : 
; 3398 :     SpeedTreeCatch("CSpeedTreeRT::SetLeafTextureCoords")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CD@DILLEMNK@CSpeedTreeRT?3?3SetLeafTextureCoo@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv221[ebp], eax
	mov	edx, DWORD PTR tv221[ebp]
	mov	DWORD PTR tv211[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv211[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN15@SetLeafTex
	ret	0
__catch$?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$1:

; 3399 :     SpeedTreeCatchAll("CSpeedTreeRT::SetLeafTextureCoords");

	push	OFFSET ??_C@_0CD@DILLEMNK@CSpeedTreeRT?3?3SetLeafTextureCoo@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv222[ebp], eax
	mov	ecx, DWORD PTR tv222[ebp]
	mov	DWORD PTR tv214[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv214[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN17@SetLeafTex
	ret	0
$LN9@SetLeafTex:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN16@SetLeafTex
$LN17@SetLeafTex:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN14@SetLeafTex
$LN16@SetLeafTex:
	jmp	SHORT $LN14@SetLeafTex
$LN15@SetLeafTex:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN14@SetLeafTex:
$LN1@SetLeafTex:

; 3400 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN21@SetLeafTex
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 324				; 00000144H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN21@SetLeafTex:
	DD	1
	DD	$LN20@SetLeafTex
$LN20@SetLeafTex:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN18@SetLeafTex
$LN18@SetLeafTex:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-328]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetLeafTextureCoords@CSpeedTreeRT@@QAEXIPBM@Z ENDP	; CSpeedTreeRT::SetLeafTextureCoords
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z
_TEXT	SEGMENT
tv215 = -376						; size = 4
tv212 = -376						; size = 4
tv225 = -372						; size = 4
tv224 = -372						; size = 4
tv223 = -372						; size = 4
tv222 = -372						; size = 4
tv221 = -372						; size = 4
tv220 = -372						; size = 4
tv219 = -372						; size = 4
tv218 = -372						; size = 4
tv217 = -372						; size = 4
$T2 = -364						; size = 28
$T3 = -328						; size = 28
$T4 = -292						; size = 4
$T5 = -280						; size = 4
_cException$6 = -76					; size = 4
_i$7 = -64						; size = 4
_i$8 = -52						; size = 4
_vLeaves$9 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_sTextures$ = 8						; size = 4
?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z PROC	; CSpeedTreeRT::GetTextures, COMDAT
; _this$ = ecx

; 3338 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 360				; 00000168H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-184]
	mov	ecx, 42					; 0000002aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 3339 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 3340 :     {
; 3341 :         // branch
; 3342 :         sTextures.m_pBranchTextureFilename = m_pEngine->GetBranchTextureFilename( ).c_str( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetBranchTextureFilename@CTreeEngine@@QBEABVCIdvFilename@@XZ ; CTreeEngine::GetBranchTextureFilename
	mov	DWORD PTR tv217[ebp], eax
	mov	ecx, DWORD PTR tv217[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	ecx, DWORD PTR _sTextures$[ebp]
	mov	DWORD PTR [ecx], eax

; 3343 : 
; 3344 :         // leaves
; 3345 :         const vector<SIdvLeafTexture>& vLeaves = m_pEngine->GetLeafTextures( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetLeafTextures@CTreeEngine@@QBEABV?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@XZ ; CTreeEngine::GetLeafTextures
	mov	DWORD PTR tv218[ebp], eax
	mov	ecx, DWORD PTR tv218[ebp]
	mov	DWORD PTR _vLeaves$9[ebp], ecx

; 3346 :         sTextures.m_uiLeafTextureCount = vLeaves.size( );

	mov	ecx, DWORD PTR _vLeaves$9[ebp]
	call	?size@?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@QBEIXZ ; std::vector<SIdvLeafTexture,std::allocator<SIdvLeafTexture> >::size
	mov	ecx, DWORD PTR _sTextures$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 3347 :         if (sTextures.m_uiLeafTextureCount > 0)

	mov	eax, DWORD PTR _sTextures$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jbe	$LN9@GetTexture

; 3348 :         {
; 3349 :             sTextures.m_pLeafTextureFilenames = new const char*[sTextures.m_uiLeafTextureCount];

	mov	eax, DWORD PTR _sTextures$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, 4
	mul	ecx
	mov	edx, -1
	cmovb	eax, edx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR tv219[ebp], eax
	mov	eax, DWORD PTR tv219[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	ecx, DWORD PTR _sTextures$[ebp]
	mov	edx, DWORD PTR $T5[ebp]
	mov	DWORD PTR [ecx+8], edx

; 3350 : 
; 3351 :             for (unsigned int i = 0; i < vLeaves.size( ); ++i)

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN4@GetTexture
$LN2@GetTexture:
	mov	eax, DWORD PTR _i$8[ebp]
	add	eax, 1
	mov	DWORD PTR _i$8[ebp], eax
$LN4@GetTexture:
	mov	ecx, DWORD PTR _vLeaves$9[ebp]
	call	?size@?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@QBEIXZ ; std::vector<SIdvLeafTexture,std::allocator<SIdvLeafTexture> >::size
	cmp	DWORD PTR _i$8[ebp], eax
	jae	SHORT $LN3@GetTexture

; 3352 :                 sTextures.m_pLeafTextureFilenames[i] = vLeaves[i].m_strFilename.c_str( );

	mov	eax, DWORD PTR _i$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _vLeaves$9[ebp]
	call	??A?$vector@USIdvLeafTexture@@V?$allocator@USIdvLeafTexture@@@std@@@std@@QBEABUSIdvLeafTexture@@I@Z ; std::vector<SIdvLeafTexture,std::allocator<SIdvLeafTexture> >::operator[]
	add	eax, 20					; 00000014H
	mov	ecx, eax
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	ecx, DWORD PTR _sTextures$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _i$8[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	jmp	SHORT $LN2@GetTexture
$LN3@GetTexture:

; 3353 :         }

	jmp	SHORT $LN10@GetTexture
$LN9@GetTexture:

; 3354 :         else
; 3355 :             sTextures.m_pLeafTextureFilenames = NULL;

	mov	eax, DWORD PTR _sTextures$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN10@GetTexture:

; 3356 : 
; 3357 :         // fronds
; 3358 :         sTextures.m_uiFrondTextureCount = m_pFrondEngine->GetTextureCount( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	call	?GetTextureCount@CFrondEngine@@QBEIXZ	; CFrondEngine::GetTextureCount
	mov	DWORD PTR tv220[ebp], eax
	mov	ecx, DWORD PTR _sTextures$[ebp]
	mov	edx, DWORD PTR tv220[ebp]
	mov	DWORD PTR [ecx+12], edx

; 3359 :         if (sTextures.m_uiFrondTextureCount > 0)

	mov	eax, DWORD PTR _sTextures$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	$LN11@GetTexture

; 3360 :         {
; 3361 :             sTextures.m_pFrondTextureFilenames = new const char*[sTextures.m_uiFrondTextureCount];

	mov	eax, DWORD PTR _sTextures$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	ecx, 4
	mul	ecx
	mov	edx, -1
	cmovb	eax, edx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR tv221[ebp], eax
	mov	eax, DWORD PTR tv221[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR _sTextures$[ebp]
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR [ecx+16], edx

; 3362 :             for (unsigned int i = 0; i < sTextures.m_uiFrondTextureCount; ++i)

	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN7@GetTexture
$LN5@GetTexture:
	mov	eax, DWORD PTR _i$7[ebp]
	add	eax, 1
	mov	DWORD PTR _i$7[ebp], eax
$LN7@GetTexture:
	mov	eax, DWORD PTR _sTextures$[ebp]
	mov	ecx, DWORD PTR _i$7[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN6@GetTexture

; 3363 :                 sTextures.m_pFrondTextureFilenames[i] = m_pFrondEngine->GetTextureFilename(i);

	mov	eax, DWORD PTR _i$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+88]
	call	?GetTextureFilename@CFrondEngine@@QBEPBDI@Z ; CFrondEngine::GetTextureFilename
	mov	DWORD PTR tv222[ebp], eax
	mov	edx, DWORD PTR _sTextures$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$7[ebp]
	mov	edx, DWORD PTR tv222[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
	jmp	SHORT $LN5@GetTexture
$LN6@GetTexture:

; 3364 :         }

	jmp	SHORT $LN12@GetTexture
$LN11@GetTexture:

; 3365 :         else
; 3366 :             sTextures.m_pFrondTextureFilenames = NULL;

	mov	eax, DWORD PTR _sTextures$[ebp]
	mov	DWORD PTR [eax+16], 0
$LN12@GetTexture:

; 3367 : 
; 3368 :         // self shadow
; 3369 :         if (m_pProjectedShadow)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $LN13@GetTexture

; 3370 :             sTextures.m_pSelfShadowFilename = m_pProjectedShadow->GetSelfShadowFilename( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	call	?GetSelfShadowFilename@CProjectedShadow@@QAEPBDXZ ; CProjectedShadow::GetSelfShadowFilename
	mov	DWORD PTR tv223[ebp], eax
	mov	ecx, DWORD PTR _sTextures$[ebp]
	mov	edx, DWORD PTR tv223[ebp]
	mov	DWORD PTR [ecx+24], edx
$LN13@GetTexture:

; 3371 : 
; 3372 :         // composite
; 3373 :         if (m_pEmbeddedTexCoords)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	SHORT $LN14@GetTexture

; 3374 :             sTextures.m_pCompositeFilename = m_pEmbeddedTexCoords->m_strCompositeFilename.c_str( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	add	ecx, 24					; 00000018H
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	ecx, DWORD PTR _sTextures$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN14@GetTexture:

; 3375 :     }

	jmp	$LN16@GetTexture
__catch$?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z$0:

; 3376 : 
; 3377 :     SpeedTreeCatch("CSpeedTreeRT::GetTextures")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$6[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$6[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BK@DHPJOIPO@CSpeedTreeRT?3?3GetTextures@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv224[ebp], eax
	mov	edx, DWORD PTR tv224[ebp]
	mov	DWORD PTR tv212[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv212[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN22@GetTexture
	ret	0
__catch$?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z$1:

; 3378 :     SpeedTreeCatchAll("CSpeedTreeRT::GetTextures");

	push	OFFSET ??_C@_0BK@DHPJOIPO@CSpeedTreeRT?3?3GetTextures@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv225[ebp], eax
	mov	ecx, DWORD PTR tv225[ebp]
	mov	DWORD PTR tv215[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv215[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN24@GetTexture
	ret	0
$LN16@GetTexture:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN23@GetTexture
$LN24@GetTexture:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN21@GetTexture
$LN23@GetTexture:
	jmp	SHORT $LN21@GetTexture
$LN22@GetTexture:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN21@GetTexture:

; 3379 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN28@GetTexture
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 376				; 00000178H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN28@GetTexture:
	DD	1
	DD	$LN27@GetTexture
$LN27@GetTexture:
	DD	-76					; ffffffb4H
	DD	4
	DD	$LN25@GetTexture
$LN25@GetTexture:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-380]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z ENDP	; CSpeedTreeRT::GetTextures
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z
_TEXT	SEGMENT
tv167 = -316						; size = 4
tv164 = -316						; size = 4
tv170 = -312						; size = 4
tv169 = -312						; size = 4
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_sGeometry$ = 8						; size = 4
_ulBitVector$ = 12					; size = 4
_sOverrideBranchLodValue$ = 16				; size = 2
_sOverrideFrondLodValue$ = 20				; size = 2
_sOverrideLeafLodValue$ = 24				; size = 2
?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z PROC ; CSpeedTreeRT::GetGeometry, COMDAT
; _this$ = ecx

; 2838 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2839 :     st_assert(m_pEngine);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@GetGeometr
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0??GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@2@KFFF@Z@4JA
	add	eax, 1
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@GetGeometr:

; 2840 : 
; 2841 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2842 :     {
; 2843 :         if (ulBitVector & SpeedTree_BranchGeometry)

	mov	eax, DWORD PTR _ulBitVector$[ebp]
	and	eax, 1
	je	SHORT $LN4@GetGeometr

; 2844 :             GetBranchGeometry(sGeometry, sOverrideBranchLodValue); // compute fizzle-alpha value here

	movzx	eax, WORD PTR _sOverrideBranchLodValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sGeometry$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@F@Z ; CSpeedTreeRT::GetBranchGeometry
	npad	1
$LN4@GetGeometr:

; 2845 :         if (ulBitVector & SpeedTree_FrondGeometry)

	mov	eax, DWORD PTR _ulBitVector$[ebp]
	and	eax, 2
	je	SHORT $LN5@GetGeometr

; 2846 :             GetFrondGeometry(sGeometry, sOverrideFrondLodValue); // compute fizzle-alpha value here

	movzx	eax, WORD PTR _sOverrideFrondLodValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sGeometry$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFrondGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@F@Z ; CSpeedTreeRT::GetFrondGeometry
	npad	1
$LN5@GetGeometr:

; 2847 :         if (ulBitVector & SpeedTree_LeafGeometry)

	mov	eax, DWORD PTR _ulBitVector$[ebp]
	and	eax, 4
	je	SHORT $LN6@GetGeometr

; 2848 :             GetLeafGeometry(sGeometry, sOverrideLeafLodValue);

	movzx	eax, WORD PTR _sOverrideLeafLodValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sGeometry$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLeafGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@F@Z ; CSpeedTreeRT::GetLeafGeometry
	npad	1
$LN6@GetGeometr:

; 2849 :         if (ulBitVector & SpeedTree_BillboardGeometry)

	mov	eax, DWORD PTR _ulBitVector$[ebp]
	and	eax, 8
	je	SHORT $LN9@GetGeometr

; 2850 :         {
; 2851 :             if (m_b360Billboard && !(ulBitVector & SpeedTree_SimpleBillboardOverride))

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+104]
	test	ecx, ecx
	je	SHORT $LN8@GetGeometr
	mov	eax, DWORD PTR _ulBitVector$[ebp]
	and	eax, 16					; 00000010H
	jne	SHORT $LN8@GetGeometr

; 2852 :                 Get360BillboardGeometry(sGeometry, ulBitVector);

	mov	eax, DWORD PTR _ulBitVector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sGeometry$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get360BillboardGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@K@Z ; CSpeedTreeRT::Get360BillboardGeometry
	npad	1
	jmp	SHORT $LN9@GetGeometr
$LN8@GetGeometr:

; 2853 :             else
; 2854 :                 GetSimpleBillboardGeometry(sGeometry);

	mov	eax, DWORD PTR _sGeometry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSimpleBillboardGeometry@CSpeedTreeRT@@AAEXAAUSGeometry@1@@Z ; CSpeedTreeRT::GetSimpleBillboardGeometry
	npad	1
$LN9@GetGeometr:

; 2855 :         }
; 2856 :     }

	jmp	$LN11@GetGeometr
__catch$?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z$0:

; 2857 : 
; 2858 :     SpeedTreeCatch("CSpeedTreeRT::GetGeometry")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BK@ICBJPCHI@CSpeedTreeRT?3?3GetGeometry@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv169[ebp], eax
	mov	edx, DWORD PTR tv169[ebp]
	mov	DWORD PTR tv164[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv164[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN17@GetGeometr
	ret	0
__catch$?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z$1:

; 2859 :     SpeedTreeCatchAll("CSpeedTreeRT::GetGeometry");

	push	OFFSET ??_C@_0BK@ICBJPCHI@CSpeedTreeRT?3?3GetGeometry@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv170[ebp], eax
	mov	ecx, DWORD PTR tv170[ebp]
	mov	DWORD PTR tv167[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv167[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN19@GetGeometr
	ret	0
$LN11@GetGeometr:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN18@GetGeometr
$LN19@GetGeometr:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN16@GetGeometr
$LN18@GetGeometr:
	jmp	SHORT $LN16@GetGeometr
$LN17@GetGeometr:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN16@GetGeometr:
$LN1@GetGeometr:

; 2860 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@GetGeometr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN23@GetGeometr:
	DD	1
	DD	$LN22@GetGeometr
$LN22@GetGeometr:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN20@GetGeometr
$LN20@GetGeometr:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z ENDP ; CSpeedTreeRT::GetGeometry
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ
_TEXT	SEGMENT
tv152 = -352						; size = 4
tv149 = -352						; size = 4
tv157 = -348						; size = 4
tv156 = -348						; size = 4
tv155 = -348						; size = 4
tv91 = -348						; size = 4
tv154 = -346						; size = 2
$T2 = -340						; size = 28
$T3 = -304						; size = 28
$T4 = -268						; size = 4
_cException$5 = -64					; size = 4
_i$6 = -52						; size = 4
_nNumLods$7 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ PROC	; CSpeedTreeRT::GetLeafLodSizeAdjustments, COMDAT
; _this$ = ecx

; 3268 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-160]
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 3269 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 3270 :     {
; 3271 :         if (!m_pLeafLodSizeFactors)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jne	$LN3@GetLeafLod

; 3272 :         {
; 3273 :             int nNumLods = GetNumLeafLodLevels( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumLeafLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumLeafLodLevels
	mov	WORD PTR tv154[ebp], ax
	movzx	eax, WORD PTR tv154[ebp]
	mov	DWORD PTR _nNumLods$7[ebp], eax

; 3274 :             m_pLeafLodSizeFactors = new float[nNumLods];

	mov	eax, DWORD PTR _nNumLods$7[ebp]
	mov	ecx, 4
	mul	ecx
	mov	edx, -1
	cmovb	eax, edx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR tv155[ebp], eax
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR [ecx+44], edx

; 3275 :             for (int i = 0; i < nNumLods; ++i)

	mov	DWORD PTR _i$6[ebp], 0
	jmp	SHORT $LN4@GetLeafLod
$LN2@GetLeafLod:
	mov	eax, DWORD PTR _i$6[ebp]
	add	eax, 1
	mov	DWORD PTR _i$6[ebp], eax
$LN4@GetLeafLod:
	mov	eax, DWORD PTR _i$6[ebp]
	cmp	eax, DWORD PTR _nNumLods$7[ebp]
	jge	SHORT $LN3@GetLeafLod

; 3276 :                 m_pLeafLodSizeFactors[i] = (nNumLods > 0) ? 1.0f + m_fLeafSizeIncreaseFactor * float(i) : 1.0f;

	cmp	DWORD PTR _nNumLods$7[ebp], 0
	jle	SHORT $LN8@GetLeafLod
	cvtsi2ss xmm0, DWORD PTR _i$6[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+36]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv91[ebp], xmm0
	jmp	SHORT $LN9@GetLeafLod
$LN8@GetLeafLod:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv91[ebp], xmm0
$LN9@GetLeafLod:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _i$6[ebp]
	movss	xmm0, DWORD PTR tv91[ebp]
	movss	DWORD PTR [edx+eax*4], xmm0
	jmp	SHORT $LN2@GetLeafLod
$LN3@GetLeafLod:

; 3277 :         }
; 3278 :     }

	jmp	$LN10@GetLeafLod
__catch$?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ$0:

; 3279 : 
; 3280 :     SpeedTreeCatch("CSpeedTreeRT::GetLeafLodSizeAdjustments")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$5[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$5[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CI@IJNCGOLC@CSpeedTreeRT?3?3GetLeafLodSizeAdj@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv156[ebp], eax
	mov	edx, DWORD PTR tv156[ebp]
	mov	DWORD PTR tv149[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv149[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN16@GetLeafLod
	ret	0
__catch$?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ$1:

; 3281 :     SpeedTreeCatchAll("CSpeedTreeRT::GetLeafLodSizeAdjustments");

	push	OFFSET ??_C@_0CI@IJNCGOLC@CSpeedTreeRT?3?3GetLeafLodSizeAdj@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv157[ebp], eax
	mov	ecx, DWORD PTR tv157[ebp]
	mov	DWORD PTR tv152[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv152[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN18@GetLeafLod
	ret	0
$LN10@GetLeafLod:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN17@GetLeafLod
$LN18@GetLeafLod:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN15@GetLeafLod
$LN17@GetLeafLod:
	jmp	SHORT $LN15@GetLeafLod
$LN16@GetLeafLod:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN15@GetLeafLod:

; 3282 : 
; 3283 :     return m_pLeafLodSizeFactors;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]

; 3284 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@GetLeafLod
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 352				; 00000160H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN22@GetLeafLod:
	DD	1
	DD	$LN21@GetLeafLod
$LN21@GetLeafLod:
	DD	-64					; ffffffc0H
	DD	4
	DD	$LN19@GetLeafLod
$LN19@GetLeafLod:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-356]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLeafLodSizeAdjustments@CSpeedTreeRT@@QAEPBMXZ ENDP	; CSpeedTreeRT::GetLeafLodSizeAdjustments
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z
_TEXT	SEGMENT
tv95 = -328						; size = 4
tv92 = -328						; size = 4
tv131 = -324						; size = 4
tv130 = -324						; size = 4
tv129 = -324						; size = 4
$T2 = -316						; size = 28
$T3 = -280						; size = 28
_cException$4 = -52					; size = 4
_pBillboardTable$ = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_nEntryCount$ = 8					; size = 4
?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z PROC	; CSpeedTreeRT::GetLeafBillboardTable, COMDAT
; _this$ = ecx

; 2244 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 312				; 00000138H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-136]
	mov	ecx, 30					; 0000001eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2245 :     const float* pBillboardTable = NULL;

	mov	DWORD PTR _pBillboardTable$[ebp], 0

; 2246 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2247 :     {
; 2248 :         pBillboardTable = m_pLeafGeometry->GetLeafBillboardTable(nEntryCount);

	mov	eax, DWORD PTR _nEntryCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?GetLeafBillboardTable@CLeafGeometry@@QBEPBMAAI@Z ; CLeafGeometry::GetLeafBillboardTable
	mov	DWORD PTR tv129[ebp], eax
	mov	edx, DWORD PTR tv129[ebp]
	mov	DWORD PTR _pBillboardTable$[ebp], edx

; 2249 :     }

	jmp	$LN4@GetLeafBil
__catch$?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z$0:

; 2250 : 
; 2251 :     SpeedTreeCatch("CSpeedTreeRT::GetLeafBillboardTable")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CE@IBNIGHFD@CSpeedTreeRT?3?3GetLeafBillboardT@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv130[ebp], eax
	mov	edx, DWORD PTR tv130[ebp]
	mov	DWORD PTR tv92[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv92[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN10@GetLeafBil
	ret	0
__catch$?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z$1:

; 2252 :     SpeedTreeCatchAll("CSpeedTreeRT::GetLeafBillboardTable");

	push	OFFSET ??_C@_0CE@IBNIGHFD@CSpeedTreeRT?3?3GetLeafBillboardT@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv131[ebp], eax
	mov	ecx, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv95[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv95[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN12@GetLeafBil
	ret	0
$LN4@GetLeafBil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN11@GetLeafBil
$LN12@GetLeafBil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN9@GetLeafBil
$LN11@GetLeafBil:
	jmp	SHORT $LN9@GetLeafBil
$LN10@GetLeafBil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@GetLeafBil:

; 2253 : 
; 2254 :     return pBillboardTable;

	mov	eax, DWORD PTR _pBillboardTable$[ebp]

; 2255 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@GetLeafBil
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 328				; 00000148H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN16@GetLeafBil:
	DD	1
	DD	$LN15@GetLeafBil
$LN15@GetLeafBil:
	DD	-52					; ffffffccH
	DD	4
	DD	$LN13@GetLeafBil
$LN13@GetLeafBil:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-332]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLeafBillboardTable@CSpeedTreeRT@@QBEPBMAAI@Z ENDP	; CSpeedTreeRT::GetLeafBillboardTable
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z
_TEXT	SEGMENT
tv166 = -400						; size = 4
tv163 = -400						; size = 4
tv174 = -396						; size = 4
tv173 = -396						; size = 4
tv172 = -396						; size = 4
tv171 = -396						; size = 4
tv170 = -396						; size = 4
tv169 = -396						; size = 4
tv168 = -394						; size = 2
$T2 = -388						; size = 28
$T3 = -352						; size = 28
$T4 = -316						; size = 4
_cException$5 = -112					; size = 4
_i$6 = -100						; size = 4
_pTexIndices$7 = -88					; size = 4
_pStrips$8 = -76					; size = 4
_pStripLengths$9 = -64					; size = 4
_usNumStrips$10 = -52					; size = 2
_pMapIndexes$ = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_nLodLevel$ = 8						; size = 4
?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z PROC ; CSpeedTreeRT::GetFrondGeometryMapIndexes, COMDAT
; _this$ = ecx

; 2801 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 384				; 00000180H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2802 :     unsigned char* pMapIndexes = NULL;

	mov	DWORD PTR _pMapIndexes$[ebp], 0

; 2803 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2804 :     {
; 2805 :         if (m_pFrondGeometry)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	$LN3@GetFrondGe

; 2806 :         {
; 2807 :             unsigned short usNumStrips = m_pFrondGeometry->GetNumStrips(static_cast<unsigned short>(nLodLevel));

	movzx	eax, WORD PTR _nLodLevel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+92]
	call	?GetNumStrips@CIndexedGeometry@@QBEGF@Z	; CIndexedGeometry::GetNumStrips
	mov	WORD PTR tv168[ebp], ax
	mov	dx, WORD PTR tv168[ebp]
	mov	WORD PTR _usNumStrips$10[ebp], dx

; 2808 :             if (usNumStrips > 0)

	movzx	eax, WORD PTR _usNumStrips$10[ebp]
	test	eax, eax
	jle	$LN3@GetFrondGe

; 2809 :             {
; 2810 :                 pMapIndexes = new unsigned char[usNumStrips];

	movzx	eax, WORD PTR _usNumStrips$10[ebp]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR tv169[ebp], eax
	mov	ecx, DWORD PTR tv169[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _pMapIndexes$[ebp], edx

; 2811 : 
; 2812 :                 const unsigned short* pStripLengths = m_pFrondGeometry->GetStripLengthsPointer(static_cast<unsigned short>(nLodLevel));

	movzx	eax, WORD PTR _nLodLevel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+92]
	call	?GetStripLengthsPointer@CIndexedGeometry@@QBEPBGG@Z ; CIndexedGeometry::GetStripLengthsPointer
	mov	DWORD PTR tv170[ebp], eax
	mov	edx, DWORD PTR tv170[ebp]
	mov	DWORD PTR _pStripLengths$9[ebp], edx

; 2813 :                 const unsigned short** pStrips = const_cast<const unsigned short**>(m_pFrondGeometry->GetStripsPointer(static_cast<unsigned short>(nLodLevel)));

	movzx	eax, WORD PTR _nLodLevel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+92]
	call	?GetStripsPointer@CIndexedGeometry@@QBEPAPAGG@Z ; CIndexedGeometry::GetStripsPointer
	mov	DWORD PTR tv171[ebp], eax
	mov	edx, DWORD PTR tv171[ebp]
	mov	DWORD PTR _pStrips$8[ebp], edx

; 2814 :                 const unsigned char* pTexIndices = m_pFrondGeometry->GetVertexTexIndices( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	?GetVertexTexIndices@CIndexedGeometry@@QBEPBEXZ ; CIndexedGeometry::GetVertexTexIndices
	mov	DWORD PTR tv172[ebp], eax
	mov	ecx, DWORD PTR tv172[ebp]
	mov	DWORD PTR _pTexIndices$7[ebp], ecx

; 2815 : 
; 2816 :                 for (int i = 0; i < usNumStrips; ++i)

	mov	DWORD PTR _i$6[ebp], 0
	jmp	SHORT $LN4@GetFrondGe
$LN2@GetFrondGe:
	mov	eax, DWORD PTR _i$6[ebp]
	add	eax, 1
	mov	DWORD PTR _i$6[ebp], eax
$LN4@GetFrondGe:
	movzx	eax, WORD PTR _usNumStrips$10[ebp]
	cmp	DWORD PTR _i$6[ebp], eax
	jge	SHORT $LN3@GetFrondGe

; 2817 :                 {
; 2818 :                     if (pStripLengths[i] == 0)

	mov	eax, DWORD PTR _i$6[ebp]
	mov	ecx, DWORD PTR _pStripLengths$9[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	test	edx, edx
	jne	SHORT $LN8@GetFrondGe

; 2819 :                         pMapIndexes[i] = 0;

	mov	eax, DWORD PTR _pMapIndexes$[ebp]
	add	eax, DWORD PTR _i$6[ebp]
	mov	BYTE PTR [eax], 0
	jmp	SHORT $LN9@GetFrondGe
$LN8@GetFrondGe:

; 2820 :                     else
; 2821 :                         pMapIndexes[i] = pTexIndices[pStrips[i][0]];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _i$6[ebp]
	mov	eax, DWORD PTR _pStrips$8[ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	movzx	eax, WORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _pMapIndexes$[ebp]
	add	ecx, DWORD PTR _i$6[ebp]
	mov	edx, DWORD PTR _pTexIndices$7[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], al
$LN9@GetFrondGe:

; 2822 :                 }

	jmp	SHORT $LN2@GetFrondGe
$LN3@GetFrondGe:

; 2823 :             }
; 2824 :         }
; 2825 :     }

	jmp	$LN11@GetFrondGe
__catch$?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z$0:

; 2826 : 
; 2827 :     SpeedTreeCatch("CSpeedTreeRT::GetFrondGeometryMapIndexes( )")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$5[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$5[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CM@DCKGMMJN@CSpeedTreeRT?3?3GetFrondGeometryM@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv173[ebp], eax
	mov	edx, DWORD PTR tv173[ebp]
	mov	DWORD PTR tv163[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv163[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN17@GetFrondGe
	ret	0
__catch$?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z$1:

; 2828 :     SpeedTreeCatchAll("CSpeedTreeRT::GetFrondGeometryMapIndexes( )");

	push	OFFSET ??_C@_0CM@DCKGMMJN@CSpeedTreeRT?3?3GetFrondGeometryM@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv174[ebp], eax
	mov	ecx, DWORD PTR tv174[ebp]
	mov	DWORD PTR tv166[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv166[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN19@GetFrondGe
	ret	0
$LN11@GetFrondGe:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN18@GetFrondGe
$LN19@GetFrondGe:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN16@GetFrondGe
$LN18@GetFrondGe:
	jmp	SHORT $LN16@GetFrondGe
$LN17@GetFrondGe:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN16@GetFrondGe:

; 2829 : 
; 2830 :     return pMapIndexes;

	mov	eax, DWORD PTR _pMapIndexes$[ebp]

; 2831 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@GetFrondGe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 400				; 00000190H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN23@GetFrondGe:
	DD	1
	DD	$LN22@GetFrondGe
$LN22@GetFrondGe:
	DD	-112					; ffffff90H
	DD	4
	DD	$LN20@GetFrondGe
$LN20@GetFrondGe:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-404]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFrondGeometryMapIndexes@CSpeedTreeRT@@QBEPAEH@Z ENDP ; CSpeedTreeRT::GetFrondGeometryMapIndexes
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ
_TEXT	SEGMENT
tv142 = -328						; size = 4
tv139 = -328						; size = 4
tv145 = -324						; size = 4
tv144 = -324						; size = 4
tv81 = -324						; size = 4
$T2 = -316						; size = 28
$T3 = -280						; size = 28
$T4 = -244						; size = 4
_cException$5 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ PROC		; CSpeedTreeRT::DeleteFrondGeometry, COMDAT
; _this$ = ecx

; 2778 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 312				; 00000138H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-136]
	mov	ecx, 30					; 0000001eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2779 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2780 :     {
; 2781 :         if (m_bTreeComputed &&
; 2782 :             m_pFrondGeometry &&
; 2783 :             !m_pInstanceData &&
; 2784 :             m_pInstanceRefCount &&

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+69]
	test	ecx, ecx
	je	SHORT $LN3@DeleteFron
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN3@DeleteFron
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	SHORT $LN3@DeleteFron
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN3@DeleteFron
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN3@DeleteFron

; 2785 :             *m_pInstanceRefCount == 1)
; 2786 :         {
; 2787 :             delete m_pFrondGeometry;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR $T4[ebp], ecx
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN5@DeleteFron
	push	1
	mov	ecx, DWORD PTR $T4[ebp]
	call	??_GCIndexedGeometry@@QAEPAXI@Z
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN6@DeleteFron
$LN5@DeleteFron:
	mov	DWORD PTR tv81[ebp], 0
$LN6@DeleteFron:

; 2788 :             m_pFrondGeometry = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+92], 0
$LN3@DeleteFron:

; 2789 :         }
; 2790 :     }

	jmp	$LN7@DeleteFron
__catch$?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ$0:

; 2791 : 
; 2792 :     SpeedTreeCatch("CSpeedTreeRT::DeleteFrondGeometry")

	mov	eax, DWORD PTR _cException$5[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _cException$5[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CC@JHFKHJHB@CSpeedTreeRT?3?3DeleteFrondGeomet@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv144[ebp], eax
	mov	edx, DWORD PTR tv144[ebp]
	mov	DWORD PTR tv139[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv139[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN13@DeleteFron
	ret	0
__catch$?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ$1:

; 2793 :     SpeedTreeCatchAll("CSpeedTreeRT::DeleteFrondGeometry");

	push	OFFSET ??_C@_0CC@JHFKHJHB@CSpeedTreeRT?3?3DeleteFrondGeomet@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv145[ebp], eax
	mov	ecx, DWORD PTR tv145[ebp]
	mov	DWORD PTR tv142[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv142[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN15@DeleteFron
	ret	0
$LN7@DeleteFron:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN14@DeleteFron
$LN15@DeleteFron:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN12@DeleteFron
$LN14@DeleteFron:
	jmp	SHORT $LN12@DeleteFron
$LN13@DeleteFron:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN12@DeleteFron:

; 2794 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@DeleteFron
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 328				; 00000148H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN19@DeleteFron:
	DD	1
	DD	$LN18@DeleteFron
$LN18@DeleteFron:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN16@DeleteFron
$LN16@DeleteFron:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-332]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DeleteFrondGeometry@CSpeedTreeRT@@QAEXXZ ENDP		; CSpeedTreeRT::DeleteFrondGeometry
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ
_TEXT	SEGMENT
tv140 = -328						; size = 4
tv137 = -328						; size = 4
tv143 = -324						; size = 4
tv142 = -324						; size = 4
tv79 = -324						; size = 4
$T2 = -316						; size = 28
$T3 = -280						; size = 28
$T4 = -244						; size = 4
_cException$5 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ PROC		; CSpeedTreeRT::DeleteBranchGeometry, COMDAT
; _this$ = ecx

; 2208 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 312				; 00000138H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-136]
	mov	ecx, 30					; 0000001eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2209 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2210 :     {
; 2211 :         if (m_bTreeComputed &&
; 2212 :             m_pBranchGeometry &&
; 2213 :             !m_pInstanceData &&

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+69]
	test	ecx, ecx
	je	SHORT $LN3@DeleteBran
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@DeleteBran
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	SHORT $LN3@DeleteBran
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN3@DeleteBran

; 2214 :             *m_pInstanceRefCount == 1)
; 2215 :         {
; 2216 :             delete m_pBranchGeometry;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T4[ebp], ecx
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN5@DeleteBran
	push	1
	mov	ecx, DWORD PTR $T4[ebp]
	call	??_GCIndexedGeometry@@QAEPAXI@Z
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN6@DeleteBran
$LN5@DeleteBran:
	mov	DWORD PTR tv79[ebp], 0
$LN6@DeleteBran:

; 2217 :             m_pBranchGeometry = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@DeleteBran:

; 2218 :         }
; 2219 :     }

	jmp	$LN7@DeleteBran
__catch$?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ$0:

; 2220 : 
; 2221 :     SpeedTreeCatch("CSpeedTreeRT::DeleteBranchGeometry")

	mov	eax, DWORD PTR _cException$5[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _cException$5[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CD@MCKNGMH@CSpeedTreeRT?3?3DeleteBranchGeome@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv142[ebp], eax
	mov	edx, DWORD PTR tv142[ebp]
	mov	DWORD PTR tv137[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv137[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN13@DeleteBran
	ret	0
__catch$?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ$1:

; 2222 :     SpeedTreeCatchAll("CSpeedTreeRT::DeleteBranchGeometry");

	push	OFFSET ??_C@_0CD@MCKNGMH@CSpeedTreeRT?3?3DeleteBranchGeome@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv143[ebp], eax
	mov	ecx, DWORD PTR tv143[ebp]
	mov	DWORD PTR tv140[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv140[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN15@DeleteBran
	ret	0
$LN7@DeleteBran:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN14@DeleteBran
$LN15@DeleteBran:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN12@DeleteBran
$LN14@DeleteBran:
	jmp	SHORT $LN12@DeleteBran
$LN13@DeleteBran:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN12@DeleteBran:

; 2223 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@DeleteBran
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 328				; 00000148H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN19@DeleteBran:
	DD	1
	DD	$LN18@DeleteBran
$LN18@DeleteBran:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN16@DeleteBran
$LN16@DeleteBran:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-332]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DeleteBranchGeometry@CSpeedTreeRT@@QAEXXZ ENDP		; CSpeedTreeRT::DeleteBranchGeometry
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetHorzBillboardFadeAngles@CSpeedTreeRT@@SAXAAM0@Z
_TEXT	SEGMENT
_fStart$ = 8						; size = 4
_fEnd$ = 12						; size = 4
?GetHorzBillboardFadeAngles@CSpeedTreeRT@@SAXAAM0@Z PROC ; CSpeedTreeRT::GetHorzBillboardFadeAngles, COMDAT

; 3684 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 3685 :     fStart = m_fHorizontalFadeStartAngle;

	mov	eax, DWORD PTR _fStart$[ebp]
	movss	xmm0, DWORD PTR ?m_fHorizontalFadeStartAngle@CSpeedTreeRT@@0MA
	movss	DWORD PTR [eax], xmm0

; 3686 :     fEnd = m_fHorizontalFadeEndAngle;

	mov	eax, DWORD PTR _fEnd$[ebp]
	movss	xmm0, DWORD PTR ?m_fHorizontalFadeEndAngle@CSpeedTreeRT@@0MA
	movss	DWORD PTR [eax], xmm0

; 3687 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetHorzBillboardFadeAngles@CSpeedTreeRT@@SAXAAM0@Z ENDP ; CSpeedTreeRT::GetHorzBillboardFadeAngles
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetHorzBillboardFadeAngles@CSpeedTreeRT@@SAXMM@Z
_TEXT	SEGMENT
_fStart$ = 8						; size = 4
_fEnd$ = 12						; size = 4
?SetHorzBillboardFadeAngles@CSpeedTreeRT@@SAXMM@Z PROC	; CSpeedTreeRT::SetHorzBillboardFadeAngles, COMDAT

; 3674 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 3675 :     m_fHorizontalFadeStartAngle = fStart;

	movss	xmm0, DWORD PTR _fStart$[ebp]
	movss	DWORD PTR ?m_fHorizontalFadeStartAngle@CSpeedTreeRT@@0MA, xmm0

; 3676 :     m_fHorizontalFadeEndAngle = fEnd;

	movss	xmm0, DWORD PTR _fEnd$[ebp]
	movss	DWORD PTR ?m_fHorizontalFadeEndAngle@CSpeedTreeRT@@0MA, xmm0

; 3677 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetHorzBillboardFadeAngles@CSpeedTreeRT@@SAXMM@Z ENDP	; CSpeedTreeRT::SetHorzBillboardFadeAngles
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetNumFrondLodLevels@CSpeedTreeRT@@QBEGXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetNumFrondLodLevels@CSpeedTreeRT@@QBEGXZ PROC		; CSpeedTreeRT::GetNumFrondLodLevels, COMDAT
; _this$ = ecx

; 2199 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2200 :     return m_usNumFrondLodLevels;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [eax+96]

; 2201 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumFrondLodLevels@CSpeedTreeRT@@QBEGXZ ENDP		; CSpeedTreeRT::GetNumFrondLodLevels
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetNumLeafLodLevels@CSpeedTreeRT@@QBEGXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetNumLeafLodLevels@CSpeedTreeRT@@QBEGXZ PROC		; CSpeedTreeRT::GetNumLeafLodLevels, COMDAT
; _this$ = ecx

; 2190 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2191 :     return static_cast<unsigned short>(m_pEngine->GetNumLeafLodLevels( ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetNumLeafLodLevels@CTreeEngine@@QBEHXZ ; CTreeEngine::GetNumLeafLodLevels

; 2192 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumLeafLodLevels@CSpeedTreeRT@@QBEGXZ ENDP		; CSpeedTreeRT::GetNumLeafLodLevels
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetNumBranchLodLevels@CSpeedTreeRT@@QBEGXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetNumBranchLodLevels@CSpeedTreeRT@@QBEGXZ PROC	; CSpeedTreeRT::GetNumBranchLodLevels, COMDAT
; _this$ = ecx

; 2181 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2182 :     return static_cast<unsigned short>(m_pEngine->GetNumBranchLodLevels( ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetNumBranchLodLevels@CTreeEngine@@QBEIXZ ; CTreeEngine::GetNumBranchLodLevels

; 2183 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumBranchLodLevels@CSpeedTreeRT@@QBEGXZ ENDP	; CSpeedTreeRT::GetNumBranchLodLevels
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetDiscreteFrondLodLevel@CSpeedTreeRT@@QBEFM@Z
_TEXT	SEGMENT
_nNumLodLevels$ = -32					; size = 4
_sLevel$ = -20						; size = 2
_this$ = -8						; size = 4
_fLodLevel$ = 8						; size = 4
?GetDiscreteFrondLodLevel@CSpeedTreeRT@@QBEFM@Z PROC	; CSpeedTreeRT::GetDiscreteFrondLodLevel, COMDAT
; _this$ = ecx

; 2128 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2129 :     short sLevel = 0;

	xor	eax, eax
	mov	WORD PTR _sLevel$[ebp], ax

; 2130 :     // -1.0f passed in means to use the current interval value
; 2131 :     if (fLodLevel == -1.0f)

	movss	xmm0, DWORD PTR _fLodLevel$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@GetDiscret

; 2132 :         fLodLevel = GetLodLevel( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLodLevel@CSpeedTreeRT@@QBEMXZ	; CSpeedTreeRT::GetLodLevel
	fstp	DWORD PTR _fLodLevel$[ebp]
$LN2@GetDiscret:

; 2133 : 
; 2134 :     int nNumLodLevels = GetNumFrondLodLevels( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumFrondLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumFrondLodLevels
	movzx	eax, ax
	mov	DWORD PTR _nNumLodLevels$[ebp], eax

; 2135 :     sLevel = static_cast<short>((1.0f - fLodLevel) * nNumLodLevels);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _fLodLevel$[ebp]
	cvtsi2ss xmm1, DWORD PTR _nNumLodLevels$[ebp]
	mulss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR _sLevel$[ebp], ax

; 2136 :     if (sLevel == nNumLodLevels)

	movsx	eax, WORD PTR _sLevel$[ebp]
	cmp	eax, DWORD PTR _nNumLodLevels$[ebp]
	jne	SHORT $LN3@GetDiscret

; 2137 :         sLevel--;

	mov	ax, WORD PTR _sLevel$[ebp]
	sub	ax, 1
	mov	WORD PTR _sLevel$[ebp], ax
$LN3@GetDiscret:

; 2138 : 
; 2139 :     st_assert(sLevel >= 0 && sLevel < GetNumFrondLodLevels( ));

	movsx	eax, WORD PTR _sLevel$[ebp]
	test	eax, eax
	jl	SHORT $LN5@GetDiscret
	movsx	esi, WORD PTR _sLevel$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumFrondLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumFrondLodLevels
	movzx	eax, ax
	cmp	esi, eax
	jl	SHORT $LN4@GetDiscret
$LN5@GetDiscret:
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0??GetDiscreteFrondLodLevel@CSpeedTreeRT@@QBEFM@Z@4JA
	add	eax, 11					; 0000000bH
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN4@GetDiscret:

; 2140 :     return sLevel;

	mov	ax, WORD PTR _sLevel$[ebp]
$LN1@GetDiscret:

; 2141 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetDiscreteFrondLodLevel@CSpeedTreeRT@@QBEFM@Z ENDP	; CSpeedTreeRT::GetDiscreteFrondLodLevel
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetDiscreteLeafLodLevel@CSpeedTreeRT@@QBEGM@Z
_TEXT	SEGMENT
_nNumLodLevels$1 = -44					; size = 4
_nNumLodLevels$2 = -32					; size = 4
_nLevel$ = -20						; size = 2
_this$ = -8						; size = 4
_fLodLevel$ = 8						; size = 4
?GetDiscreteLeafLodLevel@CSpeedTreeRT@@QBEGM@Z PROC	; CSpeedTreeRT::GetDiscreteLeafLodLevel, COMDAT
; _this$ = ecx

; 2148 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2149 :     unsigned short nLevel = 0;

	xor	eax, eax
	mov	WORD PTR _nLevel$[ebp], ax

; 2150 :     // -1.0f passed in means to use the current interval value
; 2151 :     if (fLodLevel == -1.0f)

	movss	xmm0, DWORD PTR _fLodLevel$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@GetDiscret

; 2152 :         fLodLevel = GetLodLevel( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLodLevel@CSpeedTreeRT@@QBEMXZ	; CSpeedTreeRT::GetLodLevel
	fstp	DWORD PTR _fLodLevel$[ebp]
$LN2@GetDiscret:

; 2153 : 
; 2154 :     if (m_bDropToBillboard && m_pEmbeddedTexCoords && m_pEmbeddedTexCoords->m_nNumBillboards > 0)

	movzx	eax, BYTE PTR ?m_bDropToBillboard@CSpeedTreeRT@@0_NA ; CSpeedTreeRT::m_bDropToBillboard
	test	eax, eax
	je	$LN3@GetDiscret
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	$LN3@GetDiscret
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	cmp	DWORD PTR [ecx+8], 0
	jle	$LN3@GetDiscret

; 2155 :     {
; 2156 :         int nNumLodLevels = GetNumLeafLodLevels( ) + 1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumLeafLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumLeafLodLevels
	movzx	eax, ax
	add	eax, 1
	mov	DWORD PTR _nNumLodLevels$2[ebp], eax

; 2157 :         nLevel = static_cast<unsigned short>((1.0f - fLodLevel) * nNumLodLevels);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _fLodLevel$[ebp]
	cvtsi2ss xmm1, DWORD PTR _nNumLodLevels$2[ebp]
	mulss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR _nLevel$[ebp], ax

; 2158 :         if (nLevel == nNumLodLevels)

	movzx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, DWORD PTR _nNumLodLevels$2[ebp]
	jne	SHORT $LN5@GetDiscret

; 2159 :             nLevel--;

	mov	ax, WORD PTR _nLevel$[ebp]
	sub	ax, 1
	mov	WORD PTR _nLevel$[ebp], ax
$LN5@GetDiscret:

; 2160 : 
; 2161 :         st_assert(nLevel >= 0 && nLevel < nNumLodLevels);

	movzx	eax, WORD PTR _nLevel$[ebp]
	test	eax, eax
	jl	SHORT $LN7@GetDiscret
	movzx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, DWORD PTR _nNumLodLevels$2[ebp]
	jl	SHORT $LN6@GetDiscret
$LN7@GetDiscret:
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0??GetDiscreteLeafLodLevel@CSpeedTreeRT@@QBEGM@Z@4JA
	add	eax, 13					; 0000000dH
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN6@GetDiscret:

; 2162 :     }

	jmp	$LN9@GetDiscret
$LN3@GetDiscret:

; 2163 :     else
; 2164 :     {
; 2165 :         int nNumLodLevels = GetNumLeafLodLevels( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumLeafLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumLeafLodLevels
	movzx	eax, ax
	mov	DWORD PTR _nNumLodLevels$1[ebp], eax

; 2166 :         nLevel = static_cast<unsigned short>((1.0f - fLodLevel) * nNumLodLevels);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _fLodLevel$[ebp]
	cvtsi2ss xmm1, DWORD PTR _nNumLodLevels$1[ebp]
	mulss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR _nLevel$[ebp], ax

; 2167 :         if (nLevel == nNumLodLevels)

	movzx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, DWORD PTR _nNumLodLevels$1[ebp]
	jne	SHORT $LN8@GetDiscret

; 2168 :             nLevel--;

	mov	ax, WORD PTR _nLevel$[ebp]
	sub	ax, 1
	mov	WORD PTR _nLevel$[ebp], ax
$LN8@GetDiscret:

; 2169 : 
; 2170 :         st_assert(nLevel >= 0 && nLevel < nNumLodLevels);

	movzx	eax, WORD PTR _nLevel$[ebp]
	test	eax, eax
	jl	SHORT $LN10@GetDiscret
	movzx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, DWORD PTR _nNumLodLevels$1[ebp]
	jl	SHORT $LN9@GetDiscret
$LN10@GetDiscret:
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0??GetDiscreteLeafLodLevel@CSpeedTreeRT@@QBEGM@Z@4JA
	add	eax, 22					; 00000016H
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN9@GetDiscret:

; 2171 :     }
; 2172 : 
; 2173 :     return nLevel;

	mov	ax, WORD PTR _nLevel$[ebp]
$LN1@GetDiscret:

; 2174 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetDiscreteLeafLodLevel@CSpeedTreeRT@@QBEGM@Z ENDP	; CSpeedTreeRT::GetDiscreteLeafLodLevel
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetDiscreteBranchLodLevel@CSpeedTreeRT@@QBEFM@Z
_TEXT	SEGMENT
_nNumLodLevels$ = -32					; size = 4
_sLevel$ = -20						; size = 2
_this$ = -8						; size = 4
_fLodLevel$ = 8						; size = 4
?GetDiscreteBranchLodLevel@CSpeedTreeRT@@QBEFM@Z PROC	; CSpeedTreeRT::GetDiscreteBranchLodLevel, COMDAT
; _this$ = ecx

; 2108 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2109 :     short sLevel = 0;

	xor	eax, eax
	mov	WORD PTR _sLevel$[ebp], ax

; 2110 :     // -1.0f passed in means to use the current interval value
; 2111 :     if (fLodLevel == -1.0f)

	movss	xmm0, DWORD PTR _fLodLevel$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@GetDiscret

; 2112 :         fLodLevel = GetLodLevel( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLodLevel@CSpeedTreeRT@@QBEMXZ	; CSpeedTreeRT::GetLodLevel
	fstp	DWORD PTR _fLodLevel$[ebp]
$LN2@GetDiscret:

; 2113 : 
; 2114 :     int nNumLodLevels = GetNumBranchLodLevels( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumBranchLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumBranchLodLevels
	movzx	eax, ax
	mov	DWORD PTR _nNumLodLevels$[ebp], eax

; 2115 :     sLevel = static_cast<short>((1.0f - fLodLevel) * nNumLodLevels);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _fLodLevel$[ebp]
	cvtsi2ss xmm1, DWORD PTR _nNumLodLevels$[ebp]
	mulss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR _sLevel$[ebp], ax

; 2116 :     if (sLevel == nNumLodLevels)

	movsx	eax, WORD PTR _sLevel$[ebp]
	cmp	eax, DWORD PTR _nNumLodLevels$[ebp]
	jne	SHORT $LN3@GetDiscret

; 2117 :         sLevel--;

	mov	ax, WORD PTR _sLevel$[ebp]
	sub	ax, 1
	mov	WORD PTR _sLevel$[ebp], ax
$LN3@GetDiscret:

; 2118 : 
; 2119 :     st_assert(sLevel >= 0 && sLevel < GetNumBranchLodLevels( ));

	movsx	eax, WORD PTR _sLevel$[ebp]
	test	eax, eax
	jl	SHORT $LN5@GetDiscret
	movsx	esi, WORD PTR _sLevel$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumBranchLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumBranchLodLevels
	movzx	eax, ax
	cmp	esi, eax
	jl	SHORT $LN4@GetDiscret
$LN5@GetDiscret:
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0??GetDiscreteBranchLodLevel@CSpeedTreeRT@@QBEFM@Z@4JA
	add	eax, 11					; 0000000bH
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN4@GetDiscret:

; 2120 :     return sLevel;

	mov	ax, WORD PTR _sLevel$[ebp]
$LN1@GetDiscret:

; 2121 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetDiscreteBranchLodLevel@CSpeedTreeRT@@QBEFM@Z ENDP	; CSpeedTreeRT::GetDiscreteBranchLodLevel
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetLodLimits@CSpeedTreeRT@@QAEXMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fNear$ = 8						; size = 4
_fFar$ = 12						; size = 4
?SetLodLimits@CSpeedTreeRT@@QAEXMM@Z PROC		; CSpeedTreeRT::SetLodLimits, COMDAT
; _this$ = ecx

; 2099 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2100 :     m_pEngine->SetLodLimits(fNear, fFar);

	push	ecx
	movss	xmm0, DWORD PTR _fFar$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fNear$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?SetLodLimits@CTreeEngine@@QAEXMM@Z	; CTreeEngine::SetLodLimits
	npad	1

; 2101 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetLodLimits@CSpeedTreeRT@@QAEXMM@Z ENDP		; CSpeedTreeRT::SetLodLimits
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetLodLimits@CSpeedTreeRT@@QBEXAAM0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fNear$ = 8						; size = 4
_fFar$ = 12						; size = 4
?GetLodLimits@CSpeedTreeRT@@QBEXAAM0@Z PROC		; CSpeedTreeRT::GetLodLimits, COMDAT
; _this$ = ecx

; 2090 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2091 :     m_pEngine->GetLodLimits(fNear, fFar);

	mov	eax, DWORD PTR _fFar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fNear$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetLodLimits@CTreeEngine@@QBEXAAM0@Z	; CTreeEngine::GetLodLimits
	npad	1

; 2092 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetLodLimits@CSpeedTreeRT@@QBEXAAM0@Z ENDP		; CSpeedTreeRT::GetLodLimits
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetDropToBillboard@CSpeedTreeRT@@SAX_N@Z
_TEXT	SEGMENT
_bFlag$ = 8						; size = 1
?SetDropToBillboard@CSpeedTreeRT@@SAX_N@Z PROC		; CSpeedTreeRT::SetDropToBillboard, COMDAT

; 2081 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 2082 :     m_bDropToBillboard = bFlag;

	movzx	eax, BYTE PTR _bFlag$[ebp]
	mov	BYTE PTR ?m_bDropToBillboard@CSpeedTreeRT@@0_NA, al ; CSpeedTreeRT::m_bDropToBillboard

; 2083 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetDropToBillboard@CSpeedTreeRT@@SAX_N@Z ENDP		; CSpeedTreeRT::SetDropToBillboard
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetLodLevel@CSpeedTreeRT@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fLevel$ = 8						; size = 4
?SetLodLevel@CSpeedTreeRT@@QAEXM@Z PROC			; CSpeedTreeRT::SetLodLevel, COMDAT
; _this$ = ecx

; 2064 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2065 :     if (fLevel >= 0.0f && fLevel <= 1.0f)

	movss	xmm0, DWORD PTR _fLevel$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN2@SetLodLeve
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _fLevel$[ebp]
	jb	SHORT $LN2@SetLodLeve

; 2066 :     {
; 2067 :         if (m_pInstanceData)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN4@SetLodLeve

; 2068 :             m_pInstanceData->m_fLodLevel = fLevel;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	movss	xmm0, DWORD PTR _fLevel$[ebp]
	movss	DWORD PTR [ecx+16], xmm0
	jmp	SHORT $LN5@SetLodLeve
$LN4@SetLodLeve:

; 2069 :         else
; 2070 :             m_pEngine->SetLod(fLevel);

	push	ecx
	movss	xmm0, DWORD PTR _fLevel$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?SetLod@CTreeEngine@@QAEXM@Z		; CTreeEngine::SetLod
	npad	1
$LN5@SetLodLeve:

; 2071 :     }

	jmp	SHORT $LN3@SetLodLeve
$LN2@SetLodLeve:

; 2072 :     else
; 2073 :         SetError("SetLodLevel() expects a value in the range of 0.0 to 1.0");

	push	OFFSET ??_C@_0DJ@ECEAEPMG@SetLodLevel?$CI?$CJ?5expects?5a?5value?5i@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN3@SetLodLeve:

; 2074 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLodLevel@CSpeedTreeRT@@QAEXM@Z ENDP			; CSpeedTreeRT::SetLodLevel
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetLodLevel@CSpeedTreeRT@@QBEMXZ
_TEXT	SEGMENT
_fLevel$ = -20						; size = 4
_this$ = -8						; size = 4
?GetLodLevel@CSpeedTreeRT@@QBEMXZ PROC			; CSpeedTreeRT::GetLodLevel, COMDAT
; _this$ = ecx

; 2048 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2049 :     float fLevel = -1.0f; // default to invalid value

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _fLevel$[ebp], xmm0

; 2050 : 
; 2051 :     if (m_pInstanceData)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN2@GetLodLeve

; 2052 :         fLevel = m_pInstanceData->m_fLodLevel;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	movss	xmm0, DWORD PTR [ecx+16]
	movss	DWORD PTR _fLevel$[ebp], xmm0
	jmp	SHORT $LN3@GetLodLeve
$LN2@GetLodLeve:

; 2053 :     else
; 2054 :         fLevel = m_pEngine->GetLod( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetLod@CTreeEngine@@QBEMXZ		; CTreeEngine::GetLod
	fstp	DWORD PTR _fLevel$[ebp]
$LN3@GetLodLeve:

; 2055 : 
; 2056 :     return fLevel;

	fld	DWORD PTR _fLevel$[ebp]

; 2057 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLodLevel@CSpeedTreeRT@@QBEMXZ ENDP			; CSpeedTreeRT::GetLodLevel
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ
_TEXT	SEGMENT
tv162 = -348						; size = 4
tv159 = -348						; size = 4
tv168 = -344						; size = 4
tv167 = -344						; size = 4
tv166 = -344						; size = 4
tv165 = -344						; size = 4
tv164 = -344						; size = 4
$T2 = -336						; size = 28
$T3 = -300						; size = 28
_cException$4 = -72					; size = 4
_fOldLodLevel$5 = -60					; size = 4
_cOldPosition$6 = -48					; size = 12
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ PROC		; CSpeedTreeRT::ComputeLodLevel, COMDAT
; _this$ = ecx

; 2017 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 332				; 0000014cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-156]
	mov	ecx, 35					; 00000023H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2018 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2019 :     {
; 2020 :         if (m_pInstanceData)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	$LN3@ComputeLod

; 2021 :         {
; 2022 :             // must activate instance's attributes, make the computation,
; 2023 :             // then restore the parent's attributes
; 2024 :             CVec3 cOldPosition = m_pEngine->GetPosition( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetPosition@CIdvCamera@@QBEABVCVec3@@XZ ; CIdvCamera::GetPosition
	mov	DWORD PTR tv164[ebp], eax
	mov	ecx, DWORD PTR tv164[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cOldPosition$6[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _cOldPosition$6[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cOldPosition$6[ebp+8], ecx

; 2025 :             float fOldLodLevel = m_pEngine->GetLod( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetLod@CTreeEngine@@QBEMXZ		; CTreeEngine::GetLod
	fstp	DWORD PTR tv165[ebp]
	movss	xmm0, DWORD PTR tv165[ebp]
	movss	DWORD PTR _fOldLodLevel$5[ebp], xmm0

; 2026 : 
; 2027 :             // compute
; 2028 :             m_pEngine->SetPosition(m_pInstanceData->m_cPosition);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?SetPosition@CIdvCamera@@QAEXABVCVec3@@@Z ; CIdvCamera::SetPosition
	npad	1

; 2029 :             m_pInstanceData->m_fLodLevel = m_pEngine->ComputeLod( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?ComputeLod@CTreeEngine@@QAEMXZ		; CTreeEngine::ComputeLod
	fstp	DWORD PTR tv166[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	movss	xmm0, DWORD PTR tv166[ebp]
	movss	DWORD PTR [edx+16], xmm0

; 2030 : 
; 2031 :             // restore
; 2032 :             m_pEngine->SetLod(fOldLodLevel);

	push	ecx
	movss	xmm0, DWORD PTR _fOldLodLevel$5[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?SetLod@CTreeEngine@@QAEXM@Z		; CTreeEngine::SetLod
	npad	1

; 2033 :             m_pEngine->SetPosition(cOldPosition);

	lea	eax, DWORD PTR _cOldPosition$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?SetPosition@CIdvCamera@@QAEXABVCVec3@@@Z ; CIdvCamera::SetPosition
	npad	1

; 2034 :         }

	jmp	SHORT $LN4@ComputeLod
$LN3@ComputeLod:

; 2035 :         else
; 2036 :             (void) m_pEngine->ComputeLod( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?ComputeLod@CTreeEngine@@QAEMXZ		; CTreeEngine::ComputeLod
	fstp	ST(0)
	npad	1
$LN4@ComputeLod:

; 2037 :     }

	jmp	$LN6@ComputeLod
__catch$?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ$0:

; 2038 : 
; 2039 :     SpeedTreeCatch("CSpeedTreeRT::ComputeLodLevel")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BO@NEFNJPOG@CSpeedTreeRT?3?3ComputeLodLevel@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv167[ebp], eax
	mov	edx, DWORD PTR tv167[ebp]
	mov	DWORD PTR tv159[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv159[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN12@ComputeLod
	ret	0
__catch$?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ$1:

; 2040 :     SpeedTreeCatchAll("CSpeedTreeRT::ComputeLodLevel");

	push	OFFSET ??_C@_0BO@NEFNJPOG@CSpeedTreeRT?3?3ComputeLodLevel@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv168[ebp], eax
	mov	ecx, DWORD PTR tv168[ebp]
	mov	DWORD PTR tv162[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv162[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN14@ComputeLod
	ret	0
$LN6@ComputeLod:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN13@ComputeLod
$LN14@ComputeLod:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN11@ComputeLod
$LN13@ComputeLod:
	jmp	SHORT $LN11@ComputeLod
$LN12@ComputeLod:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN11@ComputeLod:

; 2041 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@ComputeLod
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 348				; 0000015cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@ComputeLod:
	DD	2
	DD	$LN18@ComputeLod
$LN18@ComputeLod:
	DD	-48					; ffffffd0H
	DD	12					; 0000000cH
	DD	$LN15@ComputeLod
	DD	-72					; ffffffb8H
	DD	4
	DD	$LN16@ComputeLod
$LN16@ComputeLod:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN15@ComputeLod:
	DB	99					; 00000063H
	DB	79					; 0000004fH
	DB	108					; 0000006cH
	DB	100					; 00000064H
	DB	80					; 00000050H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-352]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ ENDP		; CSpeedTreeRT::ComputeLodLevel
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z
_TEXT	SEGMENT
tv136 = -316						; size = 4
tv133 = -316						; size = 4
tv140 = -312						; size = 4
tv139 = -312						; size = 4
tv138 = -312						; size = 4
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_nStartingMatrix$ = 8					; size = 4
_nMatrixSpan$ = 12					; size = 4
?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z PROC		; CSpeedTreeRT::SetLocalMatrices, COMDAT
; _this$ = ecx

; 1994 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1995 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1996 :     {
; 1997 :         if (!m_bTreeComputed)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+69]
	test	ecx, ecx
	jne	SHORT $LN3@SetLocalMa

; 1998 :         {
; 1999 :             if (nStartingMatrix + nMatrixSpan - 1 < m_pWindEngine->GetNumWindMatrices( ))

	call	?GetNumWindMatrices@CWindEngine@@SAIXZ	; CWindEngine::GetNumWindMatrices
	mov	DWORD PTR tv138[ebp], eax
	mov	eax, DWORD PTR _nMatrixSpan$[ebp]
	mov	ecx, DWORD PTR _nStartingMatrix$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	cmp	edx, DWORD PTR tv138[ebp]
	jae	SHORT $LN5@SetLocalMa

; 2000 :                 m_pWindEngine->SetLocalMatrices(nStartingMatrix, nMatrixSpan);

	mov	eax, DWORD PTR _nMatrixSpan$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nStartingMatrix$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	call	?SetLocalMatrices@CWindEngine@@QAEXII@Z	; CWindEngine::SetLocalMatrices
	npad	1
	jmp	SHORT $LN6@SetLocalMa
$LN5@SetLocalMa:

; 2001 :             else
; 2002 :                 SetError("SetLocalMatrices() parameters exceed available wind matrices");

	push	OFFSET ??_C@_0DN@LOGCFILD@SetLocalMatrices?$CI?$CJ?5parameters?5e@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN6@SetLocalMa:

; 2003 :         }

	jmp	SHORT $LN4@SetLocalMa
$LN3@SetLocalMa:

; 2004 :         else
; 2005 :             SetError("SetLocalMatrices() has no effect after Compute() has been called");

	push	OFFSET ??_C@_0EB@IGKHMMPL@SetLocalMatrices?$CI?$CJ?5has?5no?5effec@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@SetLocalMa:

; 2006 :     }

	jmp	$LN8@SetLocalMa
__catch$?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z$0:

; 2007 : 
; 2008 :     SpeedTreeCatch("CSpeedTreeRT::SetLocalMatrices")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BP@LNJAODIF@CSpeedTreeRT?3?3SetLocalMatrices@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv139[ebp], eax
	mov	edx, DWORD PTR tv139[ebp]
	mov	DWORD PTR tv133[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv133[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN14@SetLocalMa
	ret	0
__catch$?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z$1:

; 2009 :     SpeedTreeCatchAll("CSpeedTreeRT::SetLocalMatrices");

	push	OFFSET ??_C@_0BP@LNJAODIF@CSpeedTreeRT?3?3SetLocalMatrices@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv140[ebp], eax
	mov	ecx, DWORD PTR tv140[ebp]
	mov	DWORD PTR tv136[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv136[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN16@SetLocalMa
	ret	0
$LN8@SetLocalMa:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN15@SetLocalMa
$LN16@SetLocalMa:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN13@SetLocalMa
$LN15@SetLocalMa:
	jmp	SHORT $LN13@SetLocalMa
$LN14@SetLocalMa:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN13@SetLocalMa:

; 2010 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@SetLocalMa
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN20@SetLocalMa:
	DD	1
	DD	$LN19@SetLocalMa
$LN19@SetLocalMa:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN17@SetLocalMa
$LN17@SetLocalMa:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z ENDP		; CSpeedTreeRT::SetLocalMatrices
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetLocalMatrices@CSpeedTreeRT@@QAEXAAI0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nStartingMatrix$ = 8					; size = 4
_nMatrixSpan$ = 12					; size = 4
?GetLocalMatrices@CSpeedTreeRT@@QAEXAAI0@Z PROC		; CSpeedTreeRT::GetLocalMatrices, COMDAT
; _this$ = ecx

; 1985 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1986 :     m_pWindEngine->GetLocalMatrices(nStartingMatrix, nMatrixSpan);

	mov	eax, DWORD PTR _nMatrixSpan$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nStartingMatrix$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	call	?GetLocalMatrices@CWindEngine@@QAEXAAI0@Z ; CWindEngine::GetLocalMatrices
	npad	1

; 1987 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetLocalMatrices@CSpeedTreeRT@@QAEXAAI0@Z ENDP		; CSpeedTreeRT::GetLocalMatrices
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z
_TEXT	SEGMENT
tv165 = -304						; size = 4
tv162 = -304						; size = 4
tv169 = -300						; size = 4
tv168 = -300						; size = 4
tv167 = -300						; size = 4
$T2 = -292						; size = 28
$T3 = -256						; size = 28
_cException$4 = -28					; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_nMatrixIndex$ = 8					; size = 4
_pMatrix$ = 12						; size = 4
?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z PROC		; CSpeedTreeRT::SetWindMatrix, COMDAT

; 1959 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-112]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1960 :     st_assert(pMatrix);

	cmp	DWORD PTR _pMatrix$[ebp], 0
	jne	SHORT $LN2@SetWindMat
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0??SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z@4JA
	add	eax, 1
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN2@SetWindMat:

; 1961 :     st_assert(nMatrixIndex >= 0 && nMatrixIndex < CWindEngine::GetNumWindMatrices( ));

	cmp	DWORD PTR _nMatrixIndex$[ebp], 0
	jb	SHORT $LN4@SetWindMat
	call	?GetNumWindMatrices@CWindEngine@@SAIXZ	; CWindEngine::GetNumWindMatrices
	cmp	DWORD PTR _nMatrixIndex$[ebp], eax
	jb	SHORT $LN3@SetWindMat
$LN4@SetWindMat:
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0??SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z@4JA
	add	eax, 2
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN3@SetWindMat:

; 1962 : 
; 1963 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1964 :     {
; 1965 :         if (!pMatrix)

	cmp	DWORD PTR _pMatrix$[ebp], 0
	jne	SHORT $LN6@SetWindMat

; 1966 :             SetError("SetWindMatrix() requires a non-NULL matrix pointer");

	push	OFFSET ??_C@_0DD@CFNPDLCE@SetWindMatrix?$CI?$CJ?5requires?5a?5non?9@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	jmp	SHORT $LN9@SetWindMat
$LN6@SetWindMat:

; 1967 :         else if (nMatrixIndex >= CWindEngine::GetNumWindMatrices( ))

	call	?GetNumWindMatrices@CWindEngine@@SAIXZ	; CWindEngine::GetNumWindMatrices
	mov	DWORD PTR tv167[ebp], eax
	mov	eax, DWORD PTR _nMatrixIndex$[ebp]
	cmp	eax, DWORD PTR tv167[ebp]
	jb	SHORT $LN8@SetWindMat

; 1968 :             SetError("SetWindMatrix() - matrix index out of range");

	push	OFFSET ??_C@_0CM@FDEHPAEM@SetWindMatrix?$CI?$CJ?5?9?5matrix?5index?5@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	jmp	SHORT $LN9@SetWindMat
$LN8@SetWindMat:

; 1969 :         else
; 1970 :         {
; 1971 :             CWindEngine::SetWindMatrix(static_cast<unsigned short>(nMatrixIndex), pMatrix);

	mov	eax, DWORD PTR _pMatrix$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nMatrixIndex$[ebp]
	push	ecx
	call	?SetWindMatrix@CWindEngine@@SAXGPBM@Z	; CWindEngine::SetWindMatrix
	add	esp, 8

; 1972 :             NotifyAllTreesOfEvent(STIE_CLIENT_CHANGED_WIND);

	push	0
	call	?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z ; CSpeedTreeRT::NotifyAllTreesOfEvent
	add	esp, 4
$LN9@SetWindMat:

; 1973 :         }
; 1974 :     }

	jmp	$LN11@SetWindMat
__catch$?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z$0:

; 1975 : 
; 1976 :     SpeedTreeCatch("CSpeedTreeRT::SetWindMatrix")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BM@CAFNOPKO@CSpeedTreeRT?3?3SetWindMatrix@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv168[ebp], eax
	mov	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR tv162[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv162[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN17@SetWindMat
	ret	0
__catch$?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z$1:

; 1977 :     SpeedTreeCatchAll("CSpeedTreeRT::SetWindMatrix");

	push	OFFSET ??_C@_0BM@CAFNOPKO@CSpeedTreeRT?3?3SetWindMatrix@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv169[ebp], eax
	mov	ecx, DWORD PTR tv169[ebp]
	mov	DWORD PTR tv165[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv165[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN19@SetWindMat
	ret	0
$LN11@SetWindMat:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN18@SetWindMat
$LN19@SetWindMat:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN16@SetWindMat
$LN18@SetWindMat:
	jmp	SHORT $LN16@SetWindMat
$LN17@SetWindMat:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN16@SetWindMat:
$LN1@SetWindMat:

; 1978 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@SetWindMat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@SetWindMat:
	DD	1
	DD	$LN22@SetWindMat
$LN22@SetWindMat:
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN20@SetWindMat
$LN20@SetWindMat:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-308]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetWindMatrix@CSpeedTreeRT@@SAXIPBM@Z ENDP		; CSpeedTreeRT::SetWindMatrix
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z
_TEXT	SEGMENT
tv92 = -304						; size = 4
tv89 = -304						; size = 4
tv95 = -300						; size = 4
tv94 = -300						; size = 4
$T2 = -292						; size = 28
$T3 = -256						; size = 28
_cException$4 = -28					; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_nNumMatrices$ = 8					; size = 4
?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z PROC		; CSpeedTreeRT::SetNumWindMatrices, COMDAT

; 1944 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-112]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1945 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1946 :     {
; 1947 :         CWindEngine::SetNumWindMatrices(static_cast<unsigned short>(nNumMatrices));

	movzx	eax, WORD PTR _nNumMatrices$[ebp]
	push	eax
	call	?SetNumWindMatrices@CWindEngine@@SAXG@Z	; CWindEngine::SetNumWindMatrices
	add	esp, 4

; 1948 :     }

	jmp	$LN4@SetNumWind
__catch$?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z$0:

; 1949 : 
; 1950 :     SpeedTreeCatch("CSpeedTreeRT::SetNumWindMatrices")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CB@LHALGCIH@CSpeedTreeRT?3?3SetNumWindMatrice@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv94[ebp], eax
	mov	edx, DWORD PTR tv94[ebp]
	mov	DWORD PTR tv89[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv89[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN10@SetNumWind
	ret	0
__catch$?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z$1:

; 1951 :     SpeedTreeCatchAll("CSpeedTreeRT::SetNumWindMatrices");

	push	OFFSET ??_C@_0CB@LHALGCIH@CSpeedTreeRT?3?3SetNumWindMatrice@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv95[ebp], eax
	mov	ecx, DWORD PTR tv95[ebp]
	mov	DWORD PTR tv92[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv92[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN12@SetNumWind
	ret	0
$LN4@SetNumWind:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN11@SetNumWind
$LN12@SetNumWind:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN9@SetNumWind
$LN11@SetNumWind:
	jmp	SHORT $LN9@SetNumWind
$LN10@SetNumWind:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@SetNumWind:

; 1952 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@SetNumWind
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@SetNumWind:
	DD	1
	DD	$LN15@SetNumWind
$LN15@SetNumWind:
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN13@SetNumWind
$LN13@SetNumWind:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-308]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetNumWindMatrices@CSpeedTreeRT@@SAXH@Z ENDP		; CSpeedTreeRT::SetNumWindMatrices
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z
_TEXT	SEGMENT
tv155 = -316						; size = 4
tv152 = -316						; size = 4
tv162 = -312						; size = 4
tv161 = -312						; size = 4
tv159 = -312						; size = 4
tv158 = -312						; size = 4
tv157 = -312						; size = 4
tv160 = -309						; size = 1
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_fNewStrength$ = 8					; size = 4
_pRockingAngles$ = 12					; size = 4
_pRustleAngles$ = 16					; size = 4
_uiNumRockingAngles$ = 20				; size = 4
?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z PROC ; CSpeedTreeRT::SetWindStrengthAndLeafAngles, COMDAT
; _this$ = ecx

; 1911 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1912 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1913 :     {
; 1914 :         if (fNewStrength >= 0.0f)

	movss	xmm0, DWORD PTR _fNewStrength$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	$LN3@SetWindStr

; 1915 :         {
; 1916 :             m_pWindEngine->SetWindStrengthAndLeafAngles(fNewStrength, pRockingAngles, pRustleAngles, uiNumRockingAngles);

	mov	eax, DWORD PTR _uiNumRockingAngles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pRustleAngles$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pRockingAngles$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _fNewStrength$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?SetWindStrengthAndLeafAngles@CWindEngine@@QAEXMPBM0I@Z ; CWindEngine::SetWindStrengthAndLeafAngles
	npad	1

; 1917 : 
; 1918 :             // invalidate geometry if CPU-based wind
; 1919 :             if (GetBranchWindMethod( ) == WIND_CPU &&

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ ; CSpeedTreeRT::GetBranchWindMethod
	mov	DWORD PTR tv157[ebp], eax
	cmp	DWORD PTR tv157[ebp], 1
	jne	SHORT $LN5@SetWindStr
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN5@SetWindStr

; 1920 :                 m_pBranchGeometry)
; 1921 :                 m_pBranchGeometry->Invalidate( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?Invalidate@CIndexedGeometry@@QAEXXZ	; CIndexedGeometry::Invalidate
	npad	1
$LN5@SetWindStr:

; 1922 : 
; 1923 :             if (GetFrondWindMethod( ) == WIND_CPU &&

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFrondWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ ; CSpeedTreeRT::GetFrondWindMethod
	mov	DWORD PTR tv158[ebp], eax
	cmp	DWORD PTR tv158[ebp], 1
	jne	SHORT $LN6@SetWindStr
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN6@SetWindStr

; 1924 :                 m_pFrondGeometry)
; 1925 :                 m_pFrondGeometry->Invalidate( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	?Invalidate@CIndexedGeometry@@QAEXXZ	; CIndexedGeometry::Invalidate
	npad	1
$LN6@SetWindStr:

; 1926 : 
; 1927 :             if (GetLeafWindMethod( ) == WIND_CPU ||

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLeafWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ ; CSpeedTreeRT::GetLeafWindMethod
	mov	DWORD PTR tv159[ebp], eax
	cmp	DWORD PTR tv159[ebp], 1
	je	SHORT $LN8@SetWindStr
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetLeafRockingState@CWindEngine@@QBE_NXZ ; CWindEngine::GetLeafRockingState
	mov	BYTE PTR tv160[ebp], al
	movzx	ecx, BYTE PTR tv160[ebp]
	test	ecx, ecx
	je	SHORT $LN7@SetWindStr
$LN8@SetWindStr:

; 1928 :                 m_pWindEngine->GetLeafRockingState( ))
; 1929 :                 m_pLeafGeometry->Invalidate( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?Invalidate@CLeafGeometry@@QAEXXZ	; CLeafGeometry::Invalidate
	npad	1
$LN7@SetWindStr:

; 1930 :         }

	jmp	SHORT $LN4@SetWindStr
$LN3@SetWindStr:

; 1931 :         else
; 1932 :             SetError("SetWindStrength() expects new wind strength >= 0.0");

	push	OFFSET ??_C@_0DD@IEKNEGPD@SetWindStrength?$CI?$CJ?5expects?5new?5w@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@SetWindStr:

; 1933 :     }

	jmp	$LN10@SetWindStr
__catch$?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z$0:

; 1934 : 
; 1935 :     SpeedTreeCatch("CSpeedTreeRT::SetWindStrength")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BO@GJONFFJM@CSpeedTreeRT?3?3SetWindStrength@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv161[ebp], eax
	mov	edx, DWORD PTR tv161[ebp]
	mov	DWORD PTR tv152[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv152[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN16@SetWindStr
	ret	0
__catch$?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z$1:

; 1936 :     SpeedTreeCatchAll("CSpeedTreeRT::SetWindStrength");

	push	OFFSET ??_C@_0BO@GJONFFJM@CSpeedTreeRT?3?3SetWindStrength@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv162[ebp], eax
	mov	ecx, DWORD PTR tv162[ebp]
	mov	DWORD PTR tv155[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv155[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN18@SetWindStr
	ret	0
$LN10@SetWindStr:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN17@SetWindStr
$LN18@SetWindStr:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN15@SetWindStr
$LN17@SetWindStr:
	jmp	SHORT $LN15@SetWindStr
$LN16@SetWindStr:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN15@SetWindStr:

; 1937 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@SetWindStr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	3
$LN22@SetWindStr:
	DD	1
	DD	$LN21@SetWindStr
$LN21@SetWindStr:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN19@SetWindStr
$LN19@SetWindStr:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetWindStrengthAndLeafAngles@CSpeedTreeRT@@QAEXMPBM0I@Z ENDP ; CSpeedTreeRT::SetWindStrengthAndLeafAngles
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z
_TEXT	SEGMENT
tv163 = -328						; size = 4
tv160 = -328						; size = 4
tv173 = -324						; size = 4
tv172 = -324						; size = 4
tv170 = -324						; size = 4
tv169 = -324						; size = 4
tv168 = -324						; size = 4
tv167 = -324						; size = 4
tv166 = -324						; size = 4
tv165 = -324						; size = 4
tv171 = -321						; size = 1
$T2 = -316						; size = 28
$T3 = -280						; size = 28
_cException$4 = -52					; size = 4
_fNewFrequencyTimeShift$ = -40				; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_fNewStrength$ = 8					; size = 4
_fOldStrength$ = 12					; size = 4
_fFrequencyTimeOffset$ = 16				; size = 4
?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z PROC		; CSpeedTreeRT::SetWindStrength, COMDAT
; _this$ = ecx

; 1869 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 312				; 00000138H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-136]
	mov	ecx, 30					; 0000001eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1870 :     float fNewFrequencyTimeShift = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _fNewFrequencyTimeShift$[ebp], xmm0

; 1871 : 
; 1872 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1873 :     {
; 1874 :         if (fNewStrength >= 0.0f)

	movss	xmm0, DWORD PTR _fNewStrength$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	$LN3@SetWindStr

; 1875 :         {
; 1876 :             if (fOldStrength == -1.0f)

	movss	xmm0, DWORD PTR _fOldStrength$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@SetWindStr

; 1877 :                 fOldStrength = m_pWindEngine->GetWindStrength( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetWindStrength@CWindEngine@@QBEMXZ	; CWindEngine::GetWindStrength
	fstp	DWORD PTR tv165[ebp]
	movss	xmm0, DWORD PTR tv165[ebp]
	movss	DWORD PTR _fOldStrength$[ebp], xmm0
$LN5@SetWindStr:

; 1878 :             if (fFrequencyTimeOffset == -1.0f)

	movss	xmm0, DWORD PTR _fFrequencyTimeOffset$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@SetWindStr

; 1879 :                 fFrequencyTimeOffset = m_pWindEngine->GetFrequencyTimeShift( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetFrequencyTimeShift@CWindEngine@@QBEMXZ ; CWindEngine::GetFrequencyTimeShift
	fstp	DWORD PTR tv166[ebp]
	movss	xmm0, DWORD PTR tv166[ebp]
	movss	DWORD PTR _fFrequencyTimeOffset$[ebp], xmm0
$LN6@SetWindStr:

; 1880 : 
; 1881 :             fNewFrequencyTimeShift = m_pWindEngine->SetWindStrength(fNewStrength, fOldStrength, fFrequencyTimeOffset);

	push	ecx
	movss	xmm0, DWORD PTR _fFrequencyTimeOffset$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fOldStrength$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fNewStrength$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?SetWindStrength@CWindEngine@@QAEMMMM@Z	; CWindEngine::SetWindStrength
	fstp	DWORD PTR tv167[ebp]
	movss	xmm0, DWORD PTR tv167[ebp]
	movss	DWORD PTR _fNewFrequencyTimeShift$[ebp], xmm0

; 1882 : 
; 1883 :             // invalidate geometry if CPU-based wind
; 1884 :             if (GetBranchWindMethod( ) == WIND_CPU &&

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ ; CSpeedTreeRT::GetBranchWindMethod
	mov	DWORD PTR tv168[ebp], eax
	cmp	DWORD PTR tv168[ebp], 1
	jne	SHORT $LN7@SetWindStr
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN7@SetWindStr

; 1885 :                 m_pBranchGeometry)
; 1886 :                 m_pBranchGeometry->Invalidate( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?Invalidate@CIndexedGeometry@@QAEXXZ	; CIndexedGeometry::Invalidate
	npad	1
$LN7@SetWindStr:

; 1887 : 
; 1888 :             if (GetFrondWindMethod( ) == WIND_CPU &&

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFrondWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ ; CSpeedTreeRT::GetFrondWindMethod
	mov	DWORD PTR tv169[ebp], eax
	cmp	DWORD PTR tv169[ebp], 1
	jne	SHORT $LN8@SetWindStr
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN8@SetWindStr

; 1889 :                 m_pFrondGeometry)
; 1890 :                 m_pFrondGeometry->Invalidate( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	?Invalidate@CIndexedGeometry@@QAEXXZ	; CIndexedGeometry::Invalidate
	npad	1
$LN8@SetWindStr:

; 1891 : 
; 1892 :             if (GetLeafWindMethod( ) == WIND_CPU ||

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLeafWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ ; CSpeedTreeRT::GetLeafWindMethod
	mov	DWORD PTR tv170[ebp], eax
	cmp	DWORD PTR tv170[ebp], 1
	je	SHORT $LN10@SetWindStr
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetLeafRockingState@CWindEngine@@QBE_NXZ ; CWindEngine::GetLeafRockingState
	mov	BYTE PTR tv171[ebp], al
	movzx	ecx, BYTE PTR tv171[ebp]
	test	ecx, ecx
	je	SHORT $LN9@SetWindStr
$LN10@SetWindStr:

; 1893 :                 m_pWindEngine->GetLeafRockingState( ))
; 1894 :                 m_pLeafGeometry->Invalidate( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?Invalidate@CLeafGeometry@@QAEXXZ	; CLeafGeometry::Invalidate
	npad	1
$LN9@SetWindStr:

; 1895 :         }

	jmp	SHORT $LN4@SetWindStr
$LN3@SetWindStr:

; 1896 :         else
; 1897 :             SetError("SetWindStrength() expects new wind strength >= 0.0");

	push	OFFSET ??_C@_0DD@IEKNEGPD@SetWindStrength?$CI?$CJ?5expects?5new?5w@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@SetWindStr:

; 1898 :     }

	jmp	$LN12@SetWindStr
__catch$?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z$0:

; 1899 : 
; 1900 :     SpeedTreeCatch("CSpeedTreeRT::SetWindStrength")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BO@GJONFFJM@CSpeedTreeRT?3?3SetWindStrength@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv172[ebp], eax
	mov	edx, DWORD PTR tv172[ebp]
	mov	DWORD PTR tv160[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv160[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN18@SetWindStr
	ret	0
__catch$?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z$1:

; 1901 :     SpeedTreeCatchAll("CSpeedTreeRT::SetWindStrength");

	push	OFFSET ??_C@_0BO@GJONFFJM@CSpeedTreeRT?3?3SetWindStrength@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR tv173[ebp]
	mov	DWORD PTR tv163[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv163[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN20@SetWindStr
	ret	0
$LN12@SetWindStr:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN19@SetWindStr
$LN20@SetWindStr:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN17@SetWindStr
$LN19@SetWindStr:
	jmp	SHORT $LN17@SetWindStr
$LN18@SetWindStr:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN17@SetWindStr:

; 1902 : 
; 1903 :     return fNewFrequencyTimeShift;

	fld	DWORD PTR _fNewFrequencyTimeShift$[ebp]

; 1904 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@SetWindStr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 328				; 00000148H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN24@SetWindStr:
	DD	1
	DD	$LN23@SetWindStr
$LN23@SetWindStr:
	DD	-52					; ffffffccH
	DD	4
	DD	$LN21@SetWindStr
$LN21@SetWindStr:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-332]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z ENDP		; CSpeedTreeRT::SetWindStrength
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetWindStrength@CSpeedTreeRT@@QBEMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetWindStrength@CSpeedTreeRT@@QBEMXZ PROC		; CSpeedTreeRT::GetWindStrength, COMDAT
; _this$ = ecx

; 1860 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1861 :     return m_pWindEngine->GetWindStrength( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetWindStrength@CWindEngine@@QBEMXZ	; CWindEngine::GetWindStrength

; 1862 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWindStrength@CSpeedTreeRT@@QBEMXZ ENDP		; CSpeedTreeRT::GetWindStrength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z
_TEXT	SEGMENT
tv148 = -316						; size = 4
tv145 = -316						; size = 4
tv152 = -312						; size = 4
tv151 = -312						; size = 4
tv150 = -312						; size = 4
tv83 = -309						; size = 1
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_eMethod$ = 8						; size = 4
?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z PROC ; CSpeedTreeRT::SetFrondWindMethod, COMDAT
; _this$ = ecx

; 1824 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1825 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1826 :     {
; 1827 :         // Because the wind engine is optimized to only calculate the wind
; 1828 :         // effect for the highest visible LOD, the highest overall LOD may
; 1829 :         // not be calcuated.  When the wind is turned off, some of the tree
; 1830 :         // will be positioned according to the last wind calculation and
; 1831 :         // some of it may not be.  We make a call here to force it to
; 1832 :         // calculate the entire tree's geometry for the last wind value.
; 1833 : 
; 1834 :         if (!m_bTreeComputed)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+69]
	test	ecx, ecx
	jne	$LN3@SetFrondWi

; 1835 :         {
; 1836 :             if (eMethod == WIND_NONE &&

	cmp	DWORD PTR _eMethod$[ebp], 2
	jne	SHORT $LN5@SetFrondWi
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetFrondWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ ; CWindEngine::GetFrondWindMethod
	mov	DWORD PTR tv150[ebp], eax
	cmp	DWORD PTR tv150[ebp], 1
	jne	SHORT $LN5@SetFrondWi

; 1837 :                 m_pWindEngine->GetFrondWindMethod( ) == WIND_CPU)
; 1838 :             {
; 1839 :                 m_pFrondGeometry->Invalidate( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	?Invalidate@CIndexedGeometry@@QAEXXZ	; CIndexedGeometry::Invalidate
	npad	1

; 1840 :                 (void) m_pFrondGeometry->ComputeWindEffect(0);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	?ComputeWindEffect@CIndexedGeometry@@QAE_NG@Z ; CIndexedGeometry::ComputeWindEffect
	npad	1
$LN5@SetFrondWi:

; 1841 :             }
; 1842 : 
; 1843 :             m_pWindEngine->SetFrondWindMethod(eMethod);

	mov	eax, DWORD PTR _eMethod$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+16]
	call	?SetFrondWindMethod@CWindEngine@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z ; CWindEngine::SetFrondWindMethod
	npad	1

; 1844 :             m_pFrondGeometry->EnableVertexWeighting(eMethod != WIND_NONE);

	cmp	DWORD PTR _eMethod$[ebp], 2
	je	SHORT $LN7@SetFrondWi
	mov	BYTE PTR tv83[ebp], 1
	jmp	SHORT $LN8@SetFrondWi
$LN7@SetFrondWi:
	mov	BYTE PTR tv83[ebp], 0
$LN8@SetFrondWi:
	movzx	eax, BYTE PTR tv83[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+92]
	call	?EnableVertexWeighting@CIndexedGeometry@@QAEX_N@Z ; CIndexedGeometry::EnableVertexWeighting
	npad	1

; 1845 :             m_pFrondGeometry->SetWindMethod(eMethod);

	mov	eax, DWORD PTR _eMethod$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+92]
	call	?SetWindMethod@CIndexedGeometry@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z ; CIndexedGeometry::SetWindMethod
	npad	1

; 1846 :         }

	jmp	SHORT $LN4@SetFrondWi
$LN3@SetFrondWi:

; 1847 :         else
; 1848 :             SetError("SetFrondWindMethod() has no effect after Compute() has been called");

	push	OFFSET ??_C@_0ED@HKHBLIMN@SetFrondWindMethod?$CI?$CJ?5has?5no?5eff@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@SetFrondWi:

; 1849 :     }

	jmp	$LN9@SetFrondWi
__catch$?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$0:

; 1850 : 
; 1851 :     SpeedTreeCatch("CSpeedTreeRT::SetFrondWindMethod")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CB@JBDMJJKN@CSpeedTreeRT?3?3SetFrondWindMetho@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv151[ebp], eax
	mov	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv145[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN15@SetFrondWi
	ret	0
__catch$?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$1:

; 1852 :     SpeedTreeCatchAll("CSpeedTreeRT::SetFrondWindMethod");

	push	OFFSET ??_C@_0CB@JBDMJJKN@CSpeedTreeRT?3?3SetFrondWindMetho@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv152[ebp], eax
	mov	ecx, DWORD PTR tv152[ebp]
	mov	DWORD PTR tv148[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv148[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN17@SetFrondWi
	ret	0
$LN9@SetFrondWi:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN16@SetFrondWi
$LN17@SetFrondWi:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN14@SetFrondWi
$LN16@SetFrondWi:
	jmp	SHORT $LN14@SetFrondWi
$LN15@SetFrondWi:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN14@SetFrondWi:

; 1853 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN21@SetFrondWi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN21@SetFrondWi:
	DD	1
	DD	$LN20@SetFrondWi
$LN20@SetFrondWi:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN18@SetFrondWi
$LN18@SetFrondWi:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z ENDP ; CSpeedTreeRT::SetFrondWindMethod
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetFrondWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetFrondWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ PROC ; CSpeedTreeRT::GetFrondWindMethod, COMDAT
; _this$ = ecx

; 1815 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1816 :     return m_pWindEngine->GetFrondWindMethod( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetFrondWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ ; CWindEngine::GetFrondWindMethod

; 1817 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFrondWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ ENDP ; CSpeedTreeRT::GetFrondWindMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z
_TEXT	SEGMENT
tv148 = -316						; size = 4
tv145 = -316						; size = 4
tv152 = -312						; size = 4
tv151 = -312						; size = 4
tv150 = -312						; size = 4
tv83 = -309						; size = 1
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_eMethod$ = 8						; size = 4
?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z PROC ; CSpeedTreeRT::SetBranchWindMethod, COMDAT
; _this$ = ecx

; 1779 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1780 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1781 :     {
; 1782 :         // Because the wind engine is optimized to only calculate the wind
; 1783 :         // effect for the highest visible LOD, the highest overall LOD may
; 1784 :         // not be calcuated.  When the wind is turned off, some of the tree
; 1785 :         // will be positioned according to the last wind calculation and
; 1786 :         // some of it may not be.  We make a call here to force it to
; 1787 :         // calculate the entire tree's geometry for the last wind value.
; 1788 : 
; 1789 :         if (!m_bTreeComputed)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+69]
	test	ecx, ecx
	jne	$LN3@SetBranchW

; 1790 :         {
; 1791 :             if (eMethod == WIND_NONE &&

	cmp	DWORD PTR _eMethod$[ebp], 2
	jne	SHORT $LN5@SetBranchW
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetBranchWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ ; CWindEngine::GetBranchWindMethod
	mov	DWORD PTR tv150[ebp], eax
	cmp	DWORD PTR tv150[ebp], 1
	jne	SHORT $LN5@SetBranchW

; 1792 :                 m_pWindEngine->GetBranchWindMethod( ) == WIND_CPU)
; 1793 :             {
; 1794 :                 m_pBranchGeometry->Invalidate( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?Invalidate@CIndexedGeometry@@QAEXXZ	; CIndexedGeometry::Invalidate
	npad	1

; 1795 :                 (void) m_pBranchGeometry->ComputeWindEffect(0);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?ComputeWindEffect@CIndexedGeometry@@QAE_NG@Z ; CIndexedGeometry::ComputeWindEffect
	npad	1
$LN5@SetBranchW:

; 1796 :             }
; 1797 : 
; 1798 :             m_pWindEngine->SetBranchWindMethod(eMethod);

	mov	eax, DWORD PTR _eMethod$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+16]
	call	?SetBranchWindMethod@CWindEngine@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z ; CWindEngine::SetBranchWindMethod
	npad	1

; 1799 :             m_pBranchGeometry->EnableVertexWeighting(eMethod != WIND_NONE);

	cmp	DWORD PTR _eMethod$[ebp], 2
	je	SHORT $LN7@SetBranchW
	mov	BYTE PTR tv83[ebp], 1
	jmp	SHORT $LN8@SetBranchW
$LN7@SetBranchW:
	mov	BYTE PTR tv83[ebp], 0
$LN8@SetBranchW:
	movzx	eax, BYTE PTR tv83[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?EnableVertexWeighting@CIndexedGeometry@@QAEX_N@Z ; CIndexedGeometry::EnableVertexWeighting
	npad	1

; 1800 :             m_pBranchGeometry->SetWindMethod(eMethod);

	mov	eax, DWORD PTR _eMethod$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?SetWindMethod@CIndexedGeometry@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z ; CIndexedGeometry::SetWindMethod
	npad	1

; 1801 :         }

	jmp	SHORT $LN4@SetBranchW
$LN3@SetBranchW:

; 1802 :         else
; 1803 :             SetError("SetBranchWindMethod() has no effect after Compute() has been called");

	push	OFFSET ??_C@_0EE@IEBPHJNM@SetBranchWindMethod?$CI?$CJ?5has?5no?5ef@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@SetBranchW:

; 1804 :     }

	jmp	$LN9@SetBranchW
__catch$?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$0:

; 1805 : 
; 1806 :     SpeedTreeCatch("CSpeedTreeRT::SetBranchWindMethod")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CC@MHEPFOGG@CSpeedTreeRT?3?3SetBranchWindMeth@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv151[ebp], eax
	mov	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv145[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN15@SetBranchW
	ret	0
__catch$?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$1:

; 1807 :     SpeedTreeCatchAll("CSpeedTreeRT::SetBranchWindMethod");

	push	OFFSET ??_C@_0CC@MHEPFOGG@CSpeedTreeRT?3?3SetBranchWindMeth@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv152[ebp], eax
	mov	ecx, DWORD PTR tv152[ebp]
	mov	DWORD PTR tv148[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv148[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN17@SetBranchW
	ret	0
$LN9@SetBranchW:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN16@SetBranchW
$LN17@SetBranchW:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN14@SetBranchW
$LN16@SetBranchW:
	jmp	SHORT $LN14@SetBranchW
$LN15@SetBranchW:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN14@SetBranchW:

; 1808 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN21@SetBranchW
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN21@SetBranchW:
	DD	1
	DD	$LN20@SetBranchW
$LN20@SetBranchW:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN18@SetBranchW
$LN18@SetBranchW:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z ENDP ; CSpeedTreeRT::SetBranchWindMethod
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetBranchWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetBranchWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ PROC ; CSpeedTreeRT::GetBranchWindMethod, COMDAT
; _this$ = ecx

; 1770 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1771 :     return m_pWindEngine->GetBranchWindMethod( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetBranchWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ ; CWindEngine::GetBranchWindMethod

; 1772 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBranchWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ ENDP ; CSpeedTreeRT::GetBranchWindMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z
_TEXT	SEGMENT
tv135 = -316						; size = 4
tv132 = -316						; size = 4
tv138 = -312						; size = 4
tv137 = -312						; size = 4
tv73 = -309						; size = 1
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_eMethod$ = 8						; size = 4
?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z PROC ; CSpeedTreeRT::SetLeafWindMethod, COMDAT
; _this$ = ecx

; 1749 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1750 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1751 :     {
; 1752 :         if (!m_bTreeComputed)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+69]
	test	ecx, ecx
	jne	SHORT $LN3@SetLeafWin

; 1753 :         {
; 1754 :             m_pWindEngine->SetLeafWindMethod(eMethod);

	mov	eax, DWORD PTR _eMethod$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+16]
	call	?SetLeafWindMethod@CWindEngine@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z ; CWindEngine::SetLeafWindMethod
	npad	1

; 1755 :             m_pLeafGeometry->EnableVertexWeighting(eMethod != WIND_NONE);

	cmp	DWORD PTR _eMethod$[ebp], 2
	je	SHORT $LN6@SetLeafWin
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $LN7@SetLeafWin
$LN6@SetLeafWin:
	mov	BYTE PTR tv73[ebp], 0
$LN7@SetLeafWin:
	movzx	eax, BYTE PTR tv73[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?EnableVertexWeighting@CLeafGeometry@@QAEX_N@Z ; CLeafGeometry::EnableVertexWeighting
	npad	1

; 1756 :         }

	jmp	SHORT $LN4@SetLeafWin
$LN3@SetLeafWin:

; 1757 :         else
; 1758 :             SetError("SetLeafWindMethod() has no effect after Compute() has been called");

	push	OFFSET ??_C@_0EC@JAGFALME@SetLeafWindMethod?$CI?$CJ?5has?5no?5effe@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@SetLeafWin:

; 1759 :     }

	jmp	$LN8@SetLeafWin
__catch$?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$0:

; 1760 : 
; 1761 :     SpeedTreeCatch("CSpeedTreeRT::SetLeafWindMethod")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CA@KIINICCD@CSpeedTreeRT?3?3SetLeafWindMethod@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv137[ebp], eax
	mov	edx, DWORD PTR tv137[ebp]
	mov	DWORD PTR tv132[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv132[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN14@SetLeafWin
	ret	0
__catch$?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$1:

; 1762 :     SpeedTreeCatchAll("CSpeedTreeRT::SetLeafWindMethod");

	push	OFFSET ??_C@_0CA@KIINICCD@CSpeedTreeRT?3?3SetLeafWindMethod@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv138[ebp], eax
	mov	ecx, DWORD PTR tv138[ebp]
	mov	DWORD PTR tv135[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv135[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN16@SetLeafWin
	ret	0
$LN8@SetLeafWin:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN15@SetLeafWin
$LN16@SetLeafWin:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN13@SetLeafWin
$LN15@SetLeafWin:
	jmp	SHORT $LN13@SetLeafWin
$LN14@SetLeafWin:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN13@SetLeafWin:

; 1763 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@SetLeafWin
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN20@SetLeafWin:
	DD	1
	DD	$LN19@SetLeafWin
$LN19@SetLeafWin:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN17@SetLeafWin
$LN17@SetLeafWin:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z ENDP ; CSpeedTreeRT::SetLeafWindMethod
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetLeafWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetLeafWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ PROC ; CSpeedTreeRT::GetLeafWindMethod, COMDAT
; _this$ = ecx

; 1740 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1741 :     return m_pWindEngine->GetLeafWindMethod( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetLeafWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ ; CWindEngine::GetLeafWindMethod

; 1742 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLeafWindMethod@CSpeedTreeRT@@QBE?AW4EWindMethod@1@XZ ENDP ; CSpeedTreeRT::GetLeafWindMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z
_TEXT	SEGMENT
tv131 = -316						; size = 4
tv128 = -316						; size = 4
tv134 = -312						; size = 4
tv133 = -312						; size = 4
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_nRockingGroups$ = 8					; size = 4
?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z PROC	; CSpeedTreeRT::SetNumLeafRockingGroups, COMDAT
; _this$ = ecx

; 1717 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1718 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1719 :     {
; 1720 :         if (!m_bTreeComputed)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+69]
	test	ecx, ecx
	jne	SHORT $LN3@SetNumLeaf

; 1721 :         {
; 1722 :             if (nRockingGroups == 0)

	cmp	DWORD PTR _nRockingGroups$[ebp], 0
	jne	SHORT $LN5@SetNumLeaf

; 1723 :                 nRockingGroups = 1;

	mov	DWORD PTR _nRockingGroups$[ebp], 1
$LN5@SetNumLeaf:

; 1724 : 
; 1725 :             m_pEngine->SetNumLeafRockingGroups(nRockingGroups);

	mov	eax, DWORD PTR _nRockingGroups$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?SetNumLeafRockingGroups@CTreeEngine@@QAEXH@Z ; CTreeEngine::SetNumLeafRockingGroups
	npad	1

; 1726 :         }

	jmp	SHORT $LN4@SetNumLeaf
$LN3@SetNumLeaf:

; 1727 :         else
; 1728 :             SetError("SetNumLeafRockingGroups() has no effect after Compute() has been called");

	push	OFFSET ??_C@_0EI@IEFOEBHE@SetNumLeafRockingGroups?$CI?$CJ?5has?5n@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@SetNumLeaf:

; 1729 :     }

	jmp	$LN7@SetNumLeaf
__catch$?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z$0:

; 1730 : 
; 1731 :     SpeedTreeCatch("CSpeedTreeRT::SetLeafRockingState")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CC@KEPCIKJC@CSpeedTreeRT?3?3SetLeafRockingSta@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv133[ebp], eax
	mov	edx, DWORD PTR tv133[ebp]
	mov	DWORD PTR tv128[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv128[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN13@SetNumLeaf
	ret	0
__catch$?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z$1:

; 1732 :     SpeedTreeCatchAll("CSpeedTreeRT::SetLeafRockingState");

	push	OFFSET ??_C@_0CC@KEPCIKJC@CSpeedTreeRT?3?3SetLeafRockingSta@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv134[ebp], eax
	mov	ecx, DWORD PTR tv134[ebp]
	mov	DWORD PTR tv131[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv131[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN15@SetNumLeaf
	ret	0
$LN7@SetNumLeaf:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN14@SetNumLeaf
$LN15@SetNumLeaf:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN12@SetNumLeaf
$LN14@SetNumLeaf:
	jmp	SHORT $LN12@SetNumLeaf
$LN13@SetNumLeaf:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN12@SetNumLeaf:

; 1733 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@SetNumLeaf
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN19@SetNumLeaf:
	DD	1
	DD	$LN18@SetNumLeaf
$LN18@SetNumLeaf:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN16@SetNumLeaf
$LN16@SetNumLeaf:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z ENDP	; CSpeedTreeRT::SetNumLeafRockingGroups
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetLeafRockingState@CSpeedTreeRT@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_bFlag$ = 8						; size = 1
?SetLeafRockingState@CSpeedTreeRT@@QAEX_N@Z PROC	; CSpeedTreeRT::SetLeafRockingState, COMDAT
; _this$ = ecx

; 1708 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1709 :     m_pWindEngine->SetLeafRockingState(bFlag);

	movzx	eax, BYTE PTR _bFlag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+16]
	call	?SetLeafRockingState@CWindEngine@@QAEX_N@Z ; CWindEngine::SetLeafRockingState
	npad	1

; 1710 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLeafRockingState@CSpeedTreeRT@@QAEX_N@Z ENDP	; CSpeedTreeRT::SetLeafRockingState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetLeafRockingState@CSpeedTreeRT@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetLeafRockingState@CSpeedTreeRT@@QBE_NXZ PROC		; CSpeedTreeRT::GetLeafRockingState, COMDAT
; _this$ = ecx

; 1699 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1700 :     return m_pWindEngine->GetLeafRockingState( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetLeafRockingState@CWindEngine@@QBE_NXZ ; CWindEngine::GetLeafRockingState

; 1701 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLeafRockingState@CSpeedTreeRT@@QBE_NXZ ENDP		; CSpeedTreeRT::GetLeafRockingState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?ResetLeafWindState@CSpeedTreeRT@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?ResetLeafWindState@CSpeedTreeRT@@QAEXXZ PROC		; CSpeedTreeRT::ResetLeafWindState, COMDAT
; _this$ = ecx

; 1690 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1691 :     m_pWindEngine->ResetLeafWindState( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?ResetLeafWindState@CWindEngine@@QAEXXZ	; CWindEngine::ResetLeafWindState
	npad	1

; 1692 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetLeafWindState@CSpeedTreeRT@@QAEXXZ ENDP		; CSpeedTreeRT::ResetLeafWindState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z
_TEXT	SEGMENT
tv258 = -456						; size = 4
tv255 = -456						; size = 4
tv269 = -454						; size = 2
tv264 = -454						; size = 2
tv272 = -452						; size = 4
tv271 = -452						; size = 4
tv270 = -452						; size = 4
tv268 = -452						; size = 4
tv266 = -452						; size = 4
tv265 = -452						; size = 4
tv263 = -452						; size = 4
tv261 = -452						; size = 4
tv260 = -452						; size = 4
tv253 = -452						; size = 4
tv250 = -452						; size = 4
tv174 = -452						; size = 4
tv81 = -452						; size = 4
tv267 = -450						; size = 2
tv262 = -450						; size = 2
$T2 = -444						; size = 28
$T3 = -408						; size = 28
$T4 = -372						; size = 12
$T5 = -349						; size = 1
$T6 = -340						; size = 12
$T7 = -317						; size = 1
_cException$8 = -116					; size = 4
_fInstanceLodLevel$9 = -104				; size = 4
_i$10 = -92						; size = 12
_fInstanceLodLevel$11 = -72				; size = 4
_i$12 = -60						; size = 12
_fHighestLod$13 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_bBranches$ = 8						; size = 1
_bLeaves$ = 12						; size = 1
_bFronds$ = 16						; size = 1
?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z PROC	; CSpeedTreeRT::ComputeWindEffects, COMDAT
; _this$ = ecx

; 1615 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 440				; 000001b8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1616 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1617 :     {
; 1618 :         float fHighestLod = -1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _fHighestLod$13[ebp], xmm0

; 1619 : 
; 1620 :         // branches
; 1621 :         if (bBranches &&

	movzx	eax, BYTE PTR _bBranches$[ebp]
	test	eax, eax
	je	$LN11@ComputeWin
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetBranchWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ ; CWindEngine::GetBranchWindMethod
	mov	DWORD PTR tv260[ebp], eax
	cmp	DWORD PTR tv260[ebp], 1
	jne	$LN11@ComputeWin

; 1622 :             m_pWindEngine->GetBranchWindMethod( ) == CSpeedTreeRT::WIND_CPU)
; 1623 :         {
; 1624 :             if (!m_pInstanceData && *m_pInstanceRefCount > 1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	$LN10@ComputeWin
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	cmp	DWORD PTR [ecx], 1
	jbe	$LN10@ComputeWin

; 1625 :             {
; 1626 :                 // If this tree has instances of itself, then compute the highest LOD
; 1627 :                 // among itself and its instances.  There's no need for more wind
; 1628 :                 // computations than the highest LOD because all of the LODs share
; 1629 :                 // the same vertexes.
; 1630 :                 fHighestLod = m_pEngine->GetLod( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetLod@CTreeEngine@@QBEMXZ		; CTreeEngine::GetLod
	fstp	DWORD PTR tv261[ebp]
	movss	xmm0, DWORD PTR tv261[ebp]
	movss	DWORD PTR _fHighestLod$13[ebp], xmm0

; 1631 :                 for (vector<CSpeedTreeRT*>::iterator i = m_pInstanceList->m_vInstances.begin( );

	lea	eax, DWORD PTR _i$12[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?begin@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::begin
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	jmp	SHORT $LN4@ComputeWin
$LN2@ComputeWin:

; 1632 :                      i != m_pInstanceList->m_vInstances.end( ); ++i)

	lea	ecx, DWORD PTR _i$12[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator++
	npad	1
$LN4@ComputeWin:
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?end@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::end
	mov	DWORD PTR tv250[ebp], eax
	mov	edx, DWORD PTR tv250[ebp]
	push	edx
	lea	ecx, DWORD PTR _i$12[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator!=
	mov	BYTE PTR $T7[ebp], al
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T7[ebp]
	test	eax, eax
	je	SHORT $LN3@ComputeWin

; 1633 :                 {
; 1634 :                     float fInstanceLodLevel = (*i)->GetLodLevel( );

	lea	ecx, DWORD PTR _i$12[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEAAPAVCSpeedTreeRT@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator*
	mov	ecx, DWORD PTR [eax]
	call	?GetLodLevel@CSpeedTreeRT@@QBEMXZ	; CSpeedTreeRT::GetLodLevel
	fstp	DWORD PTR tv81[ebp]
	movss	xmm0, DWORD PTR tv81[ebp]
	movss	DWORD PTR _fInstanceLodLevel$11[ebp], xmm0

; 1635 :                     if (fInstanceLodLevel > fHighestLod)

	movss	xmm0, DWORD PTR _fInstanceLodLevel$11[ebp]
	comiss	xmm0, DWORD PTR _fHighestLod$13[ebp]
	jbe	SHORT $LN12@ComputeWin

; 1636 :                         fHighestLod = fInstanceLodLevel;

	movss	xmm0, DWORD PTR _fInstanceLodLevel$11[ebp]
	movss	DWORD PTR _fHighestLod$13[ebp], xmm0
$LN12@ComputeWin:
	jmp	$LN2@ComputeWin
$LN3@ComputeWin:

; 1637 :                 }

	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR _i$12[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	npad	1

; 1638 : 
; 1639 :                 (void) m_pBranchGeometry->ComputeWindEffect(GetDiscreteBranchLodLevel(fHighestLod));

	push	ecx
	movss	xmm0, DWORD PTR _fHighestLod$13[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiscreteBranchLodLevel@CSpeedTreeRT@@QBEFM@Z ; CSpeedTreeRT::GetDiscreteBranchLodLevel
	mov	WORD PTR tv262[ebp], ax
	movzx	eax, WORD PTR tv262[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?ComputeWindEffect@CIndexedGeometry@@QAE_NG@Z ; CIndexedGeometry::ComputeWindEffect
	npad	1

; 1640 :             }

	jmp	SHORT $LN11@ComputeWin
$LN10@ComputeWin:

; 1641 :             else
; 1642 :                 (void) m_pBranchGeometry->ComputeWindEffect(GetDiscreteBranchLodLevel(GetLodLevel( )));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLodLevel@CSpeedTreeRT@@QBEMXZ	; CSpeedTreeRT::GetLodLevel
	fstp	DWORD PTR tv263[ebp]
	push	ecx
	movss	xmm0, DWORD PTR tv263[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiscreteBranchLodLevel@CSpeedTreeRT@@QBEFM@Z ; CSpeedTreeRT::GetDiscreteBranchLodLevel
	mov	WORD PTR tv264[ebp], ax
	movzx	eax, WORD PTR tv264[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?ComputeWindEffect@CIndexedGeometry@@QAE_NG@Z ; CIndexedGeometry::ComputeWindEffect
	npad	1
$LN11@ComputeWin:

; 1643 :         }
; 1644 : 
; 1645 :         // fronds
; 1646 :         if (bFronds &&

	movzx	eax, BYTE PTR _bFronds$[ebp]
	test	eax, eax
	je	$LN15@ComputeWin
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetFrondWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ ; CWindEngine::GetFrondWindMethod
	mov	DWORD PTR tv265[ebp], eax
	cmp	DWORD PTR tv265[ebp], 1
	jne	$LN15@ComputeWin

; 1647 :             m_pWindEngine->GetFrondWindMethod( ) == CSpeedTreeRT::WIND_CPU)
; 1648 :         {
; 1649 :             if (!m_pInstanceData && *m_pInstanceRefCount > 1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	$LN14@ComputeWin
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	cmp	DWORD PTR [ecx], 1
	jbe	$LN14@ComputeWin

; 1650 :             {
; 1651 :                 // If this tree has instances of itself, then compute the highest LOD
; 1652 :                 // among itself and its instances.  There's no need for more wind
; 1653 :                 // computations than the highest LOD because all of the LODs share
; 1654 :                 // the same vertexes.
; 1655 :                 if (fHighestLod == -1.0f) // we don't need to make this calc if it was

	movss	xmm0, DWORD PTR _fHighestLod$13[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN16@ComputeWin

; 1656 :                 {                         // already done for the branches
; 1657 :                     fHighestLod = m_pEngine->GetLod( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetLod@CTreeEngine@@QBEMXZ		; CTreeEngine::GetLod
	fstp	DWORD PTR tv266[ebp]
	movss	xmm0, DWORD PTR tv266[ebp]
	movss	DWORD PTR _fHighestLod$13[ebp], xmm0

; 1658 :                     for (vector<CSpeedTreeRT*>::iterator i = m_pInstanceList->m_vInstances.begin( );

	lea	eax, DWORD PTR _i$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?begin@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::begin
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	jmp	SHORT $LN7@ComputeWin
$LN5@ComputeWin:

; 1659 :                          i != m_pInstanceList->m_vInstances.end( ); ++i)

	lea	ecx, DWORD PTR _i$10[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator++
	npad	1
$LN7@ComputeWin:
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?end@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::end
	mov	DWORD PTR tv253[ebp], eax
	mov	edx, DWORD PTR tv253[ebp]
	push	edx
	lea	ecx, DWORD PTR _i$10[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator!=
	mov	BYTE PTR $T5[ebp], al
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T5[ebp]
	test	eax, eax
	je	SHORT $LN6@ComputeWin

; 1660 :                     {
; 1661 :                         float fInstanceLodLevel = (*i)->GetLodLevel( );

	lea	ecx, DWORD PTR _i$10[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBEAAPAVCSpeedTreeRT@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator*
	mov	ecx, DWORD PTR [eax]
	call	?GetLodLevel@CSpeedTreeRT@@QBEMXZ	; CSpeedTreeRT::GetLodLevel
	fstp	DWORD PTR tv174[ebp]
	movss	xmm0, DWORD PTR tv174[ebp]
	movss	DWORD PTR _fInstanceLodLevel$9[ebp], xmm0

; 1662 :                         if (fInstanceLodLevel > fHighestLod)

	movss	xmm0, DWORD PTR _fInstanceLodLevel$9[ebp]
	comiss	xmm0, DWORD PTR _fHighestLod$13[ebp]
	jbe	SHORT $LN17@ComputeWin

; 1663 :                             fHighestLod = fInstanceLodLevel;

	movss	xmm0, DWORD PTR _fInstanceLodLevel$9[ebp]
	movss	DWORD PTR _fHighestLod$13[ebp], xmm0
$LN17@ComputeWin:
	jmp	$LN5@ComputeWin
$LN6@ComputeWin:

; 1664 :                     }

	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR _i$10[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	npad	1
$LN16@ComputeWin:

; 1665 :                 }
; 1666 : 
; 1667 :                 (void) m_pFrondGeometry->ComputeWindEffect(GetDiscreteFrondLodLevel(fHighestLod));

	push	ecx
	movss	xmm0, DWORD PTR _fHighestLod$13[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiscreteFrondLodLevel@CSpeedTreeRT@@QBEFM@Z ; CSpeedTreeRT::GetDiscreteFrondLodLevel
	mov	WORD PTR tv267[ebp], ax
	movzx	eax, WORD PTR tv267[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+92]
	call	?ComputeWindEffect@CIndexedGeometry@@QAE_NG@Z ; CIndexedGeometry::ComputeWindEffect
	npad	1

; 1668 :             }

	jmp	SHORT $LN15@ComputeWin
$LN14@ComputeWin:

; 1669 :             else
; 1670 :                 (void) m_pFrondGeometry->ComputeWindEffect(GetDiscreteFrondLodLevel(GetLodLevel( )));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLodLevel@CSpeedTreeRT@@QBEMXZ	; CSpeedTreeRT::GetLodLevel
	fstp	DWORD PTR tv268[ebp]
	push	ecx
	movss	xmm0, DWORD PTR tv268[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiscreteFrondLodLevel@CSpeedTreeRT@@QBEFM@Z ; CSpeedTreeRT::GetDiscreteFrondLodLevel
	mov	WORD PTR tv269[ebp], ax
	movzx	eax, WORD PTR tv269[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+92]
	call	?ComputeWindEffect@CIndexedGeometry@@QAE_NG@Z ; CIndexedGeometry::ComputeWindEffect
	npad	1
$LN15@ComputeWin:

; 1671 :         }
; 1672 :         
; 1673 :         // leaves
; 1674 :         if (bLeaves &&

	movzx	eax, BYTE PTR _bLeaves$[ebp]
	test	eax, eax
	je	SHORT $LN18@ComputeWin
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetLeafWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ ; CWindEngine::GetLeafWindMethod
	mov	DWORD PTR tv270[ebp], eax
	cmp	DWORD PTR tv270[ebp], 1
	jne	SHORT $LN18@ComputeWin

; 1675 :             m_pWindEngine->GetLeafWindMethod( ) == CSpeedTreeRT::WIND_CPU)
; 1676 :         {
; 1677 :             m_pLeafGeometry->Invalidate( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?Invalidate@CLeafGeometry@@QAEXXZ	; CLeafGeometry::Invalidate
	npad	1
$LN18@ComputeWin:

; 1678 :         }
; 1679 :     }

	jmp	$LN20@ComputeWin
__catch$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z$0:

; 1680 : 
; 1681 :     SpeedTreeCatch("CSpeedTreeRT::ComputeWindEffects")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$8[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$8[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CB@JOANHIIK@CSpeedTreeRT?3?3ComputeWindEffect@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv271[ebp], eax
	mov	edx, DWORD PTR tv271[ebp]
	mov	DWORD PTR tv255[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	mov	ecx, DWORD PTR tv255[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN30@ComputeWin
	ret	0
__catch$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z$1:

; 1682 :     SpeedTreeCatchAll("CSpeedTreeRT::ComputeWindEffects");

	push	OFFSET ??_C@_0CB@JOANHIIK@CSpeedTreeRT?3?3ComputeWindEffect@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv272[ebp], eax
	mov	ecx, DWORD PTR tv272[ebp]
	mov	DWORD PTR tv258[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 5
	mov	ecx, DWORD PTR tv258[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN32@ComputeWin
	ret	0
$LN20@ComputeWin:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN31@ComputeWin
$LN32@ComputeWin:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN29@ComputeWin
$LN31@ComputeWin:
	jmp	SHORT $LN29@ComputeWin
$LN30@ComputeWin:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN29@ComputeWin:

; 1683 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN38@ComputeWin
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 456				; 000001c8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN38@ComputeWin:
	DD	3
	DD	$LN37@ComputeWin
$LN37@ComputeWin:
	DD	-60					; ffffffc4H
	DD	12					; 0000000cH
	DD	$LN33@ComputeWin
	DD	-92					; ffffffa4H
	DD	12					; 0000000cH
	DD	$LN34@ComputeWin
	DD	-116					; ffffff8cH
	DD	4
	DD	$LN35@ComputeWin
$LN35@ComputeWin:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN34@ComputeWin:
	DB	105					; 00000069H
	DB	0
$LN33@ComputeWin:
	DB	105					; 00000069H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z$3:
	lea	ecx, DWORD PTR _i$12[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z$5:
	lea	ecx, DWORD PTR _i$10[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z$7:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z$8:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-460]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ComputeWindEffects@CSpeedTreeRT@@QAEX_N00@Z ENDP	; CSpeedTreeRT::ComputeWindEffects
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetTime@CSpeedTreeRT@@SAXM@Z
_TEXT	SEGMENT
tv93 = -304						; size = 4
tv90 = -304						; size = 4
tv128 = -300						; size = 4
tv95 = -300						; size = 4
$T2 = -292						; size = 28
$T3 = -256						; size = 28
_cException$4 = -28					; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_fTime$ = 8						; size = 4
?SetTime@CSpeedTreeRT@@SAXM@Z PROC			; CSpeedTreeRT::SetTime, COMDAT

; 1599 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetTime@CSpeedTreeRT@@SAXM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-112]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1600 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1601 :     {
; 1602 :         CWindEngine::SetTime(fTime);

	push	ecx
	movss	xmm0, DWORD PTR _fTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SetTime@CWindEngine@@SAXM@Z		; CWindEngine::SetTime
	add	esp, 4

; 1603 :         NotifyAllTreesOfEvent(STIE_CLIENT_CHANGED_WIND);

	push	0
	call	?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z ; CSpeedTreeRT::NotifyAllTreesOfEvent
	add	esp, 4

; 1604 :     }

	jmp	$LN4@SetTime
__catch$?SetTime@CSpeedTreeRT@@SAXM@Z$0:

; 1605 : 
; 1606 :     SpeedTreeCatch("CSpeedTreeRT::SetTime")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BG@MNLGBDFC@CSpeedTreeRT?3?3SetTime@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv95[ebp], eax
	mov	edx, DWORD PTR tv95[ebp]
	mov	DWORD PTR tv90[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv90[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN10@SetTime
	ret	0
__catch$?SetTime@CSpeedTreeRT@@SAXM@Z$1:

; 1607 :     SpeedTreeCatchAll("CSpeedTreeRT::SetTime");

	push	OFFSET ??_C@_0BG@MNLGBDFC@CSpeedTreeRT?3?3SetTime@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv128[ebp], eax
	mov	ecx, DWORD PTR tv128[ebp]
	mov	DWORD PTR tv93[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv93[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN12@SetTime
	ret	0
$LN4@SetTime:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN11@SetTime
$LN12@SetTime:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN9@SetTime
$LN11@SetTime:
	jmp	SHORT $LN9@SetTime
$LN10@SetTime:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@SetTime:

; 1608 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@SetTime
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@SetTime:
	DD	1
	DD	$LN15@SetTime
$LN15@SetTime:
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN13@SetTime
$LN13@SetTime:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetTime@CSpeedTreeRT@@SAXM@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetTime@CSpeedTreeRT@@SAXM@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetTime@CSpeedTreeRT@@SAXM@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-308]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetTime@CSpeedTreeRT@@SAXM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetTime@CSpeedTreeRT@@SAXM@Z ENDP			; CSpeedTreeRT::SetTime
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetCamera@CSpeedTreeRT@@SAXPBM0@Z
_TEXT	SEGMENT
tv198 = -428						; size = 4
tv196 = -428						; size = 4
tv191 = -428						; size = 4
tv188 = -428						; size = 4
tv201 = -424						; size = 4
tv200 = -424						; size = 4
tv199 = -424						; size = 4
tv197 = -424						; size = 4
tv195 = -424						; size = 4
tv158 = -424						; size = 4
tv156 = -424						; size = 4
tv194 = -421						; size = 1
tv193 = -421						; size = 1
$T2 = -416						; size = 28
$T3 = -380						; size = 28
_cException$4 = -152					; size = 4
_fPercent$5 = -140					; size = 4
_fPitch$6 = -128					; size = 4
_cAdjustedDirection$7 = -116				; size = 12
_cNewDirection$8 = -96					; size = 12
_cNewPosition$9 = -76					; size = 12
_cOldDirection$10 = -56					; size = 12
_cOldPosition$11 = -36					; size = 12
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_pPosition$ = 8						; size = 4
_pDirection$ = 12					; size = 4
?SetCamera@CSpeedTreeRT@@SAXPBM0@Z PROC			; CSpeedTreeRT::SetCamera, COMDAT

; 1554 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetCamera@CSpeedTreeRT@@SAXPBM0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 412				; 0000019cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-236]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1555 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1556 :     {
; 1557 :         if (pPosition && pDirection)

	cmp	DWORD PTR _pPosition$[ebp], 0
	je	$LN3@SetCamera
	cmp	DWORD PTR _pDirection$[ebp], 0
	je	$LN3@SetCamera

; 1558 :         {
; 1559 :             CVec3 cOldPosition, cOldDirection;

	lea	ecx, DWORD PTR _cOldPosition$11[ebp]
	call	??0CVec3@@QAE@XZ			; CVec3::CVec3
	npad	1
	lea	ecx, DWORD PTR _cOldDirection$10[ebp]
	call	??0CVec3@@QAE@XZ			; CVec3::CVec3
	npad	1

; 1560 :             CTreeEngine::GetCamera(cOldPosition, cOldDirection);

	lea	eax, DWORD PTR _cOldDirection$10[ebp]
	push	eax
	lea	ecx, DWORD PTR _cOldPosition$11[ebp]
	push	ecx
	call	?GetCamera@CIdvCamera@@SAXAAVCVec3@@0@Z	; CIdvCamera::GetCamera
	add	esp, 8

; 1561 : 
; 1562 :             CVec3 cNewPosition(pPosition[0], pPosition[1], pPosition[2]);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pPosition$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pPosition$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pPosition$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _cNewPosition$9[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	npad	1

; 1563 :             CVec3 cNewDirection(pDirection[0], pDirection[1], pDirection[2]);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pDirection$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pDirection$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pDirection$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _cNewDirection$8[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	npad	1

; 1564 : 
; 1565 :             // only want to recompute billboards if necessary
; 1566 :             if (cOldPosition != cNewPosition ||

	lea	eax, DWORD PTR _cNewPosition$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _cOldPosition$11[ebp]
	call	??9CVec3@@QBE_NABV0@@Z			; CVec3::operator!=
	mov	BYTE PTR tv193[ebp], al
	movzx	ecx, BYTE PTR tv193[ebp]
	test	ecx, ecx
	jne	SHORT $LN6@SetCamera
	lea	eax, DWORD PTR _cNewDirection$8[ebp]
	push	eax
	lea	ecx, DWORD PTR _cOldDirection$10[ebp]
	call	??9CVec3@@QBE_NABV0@@Z			; CVec3::operator!=
	mov	BYTE PTR tv194[ebp], al
	movzx	ecx, BYTE PTR tv194[ebp]
	test	ecx, ecx
	je	$LN5@SetCamera
$LN6@SetCamera:

; 1567 :                 cOldDirection != cNewDirection)
; 1568 :             {
; 1569 :                 CTreeEngine::SetCamera(cNewPosition, cNewDirection);

	lea	eax, DWORD PTR _cNewDirection$8[ebp]
	push	eax
	lea	ecx, DWORD PTR _cNewPosition$9[ebp]
	push	ecx
	call	?SetCamera@CIdvCamera@@SAXABVCVec3@@0@Z	; CIdvCamera::SetCamera
	add	esp, 8

; 1570 :                 NotifyAllTreesOfEvent(STIE_CLIENT_CHANGED_CAMERA);

	push	1
	call	?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z ; CSpeedTreeRT::NotifyAllTreesOfEvent
	add	esp, 4

; 1571 :                 CSimpleBillboard::ComputeUnitBillboard(cNewDirection.m_afData);

	lea	eax, DWORD PTR _cNewDirection$8[ebp]
	push	eax
	call	?ComputeUnitBillboard@CSimpleBillboard@@SAXPBM@Z ; CSimpleBillboard::ComputeUnitBillboard
	add	esp, 4

; 1572 :                 NotifyAllTreesOfEvent(STIE_CLIENT_CHANGED_CAMERA);

	push	1
	call	?NotifyAllTreesOfEvent@CSpeedTreeRT@@CAXH@Z ; CSpeedTreeRT::NotifyAllTreesOfEvent
	add	esp, 4

; 1573 : 
; 1574 :                 // determine horizontal billboard fade value
; 1575 :                 CVec3 cAdjustedDirection;

	lea	ecx, DWORD PTR _cAdjustedDirection$7[ebp]
	call	??0CVec3@@QAE@XZ			; CVec3::CVec3
	npad	1

; 1576 :                 Assign3d(cAdjustedDirection, cNewDirection);

	lea	ecx, DWORD PTR _cNewDirection$8[ebp]
	call	??BCVec3@@QAEPAMXZ			; CVec3::operator float *
	mov	DWORD PTR tv195[ebp], eax
	lea	ecx, DWORD PTR _cAdjustedDirection$7[ebp]
	call	??BCVec3@@QAEPAMXZ			; CVec3::operator float *
	mov	DWORD PTR tv196[ebp], eax
	mov	eax, DWORD PTR tv195[ebp]
	push	eax
	mov	ecx, DWORD PTR tv196[ebp]
	push	ecx
	call	?Assign3d@@YAXPAMPBM@Z			; Assign3d
	add	esp, 8

; 1577 :                 float fPitch = VecRad2Deg(asinf(cAdjustedDirection[2]));

	push	2
	lea	ecx, DWORD PTR _cAdjustedDirection$7[ebp]
	call	??ACVec3@@QAEAAMH@Z			; CVec3::operator[]
	mov	DWORD PTR tv197[ebp], eax
	mov	eax, DWORD PTR tv197[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	call	_asinf
	fstp	DWORD PTR [esp]
	call	?VecRad2Deg@@YAMM@Z			; VecRad2Deg
	add	esp, 4
	fstp	DWORD PTR tv198[ebp]
	movss	xmm0, DWORD PTR tv198[ebp]
	movss	DWORD PTR _fPitch$6[ebp], xmm0

; 1578 : 
; 1579 :                 float fPercent = 1.0f - (fPitch - m_fHorizontalFadeStartAngle) / (m_fHorizontalFadeEndAngle - m_fHorizontalFadeStartAngle);

	movss	xmm0, DWORD PTR ?m_fHorizontalFadeEndAngle@CSpeedTreeRT@@0MA
	subss	xmm0, DWORD PTR ?m_fHorizontalFadeStartAngle@CSpeedTreeRT@@0MA
	movss	xmm1, DWORD PTR _fPitch$6[ebp]
	subss	xmm1, DWORD PTR ?m_fHorizontalFadeStartAngle@CSpeedTreeRT@@0MA
	divss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, xmm1
	movss	DWORD PTR _fPercent$5[ebp], xmm0

; 1580 :                 fPercent = __max(0.0f, fPercent);

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _fPercent$5[ebp]
	jbe	SHORT $LN8@SetCamera
	xorps	xmm0, xmm0
	movss	DWORD PTR tv156[ebp], xmm0
	jmp	SHORT $LN9@SetCamera
$LN8@SetCamera:
	movss	xmm0, DWORD PTR _fPercent$5[ebp]
	movss	DWORD PTR tv156[ebp], xmm0
$LN9@SetCamera:
	movss	xmm0, DWORD PTR tv156[ebp]
	movss	DWORD PTR _fPercent$5[ebp], xmm0

; 1581 :                 fPercent = __min(1.0f, fPercent);

	movss	xmm0, DWORD PTR _fPercent$5[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN10@SetCamera
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv158[ebp], xmm0
	jmp	SHORT $LN11@SetCamera
$LN10@SetCamera:
	movss	xmm0, DWORD PTR _fPercent$5[ebp]
	movss	DWORD PTR tv158[ebp], xmm0
$LN11@SetCamera:
	movss	xmm0, DWORD PTR tv158[ebp]
	movss	DWORD PTR _fPercent$5[ebp], xmm0

; 1582 : 
; 1583 :                 m_fHorizontalFadeValue = VecInterpolate(84.0f, 255.0f, fPercent);

	push	ecx
	movss	xmm0, DWORD PTR _fPercent$5[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@42a80000
	movss	DWORD PTR [esp], xmm0
	call	?VecInterpolate@@YAMMMM@Z		; VecInterpolate
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR tv199[ebp]
	movss	xmm0, DWORD PTR tv199[ebp]
	movss	DWORD PTR ?m_fHorizontalFadeValue@CSpeedTreeRT@@0MA, xmm0
$LN5@SetCamera:

; 1584 :             }
; 1585 :         }

	jmp	SHORT $LN4@SetCamera
$LN3@SetCamera:

; 1586 :         else
; 1587 :             SetError("SetCamera() requires non-NULL position and direction values");

	push	OFFSET ??_C@_0DM@LIMPHDB@SetCamera?$CI?$CJ?5requires?5non?9NULL?5p@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@SetCamera:

; 1588 :     }

	jmp	$LN12@SetCamera
__catch$?SetCamera@CSpeedTreeRT@@SAXPBM0@Z$0:

; 1589 : 
; 1590 :     SpeedTreeCatch("CSpeedTreeRT::SetCamera")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BI@GJIKHFEL@CSpeedTreeRT?3?3SetCamera@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv200[ebp], eax
	mov	edx, DWORD PTR tv200[ebp]
	mov	DWORD PTR tv188[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv188[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN18@SetCamera
	ret	0
__catch$?SetCamera@CSpeedTreeRT@@SAXPBM0@Z$1:

; 1591 :     SpeedTreeCatchAll("CSpeedTreeRT::SetCamera");

	push	OFFSET ??_C@_0BI@GJIKHFEL@CSpeedTreeRT?3?3SetCamera@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv201[ebp], eax
	mov	ecx, DWORD PTR tv201[ebp]
	mov	DWORD PTR tv191[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv191[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN20@SetCamera
	ret	0
$LN12@SetCamera:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN19@SetCamera
$LN20@SetCamera:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN17@SetCamera
$LN19@SetCamera:
	jmp	SHORT $LN17@SetCamera
$LN18@SetCamera:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN17@SetCamera:

; 1592 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN29@SetCamera
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 428				; 000001acH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN29@SetCamera:
	DD	6
	DD	$LN28@SetCamera
$LN28@SetCamera:
	DD	-36					; ffffffdcH
	DD	12					; 0000000cH
	DD	$LN21@SetCamera
	DD	-56					; ffffffc8H
	DD	12					; 0000000cH
	DD	$LN22@SetCamera
	DD	-76					; ffffffb4H
	DD	12					; 0000000cH
	DD	$LN23@SetCamera
	DD	-96					; ffffffa0H
	DD	12					; 0000000cH
	DD	$LN24@SetCamera
	DD	-116					; ffffff8cH
	DD	12					; 0000000cH
	DD	$LN25@SetCamera
	DD	-152					; ffffff68H
	DD	4
	DD	$LN26@SetCamera
$LN26@SetCamera:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN25@SetCamera:
	DB	99					; 00000063H
	DB	65					; 00000041H
	DB	100					; 00000064H
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN24@SetCamera:
	DB	99					; 00000063H
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN23@SetCamera:
	DB	99					; 00000063H
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	80					; 00000050H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN22@SetCamera:
	DB	99					; 00000063H
	DB	79					; 0000004fH
	DB	108					; 0000006cH
	DB	100					; 00000064H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN21@SetCamera:
	DB	99					; 00000063H
	DB	79					; 0000004fH
	DB	108					; 0000006cH
	DB	100					; 00000064H
	DB	80					; 00000050H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetCamera@CSpeedTreeRT@@SAXPBM0@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetCamera@CSpeedTreeRT@@SAXPBM0@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetCamera@CSpeedTreeRT@@SAXPBM0@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-432]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetCamera@CSpeedTreeRT@@SAXPBM0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetCamera@CSpeedTreeRT@@SAXPBM0@Z ENDP			; CSpeedTreeRT::SetCamera
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetCamera@CSpeedTreeRT@@SAXPAM0@Z
_TEXT	SEGMENT
_cCameraDirection$1 = -40				; size = 12
_cCameraPos$2 = -20					; size = 12
__$ArrayPad$ = -4					; size = 4
_pPosition$ = 8						; size = 4
_pDirection$ = 12					; size = 4
?GetCamera@CSpeedTreeRT@@SAXPAM0@Z PROC			; CSpeedTreeRT::GetCamera, COMDAT

; 1536 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-44]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1537 :     if (pPosition && pDirection)

	cmp	DWORD PTR _pPosition$[ebp], 0
	je	SHORT $LN2@GetCamera
	cmp	DWORD PTR _pDirection$[ebp], 0
	je	SHORT $LN2@GetCamera

; 1538 :     {
; 1539 :         CVec3 cCameraPos, cCameraDirection;

	lea	ecx, DWORD PTR _cCameraPos$2[ebp]
	call	??0CVec3@@QAE@XZ			; CVec3::CVec3
	npad	1
	lea	ecx, DWORD PTR _cCameraDirection$1[ebp]
	call	??0CVec3@@QAE@XZ			; CVec3::CVec3
	npad	1

; 1540 :         CTreeEngine::GetCamera(cCameraPos, cCameraDirection);

	lea	eax, DWORD PTR _cCameraDirection$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _cCameraPos$2[ebp]
	push	ecx
	call	?GetCamera@CIdvCamera@@SAXAAVCVec3@@0@Z	; CIdvCamera::GetCamera
	add	esp, 8

; 1541 : 
; 1542 :         memcpy(pPosition, cCameraPos.m_afData, 3 * sizeof(float));

	push	12					; 0000000cH
	lea	eax, DWORD PTR _cCameraPos$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPosition$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1543 :         memcpy(pDirection, cCameraDirection.m_afData, 3 * sizeof(float));

	push	12					; 0000000cH
	lea	eax, DWORD PTR _cCameraDirection$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDirection$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1544 :     }

	jmp	SHORT $LN3@GetCamera
$LN2@GetCamera:

; 1545 :     else
; 1546 :         SetError("GetCamera() requires non-NULL position and direction values");

	push	OFFSET ??_C@_0DM@INADBBLE@GetCamera?$CI?$CJ?5requires?5non?9NULL?5p@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN3@GetCamera:

; 1547 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@GetCamera
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 236				; 000000ecH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN8@GetCamera:
	DD	2
	DD	$LN7@GetCamera
$LN7@GetCamera:
	DD	-20					; ffffffecH
	DD	12					; 0000000cH
	DD	$LN5@GetCamera
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN6@GetCamera
$LN6@GetCamera:
	DB	99					; 00000063H
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN5@GetCamera:
	DB	99					; 00000063H
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	80					; 00000050H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	0
?GetCamera@CSpeedTreeRT@@SAXPAM0@Z ENDP			; CSpeedTreeRT::GetCamera
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z
_TEXT	SEGMENT
tv130 = -316						; size = 4
tv95 = -316						; size = 4
tv133 = -312						; size = 4
tv132 = -312						; size = 4
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_pLeafMaterial$ = 8					; size = 4
?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z PROC		; CSpeedTreeRT::SetFrondMaterial, COMDAT
; _this$ = ecx

; 1518 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1519 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1520 :     {
; 1521 :         if (!m_bTreeComputed)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+69]
	test	ecx, ecx
	jne	SHORT $LN3@SetFrondMa

; 1522 :             m_pLightingEngine->SetFrondMaterial(pLeafMaterial);

	mov	eax, DWORD PTR _pLeafMaterial$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?SetFrondMaterial@CLightingEngine@@QAEXPBM@Z ; CLightingEngine::SetFrondMaterial
	npad	1
	jmp	SHORT $LN4@SetFrondMa
$LN3@SetFrondMa:

; 1523 :         else
; 1524 :             SetError("SetFrondMaterial() has no effect after Compute() has been called");

	push	OFFSET ??_C@_0EB@FAJAKGFC@SetFrondMaterial?$CI?$CJ?5has?5no?5effec@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@SetFrondMa:

; 1525 :     }

	jmp	$LN6@SetFrondMa
__catch$?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z$0:

; 1526 : 
; 1527 :     SpeedTreeCatch("CSpeedTreeRT::SetFrondMaterial")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BP@LFKENEJP@CSpeedTreeRT?3?3SetFrondMaterial@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv132[ebp], eax
	mov	edx, DWORD PTR tv132[ebp]
	mov	DWORD PTR tv95[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv95[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN12@SetFrondMa
	ret	0
__catch$?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z$1:

; 1528 :     SpeedTreeCatchAll("CSpeedTreeRT::SetFrondMaterial");

	push	OFFSET ??_C@_0BP@LFKENEJP@CSpeedTreeRT?3?3SetFrondMaterial@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv133[ebp], eax
	mov	ecx, DWORD PTR tv133[ebp]
	mov	DWORD PTR tv130[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv130[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN14@SetFrondMa
	ret	0
$LN6@SetFrondMa:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN13@SetFrondMa
$LN14@SetFrondMa:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN11@SetFrondMa
$LN13@SetFrondMa:
	jmp	SHORT $LN11@SetFrondMa
$LN12@SetFrondMa:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN11@SetFrondMa:

; 1529 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@SetFrondMa
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN18@SetFrondMa:
	DD	1
	DD	$LN17@SetFrondMa
$LN17@SetFrondMa:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN15@SetFrondMa
$LN15@SetFrondMa:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetFrondMaterial@CSpeedTreeRT@@QAEXPBM@Z ENDP		; CSpeedTreeRT::SetFrondMaterial
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetFrondMaterial@CSpeedTreeRT@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetFrondMaterial@CSpeedTreeRT@@QBEPBMXZ PROC		; CSpeedTreeRT::GetFrondMaterial, COMDAT
; _this$ = ecx

; 1509 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1510 :     return m_pLightingEngine->GetFrondMaterial( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetFrondMaterial@CLightingEngine@@QBEPBMXZ ; CLightingEngine::GetFrondMaterial

; 1511 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFrondMaterial@CSpeedTreeRT@@QBEPBMXZ ENDP		; CSpeedTreeRT::GetFrondMaterial
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z
_TEXT	SEGMENT
tv130 = -316						; size = 4
tv95 = -316						; size = 4
tv133 = -312						; size = 4
tv132 = -312						; size = 4
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_pLeafMaterial$ = 8					; size = 4
?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z PROC		; CSpeedTreeRT::SetLeafMaterial, COMDAT
; _this$ = ecx

; 1491 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1492 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1493 :     {
; 1494 :         if (!m_bTreeComputed)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+69]
	test	ecx, ecx
	jne	SHORT $LN3@SetLeafMat

; 1495 :             m_pLightingEngine->SetLeafMaterial(pLeafMaterial);

	mov	eax, DWORD PTR _pLeafMaterial$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?SetLeafMaterial@CLightingEngine@@QAEXPBM@Z ; CLightingEngine::SetLeafMaterial
	npad	1
	jmp	SHORT $LN4@SetLeafMat
$LN3@SetLeafMat:

; 1496 :         else
; 1497 :             SetError("SetLeafMaterial() has no effect after Compute() has been called");

	push	OFFSET ??_C@_0EA@MFLNIJGM@SetLeafMaterial?$CI?$CJ?5has?5no?5effect@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@SetLeafMat:

; 1498 :     }

	jmp	$LN6@SetLeafMat
__catch$?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z$0:

; 1499 : 
; 1500 :     SpeedTreeCatch("CSpeedTreeRT::SetLeafMaterial")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BO@KAODBPCG@CSpeedTreeRT?3?3SetLeafMaterial@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv132[ebp], eax
	mov	edx, DWORD PTR tv132[ebp]
	mov	DWORD PTR tv95[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv95[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN12@SetLeafMat
	ret	0
__catch$?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z$1:

; 1501 :     SpeedTreeCatchAll("CSpeedTreeRT::SetLeafMaterial");

	push	OFFSET ??_C@_0BO@KAODBPCG@CSpeedTreeRT?3?3SetLeafMaterial@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv133[ebp], eax
	mov	ecx, DWORD PTR tv133[ebp]
	mov	DWORD PTR tv130[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv130[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN14@SetLeafMat
	ret	0
$LN6@SetLeafMat:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN13@SetLeafMat
$LN14@SetLeafMat:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN11@SetLeafMat
$LN13@SetLeafMat:
	jmp	SHORT $LN11@SetLeafMat
$LN12@SetLeafMat:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN11@SetLeafMat:

; 1502 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@SetLeafMat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN18@SetLeafMat:
	DD	1
	DD	$LN17@SetLeafMat
$LN17@SetLeafMat:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN15@SetLeafMat
$LN15@SetLeafMat:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetLeafMaterial@CSpeedTreeRT@@QAEXPBM@Z ENDP		; CSpeedTreeRT::SetLeafMaterial
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetLeafMaterial@CSpeedTreeRT@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetLeafMaterial@CSpeedTreeRT@@QBEPBMXZ PROC		; CSpeedTreeRT::GetLeafMaterial, COMDAT
; _this$ = ecx

; 1482 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1483 :     return m_pLightingEngine->GetLeafMaterial( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetLeafMaterial@CLightingEngine@@QBEPBMXZ ; CLightingEngine::GetLeafMaterial

; 1484 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLeafMaterial@CSpeedTreeRT@@QBEPBMXZ ENDP		; CSpeedTreeRT::GetLeafMaterial
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z
_TEXT	SEGMENT
tv130 = -316						; size = 4
tv95 = -316						; size = 4
tv133 = -312						; size = 4
tv132 = -312						; size = 4
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_pBranchMaterial$ = 8					; size = 4
?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z PROC		; CSpeedTreeRT::SetBranchMaterial, COMDAT
; _this$ = ecx

; 1464 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1465 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1466 :     {
; 1467 :         if (!m_bTreeComputed)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+69]
	test	ecx, ecx
	jne	SHORT $LN3@SetBranchM

; 1468 :             m_pLightingEngine->SetBranchMaterial(pBranchMaterial);

	mov	eax, DWORD PTR _pBranchMaterial$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?SetBranchMaterial@CLightingEngine@@QAEXPBM@Z ; CLightingEngine::SetBranchMaterial
	npad	1
	jmp	SHORT $LN4@SetBranchM
$LN3@SetBranchM:

; 1469 :         else
; 1470 :             SetError("SetBranchMaterial() has no effect after Compute() has been called");

	push	OFFSET ??_C@_0EC@FKMBDLKG@SetBranchMaterial?$CI?$CJ?5has?5no?5effe@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@SetBranchM:

; 1471 :     }

	jmp	$LN6@SetBranchM
__catch$?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z$0:

; 1472 : 
; 1473 :     SpeedTreeCatch("CSpeedTreeRT::SetBranchMaterial")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CA@MCAEMOA@CSpeedTreeRT?3?3SetBranchMaterial@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv132[ebp], eax
	mov	edx, DWORD PTR tv132[ebp]
	mov	DWORD PTR tv95[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv95[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN12@SetBranchM
	ret	0
__catch$?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z$1:

; 1474 :     SpeedTreeCatchAll("CSpeedTreeRT::SetBranchMaterial");

	push	OFFSET ??_C@_0CA@MCAEMOA@CSpeedTreeRT?3?3SetBranchMaterial@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv133[ebp], eax
	mov	ecx, DWORD PTR tv133[ebp]
	mov	DWORD PTR tv130[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv130[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN14@SetBranchM
	ret	0
$LN6@SetBranchM:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN13@SetBranchM
$LN14@SetBranchM:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN11@SetBranchM
$LN13@SetBranchM:
	jmp	SHORT $LN11@SetBranchM
$LN12@SetBranchM:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN11@SetBranchM:

; 1475 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@SetBranchM
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN18@SetBranchM:
	DD	1
	DD	$LN17@SetBranchM
$LN17@SetBranchM:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN15@SetBranchM
$LN15@SetBranchM:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetBranchMaterial@CSpeedTreeRT@@QAEXPBM@Z ENDP		; CSpeedTreeRT::SetBranchMaterial
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetBranchMaterial@CSpeedTreeRT@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetBranchMaterial@CSpeedTreeRT@@QBEPBMXZ PROC		; CSpeedTreeRT::GetBranchMaterial, COMDAT
; _this$ = ecx

; 1455 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1456 :     return m_pLightingEngine->GetBranchMaterial( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetBranchMaterial@CLightingEngine@@QBEPBMXZ ; CLightingEngine::GetBranchMaterial

; 1457 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBranchMaterial@CSpeedTreeRT@@QBEPBMXZ ENDP		; CSpeedTreeRT::GetBranchMaterial
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z
_TEXT	SEGMENT
tv93 = -304						; size = 4
tv90 = -304						; size = 4
tv128 = -300						; size = 4
tv95 = -300						; size = 4
$T2 = -292						; size = 28
$T3 = -256						; size = 28
_cException$4 = -28					; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_nLightIndex$ = 8					; size = 4
_pAttributes$ = 12					; size = 4
?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z PROC	; CSpeedTreeRT::SetLightAttributes, COMDAT

; 1440 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-112]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1441 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1442 :     {
; 1443 :         CLightingEngine::SetLightAttributes(nLightIndex, pAttributes);

	mov	eax, DWORD PTR _pAttributes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nLightIndex$[ebp]
	push	ecx
	call	?SetLightAttributes@CLightingEngine@@SAXIPBM@Z ; CLightingEngine::SetLightAttributes
	add	esp, 8

; 1444 :     }

	jmp	$LN4@SetLightAt
__catch$?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z$0:

; 1445 : 
; 1446 :     SpeedTreeCatch("CSpeedTreeRT::SetLightAttributes")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CB@HONICPFE@CSpeedTreeRT?3?3SetLightAttribute@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv95[ebp], eax
	mov	edx, DWORD PTR tv95[ebp]
	mov	DWORD PTR tv90[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv90[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN10@SetLightAt
	ret	0
__catch$?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z$1:

; 1447 :     SpeedTreeCatchAll("CSpeedTreeRT::SetLightAttributes");

	push	OFFSET ??_C@_0CB@HONICPFE@CSpeedTreeRT?3?3SetLightAttribute@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv128[ebp], eax
	mov	ecx, DWORD PTR tv128[ebp]
	mov	DWORD PTR tv93[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv93[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN12@SetLightAt
	ret	0
$LN4@SetLightAt:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN11@SetLightAt
$LN12@SetLightAt:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN9@SetLightAt
$LN11@SetLightAt:
	jmp	SHORT $LN9@SetLightAt
$LN10@SetLightAt:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@SetLightAt:

; 1448 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@SetLightAt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN16@SetLightAt:
	DD	1
	DD	$LN15@SetLightAt
$LN15@SetLightAt:
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN13@SetLightAt
$LN13@SetLightAt:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-308]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetLightAttributes@CSpeedTreeRT@@SAXIPBM@Z ENDP	; CSpeedTreeRT::SetLightAttributes
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetLightAttributes@CSpeedTreeRT@@SAPBMI@Z
_TEXT	SEGMENT
_nLightIndex$ = 8					; size = 4
?GetLightAttributes@CSpeedTreeRT@@SAPBMI@Z PROC		; CSpeedTreeRT::GetLightAttributes, COMDAT

; 1431 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1432 :     return CLightingEngine::GetLightAttributes(nLightIndex);

	mov	eax, DWORD PTR _nLightIndex$[ebp]
	push	eax
	call	?GetLightAttributes@CLightingEngine@@SAPBMI@Z ; CLightingEngine::GetLightAttributes
	add	esp, 4

; 1433 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLightAttributes@CSpeedTreeRT@@SAPBMI@Z ENDP		; CSpeedTreeRT::GetLightAttributes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetLightState@CSpeedTreeRT@@SAXI_N@Z
_TEXT	SEGMENT
_nLightIndex$ = 8					; size = 4
_bLightState$ = 12					; size = 1
?SetLightState@CSpeedTreeRT@@SAXI_N@Z PROC		; CSpeedTreeRT::SetLightState, COMDAT

; 1422 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1423 :     CLightingEngine::SetLightState(nLightIndex, bLightState);

	movzx	eax, BYTE PTR _bLightState$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nLightIndex$[ebp]
	push	ecx
	call	?SetLightState@CLightingEngine@@SAXI_N@Z ; CLightingEngine::SetLightState
	add	esp, 8

; 1424 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?SetLightState@CSpeedTreeRT@@SAXI_N@Z ENDP		; CSpeedTreeRT::SetLightState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetLightState@CSpeedTreeRT@@SA_NI@Z
_TEXT	SEGMENT
_nLightIndex$ = 8					; size = 4
?GetLightState@CSpeedTreeRT@@SA_NI@Z PROC		; CSpeedTreeRT::GetLightState, COMDAT

; 1413 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1414 :     return CLightingEngine::GetLightState(nLightIndex);

	mov	eax, DWORD PTR _nLightIndex$[ebp]
	push	eax
	call	?GetLightState@CLightingEngine@@SA_NI@Z	; CLightingEngine::GetLightState
	add	esp, 4

; 1415 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLightState@CSpeedTreeRT@@SA_NI@Z ENDP		; CSpeedTreeRT::GetLightState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z
_TEXT	SEGMENT
tv130 = -316						; size = 4
tv95 = -316						; size = 4
tv133 = -312						; size = 4
tv132 = -312						; size = 4
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_fScalar$ = 8						; size = 4
?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z PROC	; CSpeedTreeRT::SetLeafLightingAdjustment, COMDAT
; _this$ = ecx

; 1365 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1366 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1367 :     {
; 1368 :         if (!m_bTreeComputed)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+69]
	test	ecx, ecx
	jne	SHORT $LN3@SetLeafLig

; 1369 :             m_pLightingEngine->SetLeafLightingAdjustment(fScalar);

	push	ecx
	movss	xmm0, DWORD PTR _fScalar$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?SetLeafLightingAdjustment@CLightingEngine@@QAEXM@Z ; CLightingEngine::SetLeafLightingAdjustment
	npad	1
	jmp	SHORT $LN4@SetLeafLig
$LN3@SetLeafLig:

; 1370 :         else
; 1371 :             SetError("SetLeafLightingAdjustment() has no effect after Compute() has been called");

	push	OFFSET ??_C@_0EK@FDHHEDFI@SetLeafLightingAdjustment?$CI?$CJ?5has@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@SetLeafLig:

; 1372 :     }

	jmp	$LN6@SetLeafLig
__catch$?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z$0:

; 1373 : 
; 1374 :     SpeedTreeCatch("CSpeedTreeRT::SetLeafLightingAdjustment")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CI@EJKAJJHJ@CSpeedTreeRT?3?3SetLeafLightingAd@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv132[ebp], eax
	mov	edx, DWORD PTR tv132[ebp]
	mov	DWORD PTR tv95[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv95[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN12@SetLeafLig
	ret	0
__catch$?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z$1:

; 1375 :     SpeedTreeCatchAll("CSpeedTreeRT::SetLeafLightingAdjustment");

	push	OFFSET ??_C@_0CI@EJKAJJHJ@CSpeedTreeRT?3?3SetLeafLightingAd@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv133[ebp], eax
	mov	ecx, DWORD PTR tv133[ebp]
	mov	DWORD PTR tv130[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv130[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN14@SetLeafLig
	ret	0
$LN6@SetLeafLig:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN13@SetLeafLig
$LN14@SetLeafLig:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN11@SetLeafLig
$LN13@SetLeafLig:
	jmp	SHORT $LN11@SetLeafLig
$LN12@SetLeafLig:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN11@SetLeafLig:

; 1376 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@SetLeafLig
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN18@SetLeafLig:
	DD	1
	DD	$LN17@SetLeafLig
$LN17@SetLeafLig:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN15@SetLeafLig
$LN15@SetLeafLig:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetLeafLightingAdjustment@CSpeedTreeRT@@QAEXM@Z ENDP	; CSpeedTreeRT::SetLeafLightingAdjustment
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetLeafLightingAdjustment@CSpeedTreeRT@@QBEMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetLeafLightingAdjustment@CSpeedTreeRT@@QBEMXZ PROC	; CSpeedTreeRT::GetLeafLightingAdjustment, COMDAT
; _this$ = ecx

; 1356 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1357 :     return m_pLightingEngine->GetLeafLightingAdjustment( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetLeafLightingAdjustment@CLightingEngine@@QAEMXZ ; CLightingEngine::GetLeafLightingAdjustment

; 1358 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLeafLightingAdjustment@CSpeedTreeRT@@QBEMXZ ENDP	; CSpeedTreeRT::GetLeafLightingAdjustment
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z
_TEXT	SEGMENT
tv152 = -324						; size = 4
tv151 = -320						; size = 4
tv150 = -316						; size = 4
tv147 = -316						; size = 4
tv144 = -316						; size = 4
tv154 = -312						; size = 4
tv153 = -312						; size = 4
tv149 = -312						; size = 4
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_eStyle$ = 8						; size = 4
?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z PROC ; CSpeedTreeRT::SetStaticLightingStyle, COMDAT
; _this$ = ecx

; 1335 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 308				; 00000134H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-132]
	mov	ecx, 29					; 0000001dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1336 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1337 :     {
; 1338 :         if (!m_bTreeComputed)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+69]
	test	ecx, ecx
	jne	$LN3@SetStaticL

; 1339 :         {
; 1340 :             st_assert(m_pLightingEngine);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	$LN5@SetStaticL
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv149[ebp], eax
	mov	ecx, DWORD PTR ?__LINE__Var@?0??SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@2@@Z@4JA
	add	ecx, 5
	mov	esi, esp
	push	ecx
	mov	ecx, DWORD PTR tv149[ebp]
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv150[ebp], eax
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	edx, DWORD PTR tv150[ebp]
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv151[ebp], eax
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	mov	eax, DWORD PTR tv151[ebp]
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv152[ebp], eax
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	ecx, DWORD PTR tv152[ebp]
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN5@SetStaticL:

; 1341 :             m_pLightingEngine->SetStaticLightingStyle(eStyle);

	mov	eax, DWORD PTR _eStyle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?SetStaticLightingStyle@CLightingEngine@@QAEXW4EStaticLightingStyle@CSpeedTreeRT@@@Z ; CLightingEngine::SetStaticLightingStyle
	npad	1

; 1342 :         }

	jmp	SHORT $LN4@SetStaticL
$LN3@SetStaticL:

; 1343 :         else
; 1344 :             SetError("SetStaticLightingStyle() has no effect after Compute() has been called");

	push	OFFSET ??_C@_0EH@NCCMENJN@SetStaticLightingStyle?$CI?$CJ?5has?5no@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@SetStaticL:

; 1345 :     }

	jmp	$LN7@SetStaticL
__catch$?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z$0:

; 1346 : 
; 1347 :     SpeedTreeCatch("CSpeedTreeRT::SetStaticLightingStyle")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CF@BCLGOANH@CSpeedTreeRT?3?3SetStaticLighting@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv153[ebp], eax
	mov	edx, DWORD PTR tv153[ebp]
	mov	DWORD PTR tv144[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv144[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN13@SetStaticL
	ret	0
__catch$?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z$1:

; 1348 :     SpeedTreeCatchAll("CSpeedTreeRT::SetStaticLightingStyle");

	push	OFFSET ??_C@_0CF@BCLGOANH@CSpeedTreeRT?3?3SetStaticLighting@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv154[ebp], eax
	mov	ecx, DWORD PTR tv154[ebp]
	mov	DWORD PTR tv147[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv147[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN15@SetStaticL
	ret	0
$LN7@SetStaticL:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN14@SetStaticL
$LN15@SetStaticL:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN12@SetStaticL
$LN14@SetStaticL:
	jmp	SHORT $LN12@SetStaticL
$LN13@SetStaticL:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN12@SetStaticL:
$LN1@SetStaticL:

; 1349 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@SetStaticL
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 324				; 00000144H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN19@SetStaticL:
	DD	1
	DD	$LN18@SetStaticL
$LN18@SetStaticL:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN16@SetStaticL
$LN16@SetStaticL:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-328]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetStaticLightingStyle@CSpeedTreeRT@@QAEXW4EStaticLightingStyle@1@@Z ENDP ; CSpeedTreeRT::SetStaticLightingStyle
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetStaticLightingStyle@CSpeedTreeRT@@QBE?AW4EStaticLightingStyle@1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetStaticLightingStyle@CSpeedTreeRT@@QBE?AW4EStaticLightingStyle@1@XZ PROC ; CSpeedTreeRT::GetStaticLightingStyle, COMDAT
; _this$ = ecx

; 1326 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1327 :     return m_pLightingEngine->GetStaticLightingStyle( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetStaticLightingStyle@CLightingEngine@@QBE?AW4EStaticLightingStyle@CSpeedTreeRT@@XZ ; CLightingEngine::GetStaticLightingStyle

; 1328 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetStaticLightingStyle@CSpeedTreeRT@@QBE?AW4EStaticLightingStyle@1@XZ ENDP ; CSpeedTreeRT::GetStaticLightingStyle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z
_TEXT	SEGMENT
tv135 = -316						; size = 4
tv132 = -316						; size = 4
tv138 = -312						; size = 4
tv137 = -312						; size = 4
tv70 = -309						; size = 1
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_eMethod$ = 8						; size = 4
?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z PROC ; CSpeedTreeRT::SetFrondLightingMethod, COMDAT
; _this$ = ecx

; 1392 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1393 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1394 :     {
; 1395 :         if (!m_bTreeComputed)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+69]
	test	ecx, ecx
	jne	SHORT $LN3@SetFrondLi

; 1396 :         {
; 1397 :             m_pFrondGeometry->EnableManualLighting(eMethod == LIGHT_STATIC);

	cmp	DWORD PTR _eMethod$[ebp], 1
	jne	SHORT $LN6@SetFrondLi
	mov	BYTE PTR tv70[ebp], 1
	jmp	SHORT $LN7@SetFrondLi
$LN6@SetFrondLi:
	mov	BYTE PTR tv70[ebp], 0
$LN7@SetFrondLi:
	movzx	eax, BYTE PTR tv70[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+92]
	call	?EnableManualLighting@CIndexedGeometry@@QAEX_N@Z ; CIndexedGeometry::EnableManualLighting
	npad	1

; 1398 :             m_pLightingEngine->SetFrondLightingMethod(eMethod);

	mov	eax, DWORD PTR _eMethod$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?SetFrondLightingMethod@CLightingEngine@@QAEXW4ELightingMethod@CSpeedTreeRT@@@Z ; CLightingEngine::SetFrondLightingMethod
	npad	1

; 1399 :         }

	jmp	SHORT $LN4@SetFrondLi
$LN3@SetFrondLi:

; 1400 :         else
; 1401 :             SetError("SetFrondLightingMethod() has no effect after Compute() has been called");

	push	OFFSET ??_C@_0EH@NOGLOGJ@SetFrondLightingMethod?$CI?$CJ?5has?5no@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@SetFrondLi:

; 1402 :     }

	jmp	$LN8@SetFrondLi
__catch$?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$0:

; 1403 : 
; 1404 :     SpeedTreeCatch("CSpeedTreeRT::SetFrondLightingMethod")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CF@CLEAOJEL@CSpeedTreeRT?3?3SetFrondLightingM@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv137[ebp], eax
	mov	edx, DWORD PTR tv137[ebp]
	mov	DWORD PTR tv132[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv132[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN14@SetFrondLi
	ret	0
__catch$?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$1:

; 1405 :     SpeedTreeCatchAll("CSpeedTreeRT::SetFrondLightingMethod");

	push	OFFSET ??_C@_0CF@CLEAOJEL@CSpeedTreeRT?3?3SetFrondLightingM@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv138[ebp], eax
	mov	ecx, DWORD PTR tv138[ebp]
	mov	DWORD PTR tv135[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv135[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN16@SetFrondLi
	ret	0
$LN8@SetFrondLi:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN15@SetFrondLi
$LN16@SetFrondLi:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN13@SetFrondLi
$LN15@SetFrondLi:
	jmp	SHORT $LN13@SetFrondLi
$LN14@SetFrondLi:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN13@SetFrondLi:

; 1406 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@SetFrondLi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN20@SetFrondLi:
	DD	1
	DD	$LN19@SetFrondLi
$LN19@SetFrondLi:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN17@SetFrondLi
$LN17@SetFrondLi:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z ENDP ; CSpeedTreeRT::SetFrondLightingMethod
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetFrondLightingMethod@CSpeedTreeRT@@QBE?AW4ELightingMethod@1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetFrondLightingMethod@CSpeedTreeRT@@QBE?AW4ELightingMethod@1@XZ PROC ; CSpeedTreeRT::GetFrondLightingMethod, COMDAT
; _this$ = ecx

; 1383 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1384 :     return m_pLightingEngine->GetFrondLightingMethod( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetFrondLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ ; CLightingEngine::GetFrondLightingMethod

; 1385 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFrondLightingMethod@CSpeedTreeRT@@QBE?AW4ELightingMethod@1@XZ ENDP ; CSpeedTreeRT::GetFrondLightingMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z
_TEXT	SEGMENT
tv135 = -316						; size = 4
tv132 = -316						; size = 4
tv138 = -312						; size = 4
tv137 = -312						; size = 4
tv73 = -309						; size = 1
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_eMethod$ = 8						; size = 4
?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z PROC ; CSpeedTreeRT::SetLeafLightingMethod, COMDAT
; _this$ = ecx

; 1305 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1306 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1307 :     {
; 1308 :         if (!m_bTreeComputed)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+69]
	test	ecx, ecx
	jne	SHORT $LN3@SetLeafLig

; 1309 :         {
; 1310 :             m_pLightingEngine->SetLeafLightingMethod(eMethod);

	mov	eax, DWORD PTR _eMethod$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?SetLeafLightingMethod@CLightingEngine@@QAEXW4ELightingMethod@CSpeedTreeRT@@@Z ; CLightingEngine::SetLeafLightingMethod
	npad	1

; 1311 :             m_pLeafGeometry->EnableManualLighting(eMethod == LIGHT_STATIC);

	cmp	DWORD PTR _eMethod$[ebp], 1
	jne	SHORT $LN6@SetLeafLig
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $LN7@SetLeafLig
$LN6@SetLeafLig:
	mov	BYTE PTR tv73[ebp], 0
$LN7@SetLeafLig:
	movzx	eax, BYTE PTR tv73[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?EnableManualLighting@CLeafGeometry@@QAEX_N@Z ; CLeafGeometry::EnableManualLighting
	npad	1

; 1312 :         }

	jmp	SHORT $LN4@SetLeafLig
$LN3@SetLeafLig:

; 1313 :         else
; 1314 :             SetError("SetLeafLightingMethod() has no effect after Compute() has been called");

	push	OFFSET ??_C@_0EG@NJIHGNJJ@SetLeafLightingMethod?$CI?$CJ?5has?5no?5@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@SetLeafLig:

; 1315 :     }

	jmp	$LN8@SetLeafLig
__catch$?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$0:

; 1316 : 
; 1317 :     SpeedTreeCatch("CSpeedTreeRT::SetLeafLightingMethod")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CE@JEGOHDCD@CSpeedTreeRT?3?3SetLeafLightingMe@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv137[ebp], eax
	mov	edx, DWORD PTR tv137[ebp]
	mov	DWORD PTR tv132[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv132[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN14@SetLeafLig
	ret	0
__catch$?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$1:

; 1318 :     SpeedTreeCatchAll("CSpeedTreeRT::SetLeafLightingMethod");

	push	OFFSET ??_C@_0CE@JEGOHDCD@CSpeedTreeRT?3?3SetLeafLightingMe@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv138[ebp], eax
	mov	ecx, DWORD PTR tv138[ebp]
	mov	DWORD PTR tv135[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv135[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN16@SetLeafLig
	ret	0
$LN8@SetLeafLig:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN15@SetLeafLig
$LN16@SetLeafLig:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN13@SetLeafLig
$LN15@SetLeafLig:
	jmp	SHORT $LN13@SetLeafLig
$LN14@SetLeafLig:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN13@SetLeafLig:

; 1319 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@SetLeafLig
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN20@SetLeafLig:
	DD	1
	DD	$LN19@SetLeafLig
$LN19@SetLeafLig:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN17@SetLeafLig
$LN17@SetLeafLig:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z ENDP ; CSpeedTreeRT::SetLeafLightingMethod
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetLeafLightingMethod@CSpeedTreeRT@@QBE?AW4ELightingMethod@1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetLeafLightingMethod@CSpeedTreeRT@@QBE?AW4ELightingMethod@1@XZ PROC ; CSpeedTreeRT::GetLeafLightingMethod, COMDAT
; _this$ = ecx

; 1296 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1297 :     return m_pLightingEngine->GetLeafLightingMethod( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetLeafLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ ; CLightingEngine::GetLeafLightingMethod

; 1298 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLeafLightingMethod@CSpeedTreeRT@@QBE?AW4ELightingMethod@1@XZ ENDP ; CSpeedTreeRT::GetLeafLightingMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z
_TEXT	SEGMENT
tv135 = -316						; size = 4
tv132 = -316						; size = 4
tv138 = -312						; size = 4
tv137 = -312						; size = 4
tv70 = -309						; size = 1
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_eMethod$ = 8						; size = 4
?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z PROC ; CSpeedTreeRT::SetBranchLightingMethod, COMDAT
; _this$ = ecx

; 1275 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1276 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1277 :     {
; 1278 :         if (!m_bTreeComputed)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+69]
	test	ecx, ecx
	jne	SHORT $LN3@SetBranchL

; 1279 :         {
; 1280 :             m_pBranchGeometry->EnableManualLighting(eMethod == LIGHT_STATIC);

	cmp	DWORD PTR _eMethod$[ebp], 1
	jne	SHORT $LN6@SetBranchL
	mov	BYTE PTR tv70[ebp], 1
	jmp	SHORT $LN7@SetBranchL
$LN6@SetBranchL:
	mov	BYTE PTR tv70[ebp], 0
$LN7@SetBranchL:
	movzx	eax, BYTE PTR tv70[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?EnableManualLighting@CIndexedGeometry@@QAEX_N@Z ; CIndexedGeometry::EnableManualLighting
	npad	1

; 1281 :             m_pLightingEngine->SetBranchLightingMethod(eMethod);

	mov	eax, DWORD PTR _eMethod$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?SetBranchLightingMethod@CLightingEngine@@QAEXW4ELightingMethod@CSpeedTreeRT@@@Z ; CLightingEngine::SetBranchLightingMethod
	npad	1

; 1282 :         }

	jmp	SHORT $LN4@SetBranchL
$LN3@SetBranchL:

; 1283 :         else
; 1284 :             SetError("SetBranchLightingMethod() has no effect after Compute() has been called");

	push	OFFSET ??_C@_0EI@NEFFOLNG@SetBranchLightingMethod?$CI?$CJ?5has?5n@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@SetBranchL:

; 1285 :     }

	jmp	$LN8@SetBranchL
__catch$?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$0:

; 1286 : 
; 1287 :     SpeedTreeCatch("CSpeedTreeRT::SetBranchLightingMethod")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0CG@JIPGNOHN@CSpeedTreeRT?3?3SetBranchLighting@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv137[ebp], eax
	mov	edx, DWORD PTR tv137[ebp]
	mov	DWORD PTR tv132[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv132[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN14@SetBranchL
	ret	0
__catch$?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$1:

; 1288 :     SpeedTreeCatchAll("CSpeedTreeRT::SetBranchLightingMethod");

	push	OFFSET ??_C@_0CG@JIPGNOHN@CSpeedTreeRT?3?3SetBranchLighting@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv138[ebp], eax
	mov	ecx, DWORD PTR tv138[ebp]
	mov	DWORD PTR tv135[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv135[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN16@SetBranchL
	ret	0
$LN8@SetBranchL:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN15@SetBranchL
$LN16@SetBranchL:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN13@SetBranchL
$LN15@SetBranchL:
	jmp	SHORT $LN13@SetBranchL
$LN14@SetBranchL:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN13@SetBranchL:

; 1289 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@SetBranchL
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN20@SetBranchL:
	DD	1
	DD	$LN19@SetBranchL
$LN19@SetBranchL:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN17@SetBranchL
$LN17@SetBranchL:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z ENDP ; CSpeedTreeRT::SetBranchLightingMethod
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetBranchLightingMethod@CSpeedTreeRT@@QBE?AW4ELightingMethod@1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetBranchLightingMethod@CSpeedTreeRT@@QBE?AW4ELightingMethod@1@XZ PROC ; CSpeedTreeRT::GetBranchLightingMethod, COMDAT
; _this$ = ecx

; 1266 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1267 :     return m_pLightingEngine->GetBranchLightingMethod( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetBranchLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ ; CLightingEngine::GetBranchLightingMethod

; 1268 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBranchLightingMethod@CSpeedTreeRT@@QBE?AW4ELightingMethod@1@XZ ENDP ; CSpeedTreeRT::GetBranchLightingMethod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetLeafTargetAlphaMask@CSpeedTreeRT@@QAEXE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_ucMask$ = 8						; size = 1
?SetLeafTargetAlphaMask@CSpeedTreeRT@@QAEXE@Z PROC	; CSpeedTreeRT::SetLeafTargetAlphaMask, COMDAT
; _this$ = ecx

; 1257 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1258 :     m_ucTargetAlphaValue = ucMask;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _ucMask$[ebp]
	mov	BYTE PTR [eax+68], cl

; 1259 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLeafTargetAlphaMask@CSpeedTreeRT@@QAEXE@Z ENDP	; CSpeedTreeRT::SetLeafTargetAlphaMask
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetTreePosition@CSpeedTreeRT@@QAEXMMM@Z
_TEXT	SEGMENT
$T1 = -224						; size = 12
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SetTreePosition@CSpeedTreeRT@@QAEXMMM@Z PROC		; CSpeedTreeRT::SetTreePosition, COMDAT
; _this$ = ecx

; 1245 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1246 :     if (m_pInstanceData)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN2@SetTreePos

; 1247 :         m_pInstanceData->m_cPosition.Set(x, y, z);

	push	ecx
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, 4
	call	?Set@CVec3@@QAEXMMM@Z			; CVec3::Set
	npad	1
	jmp	SHORT $LN3@SetTreePos
$LN2@SetTreePos:

; 1248 :     else
; 1249 :         m_pEngine->SetPosition(CVec3(x, y, z));

	push	ecx
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?SetPosition@CIdvCamera@@QAEXABVCVec3@@@Z ; CIdvCamera::SetPosition
	npad	1
$LN3@SetTreePos:

; 1250 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetTreePosition@CSpeedTreeRT@@QAEXMMM@Z ENDP		; CSpeedTreeRT::SetTreePosition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetTreePosition@CSpeedTreeRT@@QBEPBMXZ
_TEXT	SEGMENT
_pPos$ = -20						; size = 4
_this$ = -8						; size = 4
?GetTreePosition@CSpeedTreeRT@@QBEPBMXZ PROC		; CSpeedTreeRT::GetTreePosition, COMDAT
; _this$ = ecx

; 1230 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1231 :     const float* pPos = NULL;

	mov	DWORD PTR _pPos$[ebp], 0

; 1232 :     if (m_pInstanceData)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN2@GetTreePos

; 1233 :         pPos = m_pInstanceData->m_cPosition.m_afData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, 4
	mov	DWORD PTR _pPos$[ebp], ecx
	jmp	SHORT $LN3@GetTreePos
$LN2@GetTreePos:

; 1234 :     else
; 1235 :         pPos = m_pEngine->GetPosition( ).m_afData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetPosition@CIdvCamera@@QBEABVCVec3@@XZ ; CIdvCamera::GetPosition
	mov	DWORD PTR _pPos$[ebp], eax
$LN3@GetTreePos:

; 1236 : 
; 1237 :     return pPos;

	mov	eax, DWORD PTR _pPos$[ebp]

; 1238 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTreePosition@CSpeedTreeRT@@QBEPBMXZ ENDP		; CSpeedTreeRT::GetTreePosition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetSeed@CSpeedTreeRT@@QBEIXZ
_TEXT	SEGMENT
tv132 = -328						; size = 4
tv129 = -328						; size = 4
tv137 = -324						; size = 4
tv136 = -324						; size = 4
tv135 = -324						; size = 4
tv134 = -321						; size = 1
$T2 = -316						; size = 28
$T3 = -280						; size = 28
_cException$4 = -52					; size = 4
_nSeed$ = -40						; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?GetSeed@CSpeedTreeRT@@QBEIXZ PROC			; CSpeedTreeRT::GetSeed, COMDAT
; _this$ = ecx

; 1209 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetSeed@CSpeedTreeRT@@QBEIXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 312				; 00000138H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-136]
	mov	ecx, 30					; 0000001eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1210 :     unsigned int nSeed = 0;

	mov	DWORD PTR _nSeed$[ebp], 0

; 1211 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1212 :     {
; 1213 :         if (m_pEngine->TransientDataIntact( ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?TransientDataIntact@CTreeEngine@@QBE_NXZ ; CTreeEngine::TransientDataIntact
	mov	BYTE PTR tv134[ebp], al
	movzx	ecx, BYTE PTR tv134[ebp]
	test	ecx, ecx
	je	SHORT $LN3@GetSeed

; 1214 :             nSeed = m_pEngine->GetSeed( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetSeed@CTreeEngine@@QBEHXZ		; CTreeEngine::GetSeed
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR tv135[ebp]
	mov	DWORD PTR _nSeed$[ebp], ecx
	jmp	SHORT $LN4@GetSeed
$LN3@GetSeed:

; 1215 :         else
; 1216 :             SetError("SetTreeSize() has no effect after DeleteTransientData() has been called");

	push	OFFSET ??_C@_0EI@JLMDCMOK@SetTreeSize?$CI?$CJ?5has?5no?5effect?5aft@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@GetSeed:

; 1217 :     }

	jmp	$LN6@GetSeed
__catch$?GetSeed@CSpeedTreeRT@@QBEIXZ$0:

; 1218 : 
; 1219 :     SpeedTreeCatch("CSpeedTreeRT::SetTreeSize")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BK@ECGBHBNP@CSpeedTreeRT?3?3SetTreeSize@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv136[ebp], eax
	mov	edx, DWORD PTR tv136[ebp]
	mov	DWORD PTR tv129[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv129[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN12@GetSeed
	ret	0
__catch$?GetSeed@CSpeedTreeRT@@QBEIXZ$1:

; 1220 :     SpeedTreeCatchAll("CSpeedTreeRT::SetTreeSize");

	push	OFFSET ??_C@_0BK@ECGBHBNP@CSpeedTreeRT?3?3SetTreeSize@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv137[ebp], eax
	mov	ecx, DWORD PTR tv137[ebp]
	mov	DWORD PTR tv132[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv132[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN14@GetSeed
	ret	0
$LN6@GetSeed:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN13@GetSeed
$LN14@GetSeed:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN11@GetSeed
$LN13@GetSeed:
	jmp	SHORT $LN11@GetSeed
$LN12@GetSeed:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN11@GetSeed:

; 1221 : 
; 1222 :     return nSeed;

	mov	eax, DWORD PTR _nSeed$[ebp]

; 1223 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@GetSeed
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 328				; 00000148H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@GetSeed:
	DD	1
	DD	$LN17@GetSeed
$LN17@GetSeed:
	DD	-52					; ffffffccH
	DD	4
	DD	$LN15@GetSeed
$LN15@GetSeed:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetSeed@CSpeedTreeRT@@QBEIXZ$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetSeed@CSpeedTreeRT@@QBEIXZ$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?GetSeed@CSpeedTreeRT@@QBEIXZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-332]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetSeed@CSpeedTreeRT@@QBEIXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetSeed@CSpeedTreeRT@@QBEIXZ ENDP			; CSpeedTreeRT::GetSeed
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z
_TEXT	SEGMENT
tv135 = -316						; size = 4
tv132 = -316						; size = 4
tv139 = -312						; size = 4
tv138 = -312						; size = 4
tv137 = -309						; size = 1
$T2 = -304						; size = 28
$T3 = -268						; size = 28
_cException$4 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_fNewSize$ = 8						; size = 4
_fNewVariance$ = 12					; size = 4
?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z PROC		; CSpeedTreeRT::SetTreeSize, COMDAT
; _this$ = ecx

; 1186 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1187 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1188 :     {
; 1189 :         if (m_pEngine->TransientDataIntact( ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?TransientDataIntact@CTreeEngine@@QBE_NXZ ; CTreeEngine::TransientDataIntact
	mov	BYTE PTR tv137[ebp], al
	movzx	ecx, BYTE PTR tv137[ebp]
	test	ecx, ecx
	je	SHORT $LN3@SetTreeSiz

; 1190 :         {
; 1191 :             if (fNewSize > 0.0f)

	movss	xmm0, DWORD PTR _fNewSize$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@SetTreeSiz

; 1192 :                 m_pEngine->SetSize(fNewSize, fNewVariance);

	push	ecx
	movss	xmm0, DWORD PTR _fNewVariance$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fNewSize$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?SetSize@CTreeEngine@@QAEXMM@Z		; CTreeEngine::SetSize
	npad	1
	jmp	SHORT $LN6@SetTreeSiz
$LN5@SetTreeSiz:

; 1193 :             else
; 1194 :                 SetError("SetTreeSize() is only valid for size values greater than 0.0");

	push	OFFSET ??_C@_0DN@HHHECPHJ@SetTreeSize?$CI?$CJ?5is?5only?5valid?5for@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN6@SetTreeSiz:

; 1195 :         }

	jmp	SHORT $LN4@SetTreeSiz
$LN3@SetTreeSiz:

; 1196 :         else
; 1197 :             SetError("SetTreeSize() has no effect after DeleteTransientData() has been called");

	push	OFFSET ??_C@_0EI@JLMDCMOK@SetTreeSize?$CI?$CJ?5has?5no?5effect?5aft@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@SetTreeSiz:

; 1198 :     }

	jmp	$LN8@SetTreeSiz
__catch$?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z$0:

; 1199 : 
; 1200 :     SpeedTreeCatch("CSpeedTreeRT::SetTreeSize")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BK@ECGBHBNP@CSpeedTreeRT?3?3SetTreeSize@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv138[ebp], eax
	mov	edx, DWORD PTR tv138[ebp]
	mov	DWORD PTR tv132[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv132[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN14@SetTreeSiz
	ret	0
__catch$?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z$1:

; 1201 :     SpeedTreeCatchAll("CSpeedTreeRT::SetTreeSize");

	push	OFFSET ??_C@_0BK@ECGBHBNP@CSpeedTreeRT?3?3SetTreeSize@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR tv139[ebp]
	mov	DWORD PTR tv135[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv135[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN16@SetTreeSiz
	ret	0
$LN8@SetTreeSiz:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN15@SetTreeSiz
$LN16@SetTreeSiz:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN13@SetTreeSiz
$LN15@SetTreeSiz:
	jmp	SHORT $LN13@SetTreeSiz
$LN14@SetTreeSiz:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN13@SetTreeSiz:

; 1202 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@SetTreeSiz
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN20@SetTreeSiz:
	DD	1
	DD	$LN19@SetTreeSiz
$LN19@SetTreeSiz:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN17@SetTreeSiz
$LN17@SetTreeSiz:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z ENDP		; CSpeedTreeRT::SetTreeSize
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?GetTreeSize@CSpeedTreeRT@@QBEXAAM0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fSize$ = 8						; size = 4
_fVariance$ = 12					; size = 4
?GetTreeSize@CSpeedTreeRT@@QBEXAAM0@Z PROC		; CSpeedTreeRT::GetTreeSize, COMDAT
; _this$ = ecx

; 1177 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1178 :     m_pEngine->GetSize(fSize, fVariance);

	mov	eax, DWORD PTR _fVariance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetSize@CTreeEngine@@QAEXAAM0@Z	; CTreeEngine::GetSize
	npad	1

; 1179 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetTreeSize@CSpeedTreeRT@@QBEXAAM0@Z ENDP		; CSpeedTreeRT::GetTreeSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z
_TEXT	SEGMENT
tv236 = -356						; size = 4
tv233 = -356						; size = 4
tv246 = -352						; size = 4
tv245 = -352						; size = 4
tv244 = -352						; size = 4
tv242 = -352						; size = 4
tv241 = -352						; size = 4
tv240 = -352						; size = 4
tv239 = -352						; size = 4
tv243 = -349						; size = 1
tv238 = -349						; size = 1
$T2 = -344						; size = 28
$T3 = -308						; size = 28
_cException$4 = -80					; size = 4
_cFile$5 = -68						; size = 20
_pData$ = -40						; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_nNumBytes$ = 8						; size = 4
_bSaveLeaves$ = 12					; size = 1
?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z PROC		; CSpeedTreeRT::SaveTree, COMDAT
; _this$ = ecx

; 1088 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-164]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1089 :     unsigned char* pData = NULL;

	mov	DWORD PTR _pData$[ebp], 0

; 1090 :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1091 :     {
; 1092 :         if (m_pEngine->TransientDataIntact( ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?TransientDataIntact@CTreeEngine@@QBE_NXZ ; CTreeEngine::TransientDataIntact
	mov	BYTE PTR tv238[ebp], al
	movzx	ecx, BYTE PTR tv238[ebp]
	test	ecx, ecx
	je	$LN3@SaveTree

; 1093 :         {
; 1094 :             CTreeFileAccess cFile;

	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	??0CTreeFileAccess@@QAE@XZ		; CTreeFileAccess::CTreeFileAccess
	mov	DWORD PTR tv239[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 1095 :             // save original spt data
; 1096 :             m_pEngine->Save(cFile, bSaveLeaves);

	movzx	eax, BYTE PTR _bSaveLeaves$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cFile$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?Save@CTreeEngine@@QBEXAAVCTreeFileAccess@@_N@Z ; CTreeEngine::Save
	npad	1

; 1097 : 
; 1098 :             // save lighting info
; 1099 :             m_pLightingEngine->Save(cFile);

	lea	eax, DWORD PTR _cFile$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?Save@CLightingEngine@@QAEXAAVCTreeFileAccess@@@Z ; CLightingEngine::Save
	npad	1

; 1100 : 
; 1101 :             // save lod info
; 1102 :             cFile.SaveToken(File_BeginLodInfo);

	push	9000					; 00002328H
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 1103 :             cFile.SaveToken(File_LeafTransitionMethod);

	push	9002					; 0000232aH
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 1104 :             cFile.SaveInt(static_cast<int>(m_eLeafLodMethod));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveInt@CTreeFileAccess@@QAEXH@Z	; CTreeFileAccess::SaveInt
	npad	1

; 1105 :             cFile.SaveToken(File_LeafTransitionRadius);

	push	9003					; 0000232bH
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 1106 :             cFile.SaveFloat(m_fLeafLodTransitionRadius);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+28]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1

; 1107 :             cFile.SaveToken(File_LeafCurveExponent);

	push	9004					; 0000232cH
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 1108 :             cFile.SaveFloat(m_fLeafLodCurveExponent);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1

; 1109 :             cFile.SaveToken(File_LeafSizeIncreaseFactor);

	push	9009					; 00002331H
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 1110 :             cFile.SaveFloat(m_fLeafSizeIncreaseFactor);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1

; 1111 :             m_pEngine->SaveLodInfo(cFile);

	lea	eax, DWORD PTR _cFile$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?SaveLodInfo@CTreeEngine@@QBEXAAVCTreeFileAccess@@@Z ; CTreeEngine::SaveLodInfo
	npad	1

; 1112 :             cFile.SaveToken(File_EndLodInfo);

	push	9001					; 00002329H
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 1113 : 
; 1114 :             // save wind info
; 1115 :             cFile.SaveToken(File_BeginNewWindInfo);

	push	11000					; 00002af8H
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 1116 :             cFile.SaveToken(File_WindLevel);

	push	11002					; 00002afaH
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 1117 :             cFile.SaveInt(m_pEngine->GetBranchLevelForWeighting( ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetBranchLevelForWeighting@CTreeEngine@@QAEHXZ ; CTreeEngine::GetBranchLevelForWeighting
	mov	DWORD PTR tv240[ebp], eax
	mov	ecx, DWORD PTR tv240[ebp]
	push	ecx
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveInt@CTreeFileAccess@@QAEXH@Z	; CTreeFileAccess::SaveInt
	npad	1

; 1118 :             cFile.SaveToken(File_EndNewWindInfo);

	push	11001					; 00002af9H
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 1119 : 
; 1120 :             // save texture coord info
; 1121 :             if (m_pEmbeddedTexCoords)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	SHORT $LN5@SaveTree

; 1122 :                 SaveTextureCoords(&cFile);

	lea	eax, DWORD PTR _cFile$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SaveTextureCoords@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::SaveTextureCoords
	npad	1
$LN5@SaveTree:

; 1123 : 
; 1124 :             // save collision objects
; 1125 :             if (m_pCollisionObjects)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $LN6@SaveTree

; 1126 :                 SaveCollisionObjects(&cFile);

	lea	eax, DWORD PTR _cFile$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SaveCollisionObjects@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::SaveCollisionObjects
	npad	1
$LN6@SaveTree:

; 1127 : 
; 1128 :             // save frond info
; 1129 :             m_pFrondEngine->Save(cFile);

	lea	eax, DWORD PTR _cFile$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+88]
	call	?Save@CFrondEngine@@QBEXAAVCTreeFileAccess@@@Z ; CFrondEngine::Save
	npad	1

; 1130 : 
; 1131 :             // save extras
; 1132 :             m_pEngine->SaveTextureControls(cFile);

	lea	eax, DWORD PTR _cFile$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?SaveTextureControls@CTreeEngine@@QBEXAAVCTreeFileAccess@@@Z ; CTreeEngine::SaveTextureControls
	npad	1

; 1133 :             m_pEngine->SaveFlareInfo(cFile);

	lea	eax, DWORD PTR _cFile$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?SaveFlareInfo@CTreeEngine@@QBEXAAVCTreeFileAccess@@@Z ; CTreeEngine::SaveFlareInfo
	npad	1

; 1134 :             m_pEngine->SaveFlareSeed(cFile);

	lea	eax, DWORD PTR _cFile$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?SaveFlareSeed@CTreeEngine@@QBEXAAVCTreeFileAccess@@@Z ; CTreeEngine::SaveFlareSeed
	npad	1

; 1135 :             cFile.SaveToken(File_LeafTransitionFactor);

	push	16014					; 00003e8eH
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 1136 :             cFile.SaveFloat(m_fLeafTransitionFactor);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1

; 1137 : 
; 1138 :             // save projected shadows
; 1139 :             if (m_pProjectedShadow)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $LN7@SaveTree

; 1140 :                 m_pProjectedShadow->Save(cFile);

	lea	eax, DWORD PTR _cFile$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+80]
	call	?Save@CProjectedShadow@@QBEXAAVCTreeFileAccess@@@Z ; CProjectedShadow::Save
	npad	1
$LN7@SaveTree:

; 1141 : 
; 1142 :             // save user data
; 1143 :             SaveUserData(&cFile);

	lea	eax, DWORD PTR _cFile$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SaveUserData@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::SaveUserData
	npad	1

; 1144 : 
; 1145 :             // save supplemental texcoord info
; 1146 :             if (m_pEmbeddedTexCoords)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	SHORT $LN8@SaveTree

; 1147 :                 SaveSupplementalTexCoordInfo(&cFile);

	lea	eax, DWORD PTR _cFile$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SaveSupplementalTexCoordInfo@CSpeedTreeRT@@ABEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::SaveSupplementalTexCoordInfo
	npad	1
$LN8@SaveTree:

; 1148 : 
; 1149 :             // speedwind scalars
; 1150 :             cFile.SaveToken(File_SpeedWindRockScalar);

	push	21000					; 00005208H
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 1151 :             cFile.SaveFloat(m_pWindEngine->GetSpeedWindRockScalar( ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetSpeedWindRockScalar@CWindEngine@@QBEMXZ ; CWindEngine::GetSpeedWindRockScalar
	fstp	DWORD PTR tv241[ebp]
	push	ecx
	movss	xmm0, DWORD PTR tv241[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1

; 1152 :             cFile.SaveToken(File_SpeedWindRustleScalar);

	push	21001					; 00005209H
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 1153 :             cFile.SaveFloat(m_pWindEngine->GetSpeedWindRustleScalar( ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetSpeedWindRustleScalar@CWindEngine@@QBEMXZ ; CWindEngine::GetSpeedWindRustleScalar
	fstp	DWORD PTR tv242[ebp]
	push	ecx
	movss	xmm0, DWORD PTR tv242[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveFloat@CTreeFileAccess@@QAEXM@Z	; CTreeFileAccess::SaveFloat
	npad	1

; 1154 : 
; 1155 :             // flexibility propagation
; 1156 :             cFile.SaveToken(File_PropagateFlexibility);

	push	22000					; 000055f0H
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveToken@CTreeFileAccess@@QAEXW4EFileToken@@@Z ; CTreeFileAccess::SaveToken
	npad	1

; 1157 :             cFile.SaveBool(CIdvBranch::GetPropagateFlexibility( ));

	call	?GetPropagateFlexibility@CIdvBranch@@SA_NXZ ; CIdvBranch::GetPropagateFlexibility
	mov	BYTE PTR tv243[ebp], al
	movzx	eax, BYTE PTR tv243[ebp]
	push	eax
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?SaveBool@CTreeFileAccess@@QAEX_N@Z	; CTreeFileAccess::SaveBool
	npad	1

; 1158 : 
; 1159 :             // create spt formatted data
; 1160 :             pData = cFile.ConvertMemoryToArray(nNumBytes);

	mov	eax, DWORD PTR _nNumBytes$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	?ConvertMemoryToArray@CTreeFileAccess@@QAEPAEAAI@Z ; CTreeFileAccess::ConvertMemoryToArray
	mov	DWORD PTR tv244[ebp], eax
	mov	ecx, DWORD PTR tv244[ebp]
	mov	DWORD PTR _pData$[ebp], ecx

; 1161 :         }

	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR _cFile$5[ebp]
	call	??1CTreeFileAccess@@QAE@XZ
	npad	1
	jmp	SHORT $LN4@SaveTree
$LN3@SaveTree:

; 1162 :         else
; 1163 :             SetError("cannot Save() after DeleteTransientData() is called");

	push	OFFSET ??_C@_0DE@NCFONFAJ@cannot?5Save?$CI?$CJ?5after?5DeleteTrans@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@SaveTree:

; 1164 :     }

	jmp	$LN10@SaveTree
__catch$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z$0:

; 1165 : 
; 1166 :     SpeedTreeCatch("CSpeedTreeRT::SaveTree")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BH@BABKOJAM@CSpeedTreeRT?3?3SaveTree@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv245[ebp], eax
	mov	edx, DWORD PTR tv245[ebp]
	mov	DWORD PTR tv233[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv233[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN17@SaveTree
	ret	0
__catch$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z$1:

; 1167 :     SpeedTreeCatchAll("CSpeedTreeRT::SaveTree");

	push	OFFSET ??_C@_0BH@BABKOJAM@CSpeedTreeRT?3?3SaveTree@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv246[ebp], eax
	mov	ecx, DWORD PTR tv246[ebp]
	mov	DWORD PTR tv236[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	mov	ecx, DWORD PTR tv236[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN19@SaveTree
	ret	0
$LN10@SaveTree:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN18@SaveTree
$LN19@SaveTree:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN16@SaveTree
$LN18@SaveTree:
	jmp	SHORT $LN16@SaveTree
$LN17@SaveTree:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN16@SaveTree:

; 1168 : 
; 1169 :     return pData;

	mov	eax, DWORD PTR _pData$[ebp]

; 1170 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@SaveTree
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 356				; 00000164H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN24@SaveTree:
	DD	2
	DD	$LN23@SaveTree
$LN23@SaveTree:
	DD	-68					; ffffffbcH
	DD	20					; 00000014H
	DD	$LN20@SaveTree
	DD	-80					; ffffffb0H
	DD	4
	DD	$LN21@SaveTree
$LN21@SaveTree:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN20@SaveTree:
	DB	99					; 00000063H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z$3:
	lea	ecx, DWORD PTR _cFile$5[ebp]
	jmp	??1CTreeFileAccess@@QAE@XZ
__unwindfunclet$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z$4:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z$5:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-360]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SaveTree@CSpeedTreeRT@@QBEPAEAAI_N@Z ENDP		; CSpeedTreeRT::SaveTree
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z
_TEXT	SEGMENT
tv247 = -380						; size = 4
tv244 = -380						; size = 4
tv266 = -376						; size = 4
tv265 = -376						; size = 4
tv264 = -376						; size = 4
tv263 = -376						; size = 4
tv262 = -376						; size = 4
tv261 = -376						; size = 4
tv260 = -376						; size = 4
tv259 = -376						; size = 4
tv258 = -376						; size = 4
tv255 = -376						; size = 4
tv254 = -376						; size = 4
tv253 = -376						; size = 4
tv252 = -376						; size = 4
tv249 = -376						; size = 4
tv81 = -376						; size = 4
tv257 = -373						; size = 1
tv256 = -373						; size = 1
tv251 = -373						; size = 1
tv250 = -373						; size = 1
$T2 = -368						; size = 28
$T3 = -332						; size = 28
_cException$4 = -104					; size = 4
_nToken$5 = -92						; size = 4
_bEndOfFile$6 = -77					; size = 1
_cFile$7 = -68						; size = 20
_bSuccess$ = -37					; size = 1
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_pBlock$ = 8						; size = 4
_nNumBytes$ = 12					; size = 4
?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z PROC		; CSpeedTreeRT::LoadTree, COMDAT
; _this$ = ecx

; 975  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 364				; 0000016cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-188]
	mov	ecx, 43					; 0000002bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 976  : //lint -e537  { it's OK that this file is included twice }
; 977  : //#include "EvalTest.h"
; 978  : 
; 979  :     bool bSuccess = false;

	mov	BYTE PTR _bSuccess$[ebp], 0

; 980  :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 981  :     {
; 982  :         CTreeFileAccess cFile(pBlock, nNumBytes);

	mov	eax, DWORD PTR _nNumBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBlock$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _cFile$7[ebp]
	call	??0CTreeFileAccess@@QAE@PBEH@Z		; CTreeFileAccess::CTreeFileAccess
	mov	DWORD PTR tv249[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 983  :         if (m_pEngine->Parse(cFile))

	lea	eax, DWORD PTR _cFile$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?Parse@CTreeEngine@@QAE_NAAVCTreeFileAccess@@@Z ; CTreeEngine::Parse
	mov	BYTE PTR tv250[ebp], al
	movzx	edx, BYTE PTR tv250[ebp]
	test	edx, edx
	je	$LN8@LoadTree

; 984  :         {
; 985  :             if (!cFile.EndOfFile( ))

	lea	ecx, DWORD PTR _cFile$7[ebp]
	call	?EndOfFile@CTreeFileAccess@@QBE_NXZ	; CTreeFileAccess::EndOfFile
	mov	BYTE PTR tv251[ebp], al
	movzx	eax, BYTE PTR tv251[ebp]
	test	eax, eax
	jne	$LN3@LoadTree

; 986  :             {
; 987  :                 // New spt data is saved after all original format to
; 988  :                 // maintain backward compatibility
; 989  : 
; 990  :                 bool bEndOfFile = false;

	mov	BYTE PTR _bEndOfFile$6[ebp], 0

; 991  :                 int nToken = cFile.ParseToken( );

	lea	ecx, DWORD PTR _cFile$7[ebp]
	call	?ParseToken@CTreeFileAccess@@QAE?AW4EFileToken@@XZ ; CTreeFileAccess::ParseToken
	mov	DWORD PTR tv252[ebp], eax
	mov	eax, DWORD PTR tv252[ebp]
	mov	DWORD PTR _nToken$5[ebp], eax
$LN4@LoadTree:

; 992  :                 do
; 993  :                 {
; 994  :                     switch (nToken)

	mov	eax, DWORD PTR _nToken$5[ebp]
	mov	DWORD PTR tv81[ebp], eax
	cmp	DWORD PTR tv81[ebp], 16013		; 00003e8dH
	jg	$LN31@LoadTree
	cmp	DWORD PTR tv81[ebp], 16013		; 00003e8dH
	je	$LN18@LoadTree
	cmp	DWORD PTR tv81[ebp], 12000		; 00002ee0H
	jg	SHORT $LN32@LoadTree
	cmp	DWORD PTR tv81[ebp], 12000		; 00002ee0H
	je	$LN14@LoadTree
	cmp	DWORD PTR tv81[ebp], 10000		; 00002710H
	jg	SHORT $LN33@LoadTree
	cmp	DWORD PTR tv81[ebp], 10000		; 00002710H
	je	$LN13@LoadTree
	cmp	DWORD PTR tv81[ebp], 8000		; 00001f40H
	je	$LN10@LoadTree
	cmp	DWORD PTR tv81[ebp], 9000		; 00002328H
	je	$LN11@LoadTree
	jmp	$LN26@LoadTree
$LN33@LoadTree:
	cmp	DWORD PTR tv81[ebp], 11000		; 00002af8H
	je	$LN12@LoadTree
	jmp	$LN26@LoadTree
$LN32@LoadTree:
	cmp	DWORD PTR tv81[ebp], 13000		; 000032c8H
	je	$LN15@LoadTree
	cmp	DWORD PTR tv81[ebp], 15000		; 00003a98H
	je	$LN16@LoadTree
	cmp	DWORD PTR tv81[ebp], 16000		; 00003e80H
	je	$LN17@LoadTree
	jmp	$LN26@LoadTree
$LN31@LoadTree:
	cmp	DWORD PTR tv81[ebp], 20000		; 00004e20H
	jg	SHORT $LN34@LoadTree
	cmp	DWORD PTR tv81[ebp], 20000		; 00004e20H
	je	$LN22@LoadTree
	cmp	DWORD PTR tv81[ebp], 16014		; 00003e8eH
	je	$LN19@LoadTree
	cmp	DWORD PTR tv81[ebp], 18000		; 00004650H
	je	$LN20@LoadTree
	cmp	DWORD PTR tv81[ebp], 19000		; 00004a38H
	je	$LN21@LoadTree
	jmp	$LN26@LoadTree
$LN34@LoadTree:
	cmp	DWORD PTR tv81[ebp], 21000		; 00005208H
	je	$LN23@LoadTree
	cmp	DWORD PTR tv81[ebp], 21001		; 00005209H
	je	$LN24@LoadTree
	cmp	DWORD PTR tv81[ebp], 22000		; 000055f0H
	je	$LN25@LoadTree
	jmp	$LN26@LoadTree
$LN10@LoadTree:

; 995  :                     {
; 996  :                     case File_BeginLightingInfo:
; 997  :                         m_pLightingEngine->Parse(cFile);

	lea	eax, DWORD PTR _cFile$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?Parse@CLightingEngine@@QAEXAAVCTreeFileAccess@@@Z ; CLightingEngine::Parse
	npad	1

; 998  :                         break;

	jmp	$LN5@LoadTree
$LN11@LoadTree:

; 999  :                     case File_BeginLodInfo:
; 1000 :                         ParseLodInfo(&cFile);

	lea	eax, DWORD PTR _cFile$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ParseLodInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::ParseLodInfo
	npad	1

; 1001 :                         break;

	jmp	$LN5@LoadTree
$LN12@LoadTree:

; 1002 :                     case File_BeginNewWindInfo:
; 1003 :                         ParseWindInfo(&cFile);

	lea	eax, DWORD PTR _cFile$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ParseWindInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::ParseWindInfo
	npad	1

; 1004 :                         break;

	jmp	$LN5@LoadTree
$LN13@LoadTree:

; 1005 :                     case File_BeginTextureCoordInfo:
; 1006 :                         ParseTextureCoordInfo(&cFile);

	lea	eax, DWORD PTR _cFile$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ParseTextureCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::ParseTextureCoordInfo
	npad	1

; 1007 :                         break;

	jmp	$LN5@LoadTree
$LN14@LoadTree:

; 1008 :                     case File_BeginCollisionInfo:
; 1009 :                         ParseCollisionObjects(&cFile);

	lea	eax, DWORD PTR _cFile$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ParseCollisionObjects@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::ParseCollisionObjects
	npad	1

; 1010 :                         break;

	jmp	$LN5@LoadTree
$LN15@LoadTree:

; 1011 :                     case File_BeginFrondInfo:
; 1012 :                         m_pFrondEngine->Parse(cFile);

	lea	eax, DWORD PTR _cFile$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+88]
	call	?Parse@CFrondEngine@@QAEXAAVCTreeFileAccess@@@Z ; CFrondEngine::Parse
	npad	1

; 1013 :                         break;

	jmp	$LN5@LoadTree
$LN16@LoadTree:

; 1014 :                     case File_BeginTextureControls:
; 1015 :                         m_pEngine->ParseTextureControls(cFile);

	lea	eax, DWORD PTR _cFile$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?ParseTextureControls@CTreeEngine@@QAEXAAVCTreeFileAccess@@@Z ; CTreeEngine::ParseTextureControls
	npad	1

; 1016 :                         break;

	jmp	$LN5@LoadTree
$LN17@LoadTree:

; 1017 :                     case File_BeginFlareInfo:
; 1018 :                         m_pEngine->ParseFlareInfo(cFile);

	lea	eax, DWORD PTR _cFile$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?ParseFlareInfo@CTreeEngine@@QAEXAAVCTreeFileAccess@@@Z ; CTreeEngine::ParseFlareInfo
	npad	1

; 1019 :                         break;

	jmp	$LN5@LoadTree
$LN18@LoadTree:

; 1020 :                     case File_FlareSeed:
; 1021 :                         m_pEngine->ParseFlareSeed(cFile);

	lea	eax, DWORD PTR _cFile$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?ParseFlareSeed@CTreeEngine@@QAEXAAVCTreeFileAccess@@@Z ; CTreeEngine::ParseFlareSeed
	npad	1

; 1022 :                         break;

	jmp	$LN5@LoadTree
$LN19@LoadTree:

; 1023 :                     case File_LeafTransitionFactor:
; 1024 :                         m_fLeafTransitionFactor = cFile.ParseFloat( );

	lea	ecx, DWORD PTR _cFile$7[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	fstp	DWORD PTR tv253[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv253[ebp]
	movss	DWORD PTR [eax+40], xmm0

; 1025 :                         break;

	jmp	$LN5@LoadTree
$LN20@LoadTree:

; 1026 :                     case File_BeginShadowProjectionInfo:
; 1027 :                         ParseShadowProjectionInfo(&cFile);

	lea	eax, DWORD PTR _cFile$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ParseShadowProjectionInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::ParseShadowProjectionInfo
	npad	1

; 1028 :                         break;

	jmp	$LN5@LoadTree
$LN21@LoadTree:

; 1029 :                     case File_BeginUserData:
; 1030 :                         ParseUserData(&cFile);

	lea	eax, DWORD PTR _cFile$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ParseUserData@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::ParseUserData
	npad	1

; 1031 :                         break;

	jmp	$LN5@LoadTree
$LN22@LoadTree:

; 1032 :                     case File_BeginSupplementalTexCoordInfo:
; 1033 :                         ParseSupplementalTexCoordInfo(&cFile);

	lea	eax, DWORD PTR _cFile$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ParseSupplementalTexCoordInfo@CSpeedTreeRT@@AAEXPAVCTreeFileAccess@@@Z ; CSpeedTreeRT::ParseSupplementalTexCoordInfo
	npad	1

; 1034 :                         break;

	jmp	SHORT $LN5@LoadTree
$LN23@LoadTree:

; 1035 :                     case File_SpeedWindRockScalar:
; 1036 :                         m_pWindEngine->SetSpeedWindRockScalar(cFile.ParseFloat( ));

	lea	ecx, DWORD PTR _cFile$7[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	fstp	DWORD PTR tv254[ebp]
	push	ecx
	movss	xmm0, DWORD PTR tv254[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?SetSpeedWindRockScalar@CWindEngine@@QAEXM@Z ; CWindEngine::SetSpeedWindRockScalar
	npad	1

; 1037 :                         break;

	jmp	SHORT $LN5@LoadTree
$LN24@LoadTree:

; 1038 :                     case File_SpeedWindRustleScalar:
; 1039 :                         m_pWindEngine->SetSpeedWindRustleScalar(cFile.ParseFloat( ));

	lea	ecx, DWORD PTR _cFile$7[ebp]
	call	?ParseFloat@CTreeFileAccess@@QAEMXZ	; CTreeFileAccess::ParseFloat
	fstp	DWORD PTR tv255[ebp]
	push	ecx
	movss	xmm0, DWORD PTR tv255[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?SetSpeedWindRustleScalar@CWindEngine@@QAEXM@Z ; CWindEngine::SetSpeedWindRustleScalar
	npad	1

; 1040 :                         break;

	jmp	SHORT $LN5@LoadTree
$LN25@LoadTree:

; 1041 :                     case File_PropagateFlexibility:
; 1042 :                         CIdvBranch::SetPropagateFlexibility(cFile.ParseBool( ));

	lea	ecx, DWORD PTR _cFile$7[ebp]
	call	?ParseBool@CTreeFileAccess@@QAE_NXZ	; CTreeFileAccess::ParseBool
	mov	BYTE PTR tv256[ebp], al
	movzx	eax, BYTE PTR tv256[ebp]
	push	eax
	call	?SetPropagateFlexibility@CIdvBranch@@SAX_N@Z ; CIdvBranch::SetPropagateFlexibility
	add	esp, 4

; 1043 :                         break;

	jmp	SHORT $LN5@LoadTree
$LN26@LoadTree:

; 1044 :                     default:
; 1045 :                         bEndOfFile = true;

	mov	BYTE PTR _bEndOfFile$6[ebp], 1
$LN5@LoadTree:

; 1046 :                     }
; 1047 :                     if (cFile.EndOfFile( ))

	lea	ecx, DWORD PTR _cFile$7[ebp]
	call	?EndOfFile@CTreeFileAccess@@QBE_NXZ	; CTreeFileAccess::EndOfFile
	mov	BYTE PTR tv257[ebp], al
	movzx	eax, BYTE PTR tv257[ebp]
	test	eax, eax
	je	SHORT $LN27@LoadTree

; 1048 :                         bEndOfFile = true;

	mov	BYTE PTR _bEndOfFile$6[ebp], 1
	jmp	SHORT $LN28@LoadTree
$LN27@LoadTree:

; 1049 :                     else
; 1050 :                         nToken = cFile.ParseToken( );

	lea	ecx, DWORD PTR _cFile$7[ebp]
	call	?ParseToken@CTreeFileAccess@@QAE?AW4EFileToken@@XZ ; CTreeFileAccess::ParseToken
	mov	DWORD PTR tv258[ebp], eax
	mov	eax, DWORD PTR tv258[ebp]
	mov	DWORD PTR _nToken$5[ebp], eax
$LN28@LoadTree:

; 1051 :                 } while (!bEndOfFile);

	movzx	eax, BYTE PTR _bEndOfFile$6[ebp]
	test	eax, eax
	je	$LN4@LoadTree
$LN3@LoadTree:

; 1052 :             }
; 1053 : 
; 1054 :             // update all lighting data
; 1055 :             SetBranchLightingMethod(m_pLightingEngine->GetBranchLightingMethod( ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetBranchLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ ; CLightingEngine::GetBranchLightingMethod
	mov	DWORD PTR tv259[ebp], eax
	mov	ecx, DWORD PTR tv259[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z ; CSpeedTreeRT::SetBranchLightingMethod
	npad	1

; 1056 :             SetLeafLightingMethod(m_pLightingEngine->GetLeafLightingMethod( ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetLeafLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ ; CLightingEngine::GetLeafLightingMethod
	mov	DWORD PTR tv260[ebp], eax
	mov	ecx, DWORD PTR tv260[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z ; CSpeedTreeRT::SetLeafLightingMethod
	npad	1

; 1057 :             SetFrondLightingMethod(m_pLightingEngine->GetFrondLightingMethod( ));       

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetFrondLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ ; CLightingEngine::GetFrondLightingMethod
	mov	DWORD PTR tv261[ebp], eax
	mov	ecx, DWORD PTR tv261[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z ; CSpeedTreeRT::SetFrondLightingMethod
	npad	1

; 1058 : 
; 1059 :             // extract other data for later queries
; 1060 :             m_nBranchWindLevel = m_pEngine->GetBranchLevelForWeighting( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetBranchLevelForWeighting@CTreeEngine@@QAEHXZ ; CTreeEngine::GetBranchLevelForWeighting
	mov	DWORD PTR tv262[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv262[ebp]
	mov	DWORD PTR [ecx+72], edx

; 1061 :             m_nFrondLevel = m_pFrondEngine->GetLevel( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	call	?GetLevel@CFrondEngine@@QBEHXZ		; CFrondEngine::GetLevel
	mov	DWORD PTR tv263[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv263[ebp]
	mov	DWORD PTR [ecx+60], edx

; 1062 : 
; 1063 :             // handle obsolete smooth_2 setting
; 1064 :             if (m_eLeafLodMethod == 2)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 2
	jne	SHORT $LN29@LoadTree

; 1065 :             {
; 1066 :                 m_eLeafLodMethod = CSpeedTreeRT::LOD_SMOOTH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 1

; 1067 :                 m_fLeafTransitionFactor = 0.5f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [eax+40], xmm0
$LN29@LoadTree:

; 1068 :             }
; 1069 : 
; 1070 :             // make matrix span match number of available matrices
; 1071 :             m_pWindEngine->SetLocalMatrices(0, m_pWindEngine->GetNumWindMatrices( ));

	call	?GetNumWindMatrices@CWindEngine@@SAIXZ	; CWindEngine::GetNumWindMatrices
	mov	DWORD PTR tv264[ebp], eax
	mov	eax, DWORD PTR tv264[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+16]
	call	?SetLocalMatrices@CWindEngine@@QAEXII@Z	; CWindEngine::SetLocalMatrices
	npad	1

; 1072 : 
; 1073 :             bSuccess = true;

	mov	BYTE PTR _bSuccess$[ebp], 1
$LN8@LoadTree:

; 1074 :         }
; 1075 :     }

	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR _cFile$7[ebp]
	call	??1CTreeFileAccess@@QAE@XZ
	npad	1
	jmp	$LN35@LoadTree
__catch$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z$0:

; 1076 : 
; 1077 :     SpeedTreeCatch("CSpeedTreeRT::LoadTree")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BH@BPMMAHHL@CSpeedTreeRT?3?3LoadTree@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv265[ebp], eax
	mov	edx, DWORD PTR tv265[ebp]
	mov	DWORD PTR tv244[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv244[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN42@LoadTree
	ret	0
__catch$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z$1:

; 1078 :     SpeedTreeCatchAll("CSpeedTreeRT::LoadTree");

	push	OFFSET ??_C@_0BH@BPMMAHHL@CSpeedTreeRT?3?3LoadTree@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv266[ebp], eax
	mov	ecx, DWORD PTR tv266[ebp]
	mov	DWORD PTR tv247[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	mov	ecx, DWORD PTR tv247[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN44@LoadTree
	ret	0
$LN35@LoadTree:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN43@LoadTree
$LN44@LoadTree:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN41@LoadTree
$LN43@LoadTree:
	jmp	SHORT $LN41@LoadTree
$LN42@LoadTree:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN41@LoadTree:

; 1079 : 
; 1080 :     return bSuccess;

	movzx	eax, BYTE PTR _bSuccess$[ebp]

; 1081 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN49@LoadTree
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 380				; 0000017cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN49@LoadTree:
	DD	2
	DD	$LN48@LoadTree
$LN48@LoadTree:
	DD	-68					; ffffffbcH
	DD	20					; 00000014H
	DD	$LN45@LoadTree
	DD	-104					; ffffff98H
	DD	4
	DD	$LN46@LoadTree
$LN46@LoadTree:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN45@LoadTree:
	DB	99					; 00000063H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z$3:
	lea	ecx, DWORD PTR _cFile$7[ebp]
	jmp	??1CTreeFileAccess@@QAE@XZ
__unwindfunclet$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z$4:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z$5:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-384]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z ENDP		; CSpeedTreeRT::LoadTree
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z
_TEXT	SEGMENT
tv210 = -580						; size = 4
tv207 = -580						; size = 4
tv205 = -580						; size = 4
tv203 = -580						; size = 4
tv201 = -580						; size = 4
tv218 = -576						; size = 4
tv217 = -576						; size = 4
tv216 = -576						; size = 4
tv215 = -576						; size = 4
tv214 = -576						; size = 4
tv212 = -576						; size = 4
tv213 = -573						; size = 1
$T2 = -568						; size = 28
$T3 = -532						; size = 28
$T4 = -496						; size = 28
$T5 = -460						; size = 12
$T6 = -440						; size = 28
$T7 = -404						; size = 12
$T8 = -384						; size = 28
$T9 = -348						; size = 12
$T10 = -328						; size = 4
$T11 = -316						; size = 4
_cException$12 = -112					; size = 4
_nBytesRead$13 = -100					; size = 4
_nErrorCode$14 = -88					; size = 4
_nNumBytes$15 = -76					; size = 4
_pFile$16 = -64						; size = 4
_pMemory$ = -52						; size = 4
_bSuccess$ = -37					; size = 1
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_pFilename$ = 8						; size = 4
?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z PROC			; CSpeedTreeRT::LoadTree, COMDAT
; _this$ = ecx

; 911  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 564				; 00000234H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 93					; 0000005dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 912  : //#include "EvalTest.h"
; 913  : 
; 914  :     bool bSuccess = false;

	mov	BYTE PTR _bSuccess$[ebp], 0

; 915  :     unsigned char* pMemory = NULL;

	mov	DWORD PTR _pMemory$[ebp], 0

; 916  : 
; 917  :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 918  :     {
; 919  :         if (pFilename)

	cmp	DWORD PTR _pFilename$[ebp], 0
	je	$LN5@LoadTree

; 920  :         {
; 921  :             FILE* pFile = fopen(pFilename, "rb");

	mov	esi, esp
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _pFilename$[ebp]
	push	eax
	call	DWORD PTR __imp__fopen
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pFile$16[ebp], eax

; 922  :             if (pFile)

	cmp	DWORD PTR _pFile$16[ebp], 0
	je	$LN4@LoadTree

; 923  :             {
; 924  :                 fseek(pFile, 0L, SEEK_END);

	mov	esi, esp
	push	2
	push	0
	mov	eax, DWORD PTR _pFile$16[ebp]
	push	eax
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1

; 925  :                 int nNumBytes = ftell(pFile);

	mov	esi, esp
	mov	eax, DWORD PTR _pFile$16[ebp]
	push	eax
	call	DWORD PTR __imp__ftell
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nNumBytes$15[ebp], eax

; 926  :                 int nErrorCode = fseek(pFile, 0, SEEK_SET);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _pFile$16[ebp]
	push	eax
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nErrorCode$14[ebp], eax

; 927  : 
; 928  :                 if (nNumBytes > 0 &&

	cmp	DWORD PTR _nNumBytes$15[ebp], 0
	jle	$LN6@LoadTree
	cmp	DWORD PTR _nErrorCode$14[ebp], 0
	jl	$LN6@LoadTree

; 929  :                     nErrorCode >= 0)
; 930  :                 {
; 931  :                     // read all of the file into memory, then pass into other Parse() function
; 932  :                     pMemory = new unsigned char[nNumBytes];

	mov	eax, DWORD PTR _nNumBytes$15[ebp]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR tv212[ebp], eax
	mov	ecx, DWORD PTR tv212[ebp]
	mov	DWORD PTR $T11[ebp], ecx
	mov	edx, DWORD PTR $T11[ebp]
	mov	DWORD PTR _pMemory$[ebp], edx

; 933  :                     int nBytesRead = fread(pMemory, 1, nNumBytes, pFile);

	mov	esi, esp
	mov	eax, DWORD PTR _pFile$16[ebp]
	push	eax
	mov	ecx, DWORD PTR _nNumBytes$15[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _pMemory$[ebp]
	push	edx
	call	DWORD PTR __imp__fread
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nBytesRead$13[ebp], eax

; 934  :                     if (nBytesRead == nNumBytes)

	mov	eax, DWORD PTR _nBytesRead$13[ebp]
	cmp	eax, DWORD PTR _nNumBytes$15[ebp]
	jne	SHORT $LN8@LoadTree

; 935  :                     {
; 936  :                         bSuccess = LoadTree(pMemory, nNumBytes);

	mov	eax, DWORD PTR _nNumBytes$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMemory$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z	; CSpeedTreeRT::LoadTree
	mov	BYTE PTR tv213[ebp], al
	mov	dl, BYTE PTR tv213[ebp]
	mov	BYTE PTR _bSuccess$[ebp], dl

; 937  : 
; 938  :                         delete[] pMemory;

	mov	eax, DWORD PTR _pMemory$[ebp]
	mov	DWORD PTR $T10[ebp], eax
	mov	ecx, DWORD PTR $T10[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 939  :                         pMemory = NULL;

	mov	DWORD PTR _pMemory$[ebp], 0

; 940  :                     }

	jmp	$LN9@LoadTree
$LN8@LoadTree:

; 941  :                     else
; 942  :                         throw(exception(IdvFormatString("only read %d of %d from %s [%s]", nBytesRead, nNumBytes, pFilename, strerror(errno)).c_str( )));

	mov	esi, esp
	call	DWORD PTR __imp___errno
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp__strerror
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	ecx, DWORD PTR _pFilename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nNumBytes$15[ebp]
	push	edx
	mov	eax, DWORD PTR _nBytesRead$13[ebp]
	push	eax
	push	OFFSET ??_C@_0CA@IGGBMNBO@only?5read?5?$CFd?5of?5?$CFd?5from?5?$CFs?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T8[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv214[ebp], eax
	mov	edx, DWORD PTR tv214[ebp]
	mov	DWORD PTR tv201[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	mov	ecx, DWORD PTR tv201[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	lea	ecx, DWORD PTR $T9[ebp]
	call	??0exception@std@@QAE@QBD@Z		; std::exception::exception
	push	OFFSET __TI1?AVexception@std@@
	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	call	__CxxThrowException@8
	npad	1
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR $T8[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN9@LoadTree:

; 943  : 
; 944  :                     // in our experience, fclose doesn't always give accurate return values
; 945  :                     (void) fclose(pFile);

	mov	esi, esp
	mov	eax, DWORD PTR _pFile$16[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1

; 946  :                 }

	jmp	$LN7@LoadTree
$LN6@LoadTree:

; 947  :                 else
; 948  :                     throw(exception(IdvFormatString("file seek failed on '%s' [%s]", pFilename, strerror(errno)).c_str( )));

	mov	esi, esp
	call	DWORD PTR __imp___errno
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp__strerror
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	ecx, DWORD PTR _pFilename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BO@LOAPLEHO@file?5seek?5failed?5on?5?8?$CFs?8?5?$FL?$CFs?$FN@
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv215[ebp], eax
	mov	eax, DWORD PTR tv215[ebp]
	mov	DWORD PTR tv203[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv203[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	lea	ecx, DWORD PTR $T7[ebp]
	call	??0exception@std@@QAE@QBD@Z		; std::exception::exception
	push	OFFSET __TI1?AVexception@std@@
	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	call	__CxxThrowException@8
	npad	1
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN7@LoadTree:

; 949  :             }

	jmp	$LN5@LoadTree
$LN4@LoadTree:

; 950  :             else
; 951  :                 throw(exception(IdvFormatString("failed to load file '%s' [%s]", pFilename, strerror(errno)).c_str( )));

	mov	esi, esp
	call	DWORD PTR __imp___errno
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp__strerror
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	ecx, DWORD PTR _pFilename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BO@MBMLMKLB@failed?5to?5load?5file?5?8?$CFs?8?5?$FL?$CFs?$FN@
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv216[ebp], eax
	mov	eax, DWORD PTR tv216[ebp]
	mov	DWORD PTR tv205[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv205[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0exception@std@@QAE@QBD@Z		; std::exception::exception
	push	OFFSET __TI1?AVexception@std@@
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	call	__CxxThrowException@8
	npad	1
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN5@LoadTree:

; 952  :         }
; 953  :     }

	jmp	$LN11@LoadTree
__catch$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z$0:

; 954  : 
; 955  :     catch (exception& cException)
; 956  :     {
; 957  :         pMemory = NULL;

	mov	DWORD PTR _pMemory$[ebp], 0

; 958  :         SetError(IdvFormatString("CSpeedTreeRT::Load Tree - %s", cException.what( )).c_str( ));

	mov	esi, esp
	mov	eax, DWORD PTR _cException$12[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$12[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BN@EBOIGFHO@CSpeedTreeRT?3?3Load?5Tree?5?9?5?$CFs@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv217[ebp], eax
	mov	edx, DWORD PTR tv217[ebp]
	mov	DWORD PTR tv207[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 5
	mov	ecx, DWORD PTR tv207[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 959  :     }

	mov	eax, $LN20@LoadTree
	ret	0
__catch$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z$1:

; 960  : 
; 961  :     catch (...)
; 962  :     {
; 963  :         pMemory = NULL;

	mov	DWORD PTR _pMemory$[ebp], 0

; 964  :         SetError(IdvFormatString("CSpeedTreeRT::LoadTree - threw an unknown system exception").c_str( ));

	push	OFFSET ??_C@_0DL@NANINALL@CSpeedTreeRT?3?3LoadTree?5?9?5threw?5@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 8
	mov	DWORD PTR tv218[ebp], eax
	mov	ecx, DWORD PTR tv218[ebp]
	mov	DWORD PTR tv210[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 6
	mov	ecx, DWORD PTR tv210[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 965  :     }

	mov	eax, $LN22@LoadTree
	ret	0
$LN11@LoadTree:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN21@LoadTree
$LN22@LoadTree:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN19@LoadTree
$LN21@LoadTree:
	jmp	SHORT $LN19@LoadTree
$LN20@LoadTree:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN19@LoadTree:

; 966  : 
; 967  :     return bSuccess;

	mov	al, BYTE PTR _bSuccess$[ebp]
$LN1@LoadTree:

; 968  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN26@LoadTree
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 580				; 00000244H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN26@LoadTree:
	DD	1
	DD	$LN25@LoadTree
$LN25@LoadTree:
	DD	-112					; ffffff90H
	DD	4
	DD	$LN23@LoadTree
$LN23@LoadTree:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z$3:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z$4:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z$5:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z$6:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z$7:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-584]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z ENDP			; CSpeedTreeRT::LoadTree
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?DeleteTransientData@CSpeedTreeRT@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?DeleteTransientData@CSpeedTreeRT@@QAEXXZ PROC		; CSpeedTreeRT::DeleteTransientData, COMDAT
; _this$ = ecx

; 899  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 900  :     if (m_pEngine->TransientDataIntact( ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?TransientDataIntact@CTreeEngine@@QBE_NXZ ; CTreeEngine::TransientDataIntact
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@DeleteTran

; 901  :         m_pEngine->FreeTransientData( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?FreeTransientData@CTreeEngine@@QAEXXZ	; CTreeEngine::FreeTransientData
	npad	1
	jmp	SHORT $LN3@DeleteTran
$LN2@DeleteTran:

; 902  :     else
; 903  :         SetError("DeleteTransientData() called with no intact transient data");

	push	OFFSET ??_C@_0DL@JAMEDGDD@DeleteTransientData?$CI?$CJ?5called?5wi@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN3@DeleteTran:

; 904  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DeleteTransientData@CSpeedTreeRT@@QAEXXZ ENDP		; CSpeedTreeRT::DeleteTransientData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ
_TEXT	SEGMENT
tv80 = -356						; size = 4
tv145 = -352						; size = 4
tv141 = -352						; size = 4
tv138 = -352						; size = 4
tv147 = -348						; size = 4
tv146 = -348						; size = 4
tv144 = -348						; size = 4
tv143 = -345						; size = 1
$T2 = -340						; size = 28
$T3 = -304						; size = 28
$T4 = -268						; size = 4
$T5 = -256						; size = 4
_cException$6 = -52					; size = 4
_pInstance$ = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ PROC		; CSpeedTreeRT::MakeInstance, COMDAT
; _this$ = ecx

; 875  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-164]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 876  :     CSpeedTreeRT* pInstance = NULL;

	mov	DWORD PTR _pInstance$[ebp], 0

; 877  :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 878  :     {
; 879  :         // we can only make instances if the transient data is intact
; 880  :         if (m_pEngine->TransientDataIntact( ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?TransientDataIntact@CTreeEngine@@QBE_NXZ ; CTreeEngine::TransientDataIntact
	mov	BYTE PTR tv143[ebp], al
	movzx	ecx, BYTE PTR tv143[ebp]
	test	ecx, ecx
	je	SHORT $LN3@MakeInstan

; 881  :         {
; 882  :             pInstance = new CSpeedTreeRT(this);

	push	156					; 0000009cH
	call	??2CSpeedTreeRT@@SAPAXI@Z		; CSpeedTreeRT::operator new
	add	esp, 4
	mov	DWORD PTR tv144[ebp], eax
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN6@MakeInstan
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0CSpeedTreeRT@@AAE@PBV0@@Z		; CSpeedTreeRT::CSpeedTreeRT
	mov	DWORD PTR tv145[ebp], eax
	mov	edx, DWORD PTR tv145[ebp]
	mov	DWORD PTR tv80[ebp], edx
	jmp	SHORT $LN7@MakeInstan
$LN6@MakeInstan:
	mov	DWORD PTR tv80[ebp], 0
$LN7@MakeInstan:
	mov	eax, DWORD PTR tv80[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _pInstance$[ebp], ecx

; 883  :         }

	jmp	SHORT $LN4@MakeInstan
$LN3@MakeInstan:

; 884  :         else
; 885  :             SetError("cannot MakeInstance() after calling DeleteTransientData()");

	push	OFFSET ??_C@_0DK@LEEALHFM@cannot?5MakeInstance?$CI?$CJ?5after?5cal@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@MakeInstan:

; 886  :     }

	jmp	$LN8@MakeInstan
__catch$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ$0:

; 887  : 
; 888  :     SpeedTreeCatch("CSpeedTreeRT::MakeInstance")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$6[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$6[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BL@PNFDFAFA@CSpeedTreeRT?3?3MakeInstance@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv146[ebp], eax
	mov	edx, DWORD PTR tv146[ebp]
	mov	DWORD PTR tv138[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv138[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN15@MakeInstan
	ret	0
__catch$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ$1:

; 889  :     SpeedTreeCatchAll("CSpeedTreeRT::MakeInstance");

	push	OFFSET ??_C@_0BL@PNFDFAFA@CSpeedTreeRT?3?3MakeInstance@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv147[ebp], eax
	mov	ecx, DWORD PTR tv147[ebp]
	mov	DWORD PTR tv141[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	mov	ecx, DWORD PTR tv141[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN17@MakeInstan
	ret	0
$LN8@MakeInstan:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN16@MakeInstan
$LN17@MakeInstan:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN14@MakeInstan
$LN16@MakeInstan:
	jmp	SHORT $LN14@MakeInstan
$LN15@MakeInstan:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN14@MakeInstan:

; 890  : 
; 891  :     return pInstance;

	mov	eax, DWORD PTR _pInstance$[ebp]

; 892  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN21@MakeInstan
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 356				; 00000164H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN21@MakeInstan:
	DD	1
	DD	$LN20@MakeInstan
$LN20@MakeInstan:
	DD	-52					; ffffffccH
	DD	4
	DD	$LN18@MakeInstan
$LN18@MakeInstan:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ$3:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3CSpeedTreeRT@@SAXPAX@Z		; CSpeedTreeRT::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ$4:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ$5:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-360]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ ENDP		; CSpeedTreeRT::MakeInstance
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?InstanceOf@CSpeedTreeRT@@QBEPBV1@XZ
_TEXT	SEGMENT
_pParent$ = -20						; size = 4
_this$ = -8						; size = 4
?InstanceOf@CSpeedTreeRT@@QBEPBV1@XZ PROC		; CSpeedTreeRT::InstanceOf, COMDAT
; _this$ = ecx

; 862  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 863  :     const CSpeedTreeRT* pParent = NULL;

	mov	DWORD PTR _pParent$[ebp], 0

; 864  :     if (m_pInstanceData)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN2@InstanceOf

; 865  :         pParent = m_pInstanceData->m_pParent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pParent$[ebp], edx
$LN2@InstanceOf:

; 866  : 
; 867  :     return pParent;

	mov	eax, DWORD PTR _pParent$[ebp]

; 868  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InstanceOf@CSpeedTreeRT@@QBEPBV1@XZ ENDP		; CSpeedTreeRT::InstanceOf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z
_TEXT	SEGMENT
tv393 = -452						; size = 4
tv389 = -452						; size = 4
tv392 = -448						; size = 4
tv388 = -448						; size = 4
tv224 = -448						; size = 4
tv206 = -448						; size = 4
tv79 = -448						; size = 4
tv391 = -444						; size = 4
tv387 = -444						; size = 4
tv383 = -444						; size = 4
tv380 = -444						; size = 4
tv378 = -444						; size = 4
tv367 = -444						; size = 4
tv363 = -444						; size = 4
tv360 = -444						; size = 4
tv239 = -444						; size = 4
tv177 = -441						; size = 1
tv157 = -441						; size = 1
tv137 = -441						; size = 1
tv395 = -440						; size = 4
tv394 = -440						; size = 4
tv390 = -440						; size = 4
tv386 = -440						; size = 4
tv385 = -440						; size = 4
tv381 = -440						; size = 4
tv379 = -440						; size = 4
tv377 = -440						; size = 4
tv376 = -440						; size = 4
tv375 = -440						; size = 4
tv373 = -440						; size = 4
tv372 = -440						; size = 4
tv370 = -440						; size = 4
tv369 = -440						; size = 4
tv366 = -440						; size = 4
tv384 = -438						; size = 2
tv382 = -438						; size = 2
tv374 = -437						; size = 1
tv371 = -437						; size = 1
tv368 = -437						; size = 1
tv365 = -437						; size = 1
$T2 = -432						; size = 28
$T3 = -396						; size = 28
$T4 = -360						; size = 4
$T5 = -348						; size = 4
$T6 = -336						; size = 4
$T7 = -324						; size = 4
$T8 = -312						; size = 4
$T9 = -300						; size = 4
$T10 = -288						; size = 12
$T11 = -268						; size = 4
$T12 = -256						; size = 4
_cException$13 = -52					; size = 4
_pClone$ = -40						; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
_nSeed$ = 20						; size = 4
?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z PROC		; CSpeedTreeRT::Clone, COMDAT
; _this$ = ecx

; 775  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 436				; 000001b4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-260]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 776  :     CSpeedTreeRT* pClone = NULL;

	mov	DWORD PTR _pClone$[ebp], 0

; 777  :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 778  :     {
; 779  :         if (m_pEngine->TransientDataIntact( ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?TransientDataIntact@CTreeEngine@@QBE_NXZ ; CTreeEngine::TransientDataIntact
	mov	BYTE PTR tv365[ebp], al
	movzx	ecx, BYTE PTR tv365[ebp]
	test	ecx, ecx
	je	$LN3@Clone

; 780  :         {
; 781  :             // allocate the clone
; 782  :             pClone = new CSpeedTreeRT;

	push	156					; 0000009cH
	call	??2CSpeedTreeRT@@SAPAXI@Z		; CSpeedTreeRT::operator new
	add	esp, 4
	mov	DWORD PTR tv366[ebp], eax
	mov	eax, DWORD PTR tv366[ebp]
	mov	DWORD PTR $T11[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN13@Clone
	mov	ecx, DWORD PTR $T11[ebp]
	call	??0CSpeedTreeRT@@QAE@XZ			; CSpeedTreeRT::CSpeedTreeRT
	mov	DWORD PTR tv367[ebp], eax
	mov	ecx, DWORD PTR tv367[ebp]
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $LN14@Clone
$LN13@Clone:
	mov	DWORD PTR tv79[ebp], 0
$LN14@Clone:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR $T12[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	eax, DWORD PTR $T12[ebp]
	mov	DWORD PTR _pClone$[ebp], eax

; 783  : 
; 784  :             // copy all of the appropriate data
; 785  :             *pClone->m_pLightingEngine = *m_pLightingEngine;

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pClone$[ebp]
	mov	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR [eax+12]
	mov	edi, DWORD PTR [edx+12]
	rep movsd

; 786  :             *pClone->m_pWindEngine = *m_pWindEngine;

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pClone$[ebp]
	mov	ecx, 17					; 00000011H
	mov	esi, DWORD PTR [eax+16]
	mov	edi, DWORD PTR [edx+16]
	rep movsd

; 787  :             *pClone->m_pFrondEngine = *m_pFrondEngine;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	push	ecx
	mov	edx, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR [edx+88]
	call	??4CFrondEngine@@QAEABV0@ABV0@@Z	; CFrondEngine::operator=
	npad	1

; 788  : 
; 789  :             pClone->m_pBranchGeometry->EnableVertexWeighting(m_pBranchGeometry->IsVertexWeightingEnabled( ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?IsVertexWeightingEnabled@CIndexedGeometry@@QBE_NXZ ; CIndexedGeometry::IsVertexWeightingEnabled
	mov	BYTE PTR tv368[ebp], al
	movzx	ecx, BYTE PTR tv368[ebp]
	push	ecx
	mov	edx, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?EnableVertexWeighting@CIndexedGeometry@@QAEX_N@Z ; CIndexedGeometry::EnableVertexWeighting
	npad	1

; 790  :             pClone->m_pBranchGeometry->EnableManualLighting(m_pLightingEngine->GetBranchLightingMethod( ) == LIGHT_STATIC);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetBranchLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ ; CLightingEngine::GetBranchLightingMethod
	mov	DWORD PTR tv369[ebp], eax
	cmp	DWORD PTR tv369[ebp], 1
	jne	SHORT $LN15@Clone
	mov	BYTE PTR tv137[ebp], 1
	jmp	SHORT $LN16@Clone
$LN15@Clone:
	mov	BYTE PTR tv137[ebp], 0
$LN16@Clone:
	movzx	ecx, BYTE PTR tv137[ebp]
	push	ecx
	mov	edx, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?EnableManualLighting@CIndexedGeometry@@QAEX_N@Z ; CIndexedGeometry::EnableManualLighting
	npad	1

; 791  :             pClone->m_pBranchGeometry->SetWindMethod(m_pWindEngine->GetBranchWindMethod( ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetBranchWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ ; CWindEngine::GetBranchWindMethod
	mov	DWORD PTR tv370[ebp], eax
	mov	ecx, DWORD PTR tv370[ebp]
	push	ecx
	mov	edx, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?SetWindMethod@CIndexedGeometry@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z ; CIndexedGeometry::SetWindMethod
	npad	1

; 792  : 
; 793  :             pClone->m_pFrondGeometry->EnableVertexWeighting(m_pFrondGeometry->IsVertexWeightingEnabled( ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	?IsVertexWeightingEnabled@CIndexedGeometry@@QBE_NXZ ; CIndexedGeometry::IsVertexWeightingEnabled
	mov	BYTE PTR tv371[ebp], al
	movzx	ecx, BYTE PTR tv371[ebp]
	push	ecx
	mov	edx, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR [edx+92]
	call	?EnableVertexWeighting@CIndexedGeometry@@QAEX_N@Z ; CIndexedGeometry::EnableVertexWeighting
	npad	1

; 794  :             pClone->m_pFrondGeometry->EnableManualLighting(m_pLightingEngine->GetFrondLightingMethod( ) == LIGHT_STATIC);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetFrondLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ ; CLightingEngine::GetFrondLightingMethod
	mov	DWORD PTR tv372[ebp], eax
	cmp	DWORD PTR tv372[ebp], 1
	jne	SHORT $LN17@Clone
	mov	BYTE PTR tv157[ebp], 1
	jmp	SHORT $LN18@Clone
$LN17@Clone:
	mov	BYTE PTR tv157[ebp], 0
$LN18@Clone:
	movzx	ecx, BYTE PTR tv157[ebp]
	push	ecx
	mov	edx, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR [edx+92]
	call	?EnableManualLighting@CIndexedGeometry@@QAEX_N@Z ; CIndexedGeometry::EnableManualLighting
	npad	1

; 795  :             pClone->m_pFrondGeometry->SetWindMethod(m_pWindEngine->GetFrondWindMethod( ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?GetFrondWindMethod@CWindEngine@@QBE?AW4EWindMethod@CSpeedTreeRT@@XZ ; CWindEngine::GetFrondWindMethod
	mov	DWORD PTR tv373[ebp], eax
	mov	ecx, DWORD PTR tv373[ebp]
	push	ecx
	mov	edx, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR [edx+92]
	call	?SetWindMethod@CIndexedGeometry@@QAEXW4EWindMethod@CSpeedTreeRT@@@Z ; CIndexedGeometry::SetWindMethod
	npad	1

; 796  : 
; 797  :             pClone->m_pLeafGeometry->EnableVertexWeighting(m_pLeafGeometry->IsVertexWeightingEnabled( ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?IsVertexWeightingEnabled@CLeafGeometry@@QBE_NXZ ; CLeafGeometry::IsVertexWeightingEnabled
	mov	BYTE PTR tv374[ebp], al
	movzx	ecx, BYTE PTR tv374[ebp]
	push	ecx
	mov	edx, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	call	?EnableVertexWeighting@CLeafGeometry@@QAEX_N@Z ; CLeafGeometry::EnableVertexWeighting
	npad	1

; 798  :             pClone->m_pLeafGeometry->EnableManualLighting(m_pLightingEngine->GetLeafLightingMethod( ) == LIGHT_STATIC);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetLeafLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ ; CLightingEngine::GetLeafLightingMethod
	mov	DWORD PTR tv375[ebp], eax
	cmp	DWORD PTR tv375[ebp], 1
	jne	SHORT $LN19@Clone
	mov	BYTE PTR tv177[ebp], 1
	jmp	SHORT $LN20@Clone
$LN19@Clone:
	mov	BYTE PTR tv177[ebp], 0
$LN20@Clone:
	movzx	ecx, BYTE PTR tv177[ebp]
	push	ecx
	mov	edx, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	call	?EnableManualLighting@CLeafGeometry@@QAEX_N@Z ; CLeafGeometry::EnableManualLighting
	npad	1

; 799  : 
; 800  :             pClone->m_ucTargetAlphaValue = m_ucTargetAlphaValue;

	mov	eax, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+68]
	mov	BYTE PTR [eax+68], dl

; 801  : 
; 802  :             m_pEngine->Clone(pClone->m_pEngine, CVec3(x, y, z), nSeed);

	push	ecx
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T10[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	mov	DWORD PTR tv376[ebp], eax
	mov	eax, DWORD PTR _nSeed$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv376[ebp]
	push	ecx
	mov	edx, DWORD PTR _pClone$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?Clone@CTreeEngine@@QBEXPAV1@ABVCVec3@@I@Z ; CTreeEngine::Clone
	npad	1

; 803  : 
; 804  :             // copy embedded coordinate if they exist
; 805  :             if (m_pEmbeddedTexCoords)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	$LN5@Clone

; 806  :             {
; 807  :                 pClone->m_pEmbeddedTexCoords = new SEmbeddedTexCoords;

	push	84					; 00000054H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv377[ebp], eax
	mov	eax, DWORD PTR tv377[ebp]
	mov	DWORD PTR $T8[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN21@Clone
	mov	ecx, DWORD PTR $T8[ebp]
	call	??0SEmbeddedTexCoords@@QAE@XZ		; SEmbeddedTexCoords::SEmbeddedTexCoords
	mov	DWORD PTR tv378[ebp], eax
	mov	ecx, DWORD PTR tv378[ebp]
	mov	DWORD PTR tv206[ebp], ecx
	jmp	SHORT $LN22@Clone
$LN21@Clone:
	mov	DWORD PTR tv206[ebp], 0
$LN22@Clone:
	mov	edx, DWORD PTR tv206[ebp]
	mov	DWORD PTR $T9[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	eax, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR $T9[ebp]
	mov	DWORD PTR [eax+76], ecx

; 808  :                 *pClone->m_pEmbeddedTexCoords = *m_pEmbeddedTexCoords;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	mov	edx, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR [edx+76]
	call	??4SEmbeddedTexCoords@@QAEABU0@ABU0@@Z	; SEmbeddedTexCoords::operator=
	npad	1
$LN5@Clone:

; 809  :             }
; 810  :             // copy projected shadow if it exists
; 811  :             if (m_pProjectedShadow)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	$LN6@Clone

; 812  :             {
; 813  :                 pClone->m_pProjectedShadow = new CProjectedShadow;

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv379[ebp], eax
	mov	eax, DWORD PTR tv379[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN23@Clone
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0CProjectedShadow@@QAE@XZ		; CProjectedShadow::CProjectedShadow
	mov	DWORD PTR tv380[ebp], eax
	mov	ecx, DWORD PTR tv380[ebp]
	mov	DWORD PTR tv224[ebp], ecx
	jmp	SHORT $LN24@Clone
$LN23@Clone:
	mov	DWORD PTR tv224[ebp], 0
$LN24@Clone:
	mov	edx, DWORD PTR tv224[ebp]
	mov	DWORD PTR $T7[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	eax, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR [eax+80], ecx

; 814  :                 *pClone->m_pProjectedShadow = *m_pProjectedShadow;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	mov	edx, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR [edx+80]
	call	??4CProjectedShadow@@QAEAAV0@ABV0@@Z
	npad	1
$LN6@Clone:

; 815  :             }
; 816  :             // copy collision objects if they exist
; 817  :             if (m_pCollisionObjects)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $LN7@Clone

; 818  :             {
; 819  :                 pClone->m_pCollisionObjects = new SCollisionObjects;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv381[ebp], eax
	mov	eax, DWORD PTR tv381[ebp]
	mov	DWORD PTR $T5[ebp], eax
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN25@Clone
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0SCollisionObjects@@QAE@XZ
	mov	DWORD PTR tv239[ebp], eax
	jmp	SHORT $LN26@Clone
$LN25@Clone:
	mov	DWORD PTR tv239[ebp], 0
$LN26@Clone:
	mov	ecx, DWORD PTR _pClone$[ebp]
	mov	edx, DWORD PTR tv239[ebp]
	mov	DWORD PTR [ecx+84], edx

; 820  :                 *pClone->m_pCollisionObjects = *m_pCollisionObjects;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	mov	edx, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR [edx+84]
	call	??4SCollisionObjects@@QAEAAU0@ABU0@@Z
	npad	1
$LN7@Clone:

; 821  :             }
; 822  :             // copy m_pLeafLodSizeFactors if allocated
; 823  :             if (m_pLeafLodSizeFactors)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN8@Clone

; 824  :             {
; 825  :                 pClone->m_pLeafLodSizeFactors = new float[GetNumLeafLodLevels( )];

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumLeafLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumLeafLodLevels
	mov	WORD PTR tv382[ebp], ax
	movzx	eax, WORD PTR tv382[ebp]
	mov	ecx, 4
	mul	ecx
	mov	edx, -1
	cmovb	eax, edx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR tv383[ebp], eax
	mov	eax, DWORD PTR tv383[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR _pClone$[ebp]
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR [ecx+44], edx

; 826  :                 memcpy(pClone->m_pLeafLodSizeFactors, m_pLeafLodSizeFactors, GetNumLeafLodLevels( ) * sizeof(float));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumLeafLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumLeafLodLevels
	mov	WORD PTR tv384[ebp], ax
	movzx	eax, WORD PTR tv384[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN8@Clone:

; 827  :             }
; 828  :             // copy user data if it exists
; 829  :             if (m_pUserData)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+100], 0
	je	SHORT $LN9@Clone

; 830  :                 pClone->m_pUserData = CopyUserData(m_pUserData);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	push	ecx
	call	?CopyUserData@CSpeedTreeRT@@CAPADPBD@Z	; CSpeedTreeRT::CopyUserData
	add	esp, 4
	mov	DWORD PTR tv385[ebp], eax
	mov	edx, DWORD PTR _pClone$[ebp]
	mov	eax, DWORD PTR tv385[ebp]
	mov	DWORD PTR [edx+100], eax
$LN9@Clone:

; 831  : 
; 832  :             pClone->m_eLeafLodMethod = m_eLeafLodMethod;

	mov	eax, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 833  :             pClone->m_fLeafLodTransitionRadius = m_fLeafLodTransitionRadius;

	mov	eax, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx

; 834  :             pClone->m_fLeafLodCurveExponent = m_fLeafLodCurveExponent;

	mov	eax, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx

; 835  :             pClone->m_fLeafSizeIncreaseFactor = m_fLeafSizeIncreaseFactor;

	mov	eax, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx

; 836  :             pClone->m_fLeafTransitionFactor = m_fLeafTransitionFactor;

	mov	eax, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx

; 837  :             pClone->m_usNumFrondLodLevels = m_usNumFrondLodLevels;

	mov	eax, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+96]
	mov	WORD PTR [eax+96], dx

; 838  :             pClone->m_b360Billboard = m_b360Billboard;

	mov	eax, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+104]
	mov	BYTE PTR [eax+104], dl

; 839  :             pClone->m_bHorizontalBillboard = m_bHorizontalBillboard;

	mov	eax, DWORD PTR _pClone$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+105]
	mov	BYTE PTR [eax+105], dl

; 840  : 
; 841  :             // copy horizontal billboard coordinates
; 842  :             memcpy(pClone->m_afHorizontalCoords, m_afHorizontalCoords, 12 * sizeof(float));

	push	48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 108				; 0000006cH
	push	eax
	mov	ecx, DWORD PTR _pClone$[ebp]
	add	ecx, 108				; 0000006cH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 843  : 
; 844  :             st_assert(pClone);

	cmp	DWORD PTR _pClone$[ebp], 0
	jne	$LN10@Clone
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv386[ebp], eax
	mov	ecx, DWORD PTR ?__LINE__Var@?0??Clone@CSpeedTreeRT@@QBEPAV2@MMMI@Z@4JA
	add	ecx, 69					; 00000045H
	mov	esi, esp
	push	ecx
	mov	ecx, DWORD PTR tv386[ebp]
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv387[ebp], eax
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	edx, DWORD PTR tv387[ebp]
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv388[ebp], eax
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	mov	eax, DWORD PTR tv388[ebp]
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv389[ebp], eax
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	ecx, DWORD PTR tv389[ebp]
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN10@Clone:

; 845  :             st_assert(pClone->m_pEngine);

	mov	eax, DWORD PTR _pClone$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$LN11@Clone
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv390[ebp], eax
	mov	ecx, DWORD PTR ?__LINE__Var@?0??Clone@CSpeedTreeRT@@QBEPAV2@MMMI@Z@4JA
	add	ecx, 70					; 00000046H
	mov	esi, esp
	push	ecx
	mov	ecx, DWORD PTR tv390[ebp]
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv391[ebp], eax
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	edx, DWORD PTR tv391[ebp]
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv392[ebp], eax
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	mov	eax, DWORD PTR tv392[ebp]
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	DWORD PTR tv393[ebp], eax
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	ecx, DWORD PTR tv393[ebp]
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN11@Clone:

; 846  :         }

	jmp	SHORT $LN4@Clone
$LN3@Clone:

; 847  :         else
; 848  :             SetError("cannot Clone() after calling DeleteTransientData()");

	push	OFFSET ??_C@_0DD@OBNCDPAD@cannot?5Clone?$CI?$CJ?5after?5calling?5De@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN4@Clone:

; 849  :     }

	jmp	$LN27@Clone
__catch$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z$0:

; 850  : 
; 851  :     SpeedTreeCatch("CSpeedTreeRT::Clone")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$13[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$13[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BE@EBKKKEGA@CSpeedTreeRT?3?3Clone@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv394[ebp], eax
	mov	edx, DWORD PTR tv394[ebp]
	mov	DWORD PTR tv360[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 5
	mov	ecx, DWORD PTR tv360[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN36@Clone
	ret	0
__catch$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z$1:

; 852  :     SpeedTreeCatchAll("CSpeedTreeRT::Clone");

	push	OFFSET ??_C@_0BE@EBKKKEGA@CSpeedTreeRT?3?3Clone@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv395[ebp], eax
	mov	ecx, DWORD PTR tv395[ebp]
	mov	DWORD PTR tv363[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 6
	mov	ecx, DWORD PTR tv363[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN38@Clone
	ret	0
$LN27@Clone:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN37@Clone
$LN38@Clone:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN35@Clone
$LN37@Clone:
	jmp	SHORT $LN35@Clone
$LN36@Clone:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN35@Clone:

; 853  : 
; 854  :     return pClone;

	mov	eax, DWORD PTR _pClone$[ebp]
$LN1@Clone:

; 855  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN42@Clone
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 452				; 000001c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	2
$LN42@Clone:
	DD	1
	DD	$LN41@Clone
$LN41@Clone:
	DD	-52					; ffffffccH
	DD	4
	DD	$LN39@Clone
$LN39@Clone:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z$3:
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??3CSpeedTreeRT@@SAXPAX@Z		; CSpeedTreeRT::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z$4:
	push	84					; 00000054H
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z$5:
	push	64					; 00000040H
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z$6:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z$7:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-456]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Clone@CSpeedTreeRT@@QBEPAV1@MMMI@Z ENDP		; CSpeedTreeRT::Clone
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z
_TEXT	SEGMENT
tv395 = -664						; size = 4
tv391 = -664						; size = 4
tv387 = -664						; size = 4
tv394 = -660						; size = 4
tv390 = -660						; size = 4
tv386 = -660						; size = 4
tv379 = -656						; size = 4
tv332 = -656						; size = 4
tv302 = -656						; size = 4
tv272 = -656						; size = 4
tv393 = -652						; size = 4
tv389 = -652						; size = 4
tv385 = -652						; size = 4
tv383 = -652						; size = 4
tv378 = -652						; size = 4
tv372 = -652						; size = 4
tv369 = -652						; size = 4
tv397 = -648						; size = 4
tv396 = -648						; size = 4
tv392 = -648						; size = 4
tv388 = -648						; size = 4
tv384 = -648						; size = 4
tv382 = -648						; size = 4
tv381 = -648						; size = 4
tv377 = -648						; size = 4
tv376 = -648						; size = 4
tv375 = -648						; size = 4
tv374 = -646						; size = 2
$T2 = -640						; size = 28
$T3 = -604						; size = 28
$T4 = -568						; size = 12
$T5 = -548						; size = 12
$T6 = -528						; size = 12
$T7 = -508						; size = 12
$T8 = -488						; size = 12
$T9 = -468						; size = 12
$T10 = -448						; size = 12
_cException$11 = -236					; size = 4
_fDimension$12 = -224					; size = 4
_cOrigin$13 = -212					; size = 12
_cExtents$14 = -192					; size = 48
_cTransform$15 = -136					; size = 64
_i$16 = -64						; size = 4
_i$17 = -52						; size = 4
_sWindInfo$18 = -40					; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_pTransform$ = 8					; size = 4
_nSeed$ = 12						; size = 4
_bCompositeStrips$ = 16					; size = 1
?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z PROC		; CSpeedTreeRT::Compute, COMDAT
; _this$ = ecx

; 670  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 648				; 00000288H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-472]
	mov	ecx, 114				; 00000072H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 671  :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 672  :     {
; 673  :         if (!m_bTreeComputed)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+69]
	test	ecx, ecx
	jne	$LN9@Compute

; 674  :         {
; 675  :             // compute tree's geometry
; 676  :             CIdvBranch::SetFrondEngine(m_pFrondEngine);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	push	ecx
	call	?SetFrondEngine@CIdvBranch@@SAXPAVCFrondEngine@@@Z ; CIdvBranch::SetFrondEngine
	add	esp, 4

; 677  :             m_pEngine->SetSeed(nSeed);

	mov	eax, DWORD PTR _nSeed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?SetSeed@CTreeEngine@@QAEXI@Z		; CTreeEngine::SetSeed
	npad	1

; 678  :             m_pEngine->Compute(m_fLeafSizeIncreaseFactor);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?Compute@CTreeEngine@@QAEXM@Z		; CTreeEngine::Compute
	npad	1

; 679  :             m_pFrondEngine->Compute(m_pFrondGeometry, m_pLightingEngine);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+88]
	call	?Compute@CFrondEngine@@QAEXPAVCIndexedGeometry@@PAVCLightingEngine@@@Z ; CFrondEngine::Compute
	npad	1

; 680  :             m_usNumFrondLodLevels = m_pFrondGeometry->GetNumLodLevels( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	?GetNumLodLevels@CIndexedGeometry@@QAEGXZ ; CIndexedGeometry::GetNumLodLevels
	mov	WORD PTR tv374[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR tv374[ebp]
	mov	WORD PTR [ecx+96], dx

; 681  : 
; 682  :             m_pEngine->InitTables( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?InitTables@CTreeEngine@@QAEXXZ		; CTreeEngine::InitTables
	npad	1

; 683  : 
; 684  :             // compute static lighting
; 685  :             if (m_pLightingEngine->GetLeafLightingMethod( ) == CSpeedTreeRT::LIGHT_STATIC)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetLeafLightingMethod@CLightingEngine@@QBE?AW4ELightingMethod@CSpeedTreeRT@@XZ ; CLightingEngine::GetLeafLightingMethod
	mov	DWORD PTR tv375[ebp], eax
	cmp	DWORD PTR tv375[ebp], 1
	jne	SHORT $LN11@Compute

; 686  :                 ComputeLeafStaticLighting( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputeLeafStaticLighting@CSpeedTreeRT@@AAEXXZ ; CSpeedTreeRT::ComputeLeafStaticLighting
	npad	1
$LN11@Compute:

; 687  : 
; 688  :             // prep wind and leaves
; 689  :             const SIdvWindInfo& sWindInfo = m_pEngine->GetWindData( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetWindData@CTreeEngine@@QBEABUSIdvWindInfo@@XZ ; CTreeEngine::GetWindData
	mov	DWORD PTR tv376[ebp], eax
	mov	ecx, DWORD PTR tv376[ebp]
	mov	DWORD PTR _sWindInfo$18[ebp], ecx

; 690  :             m_pWindEngine->Init(sWindInfo);

	mov	eax, DWORD PTR _sWindInfo$18[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+16]
	call	?Init@CWindEngine@@QAEXABUSIdvWindInfo@@@Z ; CWindEngine::Init
	npad	1

; 691  :             m_pLeafGeometry->Init(static_cast<unsigned short>(m_pEngine->GetNumLeafLodLevels( )), m_pEngine->GetAllLeaves( ), m_pEngine->GetLeafInfo( ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetLeafInfo@CTreeEngine@@QBEABUSIdvLeafInfo@@XZ ; CTreeEngine::GetLeafInfo
	mov	DWORD PTR tv377[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetAllLeaves@CTreeEngine@@QBEPAV?$vector@PAVCBillboardLeaf@@V?$allocator@PAVCBillboardLeaf@@@std@@@std@@XZ ; CTreeEngine::GetAllLeaves
	mov	DWORD PTR tv378[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetNumLeafLodLevels@CTreeEngine@@QBEHXZ ; CTreeEngine::GetNumLeafLodLevels
	mov	DWORD PTR tv379[ebp], eax
	mov	eax, DWORD PTR tv377[ebp]
	push	eax
	mov	ecx, DWORD PTR tv378[ebp]
	push	ecx
	movzx	edx, WORD PTR tv379[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?Init@CLeafGeometry@@QAEXGPBV?$vector@PAVCBillboardLeaf@@V?$allocator@PAVCBillboardLeaf@@@std@@@std@@ABUSIdvLeafInfo@@@Z ; CLeafGeometry::Init
	npad	1

; 692  : 
; 693  :             // move embedeed texcoords (from file) into leaf geometry class and fronds
; 694  :             if (m_pEmbeddedTexCoords)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	$LN6@Compute

; 695  :             {
; 696  :                 for (int i = 0; i < m_pEmbeddedTexCoords->m_nNumLeafMaps; ++i)

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN4@Compute
$LN2@Compute:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN4@Compute:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN3@Compute

; 697  :                     m_pLeafGeometry->SetTextureCoords(i, &(m_pEmbeddedTexCoords->m_pLeafTexCoords[i * 8]));

	mov	eax, DWORD PTR _i$17[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	ecx, DWORD PTR [edx+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _i$17[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?SetTextureCoords@CLeafGeometry@@QAEXIPBM@Z ; CLeafGeometry::SetTextureCoords
	npad	1
	jmp	SHORT $LN2@Compute
$LN3@Compute:

; 698  :                 
; 699  :                 for (int i = 0; i < m_pEmbeddedTexCoords->m_nNumFrondMaps; ++i)

	mov	DWORD PTR _i$16[ebp], 0
	jmp	SHORT $LN7@Compute
$LN5@Compute:
	mov	eax, DWORD PTR _i$16[ebp]
	add	eax, 1
	mov	DWORD PTR _i$16[ebp], eax
$LN7@Compute:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _i$16[ebp]
	cmp	edx, DWORD PTR [ecx+16]
	jge	SHORT $LN6@Compute

; 700  :                     m_pFrondEngine->SetTextureCoords(m_pFrondGeometry, i, &(m_pEmbeddedTexCoords->m_pFrondTexCoords[i * 8]), m_bTextureFlip);

	movzx	eax, BYTE PTR ?m_bTextureFlip@CSpeedTreeRT@@0_NA ; CSpeedTreeRT::m_bTextureFlip
	push	eax
	mov	ecx, DWORD PTR _i$16[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	edx, DWORD PTR [eax+20]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _i$16[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+88]
	call	?SetTextureCoords@CFrondEngine@@QAEXPAVCIndexedGeometry@@IPBM_N@Z ; CFrondEngine::SetTextureCoords
	npad	1
	jmp	SHORT $LN5@Compute
$LN6@Compute:

; 701  :             }
; 702  : 
; 703  :             // for each branch LOD level, convert all strips to single strip using
; 704  :             // degenerate triangles
; 705  :             if (bCompositeStrips)

	movzx	eax, BYTE PTR _bCompositeStrips$[ebp]
	test	eax, eax
	je	SHORT $LN13@Compute

; 706  :             {
; 707  :                 m_pBranchGeometry->CombineStrips( );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?CombineStrips@CIndexedGeometry@@QAEX_N@Z ; CIndexedGeometry::CombineStrips
	npad	1

; 708  :                 m_pFrondGeometry->CombineStrips(false);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	?CombineStrips@CIndexedGeometry@@QAEX_N@Z ; CIndexedGeometry::CombineStrips
	npad	1
$LN13@Compute:

; 709  :             }
; 710  : 
; 711  :             // apply optional transformation
; 712  :             if (pTransform)

	cmp	DWORD PTR _pTransform$[ebp], 0
	je	SHORT $LN15@Compute

; 713  :             {
; 714  :                 CTransform cTransform;

	lea	ecx, DWORD PTR _cTransform$15[ebp]
	call	??0CTransform@@QAE@XZ			; CTransform::CTransform
	npad	1

; 715  :                 memcpy((void*) cTransform.m_afData, pTransform, 16 * sizeof(float));

	push	64					; 00000040H
	mov	eax, DWORD PTR _pTransform$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cTransform$15[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 716  : 
; 717  :                 m_pBranchGeometry->Transform(cTransform);

	lea	eax, DWORD PTR _cTransform$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?Transform@CIndexedGeometry@@QAEXABVCTransform@@@Z ; CIndexedGeometry::Transform
	npad	1

; 718  :                 m_pLeafGeometry->Transform(cTransform);

	lea	eax, DWORD PTR _cTransform$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?Transform@CLeafGeometry@@QAEXABVCTransform@@@Z ; CLeafGeometry::Transform
	npad	1

; 719  :                 m_pFrondGeometry->Transform(cTransform);

	lea	eax, DWORD PTR _cTransform$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+92]
	call	?Transform@CIndexedGeometry@@QAEXABVCTransform@@@Z ; CIndexedGeometry::Transform
	npad	1

; 720  :                 if (m_pCollisionObjects)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $LN15@Compute

; 721  :                     m_pCollisionObjects->TransformAll(cTransform);

	lea	eax, DWORD PTR _cTransform$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+84]
	call	?TransformAll@SCollisionObjects@@QAEXAAVCTransform@@@Z ; SCollisionObjects::TransformAll
	npad	1
$LN15@Compute:

; 722  :             }
; 723  : 
; 724  :             // retrieve extents from branch and leaf geometry classes
; 725  :             CRegion cExtents;

	lea	ecx, DWORD PTR _cExtents$14[ebp]
	call	??0CRegion@@QAE@XZ			; CRegion::CRegion
	mov	DWORD PTR tv381[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 726  :             m_pBranchGeometry->ComputeExtents(cExtents);

	lea	eax, DWORD PTR _cExtents$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?ComputeExtents@CIndexedGeometry@@QBEXAAVCRegion@@@Z ; CIndexedGeometry::ComputeExtents
	npad	1

; 727  :             m_pLeafGeometry->ComputeExtents(cExtents);

	lea	eax, DWORD PTR _cExtents$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?ComputeExtents@CLeafGeometry@@QBEXAAVCRegion@@@Z ; CLeafGeometry::ComputeExtents
	npad	1

; 728  :             m_pFrondGeometry->ComputeExtents(cExtents);

	lea	eax, DWORD PTR _cExtents$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+92]
	call	?ComputeExtents@CIndexedGeometry@@QBEXAAVCRegion@@@Z ; CIndexedGeometry::ComputeExtents
	npad	1

; 729  : 
; 730  :             memcpy(m_pTreeSizes + STS_MIN_BOX, cExtents.m_cMin.m_afData, 3 * sizeof(float)); 

	push	12					; 0000000cH
	lea	eax, DWORD PTR _cExtents$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 731  :             memcpy(m_pTreeSizes + STS_MAX_BOX, cExtents.m_cMax.m_afData, 3 * sizeof(float)); 

	push	12					; 0000000cH
	lea	eax, DWORD PTR _cExtents$14[ebp+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	add	edx, 12					; 0000000cH
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 732  : 
; 733  :             // figure out how wide the billboard should be
; 734  :             CVec3 cOrigin(0.0f, 0.0f, 0.0f);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _cOrigin$13[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	npad	1

; 735  :             //lint -save -e666
; 736  : #ifdef UPVECTOR_POS_Y
; 737  :             float fDimension = cOrigin.Distance(CVec3(m_pTreeSizes[0], m_pTreeSizes[2], 0.0f));
; 738  :             fDimension = __max(fDimension, cOrigin.Distance(CVec3(m_pTreeSizes[0], m_pTreeSizes[5], 0.0f)));
; 739  :             fDimension = __max(fDimension, cOrigin.Distance(CVec3(m_pTreeSizes[3], m_pTreeSizes[2], 0.0f)));
; 740  :             fDimension = __max(fDimension, cOrigin.Distance(CVec3(m_pTreeSizes[3], m_pTreeSizes[5], 0.0f)));
; 741  : #else
; 742  :             float fDimension = cOrigin.Distance(CVec3(m_pTreeSizes[0], m_pTreeSizes[1], 0.0f));

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T10[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	mov	DWORD PTR tv382[ebp], eax
	mov	ecx, DWORD PTR tv382[ebp]
	push	ecx
	lea	ecx, DWORD PTR _cOrigin$13[ebp]
	call	?Distance@CVec3@@QBEMABV1@@Z		; CVec3::Distance
	fstp	DWORD PTR tv383[ebp]
	movss	xmm0, DWORD PTR tv383[ebp]
	movss	DWORD PTR _fDimension$12[ebp], xmm0

; 743  :             fDimension = __max(fDimension, cOrigin.Distance(CVec3(m_pTreeSizes[0], m_pTreeSizes[4], 0.0f)));

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T9[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	mov	DWORD PTR tv384[ebp], eax
	mov	ecx, DWORD PTR tv384[ebp]
	push	ecx
	lea	ecx, DWORD PTR _cOrigin$13[ebp]
	call	?Distance@CVec3@@QBEMABV1@@Z		; CVec3::Distance
	fstp	DWORD PTR tv385[ebp]
	movss	xmm0, DWORD PTR _fDimension$12[ebp]
	comiss	xmm0, DWORD PTR tv385[ebp]
	jbe	SHORT $LN18@Compute
	movss	xmm0, DWORD PTR _fDimension$12[ebp]
	movss	DWORD PTR tv272[ebp], xmm0
	jmp	SHORT $LN19@Compute
$LN18@Compute:
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T8[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	mov	DWORD PTR tv386[ebp], eax
	mov	eax, DWORD PTR tv386[ebp]
	push	eax
	lea	ecx, DWORD PTR _cOrigin$13[ebp]
	call	?Distance@CVec3@@QBEMABV1@@Z		; CVec3::Distance
	fstp	DWORD PTR tv387[ebp]
	movss	xmm0, DWORD PTR tv387[ebp]
	movss	DWORD PTR tv272[ebp], xmm0
$LN19@Compute:
	movss	xmm0, DWORD PTR tv272[ebp]
	movss	DWORD PTR _fDimension$12[ebp], xmm0

; 744  :             fDimension = __max(fDimension, cOrigin.Distance(CVec3(m_pTreeSizes[3], m_pTreeSizes[1], 0.0f)));

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T7[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	mov	DWORD PTR tv388[ebp], eax
	mov	ecx, DWORD PTR tv388[ebp]
	push	ecx
	lea	ecx, DWORD PTR _cOrigin$13[ebp]
	call	?Distance@CVec3@@QBEMABV1@@Z		; CVec3::Distance
	fstp	DWORD PTR tv389[ebp]
	movss	xmm0, DWORD PTR _fDimension$12[ebp]
	comiss	xmm0, DWORD PTR tv389[ebp]
	jbe	SHORT $LN20@Compute
	movss	xmm0, DWORD PTR _fDimension$12[ebp]
	movss	DWORD PTR tv302[ebp], xmm0
	jmp	SHORT $LN21@Compute
$LN20@Compute:
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	mov	DWORD PTR tv390[ebp], eax
	mov	eax, DWORD PTR tv390[ebp]
	push	eax
	lea	ecx, DWORD PTR _cOrigin$13[ebp]
	call	?Distance@CVec3@@QBEMABV1@@Z		; CVec3::Distance
	fstp	DWORD PTR tv391[ebp]
	movss	xmm0, DWORD PTR tv391[ebp]
	movss	DWORD PTR tv302[ebp], xmm0
$LN21@Compute:
	movss	xmm0, DWORD PTR tv302[ebp]
	movss	DWORD PTR _fDimension$12[ebp], xmm0

; 745  :             fDimension = __max(fDimension, cOrigin.Distance(CVec3(m_pTreeSizes[3], m_pTreeSizes[4], 0.0f)));

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	mov	DWORD PTR tv392[ebp], eax
	mov	ecx, DWORD PTR tv392[ebp]
	push	ecx
	lea	ecx, DWORD PTR _cOrigin$13[ebp]
	call	?Distance@CVec3@@QBEMABV1@@Z		; CVec3::Distance
	fstp	DWORD PTR tv393[ebp]
	movss	xmm0, DWORD PTR _fDimension$12[ebp]
	comiss	xmm0, DWORD PTR tv393[ebp]
	jbe	SHORT $LN22@Compute
	movss	xmm0, DWORD PTR _fDimension$12[ebp]
	movss	DWORD PTR tv332[ebp], xmm0
	jmp	SHORT $LN23@Compute
$LN22@Compute:
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0CVec3@@QAE@MMM@Z			; CVec3::CVec3
	mov	DWORD PTR tv394[ebp], eax
	mov	eax, DWORD PTR tv394[ebp]
	push	eax
	lea	ecx, DWORD PTR _cOrigin$13[ebp]
	call	?Distance@CVec3@@QBEMABV1@@Z		; CVec3::Distance
	fstp	DWORD PTR tv395[ebp]
	movss	xmm0, DWORD PTR tv395[ebp]
	movss	DWORD PTR tv332[ebp], xmm0
$LN23@Compute:
	movss	xmm0, DWORD PTR tv332[ebp]
	movss	DWORD PTR _fDimension$12[ebp], xmm0

; 746  : #endif
; 747  :             //lint -restore
; 748  :             m_pTreeSizes[STS_BB_SIZE] = fDimension * 2.0f;

	movss	xmm0, DWORD PTR _fDimension$12[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	movss	DWORD PTR [ecx+eax], xmm0

; 749  : 
; 750  :             // compute the self-shadow coordinates
; 751  :             if (m_pProjectedShadow)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $LN16@Compute

; 752  :                 ComputeSelfShadowTexCoords( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputeSelfShadowTexCoords@CSpeedTreeRT@@AAEXXZ ; CSpeedTreeRT::ComputeSelfShadowTexCoords
	npad	1
$LN16@Compute:

; 753  : 
; 754  :             // setup the horizontal billboard
; 755  :             SetupHorizontalBillboard( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupHorizontalBillboard@CSpeedTreeRT@@AAEXXZ ; CSpeedTreeRT::SetupHorizontalBillboard
	npad	1

; 756  : 
; 757  :             // some operations are not valid once the geometry has been computed
; 758  :             m_bTreeComputed = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+69], 1

; 759  :         }

	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR _cExtents$14[ebp]
	call	??1CRegion@@QAE@XZ
	npad	1
	jmp	SHORT $LN10@Compute
$LN9@Compute:

; 760  :         else
; 761  :             SetError("Compute() called more than once for single tree model (ignored)");

	push	OFFSET ??_C@_0EA@FKCHCHCL@Compute?$CI?$CJ?5called?5more?5than?5once@
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
$LN10@Compute:

; 762  :     }

	jmp	$LN24@Compute
__catch$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z$0:

; 763  : 
; 764  :     SpeedTreeCatch("CSpeedTreeRT::Compute")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$11[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$11[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BG@MNNNHHI@CSpeedTreeRT?3?3Compute@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv396[ebp], eax
	mov	edx, DWORD PTR tv396[ebp]
	mov	DWORD PTR tv369[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR tv369[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN31@Compute
	ret	0
__catch$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z$1:

; 765  :     SpeedTreeCatchAll("CSpeedTreeRT::Compute");

	push	OFFSET ??_C@_0BG@MNNNHHI@CSpeedTreeRT?3?3Compute@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv397[ebp], eax
	mov	ecx, DWORD PTR tv397[ebp]
	mov	DWORD PTR tv372[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	mov	ecx, DWORD PTR tv372[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN33@Compute
	ret	0
$LN24@Compute:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN32@Compute
$LN33@Compute:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN30@Compute
$LN32@Compute:
	jmp	SHORT $LN30@Compute
$LN31@Compute:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN30@Compute:

; 766  : 
; 767  :     return m_bTreeComputed;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+69]

; 768  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN40@Compute
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 664				; 00000298H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN40@Compute:
	DD	4
	DD	$LN39@Compute
$LN39@Compute:
	DD	-136					; ffffff78H
	DD	64					; 00000040H
	DD	$LN34@Compute
	DD	-192					; ffffff40H
	DD	48					; 00000030H
	DD	$LN35@Compute
	DD	-212					; ffffff2cH
	DD	12					; 0000000cH
	DD	$LN36@Compute
	DD	-236					; ffffff14H
	DD	4
	DD	$LN37@Compute
$LN37@Compute:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN36@Compute:
	DB	99					; 00000063H
	DB	79					; 0000004fH
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	0
$LN35@Compute:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
$LN34@Compute:
	DB	99					; 00000063H
	DB	84					; 00000054H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	109					; 0000006dH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z$3:
	lea	ecx, DWORD PTR _cExtents$14[ebp]
	jmp	??1CRegion@@QAE@XZ
__unwindfunclet$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z$4:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z$5:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-668]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z ENDP		; CSpeedTreeRT::Compute
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??_VCSpeedTreeRT@@SAXPAX@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
_pRawMemory$ = 8					; size = 4
??_VCSpeedTreeRT@@SAXPAX@Z PROC				; CSpeedTreeRT::operator delete[], COMDAT

; 661  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 662  :     ::delete[] pRawMemory;

	mov	eax, DWORD PTR _pRawMemory$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 663  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??_VCSpeedTreeRT@@SAXPAX@Z ENDP				; CSpeedTreeRT::operator delete[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??3CSpeedTreeRT@@SAXPAX@Z
_TEXT	SEGMENT
_pRawMemory$ = 8					; size = 4
??3CSpeedTreeRT@@SAXPAX@Z PROC				; CSpeedTreeRT::operator delete, COMDAT

; 635  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 636  :     ::operator delete(pRawMemory);

	mov	eax, DWORD PTR _pRawMemory$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 637  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??3CSpeedTreeRT@@SAXPAX@Z ENDP				; CSpeedTreeRT::operator delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??_UCSpeedTreeRT@@SAPAXI@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
_nSize$ = 8						; size = 4
??_UCSpeedTreeRT@@SAPAXI@Z PROC				; CSpeedTreeRT::operator new[], COMDAT

; 648  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 649  :     return ::new char[nSize];

	mov	eax, DWORD PTR _nSize$[ebp]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]

; 650  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??_UCSpeedTreeRT@@SAPAXI@Z ENDP				; CSpeedTreeRT::operator new[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??2CSpeedTreeRT@@SAPAXI@Z
_TEXT	SEGMENT
_nSize$ = 8						; size = 4
??2CSpeedTreeRT@@SAPAXI@Z PROC				; CSpeedTreeRT::operator new, COMDAT

; 622  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 623  :     return ::operator new(nSize);

	mov	eax, DWORD PTR _nSize$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 624  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??2CSpeedTreeRT@@SAPAXI@Z ENDP				; CSpeedTreeRT::operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??1CSpeedTreeRT@@QAE@XZ
_TEXT	SEGMENT
tv422 = -664						; size = 4
tv381 = -664						; size = 4
tv375 = -664						; size = 4
tv369 = -664						; size = 4
tv363 = -664						; size = 4
tv355 = -664						; size = 4
tv346 = -664						; size = 4
tv331 = -664						; size = 4
tv319 = -664						; size = 4
tv264 = -664						; size = 4
$T2 = -656						; size = 4
$T3 = -644						; size = 4
$T4 = -632						; size = 4
$T5 = -620						; size = 4
$T6 = -608						; size = 4
$T7 = -596						; size = 4
$T8 = -584						; size = 4
$T9 = -572						; size = 4
$T10 = -560						; size = 4
$T11 = -548						; size = 4
$T12 = -536						; size = 4
$T13 = -524						; size = 4
$T14 = -512						; size = 4
$T15 = -500						; size = 4
$T16 = -488						; size = 4
$T17 = -476						; size = 4
$T18 = -464						; size = 4
$T19 = -452						; size = 12
$T20 = -432						; size = 4
$T21 = -420						; size = 12
$T22 = -397						; size = 1
$T23 = -388						; size = 4
$T24 = -376						; size = 4
$T25 = -364						; size = 4
$T26 = -352						; size = 12
$T27 = -332						; size = 4
$T28 = -320						; size = 12
$T29 = -297						; size = 1
$T30 = -288						; size = 4
$T31 = -276						; size = 4
$T32 = -264						; size = 4
_iFind$33 = -60						; size = 12
_iFind$34 = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1CSpeedTreeRT@@QAE@XZ PROC				; CSpeedTreeRT::~CSpeedTreeRT, COMDAT
; _this$ = ecx

; 536  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CSpeedTreeRT@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 652				; 0000028cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-472]
	mov	ecx, 115				; 00000073H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 537  :     // delete tree from global tree list (if not an instance)
; 538  :     if (!m_pInstanceData)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	$LN2@CSpeedTree

; 539  :     {
; 540  :         vector<CSpeedTreeRT*>::iterator iFind = find(SInstanceList::m_vUniqueTrees.begin( ), SInstanceList::m_vUniqueTrees.end( ), this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T32[ebp], eax
	lea	ecx, DWORD PTR $T32[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T31[ebp], esp
	push	edx
	mov	ecx, OFFSET ?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A ; SInstanceList::m_vUniqueTrees
	call	?end@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::end
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T30[ebp], esp
	push	eax
	mov	ecx, OFFSET ?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A ; SInstanceList::m_vUniqueTrees
	call	?begin@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::begin
	lea	ecx, DWORD PTR _iFind$34[ebp]
	push	ecx
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAVCSpeedTreeRT@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@V10@V10@ABQAVCSpeedTreeRT@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >,CSpeedTreeRT *>
	add	esp, 32					; 00000020H

; 541  : 
; 542  :         // there shouldn't be any reason why this won't be found, but we're being careful
; 543  :         if (iFind != SInstanceList::m_vUniqueTrees.end( ))

	lea	eax, DWORD PTR $T28[ebp]
	push	eax
	mov	ecx, OFFSET ?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A ; SInstanceList::m_vUniqueTrees
	call	?end@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::end
	push	eax
	lea	ecx, DWORD PTR _iFind$34[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator!=
	mov	BYTE PTR $T29[ebp], al
	lea	ecx, DWORD PTR $T28[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	movzx	ecx, BYTE PTR $T29[ebp]
	test	ecx, ecx
	je	SHORT $LN3@CSpeedTree

; 544  :             (void) SInstanceList::m_vUniqueTrees.erase(iFind);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T27[ebp], esp
	lea	eax, DWORD PTR _iFind$34[ebp]
	push	eax
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@ABV01@@Z
	lea	ecx, DWORD PTR $T26[ebp]
	push	ecx
	mov	ecx, OFFSET ?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A ; SInstanceList::m_vUniqueTrees
	call	?erase@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::erase
	lea	ecx, DWORD PTR $T26[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	npad	1
$LN3@CSpeedTree:

; 545  :     }

	lea	ecx, DWORD PTR _iFind$34[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	npad	1
$LN2@CSpeedTree:

; 546  :     
; 547  :     // instance reference counting
; 548  :     st_assert(m_pInstanceRefCount);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN4@CSpeedTree
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0???1CSpeedTreeRT@@QAE@XZ@4JA
	add	eax, 12					; 0000000cH
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN4@CSpeedTree:

; 549  :     (*m_pInstanceRefCount)--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [ecx], edx

; 550  : 
; 551  :     // if this tree was an instance
; 552  :     if (m_pInstanceData)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	$LN5@CSpeedTree

; 553  :     {
; 554  :         // find the instance in the parent's instance list and delete it
; 555  :         st_assert(m_pInstanceList);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN6@CSpeedTree
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0???1CSpeedTreeRT@@QAE@XZ@4JA
	add	eax, 19					; 00000013H
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN6@CSpeedTree:

; 556  :         vector<CSpeedTreeRT*>::iterator iFind = find(m_pInstanceList->m_vInstances.begin( ), m_pInstanceList->m_vInstances.end( ), this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T25[ebp], eax
	lea	ecx, DWORD PTR $T25[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T24[ebp], esp
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?end@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::end
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T23[ebp], esp
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?begin@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::begin
	lea	eax, DWORD PTR _iFind$33[ebp]
	push	eax
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@PAVCSpeedTreeRT@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@0@V10@V10@ABQAVCSpeedTreeRT@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >,CSpeedTreeRT *>
	add	esp, 32					; 00000020H

; 557  :         st_assert(iFind != m_pInstanceList->m_vInstances.end( ));

	lea	eax, DWORD PTR $T21[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?end@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@XZ ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::end
	push	eax
	lea	ecx, DWORD PTR _iFind$33[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSpeedTreeRT *> > >::operator!=
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN11@CSpeedTree
	mov	DWORD PTR tv264[ebp], 1
	jmp	SHORT $LN12@CSpeedTree
$LN11@CSpeedTree:
	mov	DWORD PTR tv264[ebp], 0
$LN12@CSpeedTree:
	mov	al, BYTE PTR tv264[ebp]
	mov	BYTE PTR $T22[ebp], al
	lea	ecx, DWORD PTR $T21[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	movzx	ecx, BYTE PTR $T22[ebp]
	test	ecx, ecx
	je	SHORT $LN7@CSpeedTree
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0DH@MPDFADCB@D?3?2pw152?2Common?2SpeedTreeRT?2Sou@
	push	OFFSET ??_C@_08KPJKAGGE@?0?5file?3?5@
	mov	eax, DWORD PTR ?__LINE__Var@?0???1CSpeedTreeRT@@QAE@XZ@4JA
	add	eax, 21					; 00000015H
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0BH@GINBHAOG@Assertion?5failed?6Line?5@
	mov	ecx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	esi, esp
	call	DWORD PTR __imp__abort
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
$LN7@CSpeedTree:

; 558  :         (void) m_pInstanceList->m_vInstances.erase(iFind);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T20[ebp], esp
	lea	eax, DWORD PTR _iFind$33[ebp]
	push	eax
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@ABV01@@Z
	lea	ecx, DWORD PTR $T19[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?erase@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@2@@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::erase
	lea	ecx, DWORD PTR $T19[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	npad	1

; 559  : 
; 560  :         // delete the data
; 561  :         delete m_pInstanceData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR $T18[ebp], ecx
	push	20					; 00000014H
	mov	edx, DWORD PTR $T18[ebp]
	push	edx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 562  :         m_pInstanceData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 0

; 563  :     }

	lea	ecx, DWORD PTR _iFind$33[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeRT@@@std@@@std@@@std@@QAE@XZ
	npad	1
$LN5@CSpeedTree:

; 564  : 
; 565  :     // if this is the last class to hold these pointers, they should be deleted
; 566  :     if (*m_pInstanceRefCount == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	cmp	DWORD PTR [ecx], 0
	jne	$LN8@CSpeedTree

; 567  :     {
; 568  :         DeleteTransientData( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteTransientData@CSpeedTreeRT@@QAEXXZ ; CSpeedTreeRT::DeleteTransientData
	npad	1

; 569  :         delete m_pBranchGeometry;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T17[ebp], ecx
	cmp	DWORD PTR $T17[ebp], 0
	je	SHORT $LN13@CSpeedTree
	push	1
	mov	ecx, DWORD PTR $T17[ebp]
	call	??_GCIndexedGeometry@@QAEPAXI@Z
	mov	DWORD PTR tv319[ebp], eax
	jmp	SHORT $LN14@CSpeedTree
$LN13@CSpeedTree:
	mov	DWORD PTR tv319[ebp], 0
$LN14@CSpeedTree:

; 570  :         delete m_pLightingEngine;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T16[ebp], ecx
	push	176					; 000000b0H
	mov	edx, DWORD PTR $T16[ebp]
	push	edx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 571  :         delete m_pWindEngine;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T15[ebp], ecx
	push	68					; 00000044H
	mov	edx, DWORD PTR $T15[ebp]
	push	edx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 572  :         delete m_pLeafGeometry;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T14[ebp], ecx
	cmp	DWORD PTR $T14[ebp], 0
	je	SHORT $LN15@CSpeedTree
	push	1
	mov	ecx, DWORD PTR $T14[ebp]
	call	??_GCLeafGeometry@@QAEPAXI@Z
	mov	DWORD PTR tv331[ebp], eax
	jmp	SHORT $LN16@CSpeedTree
$LN15@CSpeedTree:
	mov	DWORD PTR tv331[ebp], 0
$LN16@CSpeedTree:

; 573  :         delete m_pSimpleBillboard;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T13[ebp], ecx
	push	52					; 00000034H
	mov	edx, DWORD PTR $T13[ebp]
	push	edx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 574  :         delete m_pEngine;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T12[ebp], ecx
	cmp	DWORD PTR $T12[ebp], 0
	je	SHORT $LN17@CSpeedTree
	mov	esi, esp
	push	1
	mov	edx, DWORD PTR $T12[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T12[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv346[ebp], eax
	jmp	SHORT $LN18@CSpeedTree
$LN17@CSpeedTree:
	mov	DWORD PTR tv346[ebp], 0
$LN18@CSpeedTree:

; 575  :         delete m_pInstanceRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR $T11[ebp], ecx
	push	4
	mov	edx, DWORD PTR $T11[ebp]
	push	edx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 576  :         delete m_pInstanceList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR $T10[ebp], ecx
	cmp	DWORD PTR $T10[ebp], 0
	je	SHORT $LN19@CSpeedTree
	push	1
	mov	ecx, DWORD PTR $T10[ebp]
	call	??_GSInstanceList@@QAEPAXI@Z
	mov	DWORD PTR tv355[ebp], eax
	jmp	SHORT $LN20@CSpeedTree
$LN19@CSpeedTree:
	mov	DWORD PTR tv355[ebp], 0
$LN20@CSpeedTree:

; 577  :         delete[] m_pTreeSizes;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR $T9[ebp], ecx
	mov	edx, DWORD PTR $T9[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 578  :         delete m_pCollisionObjects;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T8[ebp], ecx
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN21@CSpeedTree
	push	1
	mov	ecx, DWORD PTR $T8[ebp]
	call	??_GSCollisionObjects@@QAEPAXI@Z
	mov	DWORD PTR tv363[ebp], eax
	jmp	SHORT $LN22@CSpeedTree
$LN21@CSpeedTree:
	mov	DWORD PTR tv363[ebp], 0
$LN22@CSpeedTree:

; 579  :         delete m_pEmbeddedTexCoords;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T7[ebp], ecx
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN23@CSpeedTree
	push	1
	mov	ecx, DWORD PTR $T7[ebp]
	call	??_GSEmbeddedTexCoords@@QAEPAXI@Z
	mov	DWORD PTR tv369[ebp], eax
	jmp	SHORT $LN24@CSpeedTree
$LN23@CSpeedTree:
	mov	DWORD PTR tv369[ebp], 0
$LN24@CSpeedTree:

; 580  :         delete m_pFrondEngine;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T6[ebp], ecx
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN25@CSpeedTree
	push	1
	mov	ecx, DWORD PTR $T6[ebp]
	call	??_GCFrondEngine@@QAEPAXI@Z
	mov	DWORD PTR tv375[ebp], eax
	jmp	SHORT $LN26@CSpeedTree
$LN25@CSpeedTree:
	mov	DWORD PTR tv375[ebp], 0
$LN26@CSpeedTree:

; 581  :         delete m_pFrondGeometry;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR $T5[ebp], ecx
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN27@CSpeedTree
	push	1
	mov	ecx, DWORD PTR $T5[ebp]
	call	??_GCIndexedGeometry@@QAEPAXI@Z
	mov	DWORD PTR tv381[ebp], eax
	jmp	SHORT $LN28@CSpeedTree
$LN27@CSpeedTree:
	mov	DWORD PTR tv381[ebp], 0
$LN28@CSpeedTree:

; 582  :         delete m_pLeafLodSizeFactors;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T4[ebp], ecx
	push	4
	mov	edx, DWORD PTR $T4[ebp]
	push	edx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 583  :         delete m_pProjectedShadow;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN29@CSpeedTree
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??_GCProjectedShadow@@QAEPAXI@Z
	mov	DWORD PTR tv422[ebp], eax
	jmp	SHORT $LN30@CSpeedTree
$LN29@CSpeedTree:
	mov	DWORD PTR tv422[ebp], 0
$LN30@CSpeedTree:

; 584  :         delete[] m_pUserData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN8@CSpeedTree:

; 585  :     }
; 586  : 
; 587  :     // null the pointers because delete has been called on this
; 588  :     // instance even though memory may not necessarily be freed.
; 589  : 
; 590  :     //lint -save -e672
; 591  :     m_pBranchGeometry = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 592  :     m_pLightingEngine = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 593  :     m_pWindEngine = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 594  :     m_pLeafGeometry = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 595  :     m_pSimpleBillboard = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 596  :     m_pEngine = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 597  :     m_pInstanceRefCount = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 598  :     m_pTreeSizes = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64], 0

; 599  :     m_pInstanceList = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 600  :     m_pCollisionObjects = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 0

; 601  :     m_pEmbeddedTexCoords = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+76], 0

; 602  :     m_pFrondEngine = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+88], 0

; 603  :     m_pFrondGeometry = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+92], 0

; 604  :     m_pLeafLodSizeFactors = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 0

; 605  :     m_pProjectedShadow = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+80], 0

; 606  :     m_pUserData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], 0

; 607  :     //lint -restore 
; 608  : 
; 609  :     if (!--m_uiAllRefCount)

	mov	eax, DWORD PTR ?m_uiAllRefCount@CSpeedTreeRT@@0IA ; CSpeedTreeRT::m_uiAllRefCount
	sub	eax, 1
	mov	DWORD PTR ?m_uiAllRefCount@CSpeedTreeRT@@0IA, eax ; CSpeedTreeRT::m_uiAllRefCount
	jne	SHORT $LN9@CSpeedTree

; 610  :         CIdvBezierSpline::ClearCache( );

	call	?ClearCache@CIdvBezierSpline@@SAXXZ	; CIdvBezierSpline::ClearCache
	npad	1
$LN9@CSpeedTree:
$LN1@CSpeedTree:

; 611  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN36@CSpeedTree
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 664				; 00000298H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN36@CSpeedTree:
	DD	2
	DD	$LN35@CSpeedTree
$LN35@CSpeedTree:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN32@CSpeedTree
	DD	-60					; ffffffc4H
	DD	12					; 0000000cH
	DD	$LN33@CSpeedTree
$LN33@CSpeedTree:
	DB	105					; 00000069H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$LN32@CSpeedTree:
	DB	105					; 00000069H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CSpeedTreeRT@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-668]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CSpeedTreeRT@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CSpeedTreeRT@@QAE@XZ ENDP				; CSpeedTreeRT::~CSpeedTreeRT
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??0CSpeedTreeRT@@QAE@XZ
_TEXT	SEGMENT
tv253 = -572						; size = 4
tv238 = -572						; size = 4
tv202 = -572						; size = 4
tv190 = -572						; size = 4
tv176 = -572						; size = 4
tv164 = -572						; size = 4
tv150 = -572						; size = 4
tv135 = -572						; size = 4
tv347 = -568						; size = 4
tv345 = -568						; size = 4
tv340 = -568						; size = 4
tv338 = -568						; size = 4
tv336 = -568						; size = 4
tv334 = -568						; size = 4
tv332 = -568						; size = 4
tv330 = -568						; size = 4
tv327 = -568						; size = 4
tv324 = -568						; size = 4
tv225 = -568						; size = 4
tv349 = -564						; size = 4
tv348 = -564						; size = 4
tv346 = -564						; size = 4
tv344 = -564						; size = 4
tv343 = -564						; size = 4
tv342 = -564						; size = 4
tv341 = -564						; size = 4
tv339 = -564						; size = 4
tv337 = -564						; size = 4
tv335 = -564						; size = 4
tv333 = -564						; size = 4
tv331 = -564						; size = 4
tv329 = -564						; size = 4
$T2 = -556						; size = 28
$T3 = -520						; size = 28
$T4 = -484						; size = 4
$T5 = -472						; size = 4
$T6 = -460						; size = 4
$T7 = -448						; size = 4
$T8 = -436						; size = 4
$T9 = -424						; size = 4
$T10 = -412						; size = 4
$T11 = -400						; size = 4
$T12 = -388						; size = 4
$T13 = -376						; size = 4
$T14 = -364						; size = 4
$T15 = -352						; size = 4
$T16 = -340						; size = 4
$T17 = -328						; size = 4
$T18 = -316						; size = 4
$T19 = -304						; size = 4
$T20 = -292						; size = 4
$T21 = -280						; size = 4
$T22 = -268						; size = 4
$T23 = -256						; size = 4
_cException$24 = -52					; size = 4
_i$25 = -40						; size = 4
_this$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
??0CSpeedTreeRT@@QAE@XZ PROC				; CSpeedTreeRT::CSpeedTreeRT, COMDAT
; _this$ = ecx

; 418  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CSpeedTreeRT@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 556				; 0000022cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-380]
	mov	ecx, 91					; 0000005bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 392  :     m_pEngine(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 391  :     m_pBranchGeometry(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 396  :     m_pLeafGeometry(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 393  :     m_pLightingEngine(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 394  :     m_pWindEngine(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 395  :     m_pSimpleBillboard(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 397  :     m_eLeafLodMethod(LOD_SMOOTH),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 1

; 398  :     m_fLeafLodTransitionRadius(0.07f),

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3d8f5c29
	movss	DWORD PTR [eax+28], xmm0

; 399  :     m_fLeafLodCurveExponent(0.7f),

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR [eax+32], xmm0

; 407  :     m_fLeafSizeIncreaseFactor(0.5f),

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [eax+36], xmm0

; 400  :     m_fLeafTransitionFactor(0.0f),

	mov	eax, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+40], xmm0

; 401  :     m_pLeafLodSizeFactors(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 0

; 402  :     m_pInstanceRefCount(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 403  :     m_pInstanceData(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 0

; 412  :     m_nFrondLevel(-1),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], -1

; 404  :     m_pTreeSizes(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64], 0

; 405  :     m_ucTargetAlphaValue(0x54),

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+68], 84			; 00000054H

; 406  :     m_bTreeComputed(false),

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+69], 0

; 411  :     m_nBranchWindLevel(-1),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+72], -1

; 408  :     m_pEmbeddedTexCoords(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+76], 0

; 414  :     m_pProjectedShadow(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+80], 0

; 409  :     m_pCollisionObjects(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 0

; 410  :     m_pFrondEngine(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+88], 0

; 413  :     m_usNumFrondLodLevels(0),

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+96], ax

; 415  :     m_pUserData(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], 0

; 417  :     m_b360Billboard(false)

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+104], 0

; 416  :     m_bHorizontalBillboard(false),

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+105], 0

; 419  :     try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 420  :     {
; 421  :         m_pWindEngine = new CWindEngine;

	push	68					; 00000044H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv329[ebp], eax
	mov	eax, DWORD PTR tv329[ebp]
	mov	DWORD PTR $T22[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T22[ebp], 0
	je	SHORT $LN7@CSpeedTree
	mov	ecx, DWORD PTR $T22[ebp]
	call	??0CWindEngine@@QAE@XZ			; CWindEngine::CWindEngine
	mov	DWORD PTR tv330[ebp], eax
	mov	ecx, DWORD PTR tv330[ebp]
	mov	DWORD PTR tv135[ebp], ecx
	jmp	SHORT $LN8@CSpeedTree
$LN7@CSpeedTree:
	mov	DWORD PTR tv135[ebp], 0
$LN8@CSpeedTree:
	mov	edx, DWORD PTR tv135[ebp]
	mov	DWORD PTR $T23[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T23[ebp]
	mov	DWORD PTR [eax+16], ecx

; 422  :         m_pBranchGeometry = new CIndexedGeometry(m_pWindEngine);

	push	272					; 00000110H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv331[ebp], eax
	mov	eax, DWORD PTR tv331[ebp]
	mov	DWORD PTR $T20[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	cmp	DWORD PTR $T20[ebp], 0
	je	SHORT $LN9@CSpeedTree
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR $T20[ebp]
	call	??0CIndexedGeometry@@QAE@PAVCWindEngine@@_N@Z ; CIndexedGeometry::CIndexedGeometry
	mov	DWORD PTR tv332[ebp], eax
	mov	eax, DWORD PTR tv332[ebp]
	mov	DWORD PTR tv150[ebp], eax
	jmp	SHORT $LN10@CSpeedTree
$LN9@CSpeedTree:
	mov	DWORD PTR tv150[ebp], 0
$LN10@CSpeedTree:
	mov	ecx, DWORD PTR tv150[ebp]
	mov	DWORD PTR $T21[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T21[ebp]
	mov	DWORD PTR [edx+4], eax

; 423  :         m_pEngine = new CTreeEngine(m_pBranchGeometry);

	push	260					; 00000104H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv333[ebp], eax
	mov	eax, DWORD PTR tv333[ebp]
	mov	DWORD PTR $T18[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	cmp	DWORD PTR $T18[ebp], 0
	je	SHORT $LN11@CSpeedTree
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR $T18[ebp]
	call	??0CTreeEngine@@QAE@PAVCIndexedGeometry@@@Z ; CTreeEngine::CTreeEngine
	mov	DWORD PTR tv334[ebp], eax
	mov	eax, DWORD PTR tv334[ebp]
	mov	DWORD PTR tv164[ebp], eax
	jmp	SHORT $LN12@CSpeedTree
$LN11@CSpeedTree:
	mov	DWORD PTR tv164[ebp], 0
$LN12@CSpeedTree:
	mov	ecx, DWORD PTR tv164[ebp]
	mov	DWORD PTR $T19[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T19[ebp]
	mov	DWORD PTR [edx], eax

; 424  :         m_pLightingEngine = new CLightingEngine;

	push	176					; 000000b0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv335[ebp], eax
	mov	eax, DWORD PTR tv335[ebp]
	mov	DWORD PTR $T16[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	cmp	DWORD PTR $T16[ebp], 0
	je	SHORT $LN13@CSpeedTree
	mov	ecx, DWORD PTR $T16[ebp]
	call	??0CLightingEngine@@QAE@XZ		; CLightingEngine::CLightingEngine
	mov	DWORD PTR tv336[ebp], eax
	mov	ecx, DWORD PTR tv336[ebp]
	mov	DWORD PTR tv176[ebp], ecx
	jmp	SHORT $LN14@CSpeedTree
$LN13@CSpeedTree:
	mov	DWORD PTR tv176[ebp], 0
$LN14@CSpeedTree:
	mov	edx, DWORD PTR tv176[ebp]
	mov	DWORD PTR $T17[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T17[ebp]
	mov	DWORD PTR [eax+12], ecx

; 425  :         m_pLeafGeometry = new CLeafGeometry(m_pWindEngine);

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv337[ebp], eax
	mov	eax, DWORD PTR tv337[ebp]
	mov	DWORD PTR $T14[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 5
	cmp	DWORD PTR $T14[ebp], 0
	je	SHORT $LN15@CSpeedTree
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR $T14[ebp]
	call	??0CLeafGeometry@@QAE@PAVCWindEngine@@@Z ; CLeafGeometry::CLeafGeometry
	mov	DWORD PTR tv338[ebp], eax
	mov	eax, DWORD PTR tv338[ebp]
	mov	DWORD PTR tv190[ebp], eax
	jmp	SHORT $LN16@CSpeedTree
$LN15@CSpeedTree:
	mov	DWORD PTR tv190[ebp], 0
$LN16@CSpeedTree:
	mov	ecx, DWORD PTR tv190[ebp]
	mov	DWORD PTR $T15[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T15[ebp]
	mov	DWORD PTR [edx+8], eax

; 426  :         m_pSimpleBillboard = new CSimpleBillboard;

	push	52					; 00000034H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv339[ebp], eax
	mov	eax, DWORD PTR tv339[ebp]
	mov	DWORD PTR $T12[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 6
	cmp	DWORD PTR $T12[ebp], 0
	je	SHORT $LN17@CSpeedTree
	mov	ecx, DWORD PTR $T12[ebp]
	call	??0CSimpleBillboard@@QAE@XZ		; CSimpleBillboard::CSimpleBillboard
	mov	DWORD PTR tv340[ebp], eax
	mov	ecx, DWORD PTR tv340[ebp]
	mov	DWORD PTR tv202[ebp], ecx
	jmp	SHORT $LN18@CSpeedTree
$LN17@CSpeedTree:
	mov	DWORD PTR tv202[ebp], 0
$LN18@CSpeedTree:
	mov	edx, DWORD PTR tv202[ebp]
	mov	DWORD PTR $T13[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T13[ebp]
	mov	DWORD PTR [eax+20], ecx

; 427  :         m_pTreeSizes = new float[STS_COUNT];

	push	28					; 0000001cH
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR tv341[ebp], eax
	mov	eax, DWORD PTR tv341[ebp]
	mov	DWORD PTR $T11[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T11[ebp]
	mov	DWORD PTR [ecx+64], edx

; 428  :         m_pInstanceRefCount = new unsigned int;

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv342[ebp], eax
	mov	eax, DWORD PTR tv342[ebp]
	mov	DWORD PTR $T10[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T10[ebp]
	mov	DWORD PTR [ecx+48], edx

; 429  :         *m_pInstanceRefCount = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [ecx], 1

; 430  :         m_pInstanceList = new SInstanceList;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv343[ebp], eax
	mov	eax, DWORD PTR tv343[ebp]
	mov	DWORD PTR $T9[ebp], eax
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN19@CSpeedTree
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0SInstanceList@@QAE@XZ
	mov	DWORD PTR tv225[ebp], eax
	jmp	SHORT $LN20@CSpeedTree
$LN19@CSpeedTree:
	mov	DWORD PTR tv225[ebp], 0
$LN20@CSpeedTree:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv225[ebp]
	mov	DWORD PTR [ecx+56], edx

; 431  : 
; 432  :         // fronds
; 433  :         m_pFrondEngine = new CFrondEngine;

	push	108					; 0000006cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv344[ebp], eax
	mov	eax, DWORD PTR tv344[ebp]
	mov	DWORD PTR $T7[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN21@CSpeedTree
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0CFrondEngine@@QAE@XZ			; CFrondEngine::CFrondEngine
	mov	DWORD PTR tv345[ebp], eax
	mov	ecx, DWORD PTR tv345[ebp]
	mov	DWORD PTR tv238[ebp], ecx
	jmp	SHORT $LN22@CSpeedTree
$LN21@CSpeedTree:
	mov	DWORD PTR tv238[ebp], 0
$LN22@CSpeedTree:
	mov	edx, DWORD PTR tv238[ebp]
	mov	DWORD PTR $T8[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T8[ebp]
	mov	DWORD PTR [eax+88], ecx

; 434  :         m_pFrondGeometry = new CIndexedGeometry(m_pWindEngine, true);

	push	272					; 00000110H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv346[ebp], eax
	mov	eax, DWORD PTR tv346[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 8
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN23@CSpeedTree
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0CIndexedGeometry@@QAE@PAVCWindEngine@@_N@Z ; CIndexedGeometry::CIndexedGeometry
	mov	DWORD PTR tv347[ebp], eax
	mov	eax, DWORD PTR tv347[ebp]
	mov	DWORD PTR tv253[ebp], eax
	jmp	SHORT $LN24@CSpeedTree
$LN23@CSpeedTree:
	mov	DWORD PTR tv253[ebp], 0
$LN24@CSpeedTree:
	mov	ecx, DWORD PTR tv253[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR [edx+92], eax

; 435  : 
; 436  :         // add to global tree list
; 437  :         SInstanceList::m_vUniqueTrees.push_back(this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T4[ebp], eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, OFFSET ?m_vUniqueTrees@SInstanceList@@2V?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@A ; SInstanceList::m_vUniqueTrees
	call	?push_back@?$vector@PAVCSpeedTreeRT@@V?$allocator@PAVCSpeedTreeRT@@@std@@@std@@QAEX$$QAPAVCSpeedTreeRT@@@Z ; std::vector<CSpeedTreeRT *,std::allocator<CSpeedTreeRT *> >::push_back
	npad	1

; 438  :         m_uiAllRefCount++;

	mov	eax, DWORD PTR ?m_uiAllRefCount@CSpeedTreeRT@@0IA ; CSpeedTreeRT::m_uiAllRefCount
	add	eax, 1
	mov	DWORD PTR ?m_uiAllRefCount@CSpeedTreeRT@@0IA, eax ; CSpeedTreeRT::m_uiAllRefCount

; 439  : 
; 440  :         CIdvBranch::SetLightingEngine(m_pLightingEngine);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	?SetLightingEngine@CIdvBranch@@SAXPAVCLightingEngine@@@Z ; CIdvBranch::SetLightingEngine
	add	esp, 4

; 441  : 
; 442  :         // setup initial tree extents
; 443  :         m_pTreeSizes[STS_MIN_BOX + 0] = 0.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0

; 444  :         m_pTreeSizes[STS_MIN_BOX + 1] = 0.0f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 445  :         m_pTreeSizes[STS_MIN_BOX + 2] = 0.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 446  :         m_pTreeSizes[STS_MAX_BOX + 0] = 1.0f;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+eax], xmm0

; 447  :         m_pTreeSizes[STS_MAX_BOX + 1] = 1.0f;

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+edx], xmm0

; 448  :         m_pTreeSizes[STS_MAX_BOX + 2] = 1.0f;

	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+eax], xmm0

; 449  :         m_pTreeSizes[STS_BB_SIZE] = 1.0f;

	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+eax], xmm0

; 450  : 
; 451  :         // zero out horizontal coords
; 452  :         for (int i = 0; i < 12; ++i)

	mov	DWORD PTR _i$25[ebp], 0
	jmp	SHORT $LN4@CSpeedTree
$LN2@CSpeedTree:
	mov	eax, DWORD PTR _i$25[ebp]
	add	eax, 1
	mov	DWORD PTR _i$25[ebp], eax
$LN4@CSpeedTree:
	cmp	DWORD PTR _i$25[ebp], 12		; 0000000cH
	jge	SHORT $LN3@CSpeedTree

; 453  :             m_afHorizontalCoords[i] = 0.0f;

	mov	eax, DWORD PTR _i$25[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax*4+108], xmm0
	jmp	SHORT $LN2@CSpeedTree
$LN3@CSpeedTree:

; 454  :     }

	jmp	$LN25@CSpeedTree
__catch$??0CSpeedTreeRT@@QAE@XZ$0:

; 455  : 
; 456  :     SpeedTreeCatch("CSpeedTreeRT::CSpeedTreeRT( )")

	mov	esi, esp
	mov	eax, DWORD PTR _cException$24[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cException$24[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET ??_C@_0BO@KEOEHMAH@CSpeedTreeRT?3?3CSpeedTreeRT?$CI?5?$CJ@
	push	OFFSET ??_C@_0BB@PLNFOAPE@?$CFs?5?9?5failed?5?$FL?$CFs?$FN@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv348[ebp], eax
	mov	edx, DWORD PTR tv348[ebp]
	mov	DWORD PTR tv324[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 10		; 0000000aH
	mov	ecx, DWORD PTR tv324[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 9
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN39@CSpeedTree
	ret	0
__catch$??0CSpeedTreeRT@@QAE@XZ$1:

; 457  :     SpeedTreeCatchAll("CSpeedTreeRT::CSpeedTreeRT( )");

	push	OFFSET ??_C@_0BO@KEOEHMAH@CSpeedTreeRT?3?3CSpeedTreeRT?$CI?5?$CJ@
	push	OFFSET ??_C@_0CH@HAKOOGJA@?$CFs?5?9?5threw?5an?5unknown?5system?5ex@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; IdvFormatString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv349[ebp], eax
	mov	ecx, DWORD PTR tv349[ebp]
	mov	DWORD PTR tv327[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 11		; 0000000bH
	mov	ecx, DWORD PTR tv327[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?SetError@CSpeedTreeRT@@CAXPBD@Z	; CSpeedTreeRT::SetError
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 9
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, $LN41@CSpeedTree
	ret	0
$LN25@CSpeedTree:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN40@CSpeedTree
$LN41@CSpeedTree:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN38@CSpeedTree
$LN40@CSpeedTree:
	jmp	SHORT $LN38@CSpeedTree
$LN39@CSpeedTree:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN38@CSpeedTree:

; 458  : }

	mov	eax, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN45@CSpeedTree
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 572				; 0000023cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN45@CSpeedTree:
	DD	1
	DD	$LN44@CSpeedTree
$LN44@CSpeedTree:
	DD	-52					; ffffffccH
	DD	4
	DD	$LN42@CSpeedTree
$LN42@CSpeedTree:
	DB	99					; 00000063H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$3:
	push	68					; 00000044H
	mov	eax, DWORD PTR $T22[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$4:
	push	272					; 00000110H
	mov	eax, DWORD PTR $T20[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$5:
	push	260					; 00000104H
	mov	eax, DWORD PTR $T18[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$6:
	push	176					; 000000b0H
	mov	eax, DWORD PTR $T16[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$7:
	push	48					; 00000030H
	mov	eax, DWORD PTR $T14[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$8:
	push	52					; 00000034H
	mov	eax, DWORD PTR $T12[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$9:
	push	108					; 0000006cH
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$10:
	push	272					; 00000110H
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$11:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CSpeedTreeRT@@QAE@XZ$12:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0CSpeedTreeRT@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-576]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CSpeedTreeRT@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CSpeedTreeRT@@QAE@XZ ENDP				; CSpeedTreeRT::CSpeedTreeRT
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??4STextures@CSpeedTreeRT@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4STextures@CSpeedTreeRT@@QAEAAU01@ABU01@@Z PROC	; CSpeedTreeRT::STextures::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, 7
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edi, DWORD PTR _this$[ebp]
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4STextures@CSpeedTreeRT@@QAEAAU01@ABU01@@Z ENDP	; CSpeedTreeRT::STextures::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??1STextures@CSpeedTreeRT@@QAE@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
$T2 = -212						; size = 4
_this$ = -8						; size = 4
??1STextures@CSpeedTreeRT@@QAE@XZ PROC			; CSpeedTreeRT::STextures::~STextures, COMDAT
; _this$ = ecx

; 372  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 373  :     delete[] m_pLeafTextureFilenames;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 374  :     m_pLeafTextureFilenames = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 375  : 
; 376  :     delete[] m_pFrondTextureFilenames;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 377  :     m_pFrondTextureFilenames = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 378  : 
; 379  :     m_pBranchTextureFilename = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 380  :     m_pCompositeFilename = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 381  :     m_pSelfShadowFilename = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1STextures@CSpeedTreeRT@@QAE@XZ ENDP			; CSpeedTreeRT::STextures::~STextures
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??0STextures@CSpeedTreeRT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0STextures@CSpeedTreeRT@@QAE@XZ PROC			; CSpeedTreeRT::STextures::STextures, COMDAT
; _this$ = ecx

; 363  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 356  :     m_pBranchTextureFilename(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 357  :     m_uiLeafTextureCount(0),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 358  :     m_pLeafTextureFilenames(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 359  :     m_uiFrondTextureCount(0),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 360  :     m_pFrondTextureFilenames(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 361  :     m_pCompositeFilename(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 362  :     m_pSelfShadowFilename(NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 364  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0STextures@CSpeedTreeRT@@QAE@XZ ENDP			; CSpeedTreeRT::STextures::STextures
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??4SGeometry@CSpeedTreeRT@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4SGeometry@CSpeedTreeRT@@QAEAAU01@ABU01@@Z PROC	; CSpeedTreeRT::SGeometry::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, 72					; 00000048H
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edi, DWORD PTR _this$[ebp]
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4SGeometry@CSpeedTreeRT@@QAEAAU01@ABU01@@Z ENDP	; CSpeedTreeRT::SGeometry::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??4SBillboard@SGeometry@CSpeedTreeRT@@QAEAAU012@ABU012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4SBillboard@SGeometry@CSpeedTreeRT@@QAEAAU012@ABU012@@Z PROC ; CSpeedTreeRT::SGeometry::SBillboard::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4SBillboard@SGeometry@CSpeedTreeRT@@QAEAAU012@ABU012@@Z ENDP ; CSpeedTreeRT::SGeometry::SBillboard::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??1SBillboard@SGeometry@CSpeedTreeRT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1SBillboard@SGeometry@CSpeedTreeRT@@QAE@XZ PROC	; CSpeedTreeRT::SGeometry::SBillboard::~SBillboard, COMDAT
; _this$ = ecx

; 346  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 347  :     m_pTexCoords = NULL; // deleted in SEmbeddedTexCoords

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 348  :     m_pCoords = NULL; // deleted in CSimpleBillboard

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 349  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1SBillboard@SGeometry@CSpeedTreeRT@@QAE@XZ ENDP	; CSpeedTreeRT::SGeometry::SBillboard::~SBillboard
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??0SBillboard@SGeometry@CSpeedTreeRT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0SBillboard@SGeometry@CSpeedTreeRT@@QAE@XZ PROC	; CSpeedTreeRT::SGeometry::SBillboard::SBillboard, COMDAT
; _this$ = ecx

; 338  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 334  :     m_bIsActive(false),

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 0

; 335  :     m_pTexCoords(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 336  :     m_pCoords(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 337  :     m_fAlphaTestValue(-1.0f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+12], xmm0

; 339  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0SBillboard@SGeometry@CSpeedTreeRT@@QAE@XZ ENDP	; CSpeedTreeRT::SGeometry::SBillboard::SBillboard
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??4SLeaf@SGeometry@CSpeedTreeRT@@QAEAAU012@ABU012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4SLeaf@SGeometry@CSpeedTreeRT@@QAEAAU012@ABU012@@Z PROC ; CSpeedTreeRT::SGeometry::SLeaf::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, 15					; 0000000fH
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edi, DWORD PTR _this$[ebp]
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4SLeaf@SGeometry@CSpeedTreeRT@@QAEAAU012@ABU012@@Z ENDP ; CSpeedTreeRT::SGeometry::SLeaf::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??1SLeaf@SGeometry@CSpeedTreeRT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1SLeaf@SGeometry@CSpeedTreeRT@@QAE@XZ PROC		; CSpeedTreeRT::SGeometry::SLeaf::~SLeaf, COMDAT
; _this$ = ecx

; 314  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 315  :     // this data is deleted in CLeafGeometry::SLodGeometry::~SLodGeometry( )
; 316  :     m_pLeafMapIndices = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 317  :     m_pLeafClusterIndices = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 318  :     m_pCenterCoords = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 319  :     m_pColors = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 320  :     m_pNormals = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0

; 321  :     m_pBinormals = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 0

; 322  :     m_pTangents = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 323  :     m_pLeafMapTexCoords = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 324  :     m_pLeafMapCoords = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 325  :     m_pWindWeights = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 0

; 326  :     m_pWindMatrixIndices = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 327  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1SLeaf@SGeometry@CSpeedTreeRT@@QAE@XZ ENDP		; CSpeedTreeRT::SGeometry::SLeaf::~SLeaf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??0SLeaf@SGeometry@CSpeedTreeRT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0SLeaf@SGeometry@CSpeedTreeRT@@QAE@XZ PROC		; CSpeedTreeRT::SGeometry::SLeaf::SLeaf, COMDAT
; _this$ = ecx

; 306  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 291  :     m_bIsActive(false),

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 0

; 292  :     m_fAlphaTestValue(-1.0f),

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+4], xmm0

; 293  :     m_nDiscreteLodLevel(-1),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], -1

; 294  :     m_usLeafCount(0),

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax

; 295  :     m_pLeafMapIndices(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 296  :     m_pLeafClusterIndices(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 297  :     m_pCenterCoords(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 302  :     m_pLeafMapTexCoords(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 303  :     m_pLeafMapCoords(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 298  :     m_pColors(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 299  :     m_pNormals(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0

; 300  :     m_pBinormals(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 0

; 301  :     m_pTangents(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 304  :     m_pWindWeights(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 0

; 305  :     m_pWindMatrixIndices(NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 307  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0SLeaf@SGeometry@CSpeedTreeRT@@QAE@XZ ENDP		; CSpeedTreeRT::SGeometry::SLeaf::SLeaf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??4SIndexed@SGeometry@CSpeedTreeRT@@QAEAAU012@ABU012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4SIndexed@SGeometry@CSpeedTreeRT@@QAEAAU012@ABU012@@Z PROC ; CSpeedTreeRT::SGeometry::SIndexed::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, 14					; 0000000eH
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edi, DWORD PTR _this$[ebp]
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4SIndexed@SGeometry@CSpeedTreeRT@@QAEAAU012@ABU012@@Z ENDP ; CSpeedTreeRT::SGeometry::SIndexed::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??1SIndexed@SGeometry@CSpeedTreeRT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1SIndexed@SGeometry@CSpeedTreeRT@@QAE@XZ PROC		; CSpeedTreeRT::SGeometry::SIndexed::~SIndexed, COMDAT
; _this$ = ecx

; 271  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 272  :     // these tables are deleted in ~CIndexedGeometry( )
; 273  :     m_pColors = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 274  :     m_pNormals = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 275  :     m_pBinormals = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 276  :     m_pTangents = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 277  :     m_pCoords = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 278  :     m_pTexCoords0 = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0

; 279  :     m_pTexCoords1 = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 0

; 280  :     m_pWindWeights = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 281  :     m_pWindMatrixIndices = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 0

; 282  :     m_pStripLengths = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 283  :     m_pStrips = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1SIndexed@SGeometry@CSpeedTreeRT@@QAE@XZ ENDP		; CSpeedTreeRT::SGeometry::SIndexed::~SIndexed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??0SIndexed@SGeometry@CSpeedTreeRT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0SIndexed@SGeometry@CSpeedTreeRT@@QAE@XZ PROC		; CSpeedTreeRT::SGeometry::SIndexed::SIndexed, COMDAT
; _this$ = ecx

; 263  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 250  :     m_nDiscreteLodLevel(-1),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], -1

; 260  :     m_usNumStrips(0),

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+4], ax

; 261  :     m_pStripLengths(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 262  :     m_pStrips(NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 249  :     m_usVertexCount(0),

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+16], ax

; 251  :     m_pColors(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 252  :     m_pNormals(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 253  :     m_pBinormals(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 254  :     m_pTangents(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 255  :     m_pCoords(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 256  :     m_pTexCoords0(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0

; 257  :     m_pTexCoords1(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 0

; 258  :     m_pWindWeights(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 259  :     m_pWindMatrixIndices(NULL),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 0

; 264  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0SIndexed@SGeometry@CSpeedTreeRT@@QAE@XZ ENDP		; CSpeedTreeRT::SGeometry::SIndexed::SIndexed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??1SGeometry@CSpeedTreeRT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1SGeometry@CSpeedTreeRT@@QAE@XZ PROC			; CSpeedTreeRT::SGeometry::~SGeometry, COMDAT
; _this$ = ecx

; 241  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 242  : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	call	??1SBillboard@SGeometry@CSpeedTreeRT@@QAE@XZ ; CSpeedTreeRT::SGeometry::SBillboard::~SBillboard
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 256				; 00000100H
	call	??1SBillboard@SGeometry@CSpeedTreeRT@@QAE@XZ ; CSpeedTreeRT::SGeometry::SBillboard::~SBillboard
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 240				; 000000f0H
	call	??1SBillboard@SGeometry@CSpeedTreeRT@@QAE@XZ ; CSpeedTreeRT::SGeometry::SBillboard::~SBillboard
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??1SLeaf@SGeometry@CSpeedTreeRT@@QAE@XZ	; CSpeedTreeRT::SGeometry::SLeaf::~SLeaf
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??1SLeaf@SGeometry@CSpeedTreeRT@@QAE@XZ	; CSpeedTreeRT::SGeometry::SLeaf::~SLeaf
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??1SIndexed@SGeometry@CSpeedTreeRT@@QAE@XZ ; CSpeedTreeRT::SGeometry::SIndexed::~SIndexed
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SIndexed@SGeometry@CSpeedTreeRT@@QAE@XZ ; CSpeedTreeRT::SGeometry::SIndexed::~SIndexed
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1SGeometry@CSpeedTreeRT@@QAE@XZ ENDP			; CSpeedTreeRT::SGeometry::~SGeometry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ??0SGeometry@CSpeedTreeRT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0SGeometry@CSpeedTreeRT@@QAE@XZ PROC			; CSpeedTreeRT::SGeometry::SGeometry, COMDAT
; _this$ = ecx

; 233  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SGeometry@CSpeedTreeRT@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0SIndexed@SGeometry@CSpeedTreeRT@@QAE@XZ ; CSpeedTreeRT::SGeometry::SIndexed::SIndexed
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 231  :     m_fBranchAlphaTestValue(-1.0f),

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+56], xmm0

; 233  : {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??0SIndexed@SGeometry@CSpeedTreeRT@@QAE@XZ ; CSpeedTreeRT::SGeometry::SIndexed::SIndexed
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 232  :     m_fFrondAlphaTestValue(-1.0f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+116], xmm0

; 233  : {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??0SLeaf@SGeometry@CSpeedTreeRT@@QAE@XZ	; CSpeedTreeRT::SGeometry::SLeaf::SLeaf
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??0SLeaf@SGeometry@CSpeedTreeRT@@QAE@XZ	; CSpeedTreeRT::SGeometry::SLeaf::SLeaf
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 240				; 000000f0H
	call	??0SBillboard@SGeometry@CSpeedTreeRT@@QAE@XZ ; CSpeedTreeRT::SGeometry::SBillboard::SBillboard
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 256				; 00000100H
	call	??0SBillboard@SGeometry@CSpeedTreeRT@@QAE@XZ ; CSpeedTreeRT::SGeometry::SBillboard::SBillboard
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	call	??0SBillboard@SGeometry@CSpeedTreeRT@@QAE@XZ ; CSpeedTreeRT::SGeometry::SBillboard::SBillboard
	npad	1

; 234  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SGeometry@CSpeedTreeRT@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SIndexed@SGeometry@CSpeedTreeRT@@QAE@XZ ; CSpeedTreeRT::SGeometry::SIndexed::~SIndexed
__unwindfunclet$??0SGeometry@CSpeedTreeRT@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1SIndexed@SGeometry@CSpeedTreeRT@@QAE@XZ ; CSpeedTreeRT::SGeometry::SIndexed::~SIndexed
__unwindfunclet$??0SGeometry@CSpeedTreeRT@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1SLeaf@SGeometry@CSpeedTreeRT@@QAE@XZ	; CSpeedTreeRT::SGeometry::SLeaf::~SLeaf
__unwindfunclet$??0SGeometry@CSpeedTreeRT@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	jmp	??1SLeaf@SGeometry@CSpeedTreeRT@@QAE@XZ	; CSpeedTreeRT::SGeometry::SLeaf::~SLeaf
__unwindfunclet$??0SGeometry@CSpeedTreeRT@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 240				; 000000f0H
	jmp	??1SBillboard@SGeometry@CSpeedTreeRT@@QAE@XZ ; CSpeedTreeRT::SGeometry::SBillboard::~SBillboard
__unwindfunclet$??0SGeometry@CSpeedTreeRT@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 256				; 00000100H
	jmp	??1SBillboard@SGeometry@CSpeedTreeRT@@QAE@XZ ; CSpeedTreeRT::SGeometry::SBillboard::~SBillboard
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0SGeometry@CSpeedTreeRT@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SGeometry@CSpeedTreeRT@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SGeometry@CSpeedTreeRT@@QAE@XZ ENDP			; CSpeedTreeRT::SGeometry::SGeometry
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibGlobals_Source\IdvGlobals.h
;	COMDAT ?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ
_TEXT	SEGMENT
$T1 = -1644						; size = 4
_szBuffer$ = -1044					; size = 1024
_vlArgs$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_pField$ = 12						; size = 4
?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ PROC ; IdvFormatString, COMDAT

; 77   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1648				; 00000670H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1072]
	mov	ecx, 268				; 0000010cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR $T1[ebp], 0

; 78   :     va_list vlArgs;
; 79   :     IdvTmpString szBuffer;
; 80   :     
; 81   :     va_start(vlArgs, pField);

	lea	eax, DWORD PTR _pField$[ebp+4]
	mov	DWORD PTR _vlArgs$[ebp], eax

; 82   :     (void) vsprintf(szBuffer, pField, vlArgs);

	mov	eax, DWORD PTR _vlArgs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pField$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	call	_vsprintf
	add	esp, 12					; 0000000cH

; 83   : 
; 84   :     return szBuffer;

	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 85   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@IdvFormatS
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1648				; 00000670H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN7@IdvFormatS:
	DD	1
	DD	$LN6@IdvFormatS
$LN6@IdvFormatS:
	DD	-1044					; fffffbecH
	DD	1024					; 00000400H
	DD	$LN5@IdvFormatS
$LN5@IdvFormatS:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?IdvFormatString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ENDP ; IdvFormatString
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
$T2 = -197						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 5006 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR $T1[ebp], 0
$LN4@operator:

; 5007 : #if _ITERATOR_DEBUG_LEVEL == 2
; 5008 :     _STL_VERIFY(_STD addressof(_Left) != _STD addressof(_Right),

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	call	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	call	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 4
	cmp	esi, eax
	je	SHORT $LN8@operator
	jmp	SHORT $LN6@operator
$LN8@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0BGJ@OHAFKLGF@You?5cannot?5concatenate?5the?5same@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	5012					; 00001394H
	push	OFFSET ??_C@_0GC@JKKBGBPG@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	mov	esi, esp
	push	0
	push	5012					; 00001394H
	push	OFFSET ??_C@_1ME@EHBBECCK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1COI@GKKHJOON@?$AA?$CC?$AAY?$AAo?$AAu?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAc?$AAo?$AAn@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@operator
$LN6@operator:
	xor	eax, eax
	jne	$LN4@operator

; 5009 :         "You cannot concatenate the same moved string to itself. See N4950 [res.on.arguments]/1.3: "
; 5010 :         "If a function argument is bound to an rvalue reference parameter, the implementation may assume that "
; 5011 :         "this parameter is a unique reference to this argument, except that the argument passed to "
; 5012 :         "a move-assignment operator may be a reference to *this ([lib.types.movedfrom]).");
; 5013 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 5014 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5015 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 5031 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR $T1[ebp], 0

; 5032 :     return _STD move(_Left.append(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	push	eax
	call	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5033 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z
_TEXT	SEGMENT
tv86 = -256						; size = 4
$T1 = -248						; size = 4
$T2 = -233						; size = 1
$T3 = -221						; size = 1
__Right_size$ = -20					; size = 4
__Left_size$ = -8					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4970 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR $T1[ebp], 0

; 4971 :     using _Size_type       = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
; 4972 :     const auto _Left_size  = _Left.size();

	mov	ecx, DWORD PTR __Left$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	DWORD PTR __Left_size$[ebp], eax

; 4973 :     const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
	add	esp, 4
	push	eax
	call	??$_Convert_size@II@std@@YAII@Z		; std::_Convert_size<unsigned int,unsigned int>
	add	esp, 4
	mov	DWORD PTR __Right_size$[ebp], eax

; 4974 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	ecx, DWORD PTR __Left$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, DWORD PTR __Left_size$[ebp]
	cmp	eax, DWORD PTR __Right_size$[ebp]
	jae	SHORT $LN2@operator

; 4975 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@operator:

; 4976 :     }
; 4977 : 
; 4978 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	al, BYTE PTR $T3[ebp]
	mov	BYTE PTR $T2[ebp], al
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	DWORD PTR tv86[ebp], eax
	mov	ecx, DWORD PTR __Right_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	eax, DWORD PTR __Left_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv86[ebp]
	push	ecx
	mov	edx, DWORD PTR __Left$[ebp]
	push	edx
	movzx	eax, BYTE PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@operator:

; 4979 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GIdvFileError@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GIdvFileError@@UAEPAXI@Z PROC			; IdvFileError::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1IdvFileError@@UAE@XZ
	npad	1
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GIdvFileError@@UAEPAXI@Z ENDP			; IdvFileError::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0IdvFileError@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0IdvFileError@@QAE@ABV0@@Z PROC			; IdvFileError::IdvFileError, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0runtime_error@std@@QAE@ABV01@@Z
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7IdvFileError@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0IdvFileError@@QAE@ABV0@@Z ENDP			; IdvFileError::IdvFileError
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1IdvFileError@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1IdvFileError@@UAE@XZ PROC				; IdvFileError::~IdvFileError, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1runtime_error@std@@UAE@XZ
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1IdvFileError@@UAE@XZ ENDP				; IdvFileError::~IdvFileError
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\LibGlobals_Source\IdvGlobals.h
;	COMDAT ??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
_TEXT	SEGMENT
tv162 = -468						; size = 4
tv171 = -464						; size = 4
tv160 = -460						; size = 4
tv170 = -456						; size = 4
tv158 = -452						; size = 4
tv169 = -448						; size = 4
tv156 = -444						; size = 4
tv168 = -440						; size = 4
tv88 = -436						; size = 4
tv151 = -432						; size = 4
tv69 = -428						; size = 4
$T2 = -420						; size = 4
$T3 = -408						; size = 28
$T4 = -372						; size = 28
$T5 = -336						; size = 28
$T6 = -300						; size = 28
$T7 = -264						; size = 28
$T8 = -228						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strDetails$ = 8					; size = 4
_bAppendSystemError$ = 12				; size = 1
??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z PROC ; IdvFileError::IdvFileError, COMDAT
; _this$ = ecx

; 46   :             runtime_error(strDetails + " [" + (bAppendSystemError ? (std::string(strerror(errno))) : "") + "]") { }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 456				; 000001c8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0
	movzx	eax, BYTE PTR _bAppendSystemError$[ebp]
	test	eax, eax
	je	SHORT $LN3@IdvFileErr
	mov	esi, esp
	call	DWORD PTR __imp___errno
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__strerror
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	lea	ecx, DWORD PTR $T7[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv69[ebp], eax
	mov	edx, DWORD PTR tv69[ebp]
	mov	DWORD PTR tv151[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR $T2[ebp]
	or	eax, 1
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR tv151[ebp]
	mov	DWORD PTR tv88[ebp], ecx
	jmp	SHORT $LN4@IdvFileErr
$LN3@IdvFileErr:
	push	OFFSET ??_C@_00CNPNBAHC@@
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv168[ebp], eax
	mov	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR tv156[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR $T2[ebp]
	or	eax, 2
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR tv156[ebp]
	mov	DWORD PTR tv88[ebp], ecx
$LN4@IdvFileErr:
	mov	edx, DWORD PTR tv88[ebp]
	mov	DWORD PTR $T8[ebp], edx
	push	OFFSET ??_C@_01LBDDMOBJ@?$FN@
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	push	OFFSET ??_C@_02GBLMOEJC@?5?$FL@
	mov	ecx, DWORD PTR _strDetails$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv169[ebp], eax
	mov	eax, DWORD PTR tv169[ebp]
	mov	DWORD PTR tv158[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv158[ebp]
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv170[ebp], eax
	mov	eax, DWORD PTR tv170[ebp]
	mov	DWORD PTR tv160[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR tv160[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv171[ebp], eax
	mov	eax, DWORD PTR tv171[ebp]
	mov	DWORD PTR tv162[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR tv162[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T5[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR $T2[ebp]
	and	edx, 2
	je	SHORT $LN13@IdvFileErr
	and	DWORD PTR $T2[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN13@IdvFileErr:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	SHORT $LN14@IdvFileErr
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T7[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN14@IdvFileErr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7IdvFileError@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 468				; 000001d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$0:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN6@IdvFileErr
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@IdvFileErr:
	ret	0
__unwindfunclet$??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$1:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 2
	je	$LN8@IdvFileErr
	and	DWORD PTR $T2[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@IdvFileErr:
	ret	0
__unwindfunclet$??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$2:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$3:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$4:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-472]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0IdvFileError@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ENDP ; IdvFileError::IdvFileError
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1runtime_error@std@@UAE@XZ
	npad	1
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7runtime_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 104  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR __Message$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@QBD@Z		; std::exception::exception
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7runtime_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1507 :     constexpr const _Ty1& _Get_first() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1508 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1509 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1503 :     constexpr _Ty1& _Get_first() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1504 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1505 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4895 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4896 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4897 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4891 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4892 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4893 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT
; _this$ = ecx

; 4887 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4888 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators
	npad	1

; 4889 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -233						; size = 1
__Al$2 = -32						; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4865 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4866 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 4867 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 4868 :         if (_My_data._Large_mode_engaged()) {

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Tidy_deall

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$2[ebp], eax

; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR __Al$2[ebp]
	push	ecx
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
	add	esp, 12					; 0000000cH

; 4872 :             _My_data._Bx._Switch_to_buf();

	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1
$LN2@Tidy_deall:

; 4873 :         }
; 4874 : 
; 4875 :         _My_data._Mysize = 0;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+20], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR __My_data$[ebp]
	lea	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 4879 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4775 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4776 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR __Requested$[ebp]
	push	edx
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	add	esp, 12					; 0000000cH

; 4777 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
__Masked$ = -8						; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4762 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	eax, DWORD PTR __Requested$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Masked$[ebp], eax

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	eax, DWORD PTR __Masked$[ebp]
	cmp	eax, DWORD PTR __Max$[ebp]
	jbe	SHORT $LN2@Calculate_

; 4765 :             return _Max;

	mov	eax, DWORD PTR __Max$[ebp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 4766 :         }
; 4767 : 
; 4768 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, DWORD PTR __Old$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR __Max$[ebp]
	sub	ecx, eax
	cmp	DWORD PTR __Old$[ebp], ecx
	jbe	SHORT $LN3@Calculate_

; 4769 :             return _Max;

	mov	eax, DWORD PTR __Max$[ebp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 4770 :         }
; 4771 : 
; 4772 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	eax, DWORD PTR __Old$[ebp]
	shr	eax, 1
	add	eax, DWORD PTR __Old$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	edx, DWORD PTR __Masked$[ebp]
	push	edx
	call	??$max@I@std@@YAABIABI0@Z		; std::max<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]
$LN1@Calculate_:

; 4773 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Calculate_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN8@Calculate_:
	DD	1
	DD	$LN7@Calculate_
$LN7@Calculate_:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN6@Calculate_
$LN6@Calculate_:
	DB	95					; 0000005fH
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -260						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
__Storage_max$ = -32					; size = 4
__Alloc_max$ = -20					; size = 4
_this$ = -8						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 4170 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4171 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
	add	esp, 4
	mov	DWORD PTR __Alloc_max$[ebp], eax

; 4172 :         const size_type _Storage_max = // can always store small string

	mov	DWORD PTR $T3[ebp], 16			; 00000010H
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR __Alloc_max$[ebp]
	push	ecx
	call	??$max@I@std@@YAABIABI0@Z		; std::max<unsigned int>
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Storage_max$[ebp], edx

; 4173 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 4174 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	eax, DWORD PTR __Storage_max$[ebp]
	sub	eax, 1
	mov	DWORD PTR $T2[ebp], eax
	call	?max@?$numeric_limits@H@std@@SAHXZ	; std::numeric_limits<int>::max
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??$min@I@std@@YAABIABI0@Z		; std::min<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 4175 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 4176 :         );
; 4177 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@max_size
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@max_size:
	DD	1
	DD	$LN5@max_size
$LN5@max_size:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN4@max_size
$LN4@max_size:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	120					; 00000078H
	DB	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 4166 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4167 :         return _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 4168 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 4162 :     _NODISCARD _CONSTEXPR20 size_type length() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4163 :         return _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 4164 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 4148 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4149 :         return _Mypair._Myval2._Myptr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 4150 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 4072 :     /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN4@operator:

; 4073 : #if _CONTAINER_DEBUG_LEVEL > 0
; 4074 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Off$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	ja	SHORT $LN8@operator
	jmp	SHORT $LN6@operator
$LN8@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	4074					; 00000feaH
	push	OFFSET ??_C@_0GC@JKKBGBPG@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	mov	esi, esp
	push	0
	push	4074					; 00000feaH
	push	OFFSET ??_C@_1ME@EHBBECCK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1EA@OADAPGGK@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@operator
$LN6@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator

; 4075 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 4076 :         return _Mypair._Myval2._Myptr()[_Off];

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]

; 4077 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3434 :     _CONSTEXPR20 basic_string& assign(_In_z_ const _Elem* const _Ptr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3435 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
	add	esp, 4
	push	eax
	call	??$_Convert_size@II@std@@YAII@Z		; std::_Convert_size<unsigned int,unsigned int>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3436 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
__Old_ptr$3 = -20					; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3413 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3414 :         // assign [_Ptr, _Ptr + _Count)
; 3415 :         if (_Count <= _Mypair._Myval2._Myres) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	ja	SHORT $LN2@assign

; 3416 :             _ASAN_STRING_REMOVE(*this);
; 3417 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	DWORD PTR __Old_ptr$3[ebp], eax

; 3418 :             _Mypair._Myval2._Mysize = _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 3419 :             _Traits::move(_Old_ptr, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_ptr$3[ebp]
	push	edx
	call	?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::move
	add	esp, 12					; 0000000cH

; 3420 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	mov	BYTE PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$3[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 3421 :             _ASAN_STRING_CREATE(*this);
; 3422 :             return *this;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@assign
$LN2@assign:

; 3423 :         }
; 3424 : 
; 3425 :         return _Reallocate_for(

	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3426 :             _Count,
; 3427 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) _STATIC_CALL_OPERATOR {
; 3428 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3429 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3430 :             },
; 3431 :             _Ptr);
; 3432 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 3330 :     _CONSTEXPR20 basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3331 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
	add	esp, 4
	push	eax
	call	??$_Convert_size@II@std@@YAII@Z		; std::_Convert_size<unsigned int,unsigned int>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3332 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -245						; size = 1
$T2 = -233						; size = 1
__Old_ptr$3 = -32					; size = 4
__Old_size$ = -20					; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 3307 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3308 :         // append [_Ptr, _Ptr + _Count)
; 3309 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Old_size$[ebp], ecx

; 3310 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR __Old_size$[ebp]
	cmp	DWORD PTR __Count$[ebp], ecx
	ja	SHORT $LN2@append

; 3311 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3312 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	eax, DWORD PTR __Old_size$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 3313 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	DWORD PTR __Old_ptr$3[ebp], eax

; 3314 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_ptr$3[ebp]
	add	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	call	?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::move
	add	esp, 12					; 0000000cH

; 3315 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	add	ecx, DWORD PTR __Old_ptr$3[ebp]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 3316 :             return *this;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@append
$LN2@append:

; 3317 :         }
; 3318 : 
; 3319 :         return _Reallocate_grow_by(

	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN1@append:

; 3320 :             _Count,
; 3321 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3322 :                 const size_type _Count) _STATIC_CALL_OPERATOR {
; 3323 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3324 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3325 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3326 :             },
; 3327 :             _Ptr, _Count);
; 3328 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 3242 :     _CONSTEXPR20 basic_string& operator=(_In_z_ const _Elem* const _Ptr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3243 :         return assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3244 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right_al$ = -32					; size = 4
__Al$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 3191 :     _CONSTEXPR20 basic_string& operator=(const basic_string& _Right) {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3192 :         if (this == _STD addressof(_Right)) {

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
	add	esp, 4
	cmp	DWORD PTR _this$[ebp], eax
	jne	SHORT $LN2@operator

; 3193 :             return *this;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@operator
$LN2@operator:

; 3194 :         }
; 3195 : 
; 3196 :         auto& _Al             = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 3197 :         const auto& _Right_al = _Right._Getal();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Right_al$[ebp], eax

; 3198 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 3199 :             if (_Al != _Right_al) {
; 3200 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 3201 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 3202 :                 _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 3203 : 
; 3204 :                 const size_type _Right_size   = _Right._Mypair._Myval2._Mysize;
; 3205 :                 const _Elem* const _Right_ptr = _Right._Mypair._Myval2._Myptr();
; 3206 :                 if (_Right_size > _Small_string_capacity) {
; 3207 :                     size_type _New_capacity = _Calculate_growth(_Right_size, _Small_string_capacity, _Right.max_size());
; 3208 :                     auto _Right_al_non_const = _Right_al;
; 3209 :                     const pointer _New_ptr   = _Allocate_for_capacity(_Right_al_non_const, _New_capacity); // throws
; 3210 :                     _Traits::copy(_Unfancy(_New_ptr), _Right_ptr, _Right_size + 1);
; 3211 : 
; 3212 :                     _Tidy_deallocate();
; 3213 :                     _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);
; 3214 :                     _Mypair._Myval2._Mysize = _Right_size;
; 3215 :                     _Mypair._Myval2._Myres  = _New_capacity;
; 3216 :                     _ASAN_STRING_CREATE(*this);
; 3217 :                 } else {
; 3218 :                     _Tidy_deallocate();
; 3219 :                     _Traits::copy(_Mypair._Myval2._Bx._Buf, _Right_ptr, _Right_size + 1);
; 3220 :                     _Mypair._Myval2._Mysize = _Right_size;
; 3221 :                     _Mypair._Myval2._Myres  = _Small_string_capacity;
; 3222 :                 }
; 3223 : 
; 3224 :                 _Pocca(_Al, _Right_al);
; 3225 :                 _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 3226 :                 return *this;
; 3227 :             }
; 3228 :         }
; 3229 : 
; 3230 :         _Pocca(_Al, _Right_al);

	mov	eax, DWORD PTR __Right_al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
	add	esp, 8

; 3231 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1

; 3232 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]
$LN1@operator:

; 3233 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
__To_delete$ = -44					; size = 4
_$S8$ = -29						; size = 1
__Alproxy$ = -20					; size = 4
_this$ = -8						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3179 :     _CONSTEXPR20 ~basic_string() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3180 :         _Tidy_deallocate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1

; 3181 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3182 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	ecx, DWORD PTR _$S8$[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	lea	eax, DWORD PTR _$S8$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 3183 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __To_delete$[ebp], ecx

; 3184 :         _Mypair._Myval2._Myproxy = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 3185 :         _Delete_plain_internal(_Alproxy, _To_delete);

	mov	eax, DWORD PTR __To_delete$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Alproxy$[ebp]
	push	ecx
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 3186 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3187 :     }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
	npad	1
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@basic_stri
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@basic_stri:
	DD	1
	DD	$LN5@basic_stri
$LN5@basic_stri:
	DD	-29					; ffffffe3H
	DD	1
	DD	$LN4@basic_stri
$LN4@basic_stri:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	56					; 00000038H
	DB	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
$T1 = -269						; size = 1
$T2 = -257						; size = 1
__Right_data_mem$3 = -56				; size = 4
__My_data_mem$4 = -44					; size = 4
__Right_data$ = -32					; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT
; _this$ = ecx

; 3055 :     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 21					; 00000015H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3056 :         // assign by stealing _Right's buffer
; 3057 :         // pre: this != &_Right
; 3058 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 3059 :         // pre: *this owns no memory, iterators orphaned
; 3060 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 3061 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 3062 :         auto& _Right_data = _Right._Mypair._Myval2;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR __Right_data$[ebp], eax

; 3063 : 
; 3064 : #if !defined(_INSERT_STRING_ANNOTATION)
; 3065 :         if constexpr (_Can_memcpy_val) {
; 3066 : #if _HAS_CXX20
; 3067 :             if (!_STD is_constant_evaluated())
; 3068 : #endif // _HAS_CXX20
; 3069 :             {
; 3070 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3071 :                 if (_Right_data._Large_mode_engaged()) {

	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Take_conte

; 3072 :                     // take ownership of _Right's iterators along with its buffer
; 3073 :                     _Swap_proxy_and_iterators(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
	npad	1

; 3074 :                 } else {

	jmp	SHORT $LN3@Take_conte
$LN2@Take_conte:

; 3075 :                     _Right_data._Orphan_all();

	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
	npad	1
$LN3@Take_conte:

; 3076 :                 }
; 3077 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3078 : 
; 3079 :                 const auto _My_data_mem =

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	add	esp, 4
	add	eax, 4
	mov	DWORD PTR __My_data_mem$4[ebp], eax

; 3080 :                     reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 3081 :                 const auto _Right_data_mem =

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	add	esp, 4
	add	eax, 4
	mov	DWORD PTR __Right_data_mem$3[ebp], eax

; 3082 :                     reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 3083 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	push	24					; 00000018H
	mov	eax, DWORD PTR __Right_data_mem$3[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data_mem$4[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3084 : 
; 3085 :                 _Right_data._Mysize = 0;

	mov	eax, DWORD PTR __Right_data$[ebp]
	mov	DWORD PTR [eax+20], 0

; 3086 :                 _Right_data._Myres  = _Small_string_capacity;

	mov	eax, DWORD PTR __Right_data$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 3087 :                 _Right_data._Activate_SSO_buffer();

	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
	npad	1

; 3088 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR __Right_data$[ebp]
	lea	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 3089 :                 return;

	jmp	$LN1@Take_conte

; 3090 :             }
; 3091 :         }
; 3092 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 3093 : 
; 3094 :         if (_Right_data._Large_mode_engaged()) { // steal buffer

	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@Take_conte

; 3095 :             _Swap_proxy_and_iterators(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
	npad	1

; 3096 : 
; 3097 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);

	mov	eax, DWORD PTR __Right_data$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z ; std::_Construct_in_place<char *,char * &>
	add	esp, 8

; 3098 :             _Right_data._Bx._Switch_to_buf();

	mov	ecx, DWORD PTR __Right_data$[ebp]
	add	ecx, 4
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1

; 3099 :         } else { // copy small string buffer

	jmp	SHORT $LN5@Take_conte
$LN4@Take_conte:

; 3100 :             _Right_data._Orphan_all();

	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 3101 : 
; 3102 :             _My_data._Activate_SSO_buffer();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
	npad	1

; 3103 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);

	mov	eax, DWORD PTR __Right_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Right_data$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	push	eax
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH
$LN5@Take_conte:

; 3104 :         }
; 3105 : 
; 3106 :         _My_data._Myres  = _Right_data._Myres;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Right_data$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 3107 :         _My_data._Mysize = _Right_data._Mysize;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Right_data$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 3108 : 
; 3109 :         _Right_data._Mysize = 0;

	mov	eax, DWORD PTR __Right_data$[ebp]
	mov	DWORD PTR [eax+20], 0

; 3110 :         _Right_data._Myres  = _Small_string_capacity;

	mov	eax, DWORD PTR __Right_data$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 3111 :         _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR __Right_data$[ebp]
	lea	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8
$LN1@Take_conte:

; 3112 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__Pocma_val$ = -44					; size = 4
__Right_al$ = -32					; size = 4
__Al$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 3022 :         _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3023 :         if (this == _STD addressof(_Right)) {

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 4
	cmp	DWORD PTR _this$[ebp], eax
	jne	SHORT $LN2@operator

; 3024 :             return *this;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@operator
$LN2@operator:

; 3025 :         }
; 3026 : 
; 3027 :         auto& _Al                 = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 3028 :         auto& _Right_al           = _Right._Getal();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Right_al$[ebp], eax

; 3029 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;

	mov	DWORD PTR __Pocma_val$[ebp], 0

; 3030 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 3031 :             if (_Al != _Right_al) {
; 3032 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 3033 :                 _Mypair._Myval2._Orphan_all();
; 3034 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 3035 :             }
; 3036 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 3037 :             if (_Al != _Right_al) {
; 3038 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3039 :                 return *this;
; 3040 :             }
; 3041 :         }
; 3042 : 
; 3043 :         _Tidy_deallocate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1

; 3044 :         _Pocma(_Al, _Right_al);

	mov	eax, DWORD PTR __Right_al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
	add	esp, 8

; 3045 :         _Take_contents(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
	npad	1

; 3046 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]
$LN1@operator:

; 3047 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z
_TEXT	SEGMENT
tv157 = -485						; size = 1
tv128 = -485						; size = 1
$T2 = -477						; size = 1
$T3 = -465						; size = 1
$T4 = -453						; size = 1
__Ptr$ = -252						; size = 4
__Fancyptr$ = -240					; size = 4
__Proxy$ = -228						; size = 8
_$S16$ = -209						; size = 1
__Alproxy$ = -200					; size = 4
__New_capacity$ = -188					; size = 4
__Max$ = -176						; size = 4
__Ptr$5 = -164						; size = 4
__Fits_in_right$ = -149					; size = 1
__Ptr$6 = -140						; size = 4
__Fits_in_left$ = -125					; size = 1
__New_size$ = -116					; size = 4
__Right_capacity$ = -104				; size = 4
__Left_capacity$ = -92					; size = 4
__Right_size$ = -80					; size = 4
__Left_size$ = -68					; size = 4
__Right_data$ = -56					; size = 4
__Left_data$ = -44					; size = 4
__My_data$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 1
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2871 :         : _Mypair(_One_then_variadic_args_t{}, _Left._Getal()) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 476				; 000001dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-296]
	mov	ecx, 71					; 00000047H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	movzx	eax, BYTE PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0AAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@AAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> &>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2872 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2873 :         auto& _Left_data  = _Left._Mypair._Myval2;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	DWORD PTR __Left_data$[ebp], eax

; 2874 :         auto& _Right_data = _Right._Mypair._Myval2;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR __Right_data$[ebp], eax

; 2875 :         _Left_data._Orphan_all();

	mov	ecx, DWORD PTR __Left_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 2876 :         _Right_data._Orphan_all();

	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 2877 :         const auto _Left_size  = _Left_data._Mysize;

	mov	eax, DWORD PTR __Left_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Left_size$[ebp], ecx

; 2878 :         const auto _Right_size = _Right_data._Mysize;

	mov	eax, DWORD PTR __Right_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Right_size$[ebp], ecx

; 2879 : 
; 2880 :         const auto _Left_capacity  = _Left_data._Myres;

	mov	eax, DWORD PTR __Left_data$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Left_capacity$[ebp], ecx

; 2881 :         const auto _Right_capacity = _Right_data._Myres;

	mov	eax, DWORD PTR __Right_data$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Right_capacity$[ebp], ecx

; 2882 :         // overflow is OK due to max_size() checks:
; 2883 :         const auto _New_size     = static_cast<size_type>(_Left_size + _Right_size);

	mov	eax, DWORD PTR __Left_size$[ebp]
	add	eax, DWORD PTR __Right_size$[ebp]
	mov	DWORD PTR __New_size$[ebp], eax

; 2884 :         const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;

	mov	eax, DWORD PTR __Left_capacity$[ebp]
	sub	eax, DWORD PTR __Left_size$[ebp]
	cmp	DWORD PTR __Right_size$[ebp], eax
	ja	SHORT $LN6@basic_stri
	mov	BYTE PTR tv128[ebp], 1
	jmp	SHORT $LN7@basic_stri
$LN6@basic_stri:
	mov	BYTE PTR tv128[ebp], 0
$LN7@basic_stri:
	mov	cl, BYTE PTR tv128[ebp]
	mov	BYTE PTR __Fits_in_left$[ebp], cl

; 2885 :         if (_Fits_in_left && _Right_capacity <= _Left_capacity) {

	movzx	eax, BYTE PTR __Fits_in_left$[ebp]
	test	eax, eax
	je	SHORT $LN2@basic_stri
	mov	eax, DWORD PTR __Right_capacity$[ebp]
	cmp	eax, DWORD PTR __Left_capacity$[ebp]
	ja	SHORT $LN2@basic_stri

; 2886 :             // take _Left's buffer, max_size() is OK because _Fits_in_left
; 2887 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
	npad	1

; 2888 :             _Take_contents(_Left);

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
	npad	1

; 2889 :             const auto _Ptr = _My_data._Myptr();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	DWORD PTR __Ptr$6[ebp], eax

; 2890 :             _ASAN_STRING_MODIFY(*this, _Left_size, _New_size);
; 2891 :             _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);

	mov	eax, DWORD PTR __Right_size$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$6[ebp]
	add	ecx, DWORD PTR __Left_size$[ebp]
	push	ecx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 2892 :             _My_data._Mysize = _New_size;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2893 :             return;

	jmp	$LN1@basic_stri
$LN2@basic_stri:

; 2894 :         }
; 2895 : 
; 2896 :         const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;

	mov	eax, DWORD PTR __Right_capacity$[ebp]
	sub	eax, DWORD PTR __Right_size$[ebp]
	cmp	DWORD PTR __Left_size$[ebp], eax
	ja	SHORT $LN8@basic_stri
	mov	BYTE PTR tv157[ebp], 1
	jmp	SHORT $LN9@basic_stri
$LN8@basic_stri:
	mov	BYTE PTR tv157[ebp], 0
$LN9@basic_stri:
	mov	cl, BYTE PTR tv157[ebp]
	mov	BYTE PTR __Fits_in_right$[ebp], cl

; 2897 :         if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	call	??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NABV?$allocator@D@0@0@Z ; std::_Allocators_equal<std::allocator<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	$LN3@basic_stri
	movzx	eax, BYTE PTR __Fits_in_right$[ebp]
	test	eax, eax
	je	$LN3@basic_stri

; 2898 :             // take _Right's buffer, max_size() is OK because _Fits_in_right
; 2899 :             // At this point, we have tested:
; 2900 :             // !(_Fits_in_left && _Right_capacity <= _Left_capacity) && _Fits_in_right
; 2901 :             // therefore: (by De Morgan's Laws)
; 2902 :             // (!_Fits_in_left || _Right_capacity > _Left_capacity) && _Fits_in_right
; 2903 :             // therefore: (by the distributive property)
; 2904 :             // (!_Fits_in_left && _Fits_in_right)  // implying _Right has more capacity
; 2905 :             //     || (_Right_capacity > _Left_capacity && _Fits_in_right)  // tests that _Right has more capacity
; 2906 :             // therefore: _Right must have more than the minimum capacity, so it must be _Large_mode_engaged()
; 2907 :             _STL_INTERNAL_CHECK(_Right_data._Large_mode_engaged());
; 2908 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
	npad	1

; 2909 :             _Take_contents(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
	npad	1

; 2910 :             const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Ptr$5[ebp], eax

; 2911 :             _ASAN_STRING_MODIFY(*this, _Right_size, _New_size);
; 2912 :             _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);

	mov	eax, DWORD PTR __Right_size$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Ptr$5[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$5[ebp]
	add	edx, DWORD PTR __Left_size$[ebp]
	push	edx
	call	?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::move
	add	esp, 12					; 0000000cH

; 2913 :             _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);

	mov	eax, DWORD PTR __Left_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left_data$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$5[ebp]
	push	ecx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 2914 :             _My_data._Mysize = _New_size;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2915 :             return;

	jmp	$LN1@basic_stri
$LN3@basic_stri:

; 2916 :         }
; 2917 : 
; 2918 :         // can't use either buffer, reallocate
; 2919 :         const auto _Max = max_size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Max$[ebp], eax

; 2920 :         if (_Max - _Left_size < _Right_size) { // check if max_size() is OK

	mov	eax, DWORD PTR __Max$[ebp]
	sub	eax, DWORD PTR __Left_size$[ebp]
	cmp	eax, DWORD PTR __Right_size$[ebp]
	jae	SHORT $LN4@basic_stri

; 2921 :             _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN4@basic_stri:

; 2922 :         }
; 2923 : 
; 2924 :         size_type _New_capacity = _Calculate_growth(_New_size, _Small_string_capacity, _Max);

	mov	eax, DWORD PTR __Max$[ebp]
	push	eax
	push	15					; 0000000fH
	mov	ecx, DWORD PTR __New_size$[ebp]
	push	ecx
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __New_capacity$[ebp], eax

; 2925 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	ecx, DWORD PTR _$S16$[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	lea	eax, DWORD PTR _$S16$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 2926 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws

	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Alproxy$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2927 :         const pointer _Fancyptr = _Allocate_for_capacity(_Getal(), _New_capacity); // throws

	lea	eax, DWORD PTR __New_capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	add	esp, 8
	mov	DWORD PTR __Fancyptr$[ebp], eax

; 2928 :         // nothrow hereafter
; 2929 :         _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

	lea	eax, DWORD PTR __Fancyptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
	add	esp, 8

; 2930 :         _My_data._Mysize = _New_size;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2931 :         _My_data._Myres  = _New_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 2932 :         const auto _Ptr  = _Unfancy(_Fancyptr);

	mov	eax, DWORD PTR __Fancyptr$[ebp]
	push	eax
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax

; 2933 :         _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);

	mov	eax, DWORD PTR __Left_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left_data$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 2934 :         _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);

	mov	eax, DWORD PTR __Right_size$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, DWORD PTR __Left_size$[ebp]
	push	ecx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 2935 :         _ASAN_STRING_CREATE(*this);
; 2936 :         _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
	npad	1

; 2937 :     }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
$LN1@basic_stri:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN5@basic_stri:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@basic_stri
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 488				; 000001e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN18@basic_stri:
	DD	4
	DD	$LN17@basic_stri
$LN17@basic_stri:
	DD	-188					; ffffff44H
	DD	4
	DD	$LN12@basic_stri
	DD	-209					; ffffff2fH
	DD	1
	DD	$LN13@basic_stri
	DD	-228					; ffffff1cH
	DD	8
	DD	$LN14@basic_stri
	DD	-240					; ffffff10H
	DD	4
	DD	$LN15@basic_stri
$LN15@basic_stri:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN14@basic_stri:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
$LN13@basic_stri:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	49					; 00000031H
	DB	54					; 00000036H
	DB	0
$LN12@basic_stri:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z$1:
	lea	ecx, DWORD PTR __Proxy$[ebp]
	jmp	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-492]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
_TEXT	SEGMENT
$T2 = -345						; size = 1
$T3 = -333						; size = 1
$T4 = -321						; size = 1
__Fancyptr$5 = -120					; size = 4
__Proxy$ = -108						; size = 8
_$S17$ = -89						; size = 1
__Alproxy$ = -80					; size = 4
__Ptr$ = -68						; size = 4
__My_data$ = -56					; size = 4
__New_capacity$ = -44					; size = 4
__New_size$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 1
__Source_of_al$ = 12					; size = 4
__Left_ptr$ = 16					; size = 4
__Left_size$ = 20					; size = 4
__Right_ptr$ = 24					; size = 4
__Right_size$ = 28					; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2843 :             _One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-160]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2842 :         : _Mypair(

	mov	ecx, DWORD PTR __Source_of_al$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
	add	esp, 8
	push	eax
	movzx	ecx, BYTE PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2844 :         _STL_INTERNAL_CHECK(_Left_size <= max_size());
; 2845 :         _STL_INTERNAL_CHECK(_Right_size <= max_size());
; 2846 :         _STL_INTERNAL_CHECK(_Right_size <= max_size() - _Left_size);
; 2847 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);

	mov	eax, DWORD PTR __Left_size$[ebp]
	add	eax, DWORD PTR __Right_size$[ebp]
	mov	DWORD PTR __New_size$[ebp], eax

; 2848 :         size_type _New_capacity = _Small_string_capacity;

	mov	DWORD PTR __New_capacity$[ebp], 15	; 0000000fH

; 2849 :         auto& _My_data          = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2850 :         _Elem* _Ptr             = _My_data._Bx._Buf;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Ptr$[ebp], eax

; 2851 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	ecx, DWORD PTR _$S17$[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	lea	eax, DWORD PTR _$S17$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 2852 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws

	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Alproxy$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2853 : 
; 2854 :         if (_New_capacity < _New_size) {

	mov	eax, DWORD PTR __New_capacity$[ebp]
	cmp	eax, DWORD PTR __New_size$[ebp]
	jae	SHORT $LN2@basic_stri

; 2855 :             _New_capacity           = _Calculate_growth(_New_size, _Small_string_capacity, max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	push	eax
	push	15					; 0000000fH
	mov	eax, DWORD PTR __New_size$[ebp]
	push	eax
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __New_capacity$[ebp], eax

; 2856 :             const pointer _Fancyptr = _Allocate_for_capacity(_Getal(), _New_capacity); // throws

	lea	eax, DWORD PTR __New_capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	add	esp, 8
	mov	DWORD PTR __Fancyptr$5[ebp], eax

; 2857 :             _Ptr                    = _Unfancy(_Fancyptr);

	mov	eax, DWORD PTR __Fancyptr$5[ebp]
	push	eax
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax

; 2858 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

	lea	eax, DWORD PTR __Fancyptr$5[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
	add	esp, 8
$LN2@basic_stri:

; 2859 :         }
; 2860 : 
; 2861 :         _My_data._Mysize = _New_size;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2862 :         _My_data._Myres  = _New_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 2863 :         _Traits::copy(_Ptr, _Left_ptr, _Left_size);

	mov	eax, DWORD PTR __Left_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 2864 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

	mov	eax, DWORD PTR __Right_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, DWORD PTR __Left_size$[ebp]
	push	edx
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 2865 :         _Traits::assign(_Ptr[_New_size], _Elem());

	mov	BYTE PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, DWORD PTR __New_size$[ebp]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 2866 :         _ASAN_STRING_CREATE(*this);
; 2867 :         _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
	npad	1

; 2868 :     }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@basic_stri
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 352				; 00000160H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN12@basic_stri:
	DD	4
	DD	$LN11@basic_stri
$LN11@basic_stri:
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN6@basic_stri
	DD	-89					; ffffffa7H
	DD	1
	DD	$LN7@basic_stri
	DD	-108					; ffffff94H
	DD	8
	DD	$LN8@basic_stri
	DD	-120					; ffffff88H
	DD	4
	DD	$LN9@basic_stri
$LN9@basic_stri:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN8@basic_stri:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
$LN7@basic_stri:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	49					; 00000031H
	DB	55					; 00000037H
	DB	0
$LN6@basic_stri:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z$1:
	lea	ecx, DWORD PTR __Proxy$[ebp]
	jmp	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-356]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T2 = -233						; size = 1
$T3 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2819 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	call	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
	add	esp, 4
	push	eax
	movzx	eax, BYTE PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
	npad	1

; 2820 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
	npad	1

; 2821 :         _Take_contents(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
	npad	1

; 2822 :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty, COMDAT
; _this$ = ecx

; 2646 :     _CONSTEXPR20 void _Construct_empty() {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2647 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2648 :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
	npad	1

; 2649 : 
; 2650 :         // initialize basic_string data members
; 2651 :         _My_data._Mysize = 0;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+20], 0

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 2653 :         _My_data._Activate_SSO_buffer();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
	npad	1

; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR __My_data$[ebp]
	lea	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 2657 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Capacity$ = 16					; size = 4
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 2641 :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2642 :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	mov	eax, DWORD PTR __Capacity$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate
	npad	1

; 2644 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2559 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
	add	esp, 4
	push	eax
	call	??$_Convert_size@II@std@@YAII@Z		; std::_Convert_size<unsigned int,unsigned int>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1

; 2561 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T2 = -233						; size = 1
$T3 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2508 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
	add	esp, 8
	push	eax
	movzx	ecx, BYTE PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2509 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
	npad	1

; 2510 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2499 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 2500 :         _Construct_empty();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
	npad	1

; 2501 :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT
; _this$ = ecx

; 2291 :         _CONSTEXPR20 void _Switch_to_buf() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2292 :             _STD _Destroy_in_place(_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
	add	esp, 4

; 2293 : 
; 2294 : #if _HAS_CXX20
; 2295 :             // start the lifetime of the array elements
; 2296 :             if (_STD is_constant_evaluated()) {
; 2297 :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2298 :                     _Buf[_Idx] = value_type();
; 2299 :                 }
; 2300 :             }
; 2301 : #endif // _HAS_CXX20
; 2302 :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT
; _this$ = ecx

; 2247 :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2248 :         // start the lifetime of the array elements
; 2249 : #if _HAS_CXX20
; 2250 :         if (_STD is_constant_evaluated()) {
; 2251 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2252 :                 _Bx._Buf[_Idx] = value_type();
; 2253 :             }
; 2254 :         }
; 2255 : #endif // _HAS_CXX20
; 2256 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT
; _this$ = ecx

; 2243 :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2244 :         return _Myres > _Small_string_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 15			; 0000000fH
	jbe	SHORT $LN3@Large_mode
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@Large_mode
$LN3@Large_mode:
	mov	DWORD PTR tv66[ebp], 0
$LN4@Large_mode:
	movzx	eax, BYTE PTR tv66[ebp]

; 2245 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Result$ = -20						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2234 :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR __Result$[ebp], eax

; 2236 :         if (_Large_mode_engaged()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2238 :         }
; 2239 : 
; 2240 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2241 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Result$ = -20						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2225 :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR __Result$[ebp], eax

; 2227 :         if (_Large_mode_engaged()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2229 :         }
; 2230 : 
; 2231 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2232 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2212 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12
	npad	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
	npad	1

; 2213 : 
; 2214 :     // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
; 2215 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2216 :     // roundup mask for allocated buffers, [0, 15]
; 2217 :     static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
; 2218 :                                            : sizeof(value_type) <= 2 ? 7
; 2219 :                                            : sizeof(value_type) <= 4 ? 3
; 2220 :                                            : sizeof(value_type) <= 8 ? 1
; 2221 :                                                                      : 0;
; 2222 :     // capacity in small mode
; 2223 :     static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;
; 2224 : 
; 2225 :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
; 2226 :         value_type* _Result = _Bx._Buf;
; 2227 :         if (_Large_mode_engaged()) {
; 2228 :             _Result = _Unfancy(_Bx._Ptr);
; 2229 :         }
; 2230 : 
; 2231 :         return _Result;
; 2232 :     }
; 2233 : 
; 2234 :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 2235 :         const value_type* _Result = _Bx._Buf;
; 2236 :         if (_Large_mode_engaged()) {
; 2237 :             _Result = _Unfancy(_Bx._Ptr);
; 2238 :         }
; 2239 : 
; 2240 :         return _Result;
; 2241 :     }
; 2242 : 
; 2243 :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
; 2244 :         return _Myres > _Small_string_capacity;
; 2245 :     }
; 2246 : 
; 2247 :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
; 2248 :         // start the lifetime of the array elements
; 2249 : #if _HAS_CXX20
; 2250 :         if (_STD is_constant_evaluated()) {
; 2251 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2252 :                 _Bx._Buf[_Idx] = value_type();
; 2253 :             }
; 2254 :         }
; 2255 : #endif // _HAS_CXX20
; 2256 :     }
; 2257 : 
; 2258 :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 2259 :         // checks whether _Off is in the bounds of [0, size()]
; 2260 :         if (_Mysize < _Off) {
; 2261 :             _Xran();
; 2262 :         }
; 2263 :     }
; 2264 : 
; 2265 :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 2266 :         // checks whether _Off is in the bounds of [0, size())
; 2267 :         if (_Mysize <= _Off) {
; 2268 :             _Xran();
; 2269 :         }
; 2270 :     }
; 2271 : 
; 2272 :     [[noreturn]] static void _Xran() {
; 2273 :         _Xout_of_range("invalid string position");
; 2274 :     }
; 2275 : 
; 2276 :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2277 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2278 :         return (_STD min)(_Size, _Mysize - _Off);
; 2279 :     }
; 2280 : 
; 2281 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2282 :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 2283 :         // renaming `_String_val` (and fixing the visualizer).
; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2286 : 
; 2287 :         value_type _Buf[_BUF_SIZE];
; 2288 :         pointer _Ptr;
; 2289 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2290 : 
; 2291 :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 2292 :             _STD _Destroy_in_place(_Ptr);
; 2293 : 
; 2294 : #if _HAS_CXX20
; 2295 :             // start the lifetime of the array elements
; 2296 :             if (_STD is_constant_evaluated()) {
; 2297 :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2298 :                     _Buf[_Idx] = value_type();
; 2299 :                 }
; 2300 :             }
; 2301 : #endif // _HAS_CXX20
; 2302 :         }
; 2303 :     };
; 2304 :     _Bxty _Bx;
; 2305 : 
; 2306 :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 2307 :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 2212 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 717  :     _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 718  :         return _Al;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 719  :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 713  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 714  :         return static_cast<size_t>(-1) / sizeof(value_type);

	or	eax, -1

; 715  :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 953  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$00@std@@YAII@Z	; std::_Get_size_of_n<1>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
	add	esp, 4

; 956  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 947  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN4@deallocate:

; 948  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN10@deallocate
	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN8@deallocate
$LN10@deallocate:
	jmp	SHORT $LN6@deallocate
$LN8@deallocate:
	mov	esi, esp
	push	OFFSET ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	948					; 000003b4H
	push	OFFSET ??_C@_0GC@GDGMGNBP@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN12@deallocate
	int	3
$LN12@deallocate:
	mov	esi, esp
	push	0
	push	948					; 000003b4H
	push	OFFSET ??_C@_1ME@KJJNLLPL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN8@deallocate
$LN6@deallocate:
	xor	eax, eax
	jne	SHORT $LN4@deallocate

; 949  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07@std@@YAXPAXI@Z	; std::_Deallocate<8>
	add	esp, 8

; 951  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 939  :     constexpr allocator() noexcept {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2326 : [[noreturn]] inline void _Xlen_string() {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2327 :     _Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
	npad	1
$LN1@Xlen_strin:

; 2328 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 471  :     _NODISCARD static constexpr int_type eof() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 472  :         return static_cast<int_type>(EOF);

	or	eax, -1

; 473  :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 463  :     _NODISCARD static constexpr bool eq_int_type(const int_type _Left, const int_type _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi

; 464  :         return _Left == _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@eq_int_typ
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
	mov	DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
	movzx	eax, BYTE PTR tv65[ebp]

; 465  :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 438  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             return _Primary_char_traits::assign(_Left, _Right);
; 442  :         }
; 443  : #endif // _HAS_CXX20
; 444  :         _Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 445  :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 385  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 386  :         // find length of null-terminated string
; 387  : #if _HAS_CXX17
; 388  : #ifdef __cpp_char8_t
; 389  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 390  : #if _HAS_U8_INTRINSICS
; 391  :             return __builtin_u8strlen(_First);
; 392  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 393  :             return _Primary_char_traits::length(_First);
; 394  : #endif // ^^^ no u8 intrinsics ^^^
; 395  :         } else
; 396  : #endif // defined(__cpp_char8_t)
; 397  :         {
; 398  :             return __builtin_strlen(_First);
; 399  :         }
; 400  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 401  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	_strlen
	add	esp, 4

; 402  : #endif // ^^^ !_HAS_CXX17 ^^^
; 403  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #if _HAS_CXX20
; 85   :         if (_STD is_constant_evaluated()) {
; 86   :             // dest: [_First1, _First1 + _Count)
; 87   :             // src: [_First2, _First2 + _Count)
; 88   :             // We need to handle overlapping ranges.
; 89   :             // If _First1 is in the src range, we need a backward loop.
; 90   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 91   : 
; 92   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 93   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 94   :             bool _Loop_forward = true;
; 95   : 
; 96   :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 97   :                 if (_First1 == _Src) {
; 98   :                     _Loop_forward = false;
; 99   :                     break;
; 100  :                 }
; 101  :             }
; 102  : 
; 103  :             if (_Loop_forward) {
; 104  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 105  :                     _First1[_Idx] = _First2[_Idx];
; 106  :                 }
; 107  :             } else {
; 108  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
; 109  :                     _First1[_Idx - 1] = _First2[_Idx - 1];
; 110  :                 }
; 111  :             }
; 112  : 
; 113  :             return _First1;
; 114  :         }
; 115  : #endif // _HAS_CXX20
; 116  : 
; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 118  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 119  : 
; 120  :         return _First1;

	mov	eax, DWORD PTR __First1$[ebp]

; 121  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 48   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 49   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 50   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 51   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 52   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 53   : #if _HAS_CXX20
; 54   :         if (_STD is_constant_evaluated()) {
; 55   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 56   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 57   :                 _First1[_Idx] = _First2[_Idx];
; 58   :             }
; 59   : 
; 60   :             return _First1;
; 61   :         }
; 62   : #endif // _HAS_CXX20
; 63   : 
; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 65   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 66   : 
; 67   :         return _First1;

	mov	eax, DWORD PTR __First1$[ebp]

; 68   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0_Basic_container_proxy_ptr12@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Basic_container_proxy_ptr12@std@@IAE@XZ PROC	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12, COMDAT
; _this$ = ecx

; 1430 :     _CONSTEXPR20 _Basic_container_proxy_ptr12()                       = default;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1423 :     _Container_proxy* _Ptr = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1430 :     _CONSTEXPR20 _Basic_container_proxy_ptr12()                       = default;

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Basic_container_proxy_ptr12@std@@IAE@XZ ENDP	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ PROC	; std::_Basic_container_proxy_ptr12::_Release, COMDAT
; _this$ = ecx

; 1425 :     constexpr void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1426 :         _Ptr = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1427 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ENDP	; std::_Basic_container_proxy_ptr12::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -8						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>, COMDAT

; 754  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi

; 755  :     // assign _New_val to _Val, return previous _Val
; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Old_val$[ebp], ecx

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR __New_val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 758  :     return _Old_val;

	mov	eax, DWORD PTR __Old_val$[ebp]

; 759  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ
_TEXT	SEGMENT
__Lock$ = -20						; size = 4
_this$ = -8						; size = 4
?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ PROC	; std::_Iterator_base12::_Orphan_me_locked_v3, COMDAT
; _this$ = ecx

; 1339 :     void _Orphan_me_locked_v3() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1340 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1

; 1341 :         _Orphan_me_unlocked_v3();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
	npad	1

; 1342 :     }

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Orphan_me_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@Orphan_me_:
	DD	1
	DD	$LN5@Orphan_me_
$LN5@Orphan_me_:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN4@Orphan_me_
$LN4@Orphan_me_:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ ENDP	; std::_Iterator_base12::_Orphan_me_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ
_TEXT	SEGMENT
__Pnext$ = -20						; size = 4
_this$ = -8						; size = 4
?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ PROC ; std::_Iterator_base12::_Orphan_me_unlocked_v3, COMDAT
; _this$ = ecx

; 1323 :     _CONSTEXPR20 void _Orphan_me_unlocked_v3() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1324 :         if (!_Myproxy) { // already orphaned

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN10@Orphan_me_

; 1325 :             return;

	jmp	$LN1@Orphan_me_
$LN10@Orphan_me_:

; 1326 :         }
; 1327 : 
; 1328 :         // adopted, remove self from list
; 1329 :         _Iterator_base12** _Pnext = &_Myproxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$[ebp], ecx
$LN2@Orphan_me_:

; 1330 :         while (*_Pnext && *_Pnext != this) {

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Orphan_me_
	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _this$[ebp]
	je	SHORT $LN3@Orphan_me_

; 1331 :             _Pnext = &(*_Pnext)->_Mynextiter;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$[ebp], ecx

; 1332 :         }

	jmp	SHORT $LN2@Orphan_me_
$LN3@Orphan_me_:

; 1333 : 
; 1334 :         _STL_VERIFY(*_Pnext, "ITERATOR LIST CORRUPTED!");

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN11@Orphan_me_
	jmp	SHORT $LN8@Orphan_me_
$LN11@Orphan_me_:
	mov	esi, esp
	push	OFFSET ??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1334					; 00000536H
	push	OFFSET ??_C@_0GC@GDGMGNBP@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN14@Orphan_me_
	int	3
$LN14@Orphan_me_:
	mov	esi, esp
	push	0
	push	1334					; 00000536H
	push	OFFSET ??_C@_1ME@KJJNLLPL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN11@Orphan_me_
$LN8@Orphan_me_:
	xor	eax, eax
	jne	SHORT $LN3@Orphan_me_

; 1335 :         *_Pnext  = _Mynextiter;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 1336 :         _Myproxy = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Orphan_me_:

; 1337 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ENDP ; std::_Iterator_base12::_Orphan_me_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Lock$ = -20						; size = 4
_this$ = -8						; size = 4
__Parent$ = 8						; size = 4
?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt_locked, COMDAT
; _this$ = ecx

; 1318 :     void _Adopt_locked(const _Container_base12* _Parent) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1319 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1

; 1320 :         _Adopt_unlocked(_Parent);

	mov	eax, DWORD PTR __Parent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked
	npad	1

; 1321 :     }

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Adopt_lock
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN6@Adopt_lock:
	DD	1
	DD	$LN5@Adopt_lock
$LN5@Adopt_lock:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN4@Adopt_lock
$LN4@Adopt_lock:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt_locked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Parent_proxy$ = -20					; size = 4
_this$ = -8						; size = 4
__Parent$ = 8						; size = 4
?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt_unlocked, COMDAT
; _this$ = ecx

; 1301 :     _CONSTEXPR20 void _Adopt_unlocked(const _Container_base12* _Parent) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1302 :         if (!_Parent) {

	cmp	DWORD PTR __Parent$[ebp], 0
	jne	SHORT $LN2@Adopt_unlo

; 1303 :             _Orphan_me_unlocked_v3();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
	npad	1

; 1304 :             return;

	jmp	SHORT $LN1@Adopt_unlo
$LN2@Adopt_unlo:

; 1305 :         }
; 1306 : 
; 1307 :         _Container_proxy* _Parent_proxy = _Parent->_Myproxy;

	mov	eax, DWORD PTR __Parent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Parent_proxy$[ebp], ecx

; 1308 :         if (_Myproxy != _Parent_proxy) { // change parentage

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Parent_proxy$[ebp]
	je	SHORT $LN3@Adopt_unlo

; 1309 :             if (_Myproxy) { // adopted, remove self from list

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@Adopt_unlo

; 1310 :                 _Orphan_me_unlocked_v3();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
	npad	1
$LN4@Adopt_unlo:

; 1311 :             }
; 1312 :             _Mynextiter                 = _Parent_proxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parent_proxy$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1313 :             _Parent_proxy->_Myfirstiter = this;

	mov	eax, DWORD PTR __Parent_proxy$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1314 :             _Myproxy                    = _Parent_proxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parent_proxy$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Adopt_unlo:
$LN1@Adopt_unlo:

; 1315 :         }
; 1316 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z
_TEXT	SEGMENT
__Lock$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z PROC	; std::_Iterator_base12::_Assign_locked, COMDAT
; _this$ = ecx

; 1296 :     void _Assign_locked(const _Iterator_base12& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1297 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1

; 1298 :         _Assign_unlocked(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_unlocked
	npad	1

; 1299 :     }

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Assign_loc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN6@Assign_loc:
	DD	1
	DD	$LN5@Assign_loc
$LN5@Assign_loc:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN4@Assign_loc
$LN4@Assign_loc:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z ENDP	; std::_Iterator_base12::_Assign_locked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z PROC ; std::_Iterator_base12::_Assign_unlocked, COMDAT
; _this$ = ecx

; 1284 :     _CONSTEXPR20 void _Assign_unlocked(const _Iterator_base12& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1285 :         if (_Myproxy == _Right._Myproxy) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Assign_unl

; 1286 :             return;

	jmp	SHORT $LN1@Assign_unl
$LN2@Assign_unl:

; 1287 :         }
; 1288 : 
; 1289 :         if (_Right._Myproxy) {

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Assign_unl

; 1290 :             _Adopt_unlocked(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked
	npad	1

; 1291 :         } else { // becoming invalid, disown current parent

	jmp	SHORT $LN4@Assign_unl
$LN3@Assign_unl:

; 1292 :             _Orphan_me_unlocked_v3();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
	npad	1
$LN4@Assign_unl:
$LN1@Assign_unl:

; 1293 :         }
; 1294 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z ENDP ; std::_Iterator_base12::_Assign_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
tv68 = -208						; size = 4
_this$ = -8						; size = 4
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 1273 :     _CONSTEXPR20 const _Container_base12* _Getcont() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1274 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Getcont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@Getcont
$LN3@Getcont:
	mov	DWORD PTR tv68[ebp], 0
$LN4@Getcont:
	mov	eax, DWORD PTR tv68[ebp]

; 1275 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 1253 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : #if _HAS_CXX20
; 1255 :         if (_STD is_constant_evaluated()) {
; 1256 :             _Adopt_unlocked(_Parent);
; 1257 :         } else
; 1258 : #endif // _HAS_CXX20
; 1259 :         {
; 1260 :             _Adopt_locked(_Parent);

	mov	eax, DWORD PTR __Parent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_locked
	npad	1

; 1261 :         }
; 1262 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$ = ecx

; 1242 :     _CONSTEXPR20 ~_Iterator_base12() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1243 : #if _HAS_CXX20
; 1244 :         if (_STD is_constant_evaluated()) {
; 1245 :             _Orphan_me_unlocked_v3();
; 1246 :         } else
; 1247 : #endif // _HAS_CXX20
; 1248 :         {
; 1249 :             _Orphan_me_locked_v3();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_locked_v3
	npad	1

; 1250 :         }
; 1251 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z PROC		; std::_Iterator_base12::operator=, COMDAT
; _this$ = ecx

; 1225 :     _CONSTEXPR20 _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1226 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1227 : #if _HAS_CXX20
; 1228 :         if (_STD is_constant_evaluated()) {
; 1229 :             _Assign_unlocked(_Right);
; 1230 :         } else
; 1231 : #endif // _HAS_CXX20
; 1232 :         {
; 1233 :             _Assign_locked(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_locked
	npad	1

; 1234 :         }
; 1235 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1236 :         _Myproxy = _Right._Myproxy;
; 1237 : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 2 ^^^
; 1238 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1239 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ENDP		; std::_Iterator_base12::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0_Iterator_base12@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??0_Iterator_base12@std@@QAE@ABU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 1221 :     _CONSTEXPR20 _Iterator_base12(const _Iterator_base12& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1224 : 
; 1225 :     _CONSTEXPR20 _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {
; 1226 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1227 : #if _HAS_CXX20
; 1228 :         if (_STD is_constant_evaluated()) {
; 1229 :             _Assign_unlocked(_Right);
; 1230 :         } else
; 1231 : #endif // _HAS_CXX20
; 1232 :         {
; 1233 :             _Assign_locked(_Right);
; 1234 :         }
; 1235 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1236 :         _Myproxy = _Right._Myproxy;
; 1237 : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 2 ^^^
; 1238 :         return *this;
; 1239 :     }
; 1240 : 
; 1241 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1242 :     _CONSTEXPR20 ~_Iterator_base12() noexcept {
; 1243 : #if _HAS_CXX20
; 1244 :         if (_STD is_constant_evaluated()) {
; 1245 :             _Orphan_me_unlocked_v3();
; 1246 :         } else
; 1247 : #endif // _HAS_CXX20
; 1248 :         {
; 1249 :             _Orphan_me_locked_v3();
; 1250 :         }
; 1251 :     }
; 1252 : 
; 1253 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {
; 1254 : #if _HAS_CXX20
; 1255 :         if (_STD is_constant_evaluated()) {
; 1256 :             _Adopt_unlocked(_Parent);
; 1257 :         } else
; 1258 : #endif // _HAS_CXX20
; 1259 :         {
; 1260 :             _Adopt_locked(_Parent);
; 1261 :         }
; 1262 :     }
; 1263 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1264 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {
; 1265 :         if (_Parent) { // have a parent, do adoption
; 1266 :             _Myproxy = _Parent->_Myproxy;
; 1267 :         } else { // no future parent, just disown current parent
; 1268 :             _Myproxy = nullptr;
; 1269 :         }
; 1270 :     }
; 1271 : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 2 ^^^
; 1272 : 
; 1273 :     _CONSTEXPR20 const _Container_base12* _Getcont() const noexcept {
; 1274 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;
; 1275 :     }
; 1276 : 
; 1277 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1278 : 
; 1279 :     mutable _Container_proxy* _Myproxy    = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1280 :     mutable _Iterator_base12* _Mynextiter = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1222 :         *this = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=
	npad	1

; 1223 :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Iterator_base12@std@@QAE@ABU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 1219 :     _CONSTEXPR20 _Iterator_base12() noexcept = default; // construct orphaned iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1220 : 
; 1221 :     _CONSTEXPR20 _Iterator_base12(const _Iterator_base12& _Right) noexcept {
; 1222 :         *this = _Right;
; 1223 :     }
; 1224 : 
; 1225 :     _CONSTEXPR20 _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {
; 1226 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1227 : #if _HAS_CXX20
; 1228 :         if (_STD is_constant_evaluated()) {
; 1229 :             _Assign_unlocked(_Right);
; 1230 :         } else
; 1231 : #endif // _HAS_CXX20
; 1232 :         {
; 1233 :             _Assign_locked(_Right);
; 1234 :         }
; 1235 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1236 :         _Myproxy = _Right._Myproxy;
; 1237 : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 2 ^^^
; 1238 :         return *this;
; 1239 :     }
; 1240 : 
; 1241 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1242 :     _CONSTEXPR20 ~_Iterator_base12() noexcept {
; 1243 : #if _HAS_CXX20
; 1244 :         if (_STD is_constant_evaluated()) {
; 1245 :             _Orphan_me_unlocked_v3();
; 1246 :         } else
; 1247 : #endif // _HAS_CXX20
; 1248 :         {
; 1249 :             _Orphan_me_locked_v3();
; 1250 :         }
; 1251 :     }
; 1252 : 
; 1253 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {
; 1254 : #if _HAS_CXX20
; 1255 :         if (_STD is_constant_evaluated()) {
; 1256 :             _Adopt_unlocked(_Parent);
; 1257 :         } else
; 1258 : #endif // _HAS_CXX20
; 1259 :         {
; 1260 :             _Adopt_locked(_Parent);
; 1261 :         }
; 1262 :     }
; 1263 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1264 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {
; 1265 :         if (_Parent) { // have a parent, do adoption
; 1266 :             _Myproxy = _Parent->_Myproxy;
; 1267 :         } else { // no future parent, just disown current parent
; 1268 :             _Myproxy = nullptr;
; 1269 :         }
; 1270 :     }
; 1271 : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 2 ^^^
; 1272 : 
; 1273 :     _CONSTEXPR20 const _Container_base12* _Getcont() const noexcept {
; 1274 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;
; 1275 :     }
; 1276 : 
; 1277 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1278 : 
; 1279 :     mutable _Container_proxy* _Myproxy    = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1280 :     mutable _Iterator_base12* _Mynextiter = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1219 :     _CONSTEXPR20 _Iterator_base12() noexcept = default; // construct orphaned iterator

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AAEXAAU12@@Z
_TEXT	SEGMENT
__Lock$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AAEXAAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators_locked, COMDAT
; _this$ = ecx

; 1211 :     void _Swap_proxy_and_iterators_locked(_Container_base12& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1212 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1

; 1213 :         _Swap_proxy_and_iterators_unlocked(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked
	npad	1

; 1214 :     }

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Swap_proxy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN6@Swap_proxy:
	DD	1
	DD	$LN5@Swap_proxy
$LN5@Swap_proxy:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN4@Swap_proxy
$LN4@Swap_proxy:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AAEXAAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators_locked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
__Lock$ = -20						; size = 4
_this$ = -8						; size = 4
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT
; _this$ = ecx

; 1206 :     void _Orphan_all_locked_v3() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1207 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1

; 1208 :         _Orphan_all_unlocked_v3();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
	npad	1

; 1209 :     }

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Orphan_all
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@Orphan_all:
	DD	1
	DD	$LN5@Orphan_all
$LN5@Orphan_all:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN4@Orphan_all
$LN4@Orphan_all:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AAEXAAU12@@Z
_TEXT	SEGMENT
__Temp$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AAEXAAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked, COMDAT
; _this$ = ecx

; 1370 : _CONSTEXPR20 void _Container_base12::_Swap_proxy_and_iterators_unlocked(_Container_base12& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1371 :     _Container_proxy* _Temp = _Myproxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Temp$[ebp], ecx

; 1372 :     _Myproxy                = _Right._Myproxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1373 :     _Right._Myproxy         = _Temp;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Temp$[ebp]
	mov	DWORD PTR [eax], ecx

; 1374 : 
; 1375 :     if (_Myproxy) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Swap_proxy

; 1376 :         _Myproxy->_Mycont = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx
$LN2@Swap_proxy:

; 1377 :     }
; 1378 : 
; 1379 :     if (_Right._Myproxy) {

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Swap_proxy

; 1380 :         _Right._Myproxy->_Mycont = &_Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [ecx], edx
$LN3@Swap_proxy:

; 1381 :     }
; 1382 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AAEXAAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
__Pnext$2 = -20						; size = 4
_this$ = -8						; size = 4
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT
; _this$ = ecx

; 1346 : _CONSTEXPR20 void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1347 :     if (!_Myproxy) { // no proxy, already done

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@Orphan_all

; 1348 :         return;

	jmp	SHORT $LN1@Orphan_all
$LN5@Orphan_all:

; 1349 :     }
; 1350 : 
; 1351 :     // proxy allocated, drain it
; 1352 :     for (auto _Pnext = _STD exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {

	mov	DWORD PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 4
	push	edx
	call	??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
	add	esp, 8
	mov	DWORD PTR __Pnext$2[ebp], eax
	jmp	SHORT $LN4@Orphan_all
$LN2@Orphan_all:
	mov	eax, DWORD PTR __Pnext$2[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Pnext$2[ebp], ecx
$LN4@Orphan_all:
	cmp	DWORD PTR __Pnext$2[ebp], 0
	je	SHORT $LN3@Orphan_all

; 1353 :         _Pnext->_Myproxy = nullptr;

	mov	eax, DWORD PTR __Pnext$2[ebp]
	mov	DWORD PTR [eax], 0

; 1354 :     }

	jmp	SHORT $LN2@Orphan_all
$LN3@Orphan_all:
$LN1@Orphan_all:

; 1355 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators, COMDAT
; _this$ = ecx

; 1384 : _CONSTEXPR20 void _Container_base12::_Swap_proxy_and_iterators(_Container_base12& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1385 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1386 : #if _HAS_CXX20
; 1387 :     if (_STD is_constant_evaluated()) {
; 1388 :         _Swap_proxy_and_iterators_unlocked(_Right);
; 1389 :     } else
; 1390 : #endif // _HAS_CXX20
; 1391 :     {
; 1392 :         _Swap_proxy_and_iterators_locked(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_locked
	npad	1

; 1393 :     }
; 1394 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1395 :     _Swap_proxy_and_iterators_unlocked(_Right);
; 1396 : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 2 ^^^
; 1397 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 1357 : _CONSTEXPR20 void _Container_base12::_Orphan_all() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1358 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1359 : #if _HAS_CXX20
; 1360 :     if (_STD is_constant_evaluated()) {
; 1361 :         _Orphan_all_unlocked_v3();
; 1362 :     } else
; 1363 : #endif // _HAS_CXX20
; 1364 :     {
; 1365 :         _Orphan_all_locked_v3();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
	npad	1

; 1366 :     }
; 1367 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1368 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 1175 :     _CONSTEXPR20 _Container_base12() noexcept = default;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1176 : 
; 1177 :     _Container_base12(const _Container_base12&)            = delete;
; 1178 :     _Container_base12& operator=(const _Container_base12&) = delete;
; 1179 : 
; 1180 :     _CONSTEXPR20 void _Orphan_all() noexcept;
; 1181 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base12&) noexcept;
; 1182 : 
; 1183 :     template <class _Alloc>
; 1184 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {
; 1185 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
; 1186 :         _Construct_in_place(*_New_proxy, this);
; 1187 :         _Myproxy            = _New_proxy;
; 1188 :         _New_proxy->_Mycont = this;
; 1189 :     }
; 1190 : 
; 1191 :     template <class _Alloc>
; 1192 :     _CONSTEXPR20 void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
; 1193 :         // pre: no iterators refer to the existing proxy
; 1194 :         _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
; 1195 :         _Construct_in_place(*_New_proxy, this);
; 1196 :         _New_proxy->_Mycont = this;
; 1197 :         _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
; 1198 :     }
; 1199 : 
; 1200 :     _Container_proxy* _Myproxy = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1175 :     _CONSTEXPR20 _Container_base12() noexcept = default;

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Mycont_$ = 8						; size = 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 1167 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mycont_$[ebp]
	mov	DWORD PTR [eax], ecx

; 1168 : 
; 1169 :     const _Container_base12* _Mycont       = nullptr;
; 1170 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1167 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Back_shift$ = -44					; size = 4
__Min_back_shift$ = -32					; size = 4
__Ptr_container$ = -20					; size = 4
__Ptr_user$ = -8					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 169  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 170  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 171  :     _Bytes += _Non_user_size;

	mov	eax, DWORD PTR __Bytes$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 39					; 00000027H
	mov	edx, DWORD PTR __Bytes$[ebp]
	mov	DWORD PTR [edx], ecx

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Ptr_user$[ebp], ecx

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, 4
	imul	ecx, eax, -1
	mov	edx, DWORD PTR __Ptr_user$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR __Ptr_container$[ebp], eax
$LN4@Adjust_man:

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

	mov	eax, 4
	imul	ecx, eax, -2
	mov	edx, DWORD PTR __Ptr_user$[ebp]
	cmp	DWORD PTR [edx+ecx], -84215046		; fafafafaH
	jne	SHORT $LN14@Adjust_man
	jmp	SHORT $LN6@Adjust_man
$LN14@Adjust_man:
	mov	esi, esp
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0GC@GDGMGNBP@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN19@Adjust_man
	int	3
$LN19@Adjust_man:
	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_1ME@KJJNLLPL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN14@Adjust_man
$LN6@Adjust_man:
	xor	eax, eax
	jne	SHORT $LN4@Adjust_man

; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

	mov	DWORD PTR __Min_back_shift$[ebp], 8

; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR __Back_shift$[ebp], ecx
$LN10@Adjust_man:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	DWORD PTR __Back_shift$[ebp], 8
	jb	SHORT $LN16@Adjust_man
	cmp	DWORD PTR __Back_shift$[ebp], 39	; 00000027H
	ja	SHORT $LN16@Adjust_man
	jmp	SHORT $LN12@Adjust_man
$LN16@Adjust_man:
	mov	esi, esp
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0GC@GDGMGNBP@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN20@Adjust_man
	int	3
$LN20@Adjust_man:
	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_1ME@KJJNLLPL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	xor	eax, eax
	jne	SHORT $LN16@Adjust_man
$LN12@Adjust_man:
	xor	eax, eax
	jne	SHORT $LN10@Adjust_man

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR [eax], ecx

; 190  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 100  :         void* _Allocate(const size_t _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 101  :         return ::operator new(_Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 102  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -208						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 74   : [[noreturn]] inline void _Throw_bad_array_new_length() {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-20]
	mov	ecx, 5
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 75   :     _THROW(bad_array_new_length{});

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0bad_array_new_length@std@@QAE@XZ	; std::bad_array_new_length::bad_array_new_length
	push	OFFSET __TI3?AVbad_array_new_length@std@@
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__CxxThrowException@8
	npad	1
$LN1@Throw_bad_:

; 76   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 212				; 000000d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 546  :     _NODISCARD static constexpr int(max)() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 547  :         return INT_MAX;

	mov	eax, 2147483647				; 7fffffffH

; 548  :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_array_new_length@std@@UAE@XZ
	npad	1
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0bad_alloc@std@@QAE@ABV01@@Z
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 144  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 143  :         : bad_alloc("bad array new length")

	push	OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0bad_alloc@std@@AAE@QBD@Z		; std::bad_alloc::bad_alloc
	npad	1

; 144  :     {

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 145  :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ
	npad	1
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	npad	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	npad	1
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 133  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 132  :         : exception(_Message, 1)

	push	1
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@QBDH@Z		; std::exception::exception
	npad	1

; 133  :     {

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 134  :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	npad	1
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@what
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv69[ebp], edx
	jmp	SHORT $LN4@what
$LN3@what:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
	mov	eax, DWORD PTR tv69[ebp]

; 97   :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 91   :         __std_exception_destroy(&_Data);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	___std_exception_destroy
	add	esp, 4

; 92   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 73   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 72   :         : _Data()

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Other$[ebp]
	add	ecx, 4
	push	ecx
	call	___std_exception_copy
	add	esp, 8

; 75   :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 67   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 66   :         : _Data()

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 68   :         _Data._What = _Message;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Message$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 69   :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBD@Z
_TEXT	SEGMENT
__InitData$ = -24					; size = 8
_this$ = -8						; size = 4
__Message$ = 8						; size = 4
??0exception@std@@QAE@QBD@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 60   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-28]
	mov	ecx, 7
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 59   :         : _Data()

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 61   :         __std_exception_data _InitData = { _Message, true };

	mov	eax, DWORD PTR __Message$[ebp]
	mov	DWORD PTR __InitData$[ebp], eax
	mov	BYTE PTR __InitData$[ebp+4], 1

; 62   :         __std_exception_copy(&_InitData, &_Data);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	lea	ecx, DWORD PTR __InitData$[ebp]
	push	ecx
	call	___std_exception_copy
	add	esp, 8

; 63   :     }

	mov	eax, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@exception
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN6@exception:
	DD	1
	DD	$LN5@exception
$LN5@exception:
	DD	-24					; ffffffe8H
	DD	8
	DD	$LN4@exception
$LN4@exception:
	DB	95					; 0000005fH
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
??0exception@std@@QAE@QBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vsprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__ArgList$ = 16						; size = 4
_vsprintf PROC						; COMDAT

; 1473 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1474 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	push	-1
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	edx
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1475 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_vsprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -208						; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1392 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1397 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\cmath
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__Xx$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 117  : _NODISCARD _Check_return_ inline float fabs(_In_ float _Xx) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 118  :     return _CSTD fabsf(_Xx);

	push	ecx
	movss	xmm0, DWORD PTR __Xx$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4

; 119  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
;	COMDAT _powf
_TEXT	SEGMENT
tv74 = -196						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_powf	PROC						; COMDAT

; 752  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-4]
	mov	ecx, 1
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 753  :             return (float)pow(_X, _Y);

	cvtss2sd xmm0, DWORD PTR __Y$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	DWORD PTR tv74[ebp]
	fld	DWORD PTR tv74[ebp]

; 754  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_powf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv71 = -196						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 679  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-4]
	mov	ecx, 1
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 680  :             return (float)fabs(_X);

	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR tv71[ebp]
	fld	DWORD PTR tv71[ebp]

; 681  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
;	COMDAT _atan2f
_TEXT	SEGMENT
tv74 = -196						; size = 4
__Y$ = 8						; size = 4
__X$ = 12						; size = 4
_atan2f	PROC						; COMDAT

; 637  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-4]
	mov	ecx, 1
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 638  :             return (float)atan2(_Y, _X);

	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR __Y$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR tv74[ebp]
	fld	DWORD PTR tv74[ebp]

; 639  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_atan2f	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
;	COMDAT _asinf
_TEXT	SEGMENT
tv71 = -196						; size = 4
__X$ = 8						; size = 4
_asinf	PROC						; COMDAT

; 632  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-4]
	mov	ecx, 1
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 633  :             return (float)asin(_X);

	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_asin
	add	esp, 8
	fstp	DWORD PTR tv71[ebp]
	fld	DWORD PTR tv71[ebp]

; 634  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_asinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 164  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 165  :         (void)_Size;
; 166  :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 167  :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?__global_array_delete@@YAXPAXI@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_sz$ = 12						; size = 4
?__global_array_delete@@YAXPAXI@Z PROC			; __global_array_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?__global_array_delete@@YAXPAXI@Z ENDP			; __global_array_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?__global_array_delete@@YAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?__global_array_delete@@YAXPAX@Z PROC			; __global_array_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?__global_array_delete@@YAXPAX@Z ENDP			; __global_array_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?__global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_sz$ = 12						; size = 4
?__global_delete@@YAXPAXI@Z PROC			; __global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?__global_delete@@YAXPAXI@Z ENDP			; __global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?__global_delete@@YAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?__global_delete@@YAXPAX@Z PROC				; __global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?__global_delete@@YAXPAX@Z ENDP				; __global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\pw152\Common\SpeedTreeRT\SourceCode\SpeedTreeRT.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv67 = -200						; size = 4
tv66 = -196						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-8]
	mov	ecx, 2
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN5@vector
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN6@vector
$LN5@vector:
	mov	DWORD PTR tv67[ebp], 0
$LN6@vector:
	cmp	DWORD PTR tv67[ebp], 0
	je	SHORT $LN3@vector
	mov	esi, esp
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
	npad	1
	mov	eax, DWORD PTR ___t$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], eax
	jmp	SHORT $LN2@vector
$LN3@vector:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 200				; 000000c8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
